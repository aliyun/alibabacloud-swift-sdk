import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddAddressRequest : Tea.TeaModel {
    public var addressInfo: String?

    public var bizId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressInfo != nil {
            map["AddressInfo"] = self.addressInfo!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressInfo") && dict["AddressInfo"] != nil {
            self.addressInfo = dict["AddressInfo"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class AddAddressResponseBody : Tea.TeaModel {
    public var addressId: Int64?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressId") && dict["AddressId"] != nil {
            self.addressId = dict["AddressId"] as! Int64
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddItemLimitRuleRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var bizId: String?

    public var endTime: Int64?

    public var itemId: Int64?

    public var lmActivityId: Int64?

    public var lmItemId: String?

    public var ruleType: Int32?

    public var subBizCode: String?

    public var upperNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmActivityId != nil {
            map["LmActivityId"] = self.lmActivityId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.subBizCode != nil {
            map["SubBizCode"] = self.subBizCode!
        }
        if self.upperNum != nil {
            map["UpperNum"] = self.upperNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") && dict["BeginTime"] != nil {
            self.beginTime = dict["BeginTime"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
            self.lmActivityId = dict["LmActivityId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
            self.ruleType = dict["RuleType"] as! Int32
        }
        if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
            self.subBizCode = dict["SubBizCode"] as! String
        }
        if dict.keys.contains("UpperNum") && dict["UpperNum"] != nil {
            self.upperNum = dict["UpperNum"] as! Int32
        }
    }
}

public class AddItemLimitRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var model: Int64?

    public var requestId: String?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int64
        }
    }
}

public class AddItemLimitRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddItemLimitRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddItemLimitRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddItemToSubBizsRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemId: Int64?

    public var lmItemId: String?

    public var subBizIds: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.subBizIds != nil {
            map["SubBizIds"] = self.subBizIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("SubBizIds") && dict["SubBizIds"] != nil {
            self.subBizIds = dict["SubBizIds"] as! [String: Any]
        }
    }
}

public class AddItemToSubBizsShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemId: Int64?

    public var lmItemId: String?

    public var subBizIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.subBizIdsShrink != nil {
            map["SubBizIds"] = self.subBizIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("SubBizIds") && dict["SubBizIds"] != nil {
            self.subBizIdsShrink = dict["SubBizIds"] as! String
        }
    }
}

public class AddItemToSubBizsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddItemToSubBizsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddItemToSubBizsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddItemToSubBizsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSupplierNewItemsRequest : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var itemId: Int64?

        public var lmItemId: String?

        public var skuList: [Int]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.skuList != nil {
                map["SkuList"] = self.skuList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                self.skuList = dict["SkuList"] as! [Int]
            }
        }
    }
    public var bizId: String?

    public var itemList: [AddSupplierNewItemsRequest.ItemList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [AddSupplierNewItemsRequest.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = AddSupplierNewItemsRequest.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
    }
}

public class AddSupplierNewItemsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddSupplierNewItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSupplierNewItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddSupplierNewItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyRefundRequest : Tea.TeaModel {
    public class LeavePictureList : Tea.TeaModel {
        public var desc: String?

        public var picture: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.picture != nil {
                map["Picture"] = self.picture!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Picture") && dict["Picture"] != nil {
                self.picture = dict["Picture"] as! String
            }
        }
    }
    public var accountType: String?

    public var applyReasonTextId: Int64?

    public var applyRefundCount: Int32?

    public var applyRefundFee: Int64?

    public var bizClaimType: Int32?

    public var bizId: String?

    public var bizUid: String?

    public var goodsStatus: Int32?

    public var leaveMessage: String?

    public var leavePictureList: [ApplyRefundRequest.LeavePictureList]?

    public var subLmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.applyReasonTextId != nil {
            map["ApplyReasonTextId"] = self.applyReasonTextId!
        }
        if self.applyRefundCount != nil {
            map["ApplyRefundCount"] = self.applyRefundCount!
        }
        if self.applyRefundFee != nil {
            map["ApplyRefundFee"] = self.applyRefundFee!
        }
        if self.bizClaimType != nil {
            map["BizClaimType"] = self.bizClaimType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.goodsStatus != nil {
            map["GoodsStatus"] = self.goodsStatus!
        }
        if self.leaveMessage != nil {
            map["LeaveMessage"] = self.leaveMessage!
        }
        if self.leavePictureList != nil {
            var tmp : [Any] = []
            for k in self.leavePictureList! {
                tmp.append(k.toMap())
            }
            map["LeavePictureList"] = tmp
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("ApplyReasonTextId") && dict["ApplyReasonTextId"] != nil {
            self.applyReasonTextId = dict["ApplyReasonTextId"] as! Int64
        }
        if dict.keys.contains("ApplyRefundCount") && dict["ApplyRefundCount"] != nil {
            self.applyRefundCount = dict["ApplyRefundCount"] as! Int32
        }
        if dict.keys.contains("ApplyRefundFee") && dict["ApplyRefundFee"] != nil {
            self.applyRefundFee = dict["ApplyRefundFee"] as! Int64
        }
        if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
            self.bizClaimType = dict["BizClaimType"] as! Int32
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("GoodsStatus") && dict["GoodsStatus"] != nil {
            self.goodsStatus = dict["GoodsStatus"] as! Int32
        }
        if dict.keys.contains("LeaveMessage") && dict["LeaveMessage"] != nil {
            self.leaveMessage = dict["LeaveMessage"] as! String
        }
        if dict.keys.contains("LeavePictureList") && dict["LeavePictureList"] != nil {
            var tmp : [ApplyRefundRequest.LeavePictureList] = []
            for v in dict["LeavePictureList"] as! [Any] {
                var model = ApplyRefundRequest.LeavePictureList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.leavePictureList = tmp
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class ApplyRefundResponseBody : Tea.TeaModel {
    public class RefundApplicationData : Tea.TeaModel {
        public var disputeId: Int64?

        public var disputeStatus: Int32?

        public var disputeType: Int32?

        public var subLmOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disputeId != nil {
                map["DisputeId"] = self.disputeId!
            }
            if self.disputeStatus != nil {
                map["DisputeStatus"] = self.disputeStatus!
            }
            if self.disputeType != nil {
                map["DisputeType"] = self.disputeType!
            }
            if self.subLmOrderId != nil {
                map["SubLmOrderId"] = self.subLmOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
                self.disputeId = dict["DisputeId"] as! Int64
            }
            if dict.keys.contains("DisputeStatus") && dict["DisputeStatus"] != nil {
                self.disputeStatus = dict["DisputeStatus"] as! Int32
            }
            if dict.keys.contains("DisputeType") && dict["DisputeType"] != nil {
                self.disputeType = dict["DisputeType"] as! Int32
            }
            if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
                self.subLmOrderId = dict["SubLmOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var refundApplicationData: ApplyRefundResponseBody.RefundApplicationData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.refundApplicationData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.refundApplicationData != nil {
            map["RefundApplicationData"] = self.refundApplicationData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RefundApplicationData") && dict["RefundApplicationData"] != nil {
            var model = ApplyRefundResponseBody.RefundApplicationData()
            model.fromMap(dict["RefundApplicationData"] as! [String: Any])
            self.refundApplicationData = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ApplyRefundResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyRefundResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApplyRefundResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyRefundWithDesignatedTbUidRequest : Tea.TeaModel {
    public class Proofs : Tea.TeaModel {
        public var messagePic: String?

        public var messagePicDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.messagePic != nil {
                map["MessagePic"] = self.messagePic!
            }
            if self.messagePicDesc != nil {
                map["MessagePicDesc"] = self.messagePicDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MessagePic") && dict["MessagePic"] != nil {
                self.messagePic = dict["MessagePic"] as! String
            }
            if dict.keys.contains("MessagePicDesc") && dict["MessagePicDesc"] != nil {
                self.messagePicDesc = dict["MessagePicDesc"] as! String
            }
        }
    }
    public var bizId: String?

    public var disputeId: Int64?

    public var goodsStatus: Int32?

    public var message: String?

    public var proofs: [ApplyRefundWithDesignatedTbUidRequest.Proofs]?

    public var reasonId: Int64?

    public var refundCode: Int32?

    public var refundCount: Int32?

    public var refundFee: Int64?

    public var subLmOrderId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.goodsStatus != nil {
            map["GoodsStatus"] = self.goodsStatus!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.proofs != nil {
            var tmp : [Any] = []
            for k in self.proofs! {
                tmp.append(k.toMap())
            }
            map["Proofs"] = tmp
        }
        if self.reasonId != nil {
            map["ReasonId"] = self.reasonId!
        }
        if self.refundCode != nil {
            map["RefundCode"] = self.refundCode!
        }
        if self.refundCount != nil {
            map["RefundCount"] = self.refundCount!
        }
        if self.refundFee != nil {
            map["RefundFee"] = self.refundFee!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("GoodsStatus") && dict["GoodsStatus"] != nil {
            self.goodsStatus = dict["GoodsStatus"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Proofs") && dict["Proofs"] != nil {
            var tmp : [ApplyRefundWithDesignatedTbUidRequest.Proofs] = []
            for v in dict["Proofs"] as! [Any] {
                var model = ApplyRefundWithDesignatedTbUidRequest.Proofs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.proofs = tmp
        }
        if dict.keys.contains("ReasonId") && dict["ReasonId"] != nil {
            self.reasonId = dict["ReasonId"] as! Int64
        }
        if dict.keys.contains("RefundCode") && dict["RefundCode"] != nil {
            self.refundCode = dict["RefundCode"] as! Int32
        }
        if dict.keys.contains("RefundCount") && dict["RefundCount"] != nil {
            self.refundCount = dict["RefundCount"] as! Int32
        }
        if dict.keys.contains("RefundFee") && dict["RefundFee"] != nil {
            self.refundFee = dict["RefundFee"] as! Int64
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class ApplyRefundWithDesignatedTbUidShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var disputeId: Int64?

    public var goodsStatus: Int32?

    public var message: String?

    public var proofsShrink: String?

    public var reasonId: Int64?

    public var refundCode: Int32?

    public var refundCount: Int32?

    public var refundFee: Int64?

    public var subLmOrderId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.goodsStatus != nil {
            map["GoodsStatus"] = self.goodsStatus!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.proofsShrink != nil {
            map["Proofs"] = self.proofsShrink!
        }
        if self.reasonId != nil {
            map["ReasonId"] = self.reasonId!
        }
        if self.refundCode != nil {
            map["RefundCode"] = self.refundCode!
        }
        if self.refundCount != nil {
            map["RefundCount"] = self.refundCount!
        }
        if self.refundFee != nil {
            map["RefundFee"] = self.refundFee!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("GoodsStatus") && dict["GoodsStatus"] != nil {
            self.goodsStatus = dict["GoodsStatus"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Proofs") && dict["Proofs"] != nil {
            self.proofsShrink = dict["Proofs"] as! String
        }
        if dict.keys.contains("ReasonId") && dict["ReasonId"] != nil {
            self.reasonId = dict["ReasonId"] as! Int64
        }
        if dict.keys.contains("RefundCode") && dict["RefundCode"] != nil {
            self.refundCode = dict["RefundCode"] as! Int32
        }
        if dict.keys.contains("RefundCount") && dict["RefundCount"] != nil {
            self.refundCount = dict["RefundCount"] as! Int32
        }
        if dict.keys.contains("RefundFee") && dict["RefundFee"] != nil {
            self.refundFee = dict["RefundFee"] as! Int64
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class ApplyRefundWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var disputeId: Int64?

        public var disputeStatus: Int32?

        public var disputeType: Int32?

        public var subLmOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disputeId != nil {
                map["DisputeId"] = self.disputeId!
            }
            if self.disputeStatus != nil {
                map["DisputeStatus"] = self.disputeStatus!
            }
            if self.disputeType != nil {
                map["DisputeType"] = self.disputeType!
            }
            if self.subLmOrderId != nil {
                map["SubLmOrderId"] = self.subLmOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
                self.disputeId = dict["DisputeId"] as! Int64
            }
            if dict.keys.contains("DisputeStatus") && dict["DisputeStatus"] != nil {
                self.disputeStatus = dict["DisputeStatus"] as! Int32
            }
            if dict.keys.contains("DisputeType") && dict["DisputeType"] != nil {
                self.disputeType = dict["DisputeType"] as! Int32
            }
            if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
                self.subLmOrderId = dict["SubLmOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: ApplyRefundWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = ApplyRefundWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ApplyRefundWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyRefundWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApplyRefundWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchRegistAnonymousTbAccountRequest : Tea.TeaModel {
    public var bizId: String?

    public var idJsonList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.idJsonList != nil {
            map["IdJsonList"] = self.idJsonList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("IdJsonList") && dict["IdJsonList"] != nil {
            self.idJsonList = dict["IdJsonList"] as! String
        }
    }
}

public class BatchRegistAnonymousTbAccountResponseBody : Tea.TeaModel {
    public var batchId: String?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchId != nil {
            map["BatchId"] = self.batchId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchId") && dict["BatchId"] != nil {
            self.batchId = dict["BatchId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchRegistAnonymousTbAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchRegistAnonymousTbAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchRegistAnonymousTbAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelOrderRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var lmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class CancelOrderResponseBody : Tea.TeaModel {
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CancelOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelOrderWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmOrderId: Int64?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class CancelOrderWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: [String: Any]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! [String: Any]
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CancelOrderWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelOrderWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelOrderWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelRealTbAccountSupportRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class CancelRealTbAccountSupportResponseBody : Tea.TeaModel {
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: Any?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Any
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CancelRealTbAccountSupportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelRealTbAccountSupportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelRealTbAccountSupportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelRefundRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var disputeId: Int64?

    public var subLmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class CancelRefundResponseBody : Tea.TeaModel {
    public class RefundApplicationData : Tea.TeaModel {
        public var disputeStatus: Int32?

        public var disputeType: Int32?

        public var subLmOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disputeStatus != nil {
                map["DisputeStatus"] = self.disputeStatus!
            }
            if self.disputeType != nil {
                map["DisputeType"] = self.disputeType!
            }
            if self.subLmOrderId != nil {
                map["SubLmOrderId"] = self.subLmOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisputeStatus") && dict["DisputeStatus"] != nil {
                self.disputeStatus = dict["DisputeStatus"] as! Int32
            }
            if dict.keys.contains("DisputeType") && dict["DisputeType"] != nil {
                self.disputeType = dict["DisputeType"] as! Int32
            }
            if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
                self.subLmOrderId = dict["SubLmOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var refundApplicationData: CancelRefundResponseBody.RefundApplicationData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.refundApplicationData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.refundApplicationData != nil {
            map["RefundApplicationData"] = self.refundApplicationData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RefundApplicationData") && dict["RefundApplicationData"] != nil {
            var model = CancelRefundResponseBody.RefundApplicationData()
            model.fromMap(dict["RefundApplicationData"] as! [String: Any])
            self.refundApplicationData = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelRefundResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelRefundResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelRefundResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelRefundWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var disputeId: Int64?

    public var subLmOrderId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class CancelRefundWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: Any?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Any
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CancelRefundWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelRefundWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelRefundWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmDisburseRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var lmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class ConfirmDisburseResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfirmDisburseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmDisburseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConfirmDisburseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmDisburseWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmOrderId: Int64?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class ConfirmDisburseWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: Any?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Any
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ConfirmDisburseWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmDisburseWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConfirmDisburseWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMovieTicketOrderRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var extJson: String?

    public var lockSeatAppKey: String?

    public var outTradeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.lockSeatAppKey != nil {
            map["LockSeatAppKey"] = self.lockSeatAppKey!
        }
        if self.outTradeId != nil {
            map["OutTradeId"] = self.outTradeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("LockSeatAppKey") && dict["LockSeatAppKey"] != nil {
            self.lockSeatAppKey = dict["LockSeatAppKey"] as! String
        }
        if dict.keys.contains("OutTradeId") && dict["OutTradeId"] != nil {
            self.outTradeId = dict["OutTradeId"] as! String
        }
    }
}

public class CreateMovieTicketOrderResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class OrderIds : Tea.TeaModel {
            public var orderIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.orderIds != nil {
                    map["OrderIds"] = self.orderIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                    self.orderIds = dict["OrderIds"] as! [String]
                }
            }
        }
        public class PayTradeIds : Tea.TeaModel {
            public var payTradeIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.payTradeIds != nil {
                    map["PayTradeIds"] = self.payTradeIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                    self.payTradeIds = dict["PayTradeIds"] as! [String]
                }
            }
        }
        public var orderIds: CreateMovieTicketOrderResponseBody.Model.OrderIds?

        public var payTradeIds: CreateMovieTicketOrderResponseBody.Model.PayTradeIds?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.orderIds?.validate()
            try self.payTradeIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds?.toMap()
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds?.toMap()
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                var model = CreateMovieTicketOrderResponseBody.Model.OrderIds()
                model.fromMap(dict["OrderIds"] as! [String: Any])
                self.orderIds = model
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                var model = CreateMovieTicketOrderResponseBody.Model.PayTradeIds()
                model.fromMap(dict["PayTradeIds"] as! [String: Any])
                self.payTradeIds = model
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: CreateMovieTicketOrderResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = CreateMovieTicketOrderResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateMovieTicketOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMovieTicketOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMovieTicketOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrderRequest : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var itemId: Int64?

        public var lmItemId: String?

        public var quantity: Int32?

        public var skuId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.skuId != nil {
                map["SkuId"] = self.skuId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                self.skuId = dict["SkuId"] as! Int64
            }
        }
    }
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var buyerMessageMap: String?

    public var deliveryAddress: String?

    public var extJson: String?

    public var itemId: Int64?

    public var itemList: [CreateOrderRequest.ItemList]?

    public var lmItemId: String?

    public var orderExpireTime: Int64?

    public var outTradeId: String?

    public var quantity: Int64?

    public var thirdPartyUserId: String?

    public var totalAmount: Int64?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.buyerMessageMap != nil {
            map["BuyerMessageMap"] = self.buyerMessageMap!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.orderExpireTime != nil {
            map["OrderExpireTime"] = self.orderExpireTime!
        }
        if self.outTradeId != nil {
            map["OutTradeId"] = self.outTradeId!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.totalAmount != nil {
            map["TotalAmount"] = self.totalAmount!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("BuyerMessageMap") && dict["BuyerMessageMap"] != nil {
            self.buyerMessageMap = dict["BuyerMessageMap"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            self.deliveryAddress = dict["DeliveryAddress"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [CreateOrderRequest.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = CreateOrderRequest.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("OrderExpireTime") && dict["OrderExpireTime"] != nil {
            self.orderExpireTime = dict["OrderExpireTime"] as! Int64
        }
        if dict.keys.contains("OutTradeId") && dict["OutTradeId"] != nil {
            self.outTradeId = dict["OutTradeId"] as! String
        }
        if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
            self.quantity = dict["Quantity"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("TotalAmount") && dict["TotalAmount"] != nil {
            self.totalAmount = dict["TotalAmount"] as! Int64
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class CreateOrderResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class LmOrderList : Tea.TeaModel {
            public class LmOrderList : Tea.TeaModel {
                public var lmOrderId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lmOrderId != nil {
                        map["LmOrderId"] = self.lmOrderId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                        self.lmOrderId = dict["LmOrderId"] as! String
                    }
                }
            }
            public var lmOrderList: [CreateOrderResponseBody.Model.LmOrderList.LmOrderList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lmOrderList != nil {
                    var tmp : [Any] = []
                    for k in self.lmOrderList! {
                        tmp.append(k.toMap())
                    }
                    map["LmOrderList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                    var tmp : [CreateOrderResponseBody.Model.LmOrderList.LmOrderList] = []
                    for v in dict["LmOrderList"] as! [Any] {
                        var model = CreateOrderResponseBody.Model.LmOrderList.LmOrderList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.lmOrderList = tmp
                }
            }
        }
        public class OrderIds : Tea.TeaModel {
            public var orderIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.orderIds != nil {
                    map["OrderIds"] = self.orderIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                    self.orderIds = dict["OrderIds"] as! [String]
                }
            }
        }
        public class PayTradeIds : Tea.TeaModel {
            public var payTradeIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.payTradeIds != nil {
                    map["PayTradeIds"] = self.payTradeIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                    self.payTradeIds = dict["PayTradeIds"] as! [String]
                }
            }
        }
        public var lmOrderList: CreateOrderResponseBody.Model.LmOrderList?

        public var orderIds: CreateOrderResponseBody.Model.OrderIds?

        public var payTradeIds: CreateOrderResponseBody.Model.PayTradeIds?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.lmOrderList?.validate()
            try self.orderIds?.validate()
            try self.payTradeIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderList != nil {
                map["LmOrderList"] = self.lmOrderList?.toMap()
            }
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds?.toMap()
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds?.toMap()
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                var model = CreateOrderResponseBody.Model.LmOrderList()
                model.fromMap(dict["LmOrderList"] as! [String: Any])
                self.lmOrderList = model
            }
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                var model = CreateOrderResponseBody.Model.OrderIds()
                model.fromMap(dict["OrderIds"] as! [String: Any])
                self.orderIds = model
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                var model = CreateOrderResponseBody.Model.PayTradeIds()
                model.fromMap(dict["PayTradeIds"] as! [String: Any])
                self.payTradeIds = model
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: CreateOrderResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = CreateOrderResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrderPayUrlForOutDiscountRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var buyInfo: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.buyInfo != nil {
            map["BuyInfo"] = self.buyInfo!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("BuyInfo") && dict["BuyInfo"] != nil {
            self.buyInfo = dict["BuyInfo"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class CreateOrderPayUrlForOutDiscountResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var allIdsMap: [String: [String: Any]]?

        public var lmOrderList: [String]?

        public var orderIds: [String]?

        public var payTradeIds: [String]?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allIdsMap != nil {
                map["AllIdsMap"] = self.allIdsMap!
            }
            if self.lmOrderList != nil {
                map["LmOrderList"] = self.lmOrderList!
            }
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds!
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds!
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllIdsMap") && dict["AllIdsMap"] != nil {
                self.allIdsMap = dict["AllIdsMap"] as! [String: [String: Any]]
            }
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                self.lmOrderList = dict["LmOrderList"] as! [String]
            }
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                self.orderIds = dict["OrderIds"] as! [String]
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                self.payTradeIds = dict["PayTradeIds"] as! [String]
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: CreateOrderPayUrlForOutDiscountResponseBody.Model?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = CreateOrderPayUrlForOutDiscountResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrderPayUrlForOutDiscountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrderPayUrlForOutDiscountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrderPayUrlForOutDiscountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrderTransactionDetailFileRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizName: String?

    public var channelName: String?

    public var createEndTime: String?

    public var createStartTime: String?

    public var itemId: String?

    public var lmShopId: String?

    public var orderStatus: String?

    public var payStatus: String?

    public var paymentEndTime: String?

    public var paymentStartTime: String?

    public var poCode: String?

    public var refundEndTime: String?

    public var refundStartTime: String?

    public var sellerId: String?

    public var sellerName: String?

    public var settlementNode: String?

    public var shopName: String?

    public var tbMainOrderId: String?

    public var tenantId: String?

    public var tenantName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizName != nil {
            map["BizName"] = self.bizName!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.createEndTime != nil {
            map["CreateEndTime"] = self.createEndTime!
        }
        if self.createStartTime != nil {
            map["CreateStartTime"] = self.createStartTime!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmShopId != nil {
            map["LmShopId"] = self.lmShopId!
        }
        if self.orderStatus != nil {
            map["OrderStatus"] = self.orderStatus!
        }
        if self.payStatus != nil {
            map["PayStatus"] = self.payStatus!
        }
        if self.paymentEndTime != nil {
            map["PaymentEndTime"] = self.paymentEndTime!
        }
        if self.paymentStartTime != nil {
            map["PaymentStartTime"] = self.paymentStartTime!
        }
        if self.poCode != nil {
            map["PoCode"] = self.poCode!
        }
        if self.refundEndTime != nil {
            map["RefundEndTime"] = self.refundEndTime!
        }
        if self.refundStartTime != nil {
            map["RefundStartTime"] = self.refundStartTime!
        }
        if self.sellerId != nil {
            map["SellerId"] = self.sellerId!
        }
        if self.sellerName != nil {
            map["SellerName"] = self.sellerName!
        }
        if self.settlementNode != nil {
            map["SettlementNode"] = self.settlementNode!
        }
        if self.shopName != nil {
            map["ShopName"] = self.shopName!
        }
        if self.tbMainOrderId != nil {
            map["TbMainOrderId"] = self.tbMainOrderId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.tenantName != nil {
            map["TenantName"] = self.tenantName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizName") && dict["BizName"] != nil {
            self.bizName = dict["BizName"] as! String
        }
        if dict.keys.contains("ChannelName") && dict["ChannelName"] != nil {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("CreateEndTime") && dict["CreateEndTime"] != nil {
            self.createEndTime = dict["CreateEndTime"] as! String
        }
        if dict.keys.contains("CreateStartTime") && dict["CreateStartTime"] != nil {
            self.createStartTime = dict["CreateStartTime"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! String
        }
        if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
            self.lmShopId = dict["LmShopId"] as! String
        }
        if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
            self.orderStatus = dict["OrderStatus"] as! String
        }
        if dict.keys.contains("PayStatus") && dict["PayStatus"] != nil {
            self.payStatus = dict["PayStatus"] as! String
        }
        if dict.keys.contains("PaymentEndTime") && dict["PaymentEndTime"] != nil {
            self.paymentEndTime = dict["PaymentEndTime"] as! String
        }
        if dict.keys.contains("PaymentStartTime") && dict["PaymentStartTime"] != nil {
            self.paymentStartTime = dict["PaymentStartTime"] as! String
        }
        if dict.keys.contains("PoCode") && dict["PoCode"] != nil {
            self.poCode = dict["PoCode"] as! String
        }
        if dict.keys.contains("RefundEndTime") && dict["RefundEndTime"] != nil {
            self.refundEndTime = dict["RefundEndTime"] as! String
        }
        if dict.keys.contains("RefundStartTime") && dict["RefundStartTime"] != nil {
            self.refundStartTime = dict["RefundStartTime"] as! String
        }
        if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
            self.sellerId = dict["SellerId"] as! String
        }
        if dict.keys.contains("SellerName") && dict["SellerName"] != nil {
            self.sellerName = dict["SellerName"] as! String
        }
        if dict.keys.contains("SettlementNode") && dict["SettlementNode"] != nil {
            self.settlementNode = dict["SettlementNode"] as! String
        }
        if dict.keys.contains("ShopName") && dict["ShopName"] != nil {
            self.shopName = dict["ShopName"] as! String
        }
        if dict.keys.contains("TbMainOrderId") && dict["TbMainOrderId"] != nil {
            self.tbMainOrderId = dict["TbMainOrderId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("TenantName") && dict["TenantName"] != nil {
            self.tenantName = dict["TenantName"] as! String
        }
    }
}

public class CreateOrderTransactionDetailFileResponseBody : Tea.TeaModel {
    public var bizViewData: [String: Any]?

    public var code: String?

    public var logsId: String?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var recordId: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizViewData != nil {
            map["BizViewData"] = self.bizViewData!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizViewData") && dict["BizViewData"] != nil {
            self.bizViewData = dict["BizViewData"] as! [String: Any]
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateOrderTransactionDetailFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrderTransactionDetailFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrderTransactionDetailFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrderV2Request : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var itemId: Int64?

        public var lmItemId: String?

        public var quantity: Int32?

        public var skuId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.skuId != nil {
                map["SkuId"] = self.skuId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                self.skuId = dict["SkuId"] as! Int64
            }
        }
    }
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var buyerMessageMap: String?

    public var deliveryAddress: String?

    public var extJson: String?

    public var itemId: Int64?

    public var itemList: [CreateOrderV2Request.ItemList]?

    public var lmItemId: String?

    public var orderExpireTime: Int64?

    public var outTradeId: String?

    public var quantity: Int64?

    public var thirdPartyUserId: String?

    public var totalAmount: Int64?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.buyerMessageMap != nil {
            map["BuyerMessageMap"] = self.buyerMessageMap!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.orderExpireTime != nil {
            map["OrderExpireTime"] = self.orderExpireTime!
        }
        if self.outTradeId != nil {
            map["OutTradeId"] = self.outTradeId!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.totalAmount != nil {
            map["TotalAmount"] = self.totalAmount!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("BuyerMessageMap") && dict["BuyerMessageMap"] != nil {
            self.buyerMessageMap = dict["BuyerMessageMap"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            self.deliveryAddress = dict["DeliveryAddress"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [CreateOrderV2Request.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = CreateOrderV2Request.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("OrderExpireTime") && dict["OrderExpireTime"] != nil {
            self.orderExpireTime = dict["OrderExpireTime"] as! Int64
        }
        if dict.keys.contains("OutTradeId") && dict["OutTradeId"] != nil {
            self.outTradeId = dict["OutTradeId"] as! String
        }
        if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
            self.quantity = dict["Quantity"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("TotalAmount") && dict["TotalAmount"] != nil {
            self.totalAmount = dict["TotalAmount"] as! Int64
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class CreateOrderV2ResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class LmOrderList : Tea.TeaModel {
            public class LmOrderList : Tea.TeaModel {
                public var lmOrderId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lmOrderId != nil {
                        map["LmOrderId"] = self.lmOrderId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                        self.lmOrderId = dict["LmOrderId"] as! String
                    }
                }
            }
            public var lmOrderList: [CreateOrderV2ResponseBody.Model.LmOrderList.LmOrderList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lmOrderList != nil {
                    var tmp : [Any] = []
                    for k in self.lmOrderList! {
                        tmp.append(k.toMap())
                    }
                    map["LmOrderList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                    var tmp : [CreateOrderV2ResponseBody.Model.LmOrderList.LmOrderList] = []
                    for v in dict["LmOrderList"] as! [Any] {
                        var model = CreateOrderV2ResponseBody.Model.LmOrderList.LmOrderList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.lmOrderList = tmp
                }
            }
        }
        public class OrderIds : Tea.TeaModel {
            public var orderIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.orderIds != nil {
                    map["OrderIds"] = self.orderIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                    self.orderIds = dict["OrderIds"] as! [String]
                }
            }
        }
        public class PayTradeIds : Tea.TeaModel {
            public var payTradeIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.payTradeIds != nil {
                    map["PayTradeIds"] = self.payTradeIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                    self.payTradeIds = dict["PayTradeIds"] as! [String]
                }
            }
        }
        public var lmOrderList: CreateOrderV2ResponseBody.Model.LmOrderList?

        public var orderIds: CreateOrderV2ResponseBody.Model.OrderIds?

        public var payTradeIds: CreateOrderV2ResponseBody.Model.PayTradeIds?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.lmOrderList?.validate()
            try self.orderIds?.validate()
            try self.payTradeIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderList != nil {
                map["LmOrderList"] = self.lmOrderList?.toMap()
            }
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds?.toMap()
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds?.toMap()
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                var model = CreateOrderV2ResponseBody.Model.LmOrderList()
                model.fromMap(dict["LmOrderList"] as! [String: Any])
                self.lmOrderList = model
            }
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                var model = CreateOrderV2ResponseBody.Model.OrderIds()
                model.fromMap(dict["OrderIds"] as! [String: Any])
                self.orderIds = model
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                var model = CreateOrderV2ResponseBody.Model.PayTradeIds()
                model.fromMap(dict["PayTradeIds"] as! [String: Any])
                self.payTradeIds = model
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: CreateOrderV2ResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = CreateOrderV2ResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateOrderV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrderV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrderV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrderWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var buyerMessages: String?

    public var deliveryAddress: String?

    public var deliveryInfo: String?

    public var extInfo: String?

    public var orderExpireTime: Int64?

    public var orderItems: String?

    public var outTradeId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.buyerMessages != nil {
            map["BuyerMessages"] = self.buyerMessages!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress!
        }
        if self.deliveryInfo != nil {
            map["DeliveryInfo"] = self.deliveryInfo!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.orderExpireTime != nil {
            map["OrderExpireTime"] = self.orderExpireTime!
        }
        if self.orderItems != nil {
            map["OrderItems"] = self.orderItems!
        }
        if self.outTradeId != nil {
            map["OutTradeId"] = self.outTradeId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BuyerMessages") && dict["BuyerMessages"] != nil {
            self.buyerMessages = dict["BuyerMessages"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            self.deliveryAddress = dict["DeliveryAddress"] as! String
        }
        if dict.keys.contains("DeliveryInfo") && dict["DeliveryInfo"] != nil {
            self.deliveryInfo = dict["DeliveryInfo"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("OrderExpireTime") && dict["OrderExpireTime"] != nil {
            self.orderExpireTime = dict["OrderExpireTime"] as! Int64
        }
        if dict.keys.contains("OrderItems") && dict["OrderItems"] != nil {
            self.orderItems = dict["OrderItems"] as! String
        }
        if dict.keys.contains("OutTradeId") && dict["OutTradeId"] != nil {
            self.outTradeId = dict["OutTradeId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class CreateOrderWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var allIdsMap: [String: [String: Any]]?

        public var app: String?

        public var lmOrderIds: [String]?

        public var orderIds: [String]?

        public var payTradeIds: [String]?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allIdsMap != nil {
                map["AllIdsMap"] = self.allIdsMap!
            }
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.lmOrderIds != nil {
                map["LmOrderIds"] = self.lmOrderIds!
            }
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds!
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds!
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllIdsMap") && dict["AllIdsMap"] != nil {
                self.allIdsMap = dict["AllIdsMap"] as! [String: [String: Any]]
            }
            if dict.keys.contains("App") && dict["App"] != nil {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("LmOrderIds") && dict["LmOrderIds"] != nil {
                self.lmOrderIds = dict["LmOrderIds"] as! [String]
            }
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                self.orderIds = dict["OrderIds"] as! [String]
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                self.payTradeIds = dict["PayTradeIds"] as! [String]
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: CreateOrderWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = CreateOrderWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateOrderWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrderWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrderWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOutDiscountOrderWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var buyerMessages: String?

    public var deliveryAddress: String?

    public var deliveryInfo: String?

    public var extInfo: String?

    public var orderExpireTime: Int64?

    public var orderItems: String?

    public var outDiscountInfos: String?

    public var outTradeId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.buyerMessages != nil {
            map["BuyerMessages"] = self.buyerMessages!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress!
        }
        if self.deliveryInfo != nil {
            map["DeliveryInfo"] = self.deliveryInfo!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.orderExpireTime != nil {
            map["OrderExpireTime"] = self.orderExpireTime!
        }
        if self.orderItems != nil {
            map["OrderItems"] = self.orderItems!
        }
        if self.outDiscountInfos != nil {
            map["OutDiscountInfos"] = self.outDiscountInfos!
        }
        if self.outTradeId != nil {
            map["OutTradeId"] = self.outTradeId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BuyerMessages") && dict["BuyerMessages"] != nil {
            self.buyerMessages = dict["BuyerMessages"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            self.deliveryAddress = dict["DeliveryAddress"] as! String
        }
        if dict.keys.contains("DeliveryInfo") && dict["DeliveryInfo"] != nil {
            self.deliveryInfo = dict["DeliveryInfo"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("OrderExpireTime") && dict["OrderExpireTime"] != nil {
            self.orderExpireTime = dict["OrderExpireTime"] as! Int64
        }
        if dict.keys.contains("OrderItems") && dict["OrderItems"] != nil {
            self.orderItems = dict["OrderItems"] as! String
        }
        if dict.keys.contains("OutDiscountInfos") && dict["OutDiscountInfos"] != nil {
            self.outDiscountInfos = dict["OutDiscountInfos"] as! String
        }
        if dict.keys.contains("OutTradeId") && dict["OutTradeId"] != nil {
            self.outTradeId = dict["OutTradeId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class CreateOutDiscountOrderWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var allIdsMap: [String: [String: Any]]?

        public var app: String?

        public var lmOrderIds: [String]?

        public var orderIds: [String]?

        public var payTradeIds: [String]?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allIdsMap != nil {
                map["AllIdsMap"] = self.allIdsMap!
            }
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.lmOrderIds != nil {
                map["LmOrderIds"] = self.lmOrderIds!
            }
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds!
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds!
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllIdsMap") && dict["AllIdsMap"] != nil {
                self.allIdsMap = dict["AllIdsMap"] as! [String: [String: Any]]
            }
            if dict.keys.contains("App") && dict["App"] != nil {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("LmOrderIds") && dict["LmOrderIds"] != nil {
                self.lmOrderIds = dict["LmOrderIds"] as! [String]
            }
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                self.orderIds = dict["OrderIds"] as! [String]
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                self.payTradeIds = dict["PayTradeIds"] as! [String]
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: CreateOutDiscountOrderWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = CreateOutDiscountOrderWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateOutDiscountOrderWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOutDiscountOrderWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOutDiscountOrderWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePayUrlRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var buyInfo: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.buyInfo != nil {
            map["BuyInfo"] = self.buyInfo!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("BuyInfo") && dict["BuyInfo"] != nil {
            self.buyInfo = dict["BuyInfo"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class CreatePayUrlResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var lmOrderList: [String]?

        public var orderIds: [String]?

        public var payTradeIds: [String]?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderList != nil {
                map["LmOrderList"] = self.lmOrderList!
            }
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds!
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds!
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                self.lmOrderList = dict["LmOrderList"] as! [String]
            }
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                self.orderIds = dict["OrderIds"] as! [String]
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                self.payTradeIds = dict["PayTradeIds"] as! [String]
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: CreatePayUrlResponseBody.Model?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = CreatePayUrlResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreatePayUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePayUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreatePayUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSettleConfirmRequest : Tea.TeaModel {
    public var bizId: String?

    public var extInfo: String?

    public var merchantId: String?

    public var outRequestNo: String?

    public var outTradeNo: String?

    public var settleInfo: String?

    public var tradeNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.merchantId != nil {
            map["MerchantId"] = self.merchantId!
        }
        if self.outRequestNo != nil {
            map["OutRequestNo"] = self.outRequestNo!
        }
        if self.outTradeNo != nil {
            map["OutTradeNo"] = self.outTradeNo!
        }
        if self.settleInfo != nil {
            map["SettleInfo"] = self.settleInfo!
        }
        if self.tradeNo != nil {
            map["TradeNo"] = self.tradeNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("MerchantId") && dict["MerchantId"] != nil {
            self.merchantId = dict["MerchantId"] as! String
        }
        if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
            self.outRequestNo = dict["OutRequestNo"] as! String
        }
        if dict.keys.contains("OutTradeNo") && dict["OutTradeNo"] != nil {
            self.outTradeNo = dict["OutTradeNo"] as! String
        }
        if dict.keys.contains("SettleInfo") && dict["SettleInfo"] != nil {
            self.settleInfo = dict["SettleInfo"] as! String
        }
        if dict.keys.contains("TradeNo") && dict["TradeNo"] != nil {
            self.tradeNo = dict["TradeNo"] as! String
        }
    }
}

public class CreateSettleConfirmResponseBody : Tea.TeaModel {
    public class TradeSettleConfirmResponse : Tea.TeaModel {
        public var outRequestNo: String?

        public var tradeNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.outRequestNo != nil {
                map["OutRequestNo"] = self.outRequestNo!
            }
            if self.tradeNo != nil {
                map["TradeNo"] = self.tradeNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
                self.outRequestNo = dict["OutRequestNo"] as! String
            }
            if dict.keys.contains("TradeNo") && dict["TradeNo"] != nil {
                self.tradeNo = dict["TradeNo"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var tradeSettleConfirmResponse: CreateSettleConfirmResponseBody.TradeSettleConfirmResponse?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tradeSettleConfirmResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tradeSettleConfirmResponse != nil {
            map["TradeSettleConfirmResponse"] = self.tradeSettleConfirmResponse?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TradeSettleConfirmResponse") && dict["TradeSettleConfirmResponse"] != nil {
            var model = CreateSettleConfirmResponseBody.TradeSettleConfirmResponse()
            model.fromMap(dict["TradeSettleConfirmResponse"] as! [String: Any])
            self.tradeSettleConfirmResponse = model
        }
    }
}

public class CreateSettleConfirmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSettleConfirmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSettleConfirmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVirtualProductOrderRequest : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var itemId: Int64?

        public var lmItemId: String?

        public var quantity: Int32?

        public var skuId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.skuId != nil {
                map["SkuId"] = self.skuId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                self.skuId = dict["SkuId"] as! Int64
            }
        }
    }
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var deliveryAddress: String?

    public var extJson: String?

    public var itemId: Int64?

    public var itemList: [CreateVirtualProductOrderRequest.ItemList]?

    public var lmItemId: String?

    public var orderExpireTime: Int64?

    public var outTradeId: String?

    public var quantity: Int64?

    public var thirdPartyUserId: String?

    public var totalAmount: Int64?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.orderExpireTime != nil {
            map["OrderExpireTime"] = self.orderExpireTime!
        }
        if self.outTradeId != nil {
            map["OutTradeId"] = self.outTradeId!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.totalAmount != nil {
            map["TotalAmount"] = self.totalAmount!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            self.deliveryAddress = dict["DeliveryAddress"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [CreateVirtualProductOrderRequest.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = CreateVirtualProductOrderRequest.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("OrderExpireTime") && dict["OrderExpireTime"] != nil {
            self.orderExpireTime = dict["OrderExpireTime"] as! Int64
        }
        if dict.keys.contains("OutTradeId") && dict["OutTradeId"] != nil {
            self.outTradeId = dict["OutTradeId"] as! String
        }
        if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
            self.quantity = dict["Quantity"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("TotalAmount") && dict["TotalAmount"] != nil {
            self.totalAmount = dict["TotalAmount"] as! Int64
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class CreateVirtualProductOrderResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class LmOrderList : Tea.TeaModel {
            public class LmOrderList : Tea.TeaModel {
                public var lmOrderId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lmOrderId != nil {
                        map["LmOrderId"] = self.lmOrderId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                        self.lmOrderId = dict["LmOrderId"] as! String
                    }
                }
            }
            public var lmOrderList: [CreateVirtualProductOrderResponseBody.Model.LmOrderList.LmOrderList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lmOrderList != nil {
                    var tmp : [Any] = []
                    for k in self.lmOrderList! {
                        tmp.append(k.toMap())
                    }
                    map["LmOrderList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                    var tmp : [CreateVirtualProductOrderResponseBody.Model.LmOrderList.LmOrderList] = []
                    for v in dict["LmOrderList"] as! [Any] {
                        var model = CreateVirtualProductOrderResponseBody.Model.LmOrderList.LmOrderList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.lmOrderList = tmp
                }
            }
        }
        public class OrderIds : Tea.TeaModel {
            public var orderIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.orderIds != nil {
                    map["OrderIds"] = self.orderIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                    self.orderIds = dict["OrderIds"] as! [String]
                }
            }
        }
        public class PayTradeIds : Tea.TeaModel {
            public var payTradeIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.payTradeIds != nil {
                    map["PayTradeIds"] = self.payTradeIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                    self.payTradeIds = dict["PayTradeIds"] as! [String]
                }
            }
        }
        public var lmOrderList: CreateVirtualProductOrderResponseBody.Model.LmOrderList?

        public var orderIds: CreateVirtualProductOrderResponseBody.Model.OrderIds?

        public var payTradeIds: CreateVirtualProductOrderResponseBody.Model.PayTradeIds?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.lmOrderList?.validate()
            try self.orderIds?.validate()
            try self.payTradeIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderList != nil {
                map["LmOrderList"] = self.lmOrderList?.toMap()
            }
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds?.toMap()
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds?.toMap()
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                var model = CreateVirtualProductOrderResponseBody.Model.LmOrderList()
                model.fromMap(dict["LmOrderList"] as! [String: Any])
                self.lmOrderList = model
            }
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                var model = CreateVirtualProductOrderResponseBody.Model.OrderIds()
                model.fromMap(dict["OrderIds"] as! [String: Any])
                self.orderIds = model
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                var model = CreateVirtualProductOrderResponseBody.Model.PayTradeIds()
                model.fromMap(dict["PayTradeIds"] as! [String: Any])
                self.payTradeIds = model
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: CreateVirtualProductOrderResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = CreateVirtualProductOrderResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateVirtualProductOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVirtualProductOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateVirtualProductOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWithholdTradeRequest : Tea.TeaModel {
    public var agreementNo: String?

    public var body: String?

    public var buyerId: String?

    public var extInfo: String?

    public var goodsDetail: String?

    public var merchantId: String?

    public var outRequestNo: String?

    public var outTradeNo: String?

    public var settleMode: String?

    public var subject: String?

    public var totalAmount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agreementNo != nil {
            map["AgreementNo"] = self.agreementNo!
        }
        if self.body != nil {
            map["Body"] = self.body!
        }
        if self.buyerId != nil {
            map["BuyerId"] = self.buyerId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.goodsDetail != nil {
            map["GoodsDetail"] = self.goodsDetail!
        }
        if self.merchantId != nil {
            map["MerchantId"] = self.merchantId!
        }
        if self.outRequestNo != nil {
            map["OutRequestNo"] = self.outRequestNo!
        }
        if self.outTradeNo != nil {
            map["OutTradeNo"] = self.outTradeNo!
        }
        if self.settleMode != nil {
            map["SettleMode"] = self.settleMode!
        }
        if self.subject != nil {
            map["Subject"] = self.subject!
        }
        if self.totalAmount != nil {
            map["TotalAmount"] = self.totalAmount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgreementNo") && dict["AgreementNo"] != nil {
            self.agreementNo = dict["AgreementNo"] as! String
        }
        if dict.keys.contains("Body") && dict["Body"] != nil {
            self.body = dict["Body"] as! String
        }
        if dict.keys.contains("BuyerId") && dict["BuyerId"] != nil {
            self.buyerId = dict["BuyerId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("GoodsDetail") && dict["GoodsDetail"] != nil {
            self.goodsDetail = dict["GoodsDetail"] as! String
        }
        if dict.keys.contains("MerchantId") && dict["MerchantId"] != nil {
            self.merchantId = dict["MerchantId"] as! String
        }
        if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
            self.outRequestNo = dict["OutRequestNo"] as! String
        }
        if dict.keys.contains("OutTradeNo") && dict["OutTradeNo"] != nil {
            self.outTradeNo = dict["OutTradeNo"] as! String
        }
        if dict.keys.contains("SettleMode") && dict["SettleMode"] != nil {
            self.settleMode = dict["SettleMode"] as! String
        }
        if dict.keys.contains("Subject") && dict["Subject"] != nil {
            self.subject = dict["Subject"] as! String
        }
        if dict.keys.contains("TotalAmount") && dict["TotalAmount"] != nil {
            self.totalAmount = dict["TotalAmount"] as! String
        }
    }
}

public class CreateWithholdTradeResponseBody : Tea.TeaModel {
    public class WithholdTradeResponse : Tea.TeaModel {
        public var outRequestNo: String?

        public var outTradeNo: String?

        public var paymentDate: String?

        public var tradeNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.outRequestNo != nil {
                map["OutRequestNo"] = self.outRequestNo!
            }
            if self.outTradeNo != nil {
                map["OutTradeNo"] = self.outTradeNo!
            }
            if self.paymentDate != nil {
                map["PaymentDate"] = self.paymentDate!
            }
            if self.tradeNo != nil {
                map["TradeNo"] = self.tradeNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
                self.outRequestNo = dict["OutRequestNo"] as! String
            }
            if dict.keys.contains("OutTradeNo") && dict["OutTradeNo"] != nil {
                self.outTradeNo = dict["OutTradeNo"] as! String
            }
            if dict.keys.contains("PaymentDate") && dict["PaymentDate"] != nil {
                self.paymentDate = dict["PaymentDate"] as! String
            }
            if dict.keys.contains("TradeNo") && dict["TradeNo"] != nil {
                self.tradeNo = dict["TradeNo"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var withholdTradeResponse: CreateWithholdTradeResponseBody.WithholdTradeResponse?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.withholdTradeResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.withholdTradeResponse != nil {
            map["WithholdTradeResponse"] = self.withholdTradeResponse?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WithholdTradeResponse") && dict["WithholdTradeResponse"] != nil {
            var model = CreateWithholdTradeResponseBody.WithholdTradeResponse()
            model.fromMap(dict["WithholdTradeResponse"] as! [String: Any])
            self.withholdTradeResponse = model
        }
    }
}

public class CreateWithholdTradeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWithholdTradeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateWithholdTradeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeductUserPointRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class DeductUserPointShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfoShrink: String?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class DeductUserPointResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountId: String?

        public var action: String?

        public var amount: Int64?

        public var bizId: String?

        public var bizUid: String?

        public var description_: String?

        public var extInfo: [String: Any]?

        public var idempotentId: String?

        public var name: String?

        public var recordId: String?

        public var rest: Int64?

        public var ruleId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizUid != nil {
                map["BizUid"] = self.bizUid!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.idempotentId != nil {
                map["IdempotentId"] = self.idempotentId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.rest != nil {
                map["Rest"] = self.rest!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Amount") && dict["Amount"] != nil {
                self.amount = dict["Amount"] as! Int64
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
                self.bizUid = dict["BizUid"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
                self.idempotentId = dict["IdempotentId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("Rest") && dict["Rest"] != nil {
                self.rest = dict["Rest"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: DeductUserPointResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = DeductUserPointResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeductUserPointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeductUserPointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeductUserPointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBizItemsRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIdList: [Int64]?

    public var subBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIdList != nil {
            map["ItemIdList"] = self.itemIdList!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIdList") && dict["ItemIdList"] != nil {
            self.itemIdList = dict["ItemIdList"] as! [Int64]
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
    }
}

public class DeleteBizItemsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBizItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBizItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBizItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteItemLimitRuleRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemId: Int64?

    public var lmActivityId: Int64?

    public var lmItemId: String?

    public var ruleId: Int64?

    public var subBizCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmActivityId != nil {
            map["LmActivityId"] = self.lmActivityId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.subBizCode != nil {
            map["SubBizCode"] = self.subBizCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
            self.lmActivityId = dict["LmActivityId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
            self.subBizCode = dict["SubBizCode"] as! String
        }
    }
}

public class DeleteItemLimitRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var model: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteItemLimitRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteItemLimitRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteItemLimitRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadCpsBillFileRequest : Tea.TeaModel {
    public var billId: String?

    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.billId != nil {
            map["BillId"] = self.billId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BillId") && dict["BillId"] != nil {
            self.billId = dict["BillId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class DownloadCpsBillFileResponseBody : Tea.TeaModel {
    public var bizViewData: [String: Any]?

    public var code: String?

    public var logsId: String?

    public var message: String?

    public var ossUrl: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizViewData != nil {
            map["BizViewData"] = self.bizViewData!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ossUrl != nil {
            map["OssUrl"] = self.ossUrl!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizViewData") && dict["BizViewData"] != nil {
            self.bizViewData = dict["BizViewData"] as! [String: Any]
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OssUrl") && dict["OssUrl"] != nil {
            self.ossUrl = dict["OssUrl"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DownloadCpsBillFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadCpsBillFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DownloadCpsBillFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadItemBillFileRequest : Tea.TeaModel {
    public var billId: String?

    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.billId != nil {
            map["BillId"] = self.billId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BillId") && dict["BillId"] != nil {
            self.billId = dict["BillId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class DownloadItemBillFileResponseBody : Tea.TeaModel {
    public var bizViewData: [String: Any]?

    public var code: String?

    public var logsId: String?

    public var message: String?

    public var ossUrl: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizViewData != nil {
            map["BizViewData"] = self.bizViewData!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ossUrl != nil {
            map["OssUrl"] = self.ossUrl!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizViewData") && dict["BizViewData"] != nil {
            self.bizViewData = dict["BizViewData"] as! [String: Any]
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OssUrl") && dict["OssUrl"] != nil {
            self.ossUrl = dict["OssUrl"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DownloadItemBillFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadItemBillFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DownloadItemBillFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadOrderTransactionDetailFileRequest : Tea.TeaModel {
    public var bizId: String?

    public var recordId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
            self.recordId = dict["RecordId"] as! String
        }
    }
}

public class DownloadOrderTransactionDetailFileResponseBody : Tea.TeaModel {
    public var bizViewData: [String: Any]?

    public var code: String?

    public var logsId: String?

    public var message: String?

    public var ossUrl: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizViewData != nil {
            map["BizViewData"] = self.bizViewData!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ossUrl != nil {
            map["OssUrl"] = self.ossUrl!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizViewData") && dict["BizViewData"] != nil {
            self.bizViewData = dict["BizViewData"] as! [String: Any]
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OssUrl") && dict["OssUrl"] != nil {
            self.ossUrl = dict["OssUrl"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DownloadOrderTransactionDetailFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadOrderTransactionDetailFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DownloadOrderTransactionDetailFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableOrderRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var extJson: String?

    public var lmOrderId: String?

    public var outTradeId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.outTradeId != nil {
            map["OutTradeId"] = self.outTradeId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! String
        }
        if dict.keys.contains("OutTradeId") && dict["OutTradeId"] != nil {
            self.outTradeId = dict["OutTradeId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class EnableOrderResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class LmOrderList : Tea.TeaModel {
            public class LmOrderList : Tea.TeaModel {
                public var lmOrderId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lmOrderId != nil {
                        map["LmOrderId"] = self.lmOrderId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                        self.lmOrderId = dict["LmOrderId"] as! String
                    }
                }
            }
            public var lmOrderList: [EnableOrderResponseBody.Model.LmOrderList.LmOrderList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lmOrderList != nil {
                    var tmp : [Any] = []
                    for k in self.lmOrderList! {
                        tmp.append(k.toMap())
                    }
                    map["LmOrderList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                    var tmp : [EnableOrderResponseBody.Model.LmOrderList.LmOrderList] = []
                    for v in dict["LmOrderList"] as! [Any] {
                        var model = EnableOrderResponseBody.Model.LmOrderList.LmOrderList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.lmOrderList = tmp
                }
            }
        }
        public class OrderIds : Tea.TeaModel {
            public var orderIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.orderIds != nil {
                    map["OrderIds"] = self.orderIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                    self.orderIds = dict["OrderIds"] as! [String]
                }
            }
        }
        public class PayTradeIds : Tea.TeaModel {
            public var payTradeIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.payTradeIds != nil {
                    map["PayTradeIds"] = self.payTradeIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                    self.payTradeIds = dict["PayTradeIds"] as! [String]
                }
            }
        }
        public var lmOrderList: EnableOrderResponseBody.Model.LmOrderList?

        public var orderIds: EnableOrderResponseBody.Model.OrderIds?

        public var payTradeIds: EnableOrderResponseBody.Model.PayTradeIds?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.lmOrderList?.validate()
            try self.orderIds?.validate()
            try self.payTradeIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderList != nil {
                map["LmOrderList"] = self.lmOrderList?.toMap()
            }
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds?.toMap()
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds?.toMap()
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                var model = EnableOrderResponseBody.Model.LmOrderList()
                model.fromMap(dict["LmOrderList"] as! [String: Any])
                self.lmOrderList = model
            }
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                var model = EnableOrderResponseBody.Model.OrderIds()
                model.fromMap(dict["OrderIds"] as! [String: Any])
                self.orderIds = model
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                var model = EnableOrderResponseBody.Model.PayTradeIds()
                model.fromMap(dict["PayTradeIds"] as! [String: Any])
                self.payTradeIds = model
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: EnableOrderResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = EnableOrderResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class EnableOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableOrderWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmOrderId: Int64?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class EnableOrderWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class LmOrderList : Tea.TeaModel {
            public var extJson: [String: String]?

            public var lmOrderId: String?

            public var subLmOrderIdList: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extJson != nil {
                    map["ExtJson"] = self.extJson!
                }
                if self.lmOrderId != nil {
                    map["LmOrderId"] = self.lmOrderId!
                }
                if self.subLmOrderIdList != nil {
                    map["SubLmOrderIdList"] = self.subLmOrderIdList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                    self.extJson = dict["ExtJson"] as! [String: String]
                }
                if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                    self.lmOrderId = dict["LmOrderId"] as! String
                }
                if dict.keys.contains("SubLmOrderIdList") && dict["SubLmOrderIdList"] != nil {
                    self.subLmOrderIdList = dict["SubLmOrderIdList"] as! [String]
                }
            }
        }
        public var lmOrderList: [EnableOrderWithDesignatedTbUidResponseBody.Model.LmOrderList]?

        public var orderIds: [String]?

        public var payTradeIds: [String]?

        public var redirectUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderList != nil {
                var tmp : [Any] = []
                for k in self.lmOrderList! {
                    tmp.append(k.toMap())
                }
                map["LmOrderList"] = tmp
            }
            if self.orderIds != nil {
                map["OrderIds"] = self.orderIds!
            }
            if self.payTradeIds != nil {
                map["PayTradeIds"] = self.payTradeIds!
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                var tmp : [EnableOrderWithDesignatedTbUidResponseBody.Model.LmOrderList] = []
                for v in dict["LmOrderList"] as! [Any] {
                    var model = EnableOrderWithDesignatedTbUidResponseBody.Model.LmOrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmOrderList = tmp
            }
            if dict.keys.contains("OrderIds") && dict["OrderIds"] != nil {
                self.orderIds = dict["OrderIds"] as! [String]
            }
            if dict.keys.contains("PayTradeIds") && dict["PayTradeIds"] != nil {
                self.payTradeIds = dict["PayTradeIds"] as! [String]
            }
            if dict.keys.contains("RedirectUrl") && dict["RedirectUrl"] != nil {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: EnableOrderWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = EnableOrderWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class EnableOrderWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableOrderWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableOrderWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteNodeRequest : Tea.TeaModel {
    public var bizId: String?

    public var nodeId: String?

    public var nodeInstanceId: String?

    public var processId: String?

    public var processInstanceId: String?

    public var requestData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeInstanceId != nil {
            map["NodeInstanceId"] = self.nodeInstanceId!
        }
        if self.processId != nil {
            map["ProcessId"] = self.processId!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.requestData != nil {
            map["RequestData"] = self.requestData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeInstanceId") && dict["NodeInstanceId"] != nil {
            self.nodeInstanceId = dict["NodeInstanceId"] as! String
        }
        if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
            self.processId = dict["ProcessId"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("RequestData") && dict["RequestData"] != nil {
            self.requestData = dict["RequestData"] as! String
        }
    }
}

public class ExecuteNodeResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var processInstanceId: String?

        public var responseData: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.responseData != nil {
                map["ResponseData"] = self.responseData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("ResponseData") && dict["ResponseData"] != nil {
                self.responseData = dict["ResponseData"] as! [String: Any]
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: ExecuteNodeResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = ExecuteNodeResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ExecuteNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecuteNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FreezeUserPointRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class FreezeUserPointShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfoShrink: String?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class FreezeUserPointResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountId: String?

        public var action: String?

        public var amount: Int64?

        public var bizId: String?

        public var bizUid: String?

        public var description_: String?

        public var extInfo: [String: Any]?

        public var idempotentId: String?

        public var name: String?

        public var recordId: String?

        public var rest: Int64?

        public var ruleId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizUid != nil {
                map["BizUid"] = self.bizUid!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.idempotentId != nil {
                map["IdempotentId"] = self.idempotentId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.rest != nil {
                map["Rest"] = self.rest!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Amount") && dict["Amount"] != nil {
                self.amount = dict["Amount"] as! Int64
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
                self.bizUid = dict["BizUid"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
                self.idempotentId = dict["IdempotentId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("Rest") && dict["Rest"] != nil {
                self.rest = dict["Rest"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: FreezeUserPointResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = FreezeUserPointResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class FreezeUserPointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FreezeUserPointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = FreezeUserPointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetActivityGameInfoRequest : Tea.TeaModel {
    public var accountType: String?

    public var activityId: String?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var gameId: String?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.gameId != nil {
            map["GameId"] = self.gameId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
            self.activityId = dict["ActivityId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("GameId") && dict["GameId"] != nil {
            self.gameId = dict["GameId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class GetActivityGameInfoShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var activityId: String?

    public var bizId: String?

    public var extInfoShrink: String?

    public var gameId: String?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.gameId != nil {
            map["GameId"] = self.gameId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
            self.activityId = dict["ActivityId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("GameId") && dict["GameId"] != nil {
            self.gameId = dict["GameId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class GetActivityGameInfoResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var extInfo: String?

        public var gameDTO: String?

        public var gameShowInfo: String?

        public var userGameCoinInfos: String?

        public var userProcessDTO: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.gameDTO != nil {
                map["GameDTO"] = self.gameDTO!
            }
            if self.gameShowInfo != nil {
                map["GameShowInfo"] = self.gameShowInfo!
            }
            if self.userGameCoinInfos != nil {
                map["UserGameCoinInfos"] = self.userGameCoinInfos!
            }
            if self.userProcessDTO != nil {
                map["UserProcessDTO"] = self.userProcessDTO!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! String
            }
            if dict.keys.contains("GameDTO") && dict["GameDTO"] != nil {
                self.gameDTO = dict["GameDTO"] as! String
            }
            if dict.keys.contains("GameShowInfo") && dict["GameShowInfo"] != nil {
                self.gameShowInfo = dict["GameShowInfo"] as! String
            }
            if dict.keys.contains("UserGameCoinInfos") && dict["UserGameCoinInfos"] != nil {
                self.userGameCoinInfos = dict["UserGameCoinInfos"] as! String
            }
            if dict.keys.contains("UserProcessDTO") && dict["UserProcessDTO"] != nil {
                self.userProcessDTO = dict["UserProcessDTO"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: GetActivityGameInfoResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = GetActivityGameInfoResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetActivityGameInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetActivityGameInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetActivityGameInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCategoryChainRequest : Tea.TeaModel {
    public var bizId: String?

    public var categoryId: Int64?

    public var itemId: Int64?

    public var lmItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
    }
}

public class GetCategoryChainResponseBody : Tea.TeaModel {
    public class CategoryList : Tea.TeaModel {
        public var categoryId: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categoryId != nil {
                map["CategoryId"] = self.categoryId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                self.categoryId = dict["CategoryId"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var categoryList: [GetCategoryChainResponseBody.CategoryList]?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryList != nil {
            var tmp : [Any] = []
            for k in self.categoryList! {
                tmp.append(k.toMap())
            }
            map["CategoryList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryList") && dict["CategoryList"] != nil {
            var tmp : [GetCategoryChainResponseBody.CategoryList] = []
            for v in dict["CategoryList"] as! [Any] {
                var model = GetCategoryChainResponseBody.CategoryList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.categoryList = tmp
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCategoryChainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCategoryChainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCategoryChainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCategoryListRequest : Tea.TeaModel {
    public var bizId: String?

    public var categoryId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
            self.categoryId = dict["CategoryId"] as! Int64
        }
    }
}

public class GetCategoryListResponseBody : Tea.TeaModel {
    public class CategoryList : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var categoryId: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                    self.categoryId = dict["CategoryId"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var category: [GetCategoryListResponseBody.CategoryList.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                var tmp : [GetCategoryListResponseBody.CategoryList.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = GetCategoryListResponseBody.CategoryList.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
        }
    }
    public var categoryList: GetCategoryListResponseBody.CategoryList?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.categoryList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryList != nil {
            map["CategoryList"] = self.categoryList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryList") && dict["CategoryList"] != nil {
            var model = GetCategoryListResponseBody.CategoryList()
            model.fromMap(dict["CategoryList"] as! [String: Any])
            self.categoryList = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCategoryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCategoryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCategoryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomServiceUrlRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var cuid: String?

    public var nick: String?

    public var sellerId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.cuid != nil {
            map["Cuid"] = self.cuid!
        }
        if self.nick != nil {
            map["Nick"] = self.nick!
        }
        if self.sellerId != nil {
            map["SellerId"] = self.sellerId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("Cuid") && dict["Cuid"] != nil {
            self.cuid = dict["Cuid"] as! String
        }
        if dict.keys.contains("Nick") && dict["Nick"] != nil {
            self.nick = dict["Nick"] as! String
        }
        if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
            self.sellerId = dict["SellerId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class GetCustomServiceUrlResponseBody : Tea.TeaModel {
    public class UrlData : Tea.TeaModel {
        public var returnUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.returnUrl != nil {
                map["ReturnUrl"] = self.returnUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReturnUrl") && dict["ReturnUrl"] != nil {
                self.returnUrl = dict["ReturnUrl"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var urlData: GetCustomServiceUrlResponseBody.UrlData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.urlData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.urlData != nil {
            map["UrlData"] = self.urlData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UrlData") && dict["UrlData"] != nil {
            var model = GetCustomServiceUrlResponseBody.UrlData()
            model.fromMap(dict["UrlData"] as! [String: Any])
            self.urlData = model
        }
    }
}

public class GetCustomServiceUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomServiceUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCustomServiceUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGuidePageRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class GetGuidePageResponseBody : Tea.TeaModel {
    public class MiniShopInfo : Tea.TeaModel {
        public var bizId: String?

        public var liteShopId: String?

        public var name: String?

        public var src: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.liteShopId != nil {
                map["LiteShopId"] = self.liteShopId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.src != nil {
                map["Src"] = self.src!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("LiteShopId") && dict["LiteShopId"] != nil {
                self.liteShopId = dict["LiteShopId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Src") && dict["Src"] != nil {
                self.src = dict["Src"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var miniShopInfo: [GetGuidePageResponseBody.MiniShopInfo]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.miniShopInfo != nil {
            var tmp : [Any] = []
            for k in self.miniShopInfo! {
                tmp.append(k.toMap())
            }
            map["MiniShopInfo"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("MiniShopInfo") && dict["MiniShopInfo"] != nil {
            var tmp : [GetGuidePageResponseBody.MiniShopInfo] = []
            for v in dict["MiniShopInfo"] as! [Any] {
                var model = GetGuidePageResponseBody.MiniShopInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.miniShopInfo = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetGuidePageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGuidePageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetGuidePageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetItemPromotionRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemId: Int64?

    public var lmItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
    }
}

public class GetItemPromotionResponseBody : Tea.TeaModel {
    public class ItemPromotionModel : Tea.TeaModel {
        public var endTime: String?

        public var extInfo: [String: Any]?

        public var itemId: Int64?

        public var lmItemId: String?

        public var promotionDesc: String?

        public var promotionFlag: Bool?

        public var promotionId: String?

        public var promotionName: String?

        public var skuPromotion: [String: Any]?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.promotionDesc != nil {
                map["PromotionDesc"] = self.promotionDesc!
            }
            if self.promotionFlag != nil {
                map["PromotionFlag"] = self.promotionFlag!
            }
            if self.promotionId != nil {
                map["PromotionId"] = self.promotionId!
            }
            if self.promotionName != nil {
                map["PromotionName"] = self.promotionName!
            }
            if self.skuPromotion != nil {
                map["SkuPromotion"] = self.skuPromotion!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("PromotionDesc") && dict["PromotionDesc"] != nil {
                self.promotionDesc = dict["PromotionDesc"] as! String
            }
            if dict.keys.contains("PromotionFlag") && dict["PromotionFlag"] != nil {
                self.promotionFlag = dict["PromotionFlag"] as! Bool
            }
            if dict.keys.contains("PromotionId") && dict["PromotionId"] != nil {
                self.promotionId = dict["PromotionId"] as! String
            }
            if dict.keys.contains("PromotionName") && dict["PromotionName"] != nil {
                self.promotionName = dict["PromotionName"] as! String
            }
            if dict.keys.contains("SkuPromotion") && dict["SkuPromotion"] != nil {
                self.skuPromotion = dict["SkuPromotion"] as! [String: Any]
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var code: String?

    public var itemPromotionModel: GetItemPromotionResponseBody.ItemPromotionModel?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemPromotionModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemPromotionModel != nil {
            map["ItemPromotionModel"] = self.itemPromotionModel?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemPromotionModel") && dict["ItemPromotionModel"] != nil {
            var model = GetItemPromotionResponseBody.ItemPromotionModel()
            model.fromMap(dict["ItemPromotionModel"] as! [String: Any])
            self.itemPromotionModel = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetItemPromotionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetItemPromotionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetItemPromotionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLoginPageRequest : Tea.TeaModel {
    public var bizId: String?

    public var failUrl: String?

    public var targetUrl: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.failUrl != nil {
            map["FailUrl"] = self.failUrl!
        }
        if self.targetUrl != nil {
            map["TargetUrl"] = self.targetUrl!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("FailUrl") && dict["FailUrl"] != nil {
            self.failUrl = dict["FailUrl"] as! String
        }
        if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
            self.targetUrl = dict["TargetUrl"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class GetLoginPageResponseBody : Tea.TeaModel {
    public class UrlData : Tea.TeaModel {
        public var returnUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.returnUrl != nil {
                map["ReturnUrl"] = self.returnUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReturnUrl") && dict["ReturnUrl"] != nil {
                self.returnUrl = dict["ReturnUrl"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var urlData: GetLoginPageResponseBody.UrlData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.urlData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.urlData != nil {
            map["UrlData"] = self.urlData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UrlData") && dict["UrlData"] != nil {
            var model = GetLoginPageResponseBody.UrlData()
            model.fromMap(dict["UrlData"] as! [String: Any])
            self.urlData = model
        }
    }
}

public class GetLoginPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLoginPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLoginPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSwitchUrlRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var thirdPartyUserId: String?

    public var url: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class GetSwitchUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetSwitchUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSwitchUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSwitchUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserInfoRequest : Tea.TeaModel {
    public var appName: String?

    public var bizId: String?

    public var queryJson: String?

    public var userFlag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.queryJson != nil {
            map["QueryJson"] = self.queryJson!
        }
        if self.userFlag != nil {
            map["UserFlag"] = self.userFlag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("QueryJson") && dict["QueryJson"] != nil {
            self.queryJson = dict["QueryJson"] as! String
        }
        if dict.keys.contains("UserFlag") && dict["UserFlag"] != nil {
            self.userFlag = dict["UserFlag"] as! String
        }
    }
}

public class GetUserInfoResponseBody : Tea.TeaModel {
    public class LoginResult : Tea.TeaModel {
        public var bizId: String?

        public var bizUid: String?

        public var bizUserName: String?

        public var extInfo: [String: Any]?

        public var lmUserId: Int64?

        public var returnUrl: String?

        public var subBizId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizUid != nil {
                map["BizUid"] = self.bizUid!
            }
            if self.bizUserName != nil {
                map["BizUserName"] = self.bizUserName!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.lmUserId != nil {
                map["LmUserId"] = self.lmUserId!
            }
            if self.returnUrl != nil {
                map["ReturnUrl"] = self.returnUrl!
            }
            if self.subBizId != nil {
                map["SubBizId"] = self.subBizId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
                self.bizUid = dict["BizUid"] as! String
            }
            if dict.keys.contains("BizUserName") && dict["BizUserName"] != nil {
                self.bizUserName = dict["BizUserName"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("LmUserId") && dict["LmUserId"] != nil {
                self.lmUserId = dict["LmUserId"] as! Int64
            }
            if dict.keys.contains("ReturnUrl") && dict["ReturnUrl"] != nil {
                self.returnUrl = dict["ReturnUrl"] as! String
            }
            if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
                self.subBizId = dict["SubBizId"] as! [String]
            }
        }
    }
    public var code: String?

    public var loginResult: GetUserInfoResponseBody.LoginResult?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.loginResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.loginResult != nil {
            map["LoginResult"] = self.loginResult?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LoginResult") && dict["LoginResult"] != nil {
            var model = GetUserInfoResponseBody.LoginResult()
            model.fromMap(dict["LoginResult"] as! [String: Any])
            self.loginResult = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserTokenPageRequest : Tea.TeaModel {
    public var bizId: String?

    public var expireSeconds: Int64?

    public var extJson: String?

    public var thirdPartyUserId: String?

    public var userNick: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.expireSeconds != nil {
            map["ExpireSeconds"] = self.expireSeconds!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.userNick != nil {
            map["UserNick"] = self.userNick!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExpireSeconds") && dict["ExpireSeconds"] != nil {
            self.expireSeconds = dict["ExpireSeconds"] as! Int64
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UserNick") && dict["UserNick"] != nil {
            self.userNick = dict["UserNick"] as! String
        }
    }
}

public class GetUserTokenPageResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: GetUserTokenPageResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = GetUserTokenPageResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetUserTokenPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserTokenPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserTokenPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWithholdSignPageUrlRequest : Tea.TeaModel {
    public var deviceType: String?

    public var extInfo: String?

    public var externalAgreementNo: String?

    public var identityParameters: String?

    public var merchantId: String?

    public var merchantServiceDescription: String?

    public var merchantServiceName: String?

    public var notifyUrl: String?

    public var outRequestNo: String?

    public var returnUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.externalAgreementNo != nil {
            map["ExternalAgreementNo"] = self.externalAgreementNo!
        }
        if self.identityParameters != nil {
            map["IdentityParameters"] = self.identityParameters!
        }
        if self.merchantId != nil {
            map["MerchantId"] = self.merchantId!
        }
        if self.merchantServiceDescription != nil {
            map["MerchantServiceDescription"] = self.merchantServiceDescription!
        }
        if self.merchantServiceName != nil {
            map["MerchantServiceName"] = self.merchantServiceName!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.outRequestNo != nil {
            map["OutRequestNo"] = self.outRequestNo!
        }
        if self.returnUrl != nil {
            map["ReturnUrl"] = self.returnUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceType") && dict["DeviceType"] != nil {
            self.deviceType = dict["DeviceType"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("ExternalAgreementNo") && dict["ExternalAgreementNo"] != nil {
            self.externalAgreementNo = dict["ExternalAgreementNo"] as! String
        }
        if dict.keys.contains("IdentityParameters") && dict["IdentityParameters"] != nil {
            self.identityParameters = dict["IdentityParameters"] as! String
        }
        if dict.keys.contains("MerchantId") && dict["MerchantId"] != nil {
            self.merchantId = dict["MerchantId"] as! String
        }
        if dict.keys.contains("MerchantServiceDescription") && dict["MerchantServiceDescription"] != nil {
            self.merchantServiceDescription = dict["MerchantServiceDescription"] as! String
        }
        if dict.keys.contains("MerchantServiceName") && dict["MerchantServiceName"] != nil {
            self.merchantServiceName = dict["MerchantServiceName"] as! String
        }
        if dict.keys.contains("NotifyUrl") && dict["NotifyUrl"] != nil {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
            self.outRequestNo = dict["OutRequestNo"] as! String
        }
        if dict.keys.contains("ReturnUrl") && dict["ReturnUrl"] != nil {
            self.returnUrl = dict["ReturnUrl"] as! String
        }
    }
}

public class GetWithholdSignPageUrlResponseBody : Tea.TeaModel {
    public class WithholdSignResponse : Tea.TeaModel {
        public var outRequestNo: String?

        public var pageUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.outRequestNo != nil {
                map["OutRequestNo"] = self.outRequestNo!
            }
            if self.pageUrl != nil {
                map["PageUrl"] = self.pageUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
                self.outRequestNo = dict["OutRequestNo"] as! String
            }
            if dict.keys.contains("PageUrl") && dict["PageUrl"] != nil {
                self.pageUrl = dict["PageUrl"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var withholdSignResponse: GetWithholdSignPageUrlResponseBody.WithholdSignResponse?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.withholdSignResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.withholdSignResponse != nil {
            map["WithholdSignResponse"] = self.withholdSignResponse?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WithholdSignResponse") && dict["WithholdSignResponse"] != nil {
            var model = GetWithholdSignPageUrlResponseBody.WithholdSignResponse()
            model.fromMap(dict["WithholdSignResponse"] as! [String: Any])
            self.withholdSignResponse = model
        }
    }
}

public class GetWithholdSignPageUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWithholdSignPageUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetWithholdSignPageUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GiveUserPointRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var targetBizUid: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.targetBizUid != nil {
            map["TargetBizUid"] = self.targetBizUid!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("TargetBizUid") && dict["TargetBizUid"] != nil {
            self.targetBizUid = dict["TargetBizUid"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class GiveUserPointShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfoShrink: String?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var targetBizUid: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.targetBizUid != nil {
            map["TargetBizUid"] = self.targetBizUid!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("TargetBizUid") && dict["TargetBizUid"] != nil {
            self.targetBizUid = dict["TargetBizUid"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class GiveUserPointResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountId: String?

        public var action: String?

        public var amount: Int64?

        public var bizId: String?

        public var bizUid: String?

        public var description_: String?

        public var extInfo: [String: Any]?

        public var idempotentId: String?

        public var name: String?

        public var recordId: String?

        public var rest: Int64?

        public var ruleId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizUid != nil {
                map["BizUid"] = self.bizUid!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.idempotentId != nil {
                map["IdempotentId"] = self.idempotentId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.rest != nil {
                map["Rest"] = self.rest!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Amount") && dict["Amount"] != nil {
                self.amount = dict["Amount"] as! Int64
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
                self.bizUid = dict["BizUid"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
                self.idempotentId = dict["IdempotentId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("Rest") && dict["Rest"] != nil {
                self.rest = dict["Rest"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: GiveUserPointResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = GiveUserPointResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GiveUserPointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GiveUserPointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GiveUserPointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantPromotionToUserRequest : Tea.TeaModel {
    public var bizId: String?

    public var expireSeconds: Int64?

    public var grantMode: String?

    public var grantWay: String?

    public var idempotentId: String?

    public var promotionId: String?

    public var securityCode: String?

    public var thirdPartyUserId: String?

    public var body: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.expireSeconds != nil {
            map["ExpireSeconds"] = self.expireSeconds!
        }
        if self.grantMode != nil {
            map["GrantMode"] = self.grantMode!
        }
        if self.grantWay != nil {
            map["GrantWay"] = self.grantWay!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.securityCode != nil {
            map["SecurityCode"] = self.securityCode!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExpireSeconds") && dict["ExpireSeconds"] != nil {
            self.expireSeconds = dict["ExpireSeconds"] as! Int64
        }
        if dict.keys.contains("GrantMode") && dict["GrantMode"] != nil {
            self.grantMode = dict["GrantMode"] as! String
        }
        if dict.keys.contains("GrantWay") && dict["GrantWay"] != nil {
            self.grantWay = dict["GrantWay"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("PromotionId") && dict["PromotionId"] != nil {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("SecurityCode") && dict["SecurityCode"] != nil {
            self.securityCode = dict["SecurityCode"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            self.body = dict["body"] as! [String: Any]
        }
    }
}

public class GrantPromotionToUserShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var expireSeconds: Int64?

    public var grantMode: String?

    public var grantWay: String?

    public var idempotentId: String?

    public var promotionId: String?

    public var securityCode: String?

    public var thirdPartyUserId: String?

    public var bodyShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.expireSeconds != nil {
            map["ExpireSeconds"] = self.expireSeconds!
        }
        if self.grantMode != nil {
            map["GrantMode"] = self.grantMode!
        }
        if self.grantWay != nil {
            map["GrantWay"] = self.grantWay!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.securityCode != nil {
            map["SecurityCode"] = self.securityCode!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.bodyShrink != nil {
            map["body"] = self.bodyShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExpireSeconds") && dict["ExpireSeconds"] != nil {
            self.expireSeconds = dict["ExpireSeconds"] as! Int64
        }
        if dict.keys.contains("GrantMode") && dict["GrantMode"] != nil {
            self.grantMode = dict["GrantMode"] as! String
        }
        if dict.keys.contains("GrantWay") && dict["GrantWay"] != nil {
            self.grantWay = dict["GrantWay"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("PromotionId") && dict["PromotionId"] != nil {
            self.promotionId = dict["PromotionId"] as! String
        }
        if dict.keys.contains("SecurityCode") && dict["SecurityCode"] != nil {
            self.securityCode = dict["SecurityCode"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            self.bodyShrink = dict["body"] as! String
        }
    }
}

public class GrantPromotionToUserResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var effectiveEndTime: Int64?

        public var effectiveStartTime: Int64?

        public var promotionInstanceId: String?

        public var subBizCode: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.effectiveEndTime != nil {
                map["EffectiveEndTime"] = self.effectiveEndTime!
            }
            if self.effectiveStartTime != nil {
                map["EffectiveStartTime"] = self.effectiveStartTime!
            }
            if self.promotionInstanceId != nil {
                map["PromotionInstanceId"] = self.promotionInstanceId!
            }
            if self.subBizCode != nil {
                map["SubBizCode"] = self.subBizCode!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EffectiveEndTime") && dict["EffectiveEndTime"] != nil {
                self.effectiveEndTime = dict["EffectiveEndTime"] as! Int64
            }
            if dict.keys.contains("EffectiveStartTime") && dict["EffectiveStartTime"] != nil {
                self.effectiveStartTime = dict["EffectiveStartTime"] as! Int64
            }
            if dict.keys.contains("PromotionInstanceId") && dict["PromotionInstanceId"] != nil {
                self.promotionInstanceId = dict["PromotionInstanceId"] as! String
            }
            if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                self.subBizCode = dict["SubBizCode"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: GrantPromotionToUserResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = GrantPromotionToUserResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GrantPromotionToUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantPromotionToUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GrantPromotionToUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantUserPointRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class GrantUserPointShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfoShrink: String?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class GrantUserPointResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountId: String?

        public var action: String?

        public var amount: Int64?

        public var bizId: String?

        public var bizUid: String?

        public var description_: String?

        public var extInfo: [String: Any]?

        public var idempotentId: String?

        public var name: String?

        public var recordId: String?

        public var rest: Int64?

        public var ruleId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizUid != nil {
                map["BizUid"] = self.bizUid!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.idempotentId != nil {
                map["IdempotentId"] = self.idempotentId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.rest != nil {
                map["Rest"] = self.rest!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Amount") && dict["Amount"] != nil {
                self.amount = dict["Amount"] as! Int64
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
                self.bizUid = dict["BizUid"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
                self.idempotentId = dict["IdempotentId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("Rest") && dict["Rest"] != nil {
                self.rest = dict["Rest"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: GrantUserPointResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = GrantUserPointResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GrantUserPointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantUserPointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GrantUserPointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitApplyRefundRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizClaimType: Int32?

    public var bizId: String?

    public var bizUid: String?

    public var goodsStatus: Int32?

    public var subLmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizClaimType != nil {
            map["BizClaimType"] = self.bizClaimType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.goodsStatus != nil {
            map["GoodsStatus"] = self.goodsStatus!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
            self.bizClaimType = dict["BizClaimType"] as! Int32
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("GoodsStatus") && dict["GoodsStatus"] != nil {
            self.goodsStatus = dict["GoodsStatus"] as! Int32
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class InitApplyRefundResponseBody : Tea.TeaModel {
    public class InitApplyRefundData : Tea.TeaModel {
        public class MaxRefundFeeData : Tea.TeaModel {
            public var maxRefundFee: Int32?

            public var minRefundFee: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxRefundFee != nil {
                    map["MaxRefundFee"] = self.maxRefundFee!
                }
                if self.minRefundFee != nil {
                    map["MinRefundFee"] = self.minRefundFee!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxRefundFee") && dict["MaxRefundFee"] != nil {
                    self.maxRefundFee = dict["MaxRefundFee"] as! Int32
                }
                if dict.keys.contains("MinRefundFee") && dict["MinRefundFee"] != nil {
                    self.minRefundFee = dict["MinRefundFee"] as! Int32
                }
            }
        }
        public class RefundReasonList : Tea.TeaModel {
            public class RefundReasonList : Tea.TeaModel {
                public var proofRequired: Bool?

                public var reasonTextId: Int64?

                public var reasonTips: String?

                public var refundDescRequired: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.proofRequired != nil {
                        map["ProofRequired"] = self.proofRequired!
                    }
                    if self.reasonTextId != nil {
                        map["ReasonTextId"] = self.reasonTextId!
                    }
                    if self.reasonTips != nil {
                        map["ReasonTips"] = self.reasonTips!
                    }
                    if self.refundDescRequired != nil {
                        map["RefundDescRequired"] = self.refundDescRequired!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ProofRequired") && dict["ProofRequired"] != nil {
                        self.proofRequired = dict["ProofRequired"] as! Bool
                    }
                    if dict.keys.contains("ReasonTextId") && dict["ReasonTextId"] != nil {
                        self.reasonTextId = dict["ReasonTextId"] as! Int64
                    }
                    if dict.keys.contains("ReasonTips") && dict["ReasonTips"] != nil {
                        self.reasonTips = dict["ReasonTips"] as! String
                    }
                    if dict.keys.contains("RefundDescRequired") && dict["RefundDescRequired"] != nil {
                        self.refundDescRequired = dict["RefundDescRequired"] as! Bool
                    }
                }
            }
            public var refundReasonList: [InitApplyRefundResponseBody.InitApplyRefundData.RefundReasonList.RefundReasonList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.refundReasonList != nil {
                    var tmp : [Any] = []
                    for k in self.refundReasonList! {
                        tmp.append(k.toMap())
                    }
                    map["RefundReasonList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RefundReasonList") && dict["RefundReasonList"] != nil {
                    var tmp : [InitApplyRefundResponseBody.InitApplyRefundData.RefundReasonList.RefundReasonList] = []
                    for v in dict["RefundReasonList"] as! [Any] {
                        var model = InitApplyRefundResponseBody.InitApplyRefundData.RefundReasonList.RefundReasonList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.refundReasonList = tmp
                }
            }
        }
        public var bizClaimType: Int32?

        public var mainOrderRefund: Bool?

        public var maxRefundFeeData: InitApplyRefundResponseBody.InitApplyRefundData.MaxRefundFeeData?

        public var refundReasonList: InitApplyRefundResponseBody.InitApplyRefundData.RefundReasonList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.maxRefundFeeData?.validate()
            try self.refundReasonList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizClaimType != nil {
                map["BizClaimType"] = self.bizClaimType!
            }
            if self.mainOrderRefund != nil {
                map["MainOrderRefund"] = self.mainOrderRefund!
            }
            if self.maxRefundFeeData != nil {
                map["MaxRefundFeeData"] = self.maxRefundFeeData?.toMap()
            }
            if self.refundReasonList != nil {
                map["RefundReasonList"] = self.refundReasonList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
                self.bizClaimType = dict["BizClaimType"] as! Int32
            }
            if dict.keys.contains("MainOrderRefund") && dict["MainOrderRefund"] != nil {
                self.mainOrderRefund = dict["MainOrderRefund"] as! Bool
            }
            if dict.keys.contains("MaxRefundFeeData") && dict["MaxRefundFeeData"] != nil {
                var model = InitApplyRefundResponseBody.InitApplyRefundData.MaxRefundFeeData()
                model.fromMap(dict["MaxRefundFeeData"] as! [String: Any])
                self.maxRefundFeeData = model
            }
            if dict.keys.contains("RefundReasonList") && dict["RefundReasonList"] != nil {
                var model = InitApplyRefundResponseBody.InitApplyRefundData.RefundReasonList()
                model.fromMap(dict["RefundReasonList"] as! [String: Any])
                self.refundReasonList = model
            }
        }
    }
    public var code: String?

    public var initApplyRefundData: InitApplyRefundResponseBody.InitApplyRefundData?

    public var message: String?

    public var requestId: String?

    public var subLmOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.initApplyRefundData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.initApplyRefundData != nil {
            map["InitApplyRefundData"] = self.initApplyRefundData?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("InitApplyRefundData") && dict["InitApplyRefundData"] != nil {
            var model = InitApplyRefundResponseBody.InitApplyRefundData()
            model.fromMap(dict["InitApplyRefundData"] as! [String: Any])
            self.initApplyRefundData = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
    }
}

public class InitApplyRefundResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitApplyRefundResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InitApplyRefundResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitApplyRefundWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var disputeId: Int64?

    public var refundCode: Int32?

    public var subLmOrderId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.refundCode != nil {
            map["RefundCode"] = self.refundCode!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("RefundCode") && dict["RefundCode"] != nil {
            self.refundCode = dict["RefundCode"] as! Int32
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class InitApplyRefundWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class MaxRefundFeeData : Tea.TeaModel {
            public var maxRefundFee: Int64?

            public var minRefundFee: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxRefundFee != nil {
                    map["MaxRefundFee"] = self.maxRefundFee!
                }
                if self.minRefundFee != nil {
                    map["MinRefundFee"] = self.minRefundFee!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxRefundFee") && dict["MaxRefundFee"] != nil {
                    self.maxRefundFee = dict["MaxRefundFee"] as! Int64
                }
                if dict.keys.contains("MinRefundFee") && dict["MinRefundFee"] != nil {
                    self.minRefundFee = dict["MinRefundFee"] as! Int64
                }
            }
        }
        public class RefundReasonList : Tea.TeaModel {
            public var proofRequired: Bool?

            public var reasonTextId: Int64?

            public var reasonTips: String?

            public var refundDescRequired: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.proofRequired != nil {
                    map["ProofRequired"] = self.proofRequired!
                }
                if self.reasonTextId != nil {
                    map["ReasonTextId"] = self.reasonTextId!
                }
                if self.reasonTips != nil {
                    map["ReasonTips"] = self.reasonTips!
                }
                if self.refundDescRequired != nil {
                    map["RefundDescRequired"] = self.refundDescRequired!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ProofRequired") && dict["ProofRequired"] != nil {
                    self.proofRequired = dict["ProofRequired"] as! Bool
                }
                if dict.keys.contains("ReasonTextId") && dict["ReasonTextId"] != nil {
                    self.reasonTextId = dict["ReasonTextId"] as! Int64
                }
                if dict.keys.contains("ReasonTips") && dict["ReasonTips"] != nil {
                    self.reasonTips = dict["ReasonTips"] as! String
                }
                if dict.keys.contains("RefundDescRequired") && dict["RefundDescRequired"] != nil {
                    self.refundDescRequired = dict["RefundDescRequired"] as! Bool
                }
            }
        }
        public var bizClaimType: Int32?

        public var lmOrderId: String?

        public var mainOrderRefund: Bool?

        public var maxRefundFeeData: InitApplyRefundWithDesignatedTbUidResponseBody.Model.MaxRefundFeeData?

        public var refundReasonList: [InitApplyRefundWithDesignatedTbUidResponseBody.Model.RefundReasonList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.maxRefundFeeData?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizClaimType != nil {
                map["BizClaimType"] = self.bizClaimType!
            }
            if self.lmOrderId != nil {
                map["LmOrderId"] = self.lmOrderId!
            }
            if self.mainOrderRefund != nil {
                map["MainOrderRefund"] = self.mainOrderRefund!
            }
            if self.maxRefundFeeData != nil {
                map["MaxRefundFeeData"] = self.maxRefundFeeData?.toMap()
            }
            if self.refundReasonList != nil {
                var tmp : [Any] = []
                for k in self.refundReasonList! {
                    tmp.append(k.toMap())
                }
                map["RefundReasonList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
                self.bizClaimType = dict["BizClaimType"] as! Int32
            }
            if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                self.lmOrderId = dict["LmOrderId"] as! String
            }
            if dict.keys.contains("MainOrderRefund") && dict["MainOrderRefund"] != nil {
                self.mainOrderRefund = dict["MainOrderRefund"] as! Bool
            }
            if dict.keys.contains("MaxRefundFeeData") && dict["MaxRefundFeeData"] != nil {
                var model = InitApplyRefundWithDesignatedTbUidResponseBody.Model.MaxRefundFeeData()
                model.fromMap(dict["MaxRefundFeeData"] as! [String: Any])
                self.maxRefundFeeData = model
            }
            if dict.keys.contains("RefundReasonList") && dict["RefundReasonList"] != nil {
                var tmp : [InitApplyRefundWithDesignatedTbUidResponseBody.Model.RefundReasonList] = []
                for v in dict["RefundReasonList"] as! [Any] {
                    var model = InitApplyRefundWithDesignatedTbUidResponseBody.Model.RefundReasonList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.refundReasonList = tmp
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: InitApplyRefundWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = InitApplyRefundWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class InitApplyRefundWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitApplyRefundWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InitApplyRefundWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitModifyRefundRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizClaimType: Int32?

    public var bizId: String?

    public var bizUid: String?

    public var disputeId: Int64?

    public var goodsStatus: Int32?

    public var subLmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizClaimType != nil {
            map["BizClaimType"] = self.bizClaimType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.goodsStatus != nil {
            map["GoodsStatus"] = self.goodsStatus!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
            self.bizClaimType = dict["BizClaimType"] as! Int32
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("GoodsStatus") && dict["GoodsStatus"] != nil {
            self.goodsStatus = dict["GoodsStatus"] as! Int32
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class InitModifyRefundResponseBody : Tea.TeaModel {
    public class InitApplyRefundData : Tea.TeaModel {
        public class MaxRefundFeeData : Tea.TeaModel {
            public var maxRefundFee: Int32?

            public var minRefundFee: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxRefundFee != nil {
                    map["MaxRefundFee"] = self.maxRefundFee!
                }
                if self.minRefundFee != nil {
                    map["MinRefundFee"] = self.minRefundFee!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxRefundFee") && dict["MaxRefundFee"] != nil {
                    self.maxRefundFee = dict["MaxRefundFee"] as! Int32
                }
                if dict.keys.contains("MinRefundFee") && dict["MinRefundFee"] != nil {
                    self.minRefundFee = dict["MinRefundFee"] as! Int32
                }
            }
        }
        public class RefundReasonList : Tea.TeaModel {
            public class RefundReasonList : Tea.TeaModel {
                public var proofRequired: Bool?

                public var reasonTextId: Int64?

                public var reasonTips: String?

                public var refundDescRequired: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.proofRequired != nil {
                        map["ProofRequired"] = self.proofRequired!
                    }
                    if self.reasonTextId != nil {
                        map["ReasonTextId"] = self.reasonTextId!
                    }
                    if self.reasonTips != nil {
                        map["ReasonTips"] = self.reasonTips!
                    }
                    if self.refundDescRequired != nil {
                        map["RefundDescRequired"] = self.refundDescRequired!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ProofRequired") && dict["ProofRequired"] != nil {
                        self.proofRequired = dict["ProofRequired"] as! Bool
                    }
                    if dict.keys.contains("ReasonTextId") && dict["ReasonTextId"] != nil {
                        self.reasonTextId = dict["ReasonTextId"] as! Int64
                    }
                    if dict.keys.contains("ReasonTips") && dict["ReasonTips"] != nil {
                        self.reasonTips = dict["ReasonTips"] as! String
                    }
                    if dict.keys.contains("RefundDescRequired") && dict["RefundDescRequired"] != nil {
                        self.refundDescRequired = dict["RefundDescRequired"] as! Bool
                    }
                }
            }
            public var refundReasonList: [InitModifyRefundResponseBody.InitApplyRefundData.RefundReasonList.RefundReasonList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.refundReasonList != nil {
                    var tmp : [Any] = []
                    for k in self.refundReasonList! {
                        tmp.append(k.toMap())
                    }
                    map["RefundReasonList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RefundReasonList") && dict["RefundReasonList"] != nil {
                    var tmp : [InitModifyRefundResponseBody.InitApplyRefundData.RefundReasonList.RefundReasonList] = []
                    for v in dict["RefundReasonList"] as! [Any] {
                        var model = InitModifyRefundResponseBody.InitApplyRefundData.RefundReasonList.RefundReasonList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.refundReasonList = tmp
                }
            }
        }
        public var bizClaimType: Int32?

        public var mainOrderRefund: Bool?

        public var maxRefundFeeData: InitModifyRefundResponseBody.InitApplyRefundData.MaxRefundFeeData?

        public var refundReasonList: InitModifyRefundResponseBody.InitApplyRefundData.RefundReasonList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.maxRefundFeeData?.validate()
            try self.refundReasonList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizClaimType != nil {
                map["BizClaimType"] = self.bizClaimType!
            }
            if self.mainOrderRefund != nil {
                map["MainOrderRefund"] = self.mainOrderRefund!
            }
            if self.maxRefundFeeData != nil {
                map["MaxRefundFeeData"] = self.maxRefundFeeData?.toMap()
            }
            if self.refundReasonList != nil {
                map["RefundReasonList"] = self.refundReasonList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
                self.bizClaimType = dict["BizClaimType"] as! Int32
            }
            if dict.keys.contains("MainOrderRefund") && dict["MainOrderRefund"] != nil {
                self.mainOrderRefund = dict["MainOrderRefund"] as! Bool
            }
            if dict.keys.contains("MaxRefundFeeData") && dict["MaxRefundFeeData"] != nil {
                var model = InitModifyRefundResponseBody.InitApplyRefundData.MaxRefundFeeData()
                model.fromMap(dict["MaxRefundFeeData"] as! [String: Any])
                self.maxRefundFeeData = model
            }
            if dict.keys.contains("RefundReasonList") && dict["RefundReasonList"] != nil {
                var model = InitModifyRefundResponseBody.InitApplyRefundData.RefundReasonList()
                model.fromMap(dict["RefundReasonList"] as! [String: Any])
                self.refundReasonList = model
            }
        }
    }
    public var code: String?

    public var initApplyRefundData: InitModifyRefundResponseBody.InitApplyRefundData?

    public var message: String?

    public var requestId: String?

    public var subLmOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.initApplyRefundData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.initApplyRefundData != nil {
            map["InitApplyRefundData"] = self.initApplyRefundData?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("InitApplyRefundData") && dict["InitApplyRefundData"] != nil {
            var model = InitModifyRefundResponseBody.InitApplyRefundData()
            model.fromMap(dict["InitApplyRefundData"] as! [String: Any])
            self.initApplyRefundData = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
    }
}

public class InitModifyRefundResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitModifyRefundResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InitModifyRefundResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitModifyRefundWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var disputeId: Int64?

    public var refundCode: Int32?

    public var subLmOrderId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.refundCode != nil {
            map["RefundCode"] = self.refundCode!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("RefundCode") && dict["RefundCode"] != nil {
            self.refundCode = dict["RefundCode"] as! Int32
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class InitModifyRefundWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class MaxRefundFeeData : Tea.TeaModel {
            public var maxRefundFee: Int64?

            public var minRefundFee: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxRefundFee != nil {
                    map["MaxRefundFee"] = self.maxRefundFee!
                }
                if self.minRefundFee != nil {
                    map["MinRefundFee"] = self.minRefundFee!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxRefundFee") && dict["MaxRefundFee"] != nil {
                    self.maxRefundFee = dict["MaxRefundFee"] as! Int64
                }
                if dict.keys.contains("MinRefundFee") && dict["MinRefundFee"] != nil {
                    self.minRefundFee = dict["MinRefundFee"] as! Int64
                }
            }
        }
        public class RefundReasonList : Tea.TeaModel {
            public var proofRequired: Bool?

            public var reasonTextId: Int64?

            public var reasonTips: String?

            public var refundDescRequired: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.proofRequired != nil {
                    map["ProofRequired"] = self.proofRequired!
                }
                if self.reasonTextId != nil {
                    map["ReasonTextId"] = self.reasonTextId!
                }
                if self.reasonTips != nil {
                    map["ReasonTips"] = self.reasonTips!
                }
                if self.refundDescRequired != nil {
                    map["RefundDescRequired"] = self.refundDescRequired!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ProofRequired") && dict["ProofRequired"] != nil {
                    self.proofRequired = dict["ProofRequired"] as! Bool
                }
                if dict.keys.contains("ReasonTextId") && dict["ReasonTextId"] != nil {
                    self.reasonTextId = dict["ReasonTextId"] as! Int64
                }
                if dict.keys.contains("ReasonTips") && dict["ReasonTips"] != nil {
                    self.reasonTips = dict["ReasonTips"] as! String
                }
                if dict.keys.contains("RefundDescRequired") && dict["RefundDescRequired"] != nil {
                    self.refundDescRequired = dict["RefundDescRequired"] as! Bool
                }
            }
        }
        public var bizClaimType: Int32?

        public var lmOrderId: String?

        public var mainOrderRefund: Bool?

        public var maxRefundFeeData: InitModifyRefundWithDesignatedTbUidResponseBody.Model.MaxRefundFeeData?

        public var refundReasonList: [InitModifyRefundWithDesignatedTbUidResponseBody.Model.RefundReasonList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.maxRefundFeeData?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizClaimType != nil {
                map["BizClaimType"] = self.bizClaimType!
            }
            if self.lmOrderId != nil {
                map["LmOrderId"] = self.lmOrderId!
            }
            if self.mainOrderRefund != nil {
                map["MainOrderRefund"] = self.mainOrderRefund!
            }
            if self.maxRefundFeeData != nil {
                map["MaxRefundFeeData"] = self.maxRefundFeeData?.toMap()
            }
            if self.refundReasonList != nil {
                var tmp : [Any] = []
                for k in self.refundReasonList! {
                    tmp.append(k.toMap())
                }
                map["RefundReasonList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
                self.bizClaimType = dict["BizClaimType"] as! Int32
            }
            if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                self.lmOrderId = dict["LmOrderId"] as! String
            }
            if dict.keys.contains("MainOrderRefund") && dict["MainOrderRefund"] != nil {
                self.mainOrderRefund = dict["MainOrderRefund"] as! Bool
            }
            if dict.keys.contains("MaxRefundFeeData") && dict["MaxRefundFeeData"] != nil {
                var model = InitModifyRefundWithDesignatedTbUidResponseBody.Model.MaxRefundFeeData()
                model.fromMap(dict["MaxRefundFeeData"] as! [String: Any])
                self.maxRefundFeeData = model
            }
            if dict.keys.contains("RefundReasonList") && dict["RefundReasonList"] != nil {
                var tmp : [InitModifyRefundWithDesignatedTbUidResponseBody.Model.RefundReasonList] = []
                for v in dict["RefundReasonList"] as! [Any] {
                    var model = InitModifyRefundWithDesignatedTbUidResponseBody.Model.RefundReasonList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.refundReasonList = tmp
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: InitModifyRefundWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = InitModifyRefundWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class InitModifyRefundWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitModifyRefundWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InitModifyRefundWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListActivityAtmosphereRequest : Tea.TeaModel {
    public var accountType: String?

    public var activityId: String?

    public var bizId: String?

    public var gameId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.gameId != nil {
            map["GameId"] = self.gameId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
            self.activityId = dict["ActivityId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("GameId") && dict["GameId"] != nil {
            self.gameId = dict["GameId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class ListActivityAtmosphereResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var bizUid: String?

        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizUid != nil {
                map["BizUid"] = self.bizUid!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
                self.bizUid = dict["BizUid"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: [ListActivityAtmosphereResponseBody.Model]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [ListActivityAtmosphereResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = ListActivityAtmosphereResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListActivityAtmosphereResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListActivityAtmosphereResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListActivityAtmosphereResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListActivityGameInfoRequest : Tea.TeaModel {
    public var accountType: String?

    public var activityId: String?

    public var bizId: String?

    public var endTime: Int64?

    public var gameId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var status: String?

    public var statuses: String?

    public var subType: String?

    public var thirdPartyUserId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.gameId != nil {
            map["GameId"] = self.gameId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.statuses != nil {
            map["Statuses"] = self.statuses!
        }
        if self.subType != nil {
            map["SubType"] = self.subType!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
            self.activityId = dict["ActivityId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("GameId") && dict["GameId"] != nil {
            self.gameId = dict["GameId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Statuses") && dict["Statuses"] != nil {
            self.statuses = dict["Statuses"] as! String
        }
        if dict.keys.contains("SubType") && dict["SubType"] != nil {
            self.subType = dict["SubType"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListActivityGameInfoResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var extInfo: String?

        public var gameShowInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.gameShowInfo != nil {
                map["GameShowInfo"] = self.gameShowInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! String
            }
            if dict.keys.contains("GameShowInfo") && dict["GameShowInfo"] != nil {
                self.gameShowInfo = dict["GameShowInfo"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: [ListActivityGameInfoResponseBody.Model]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [ListActivityGameInfoResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = ListActivityGameInfoResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListActivityGameInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListActivityGameInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListActivityGameInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListItemActivitiesRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIds: [String: Any]?

    public var lmItemIds: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lmItemIds != nil {
            map["LmItemIds"] = self.lmItemIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [String: Any]
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIds = dict["LmItemIds"] as! [String: Any]
        }
    }
}

public class ListItemActivitiesShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIdsShrink: String?

    public var lmItemIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIdsShrink != nil {
            map["ItemIds"] = self.itemIdsShrink!
        }
        if self.lmItemIdsShrink != nil {
            map["LmItemIds"] = self.lmItemIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIdsShrink = dict["ItemIds"] as! String
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIdsShrink = dict["LmItemIds"] as! String
        }
    }
}

public class ListItemActivitiesResponseBody : Tea.TeaModel {
    public class LmItemActivityModelList : Tea.TeaModel {
        public class LmItemActivityModel : Tea.TeaModel {
            public class LmActivityPopModel : Tea.TeaModel {
                public var bizId: String?

                public var displayDate: String?

                public var endDate: String?

                public var extInfo: [String: Any]?

                public var id: Int64?

                public var startDate: String?

                public var subBizCode: String?

                public var title: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizId != nil {
                        map["BizId"] = self.bizId!
                    }
                    if self.displayDate != nil {
                        map["DisplayDate"] = self.displayDate!
                    }
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.extInfo != nil {
                        map["ExtInfo"] = self.extInfo!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.startDate != nil {
                        map["StartDate"] = self.startDate!
                    }
                    if self.subBizCode != nil {
                        map["SubBizCode"] = self.subBizCode!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizId") && dict["BizId"] != nil {
                        self.bizId = dict["BizId"] as! String
                    }
                    if dict.keys.contains("DisplayDate") && dict["DisplayDate"] != nil {
                        self.displayDate = dict["DisplayDate"] as! String
                    }
                    if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                        self.endDate = dict["EndDate"] as! String
                    }
                    if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                        self.extInfo = dict["ExtInfo"] as! [String: Any]
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
                        self.startDate = dict["StartDate"] as! String
                    }
                    if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                        self.subBizCode = dict["SubBizCode"] as! String
                    }
                    if dict.keys.contains("Title") && dict["Title"] != nil {
                        self.title = dict["Title"] as! String
                    }
                }
            }
            public var itemId: Int64?

            public var lmActivityPopModel: ListItemActivitiesResponseBody.LmItemActivityModelList.LmItemActivityModel.LmActivityPopModel?

            public var lmItemId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lmActivityPopModel?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.lmActivityPopModel != nil {
                    map["LmActivityPopModel"] = self.lmActivityPopModel?.toMap()
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("LmActivityPopModel") && dict["LmActivityPopModel"] != nil {
                    var model = ListItemActivitiesResponseBody.LmItemActivityModelList.LmItemActivityModel.LmActivityPopModel()
                    model.fromMap(dict["LmActivityPopModel"] as! [String: Any])
                    self.lmActivityPopModel = model
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
            }
        }
        public var lmItemActivityModel: [ListItemActivitiesResponseBody.LmItemActivityModelList.LmItemActivityModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmItemActivityModel != nil {
                var tmp : [Any] = []
                for k in self.lmItemActivityModel! {
                    tmp.append(k.toMap())
                }
                map["LmItemActivityModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmItemActivityModel") && dict["LmItemActivityModel"] != nil {
                var tmp : [ListItemActivitiesResponseBody.LmItemActivityModelList.LmItemActivityModel] = []
                for v in dict["LmItemActivityModel"] as! [Any] {
                    var model = ListItemActivitiesResponseBody.LmItemActivityModelList.LmItemActivityModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmItemActivityModel = tmp
            }
        }
    }
    public var code: String?

    public var lmItemActivityModelList: ListItemActivitiesResponseBody.LmItemActivityModelList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmItemActivityModelList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmItemActivityModelList != nil {
            map["LmItemActivityModelList"] = self.lmItemActivityModelList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmItemActivityModelList") && dict["LmItemActivityModelList"] != nil {
            var model = ListItemActivitiesResponseBody.LmItemActivityModelList()
            model.fromMap(dict["LmItemActivityModelList"] as! [String: Any])
            self.lmItemActivityModelList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListItemActivitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListItemActivitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListItemActivitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserGameProcessRequest : Tea.TeaModel {
    public var accountType: String?

    public var activityId: String?

    public var bizId: String?

    public var endTime: Int64?

    public var gameId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var status: String?

    public var statuses: String?

    public var thirdPartyUserId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.gameId != nil {
            map["GameId"] = self.gameId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.statuses != nil {
            map["Statuses"] = self.statuses!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
            self.activityId = dict["ActivityId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("GameId") && dict["GameId"] != nil {
            self.gameId = dict["GameId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Statuses") && dict["Statuses"] != nil {
            self.statuses = dict["Statuses"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListUserGameProcessResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var activityId: String?

        public var createTime: Int64?

        public var currentShowContent: String?

        public var currentStepId: String?

        public var currentStepStatus: String?

        public var desc: String?

        public var extInfo: String?

        public var gameId: String?

        public var modifyTime: Int64?

        public var name: String?

        public var processId: String?

        public var routeId: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentShowContent != nil {
                map["CurrentShowContent"] = self.currentShowContent!
            }
            if self.currentStepId != nil {
                map["CurrentStepId"] = self.currentStepId!
            }
            if self.currentStepStatus != nil {
                map["CurrentStepStatus"] = self.currentStepStatus!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.gameId != nil {
                map["GameId"] = self.gameId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CurrentShowContent") && dict["CurrentShowContent"] != nil {
                self.currentShowContent = dict["CurrentShowContent"] as! String
            }
            if dict.keys.contains("CurrentStepId") && dict["CurrentStepId"] != nil {
                self.currentStepId = dict["CurrentStepId"] as! String
            }
            if dict.keys.contains("CurrentStepStatus") && dict["CurrentStepStatus"] != nil {
                self.currentStepStatus = dict["CurrentStepStatus"] as! String
            }
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! String
            }
            if dict.keys.contains("GameId") && dict["GameId"] != nil {
                self.gameId = dict["GameId"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
                self.processId = dict["ProcessId"] as! String
            }
            if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
                self.routeId = dict["RouteId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: [ListUserGameProcessResponseBody.Model]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [ListUserGameProcessResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = ListUserGameProcessResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListUserGameProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserGameProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUserGameProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserPointRecordsRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var endTime: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pointAction: String?

    public var pointActions: String?

    public var recordId: String?

    public var ruleId: String?

    public var startTime: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pointAction != nil {
            map["PointAction"] = self.pointAction!
        }
        if self.pointActions != nil {
            map["PointActions"] = self.pointActions!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PointAction") && dict["PointAction"] != nil {
            self.pointAction = dict["PointAction"] as! String
        }
        if dict.keys.contains("PointActions") && dict["PointActions"] != nil {
            self.pointActions = dict["PointActions"] as! String
        }
        if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class ListUserPointRecordsResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var action: String?

        public var amount: Int64?

        public var createTime: Int64?

        public var description_: String?

        public var extInfo: [String: Any]?

        public var idempotentId: String?

        public var modifyTime: Int64?

        public var name: String?

        public var recordId: String?

        public var rest: Int64?

        public var ruleId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.idempotentId != nil {
                map["IdempotentId"] = self.idempotentId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.rest != nil {
                map["Rest"] = self.rest!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Amount") && dict["Amount"] != nil {
                self.amount = dict["Amount"] as! Int64
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
                self.idempotentId = dict["IdempotentId"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("Rest") && dict["Rest"] != nil {
                self.rest = dict["Rest"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: [ListUserPointRecordsResponseBody.Model]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [ListUserPointRecordsResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = ListUserPointRecordsResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListUserPointRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserPointRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUserPointRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBasicAndBizItemsRequest : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public class SkuList : Tea.TeaModel {
            public var benefitId: String?

            public var points: Int64?

            public var pointsAmount: Int64?

            public var priceCent: Int64?

            public var quantity: Int32?

            public var skuId: Int64?

            public var statusAction: Int64?

            public var supplierPrice: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.benefitId != nil {
                    map["BenefitId"] = self.benefitId!
                }
                if self.points != nil {
                    map["Points"] = self.points!
                }
                if self.pointsAmount != nil {
                    map["PointsAmount"] = self.pointsAmount!
                }
                if self.priceCent != nil {
                    map["PriceCent"] = self.priceCent!
                }
                if self.quantity != nil {
                    map["Quantity"] = self.quantity!
                }
                if self.skuId != nil {
                    map["SkuId"] = self.skuId!
                }
                if self.statusAction != nil {
                    map["StatusAction"] = self.statusAction!
                }
                if self.supplierPrice != nil {
                    map["SupplierPrice"] = self.supplierPrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BenefitId") && dict["BenefitId"] != nil {
                    self.benefitId = dict["BenefitId"] as! String
                }
                if dict.keys.contains("Points") && dict["Points"] != nil {
                    self.points = dict["Points"] as! Int64
                }
                if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                    self.pointsAmount = dict["PointsAmount"] as! Int64
                }
                if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                    self.priceCent = dict["PriceCent"] as! Int64
                }
                if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                    self.quantity = dict["Quantity"] as! Int32
                }
                if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                    self.skuId = dict["SkuId"] as! Int64
                }
                if dict.keys.contains("StatusAction") && dict["StatusAction"] != nil {
                    self.statusAction = dict["StatusAction"] as! Int64
                }
                if dict.keys.contains("SupplierPrice") && dict["SupplierPrice"] != nil {
                    self.supplierPrice = dict["SupplierPrice"] as! Int64
                }
            }
        }
        public var itemId: Int64?

        public var lmItemId: String?

        public var skuList: [ModifyBasicAndBizItemsRequest.ItemList.SkuList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.skuList != nil {
                var tmp : [Any] = []
                for k in self.skuList! {
                    tmp.append(k.toMap())
                }
                map["SkuList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                var tmp : [ModifyBasicAndBizItemsRequest.ItemList.SkuList] = []
                for v in dict["SkuList"] as! [Any] {
                    var model = ModifyBasicAndBizItemsRequest.ItemList.SkuList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skuList = tmp
            }
        }
    }
    public var bizId: String?

    public var itemList: [ModifyBasicAndBizItemsRequest.ItemList]?

    public var subBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [ModifyBasicAndBizItemsRequest.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = ModifyBasicAndBizItemsRequest.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
    }
}

public class ModifyBasicAndBizItemsResponseBody : Tea.TeaModel {
    public class FailedItemList : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public class SkuIdList : Tea.TeaModel {
                public var sku: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sku != nil {
                        map["Sku"] = self.sku!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Sku") && dict["Sku"] != nil {
                        self.sku = dict["Sku"] as! [String]
                    }
                }
            }
            public var itemId: Int64?

            public var lmItemId: String?

            public var skuIdList: ModifyBasicAndBizItemsResponseBody.FailedItemList.Item.SkuIdList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.skuIdList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.skuIdList != nil {
                    map["SkuIdList"] = self.skuIdList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("SkuIdList") && dict["SkuIdList"] != nil {
                    var model = ModifyBasicAndBizItemsResponseBody.FailedItemList.Item.SkuIdList()
                    model.fromMap(dict["SkuIdList"] as! [String: Any])
                    self.skuIdList = model
                }
            }
        }
        public var item: [ModifyBasicAndBizItemsResponseBody.FailedItemList.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [ModifyBasicAndBizItemsResponseBody.FailedItemList.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = ModifyBasicAndBizItemsResponseBody.FailedItemList.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var code: String?

    public var failedItemList: ModifyBasicAndBizItemsResponseBody.FailedItemList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failedItemList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.failedItemList != nil {
            map["FailedItemList"] = self.failedItemList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FailedItemList") && dict["FailedItemList"] != nil {
            var model = ModifyBasicAndBizItemsResponseBody.FailedItemList()
            model.fromMap(dict["FailedItemList"] as! [String: Any])
            self.failedItemList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBasicAndBizItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBasicAndBizItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyBasicAndBizItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBasicItemSupplierPriceRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmItemId: String?

    public var lmShopId: Int64?

    public var skuId: Int64?

    public var supplierPrice: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.lmShopId != nil {
            map["LmShopId"] = self.lmShopId!
        }
        if self.skuId != nil {
            map["SkuId"] = self.skuId!
        }
        if self.supplierPrice != nil {
            map["SupplierPrice"] = self.supplierPrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
            self.lmShopId = dict["LmShopId"] as! Int64
        }
        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
            self.skuId = dict["SkuId"] as! Int64
        }
        if dict.keys.contains("SupplierPrice") && dict["SupplierPrice"] != nil {
            self.supplierPrice = dict["SupplierPrice"] as! Int64
        }
    }
}

public class ModifyBasicItemSupplierPriceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var model: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBasicItemSupplierPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBasicItemSupplierPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyBasicItemSupplierPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBizItemsRequest : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public class SkuList : Tea.TeaModel {
            public var benefitId: String?

            public var points: Int64?

            public var pointsAmount: Int64?

            public var priceCent: Int64?

            public var quantity: Int32?

            public var skuId: Int64?

            public var statusAction: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.benefitId != nil {
                    map["BenefitId"] = self.benefitId!
                }
                if self.points != nil {
                    map["Points"] = self.points!
                }
                if self.pointsAmount != nil {
                    map["PointsAmount"] = self.pointsAmount!
                }
                if self.priceCent != nil {
                    map["PriceCent"] = self.priceCent!
                }
                if self.quantity != nil {
                    map["Quantity"] = self.quantity!
                }
                if self.skuId != nil {
                    map["SkuId"] = self.skuId!
                }
                if self.statusAction != nil {
                    map["StatusAction"] = self.statusAction!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BenefitId") && dict["BenefitId"] != nil {
                    self.benefitId = dict["BenefitId"] as! String
                }
                if dict.keys.contains("Points") && dict["Points"] != nil {
                    self.points = dict["Points"] as! Int64
                }
                if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                    self.pointsAmount = dict["PointsAmount"] as! Int64
                }
                if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                    self.priceCent = dict["PriceCent"] as! Int64
                }
                if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                    self.quantity = dict["Quantity"] as! Int32
                }
                if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                    self.skuId = dict["SkuId"] as! Int64
                }
                if dict.keys.contains("StatusAction") && dict["StatusAction"] != nil {
                    self.statusAction = dict["StatusAction"] as! Int64
                }
            }
        }
        public var itemId: Int64?

        public var lmItemId: String?

        public var skuList: [ModifyBizItemsRequest.ItemList.SkuList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.skuList != nil {
                var tmp : [Any] = []
                for k in self.skuList! {
                    tmp.append(k.toMap())
                }
                map["SkuList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                var tmp : [ModifyBizItemsRequest.ItemList.SkuList] = []
                for v in dict["SkuList"] as! [Any] {
                    var model = ModifyBizItemsRequest.ItemList.SkuList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skuList = tmp
            }
        }
    }
    public var bizId: String?

    public var itemList: [ModifyBizItemsRequest.ItemList]?

    public var subBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [ModifyBizItemsRequest.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = ModifyBizItemsRequest.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
    }
}

public class ModifyBizItemsResponseBody : Tea.TeaModel {
    public class FailedItemList : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public class SkuIdList : Tea.TeaModel {
                public var sku: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sku != nil {
                        map["Sku"] = self.sku!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Sku") && dict["Sku"] != nil {
                        self.sku = dict["Sku"] as! [String]
                    }
                }
            }
            public var itemId: Int64?

            public var lmItemId: String?

            public var skuIdList: ModifyBizItemsResponseBody.FailedItemList.Item.SkuIdList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.skuIdList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.skuIdList != nil {
                    map["SkuIdList"] = self.skuIdList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("SkuIdList") && dict["SkuIdList"] != nil {
                    var model = ModifyBizItemsResponseBody.FailedItemList.Item.SkuIdList()
                    model.fromMap(dict["SkuIdList"] as! [String: Any])
                    self.skuIdList = model
                }
            }
        }
        public var item: [ModifyBizItemsResponseBody.FailedItemList.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [ModifyBizItemsResponseBody.FailedItemList.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = ModifyBizItemsResponseBody.FailedItemList.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var code: String?

    public var failedItemList: ModifyBizItemsResponseBody.FailedItemList?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failedItemList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.failedItemList != nil {
            map["FailedItemList"] = self.failedItemList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FailedItemList") && dict["FailedItemList"] != nil {
            var model = ModifyBizItemsResponseBody.FailedItemList()
            model.fromMap(dict["FailedItemList"] as! [String: Any])
            self.failedItemList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ModifyBizItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBizItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyBizItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyItemLimitRuleRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var bizId: String?

    public var endTime: Int64?

    public var itemId: Int64?

    public var lmActivityId: Int64?

    public var lmItemId: String?

    public var ruleId: Int64?

    public var ruleType: Int32?

    public var subBizCode: String?

    public var upperNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmActivityId != nil {
            map["LmActivityId"] = self.lmActivityId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.subBizCode != nil {
            map["SubBizCode"] = self.subBizCode!
        }
        if self.upperNum != nil {
            map["UpperNum"] = self.upperNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") && dict["BeginTime"] != nil {
            self.beginTime = dict["BeginTime"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
            self.lmActivityId = dict["LmActivityId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
            self.ruleType = dict["RuleType"] as! Int32
        }
        if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
            self.subBizCode = dict["SubBizCode"] as! String
        }
        if dict.keys.contains("UpperNum") && dict["UpperNum"] != nil {
            self.upperNum = dict["UpperNum"] as! Int32
        }
    }
}

public class ModifyItemLimitRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var model: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyItemLimitRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyItemLimitRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyItemLimitRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyOrderDeliveryAddressRequest : Tea.TeaModel {
    public var bizId: String?

    public var deliveryAddress: String?

    public var extJson: String?

    public var lmOrderId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            self.deliveryAddress = dict["DeliveryAddress"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
    }
}

public class ModifyOrderDeliveryAddressResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var resultInfo: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultInfo != nil {
                map["ResultInfo"] = self.resultInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultInfo") && dict["ResultInfo"] != nil {
                self.resultInfo = dict["ResultInfo"] as! [String: Any]
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: ModifyOrderDeliveryAddressResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = ModifyOrderDeliveryAddressResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ModifyOrderDeliveryAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyOrderDeliveryAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyOrderDeliveryAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRefundRequest : Tea.TeaModel {
    public class LeavePictureList : Tea.TeaModel {
        public var desc: String?

        public var picture: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.picture != nil {
                map["Picture"] = self.picture!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Picture") && dict["Picture"] != nil {
                self.picture = dict["Picture"] as! String
            }
        }
    }
    public var accountType: String?

    public var applyReasonTextId: Int64?

    public var applyRefundCount: Int32?

    public var applyRefundFee: Int64?

    public var bizClaimType: Int32?

    public var bizId: String?

    public var bizUid: String?

    public var disputeId: Int64?

    public var goodsStatus: Int32?

    public var leaveMessage: String?

    public var leavePictureList: [ModifyRefundRequest.LeavePictureList]?

    public var subLmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.applyReasonTextId != nil {
            map["ApplyReasonTextId"] = self.applyReasonTextId!
        }
        if self.applyRefundCount != nil {
            map["ApplyRefundCount"] = self.applyRefundCount!
        }
        if self.applyRefundFee != nil {
            map["ApplyRefundFee"] = self.applyRefundFee!
        }
        if self.bizClaimType != nil {
            map["BizClaimType"] = self.bizClaimType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.goodsStatus != nil {
            map["GoodsStatus"] = self.goodsStatus!
        }
        if self.leaveMessage != nil {
            map["LeaveMessage"] = self.leaveMessage!
        }
        if self.leavePictureList != nil {
            var tmp : [Any] = []
            for k in self.leavePictureList! {
                tmp.append(k.toMap())
            }
            map["LeavePictureList"] = tmp
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("ApplyReasonTextId") && dict["ApplyReasonTextId"] != nil {
            self.applyReasonTextId = dict["ApplyReasonTextId"] as! Int64
        }
        if dict.keys.contains("ApplyRefundCount") && dict["ApplyRefundCount"] != nil {
            self.applyRefundCount = dict["ApplyRefundCount"] as! Int32
        }
        if dict.keys.contains("ApplyRefundFee") && dict["ApplyRefundFee"] != nil {
            self.applyRefundFee = dict["ApplyRefundFee"] as! Int64
        }
        if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
            self.bizClaimType = dict["BizClaimType"] as! Int32
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("GoodsStatus") && dict["GoodsStatus"] != nil {
            self.goodsStatus = dict["GoodsStatus"] as! Int32
        }
        if dict.keys.contains("LeaveMessage") && dict["LeaveMessage"] != nil {
            self.leaveMessage = dict["LeaveMessage"] as! String
        }
        if dict.keys.contains("LeavePictureList") && dict["LeavePictureList"] != nil {
            var tmp : [ModifyRefundRequest.LeavePictureList] = []
            for v in dict["LeavePictureList"] as! [Any] {
                var model = ModifyRefundRequest.LeavePictureList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.leavePictureList = tmp
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class ModifyRefundResponseBody : Tea.TeaModel {
    public class RefundApplicationData : Tea.TeaModel {
        public var disputeStatus: Int32?

        public var disputeType: Int32?

        public var subLmOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disputeStatus != nil {
                map["DisputeStatus"] = self.disputeStatus!
            }
            if self.disputeType != nil {
                map["DisputeType"] = self.disputeType!
            }
            if self.subLmOrderId != nil {
                map["SubLmOrderId"] = self.subLmOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisputeStatus") && dict["DisputeStatus"] != nil {
                self.disputeStatus = dict["DisputeStatus"] as! Int32
            }
            if dict.keys.contains("DisputeType") && dict["DisputeType"] != nil {
                self.disputeType = dict["DisputeType"] as! Int32
            }
            if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
                self.subLmOrderId = dict["SubLmOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var refundApplicationData: ModifyRefundResponseBody.RefundApplicationData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.refundApplicationData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.refundApplicationData != nil {
            map["RefundApplicationData"] = self.refundApplicationData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RefundApplicationData") && dict["RefundApplicationData"] != nil {
            var model = ModifyRefundResponseBody.RefundApplicationData()
            model.fromMap(dict["RefundApplicationData"] as! [String: Any])
            self.refundApplicationData = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyRefundResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRefundResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyRefundResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRefundWithDesignatedTbUidRequest : Tea.TeaModel {
    public class Proofs : Tea.TeaModel {
        public var messagePic: String?

        public var messagePicDesc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.messagePic != nil {
                map["MessagePic"] = self.messagePic!
            }
            if self.messagePicDesc != nil {
                map["MessagePicDesc"] = self.messagePicDesc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MessagePic") && dict["MessagePic"] != nil {
                self.messagePic = dict["MessagePic"] as! String
            }
            if dict.keys.contains("MessagePicDesc") && dict["MessagePicDesc"] != nil {
                self.messagePicDesc = dict["MessagePicDesc"] as! String
            }
        }
    }
    public var bizId: String?

    public var disputeId: Int64?

    public var goodsStatus: Int32?

    public var message: String?

    public var proofs: [ModifyRefundWithDesignatedTbUidRequest.Proofs]?

    public var reasonId: Int64?

    public var refundCode: Int32?

    public var refundCount: Int32?

    public var refundFee: Int64?

    public var subLmOrderId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.goodsStatus != nil {
            map["GoodsStatus"] = self.goodsStatus!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.proofs != nil {
            var tmp : [Any] = []
            for k in self.proofs! {
                tmp.append(k.toMap())
            }
            map["Proofs"] = tmp
        }
        if self.reasonId != nil {
            map["ReasonId"] = self.reasonId!
        }
        if self.refundCode != nil {
            map["RefundCode"] = self.refundCode!
        }
        if self.refundCount != nil {
            map["RefundCount"] = self.refundCount!
        }
        if self.refundFee != nil {
            map["RefundFee"] = self.refundFee!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("GoodsStatus") && dict["GoodsStatus"] != nil {
            self.goodsStatus = dict["GoodsStatus"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Proofs") && dict["Proofs"] != nil {
            var tmp : [ModifyRefundWithDesignatedTbUidRequest.Proofs] = []
            for v in dict["Proofs"] as! [Any] {
                var model = ModifyRefundWithDesignatedTbUidRequest.Proofs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.proofs = tmp
        }
        if dict.keys.contains("ReasonId") && dict["ReasonId"] != nil {
            self.reasonId = dict["ReasonId"] as! Int64
        }
        if dict.keys.contains("RefundCode") && dict["RefundCode"] != nil {
            self.refundCode = dict["RefundCode"] as! Int32
        }
        if dict.keys.contains("RefundCount") && dict["RefundCount"] != nil {
            self.refundCount = dict["RefundCount"] as! Int32
        }
        if dict.keys.contains("RefundFee") && dict["RefundFee"] != nil {
            self.refundFee = dict["RefundFee"] as! Int64
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class ModifyRefundWithDesignatedTbUidShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var disputeId: Int64?

    public var goodsStatus: Int32?

    public var message: String?

    public var proofsShrink: String?

    public var reasonId: Int64?

    public var refundCode: Int32?

    public var refundCount: Int32?

    public var refundFee: Int64?

    public var subLmOrderId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.goodsStatus != nil {
            map["GoodsStatus"] = self.goodsStatus!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.proofsShrink != nil {
            map["Proofs"] = self.proofsShrink!
        }
        if self.reasonId != nil {
            map["ReasonId"] = self.reasonId!
        }
        if self.refundCode != nil {
            map["RefundCode"] = self.refundCode!
        }
        if self.refundCount != nil {
            map["RefundCount"] = self.refundCount!
        }
        if self.refundFee != nil {
            map["RefundFee"] = self.refundFee!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("GoodsStatus") && dict["GoodsStatus"] != nil {
            self.goodsStatus = dict["GoodsStatus"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Proofs") && dict["Proofs"] != nil {
            self.proofsShrink = dict["Proofs"] as! String
        }
        if dict.keys.contains("ReasonId") && dict["ReasonId"] != nil {
            self.reasonId = dict["ReasonId"] as! Int64
        }
        if dict.keys.contains("RefundCode") && dict["RefundCode"] != nil {
            self.refundCode = dict["RefundCode"] as! Int32
        }
        if dict.keys.contains("RefundCount") && dict["RefundCount"] != nil {
            self.refundCount = dict["RefundCount"] as! Int32
        }
        if dict.keys.contains("RefundFee") && dict["RefundFee"] != nil {
            self.refundFee = dict["RefundFee"] as! Int64
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class ModifyRefundWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var disputeId: Int64?

        public var disputeStatus: Int32?

        public var disputeType: Int32?

        public var subLmOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disputeId != nil {
                map["DisputeId"] = self.disputeId!
            }
            if self.disputeStatus != nil {
                map["DisputeStatus"] = self.disputeStatus!
            }
            if self.disputeType != nil {
                map["DisputeType"] = self.disputeType!
            }
            if self.subLmOrderId != nil {
                map["SubLmOrderId"] = self.subLmOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
                self.disputeId = dict["DisputeId"] as! Int64
            }
            if dict.keys.contains("DisputeStatus") && dict["DisputeStatus"] != nil {
                self.disputeStatus = dict["DisputeStatus"] as! Int32
            }
            if dict.keys.contains("DisputeType") && dict["DisputeType"] != nil {
                self.disputeType = dict["DisputeType"] as! Int32
            }
            if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
                self.subLmOrderId = dict["SubLmOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: ModifyRefundWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = ModifyRefundWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ModifyRefundWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRefundWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyRefundWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySettleAccountRequest : Tea.TeaModel {
    public var accountChannel: String?

    public var accountId: String?

    public var accountName: String?

    public var accountNo: String?

    public var accountPayType: String?

    public var accountType: String?

    public var bizId: String?

    public var countryOrAreaCode: String?

    public var currency: String?

    public var extInfo: String?

    public var idempotentId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountChannel != nil {
            map["AccountChannel"] = self.accountChannel!
        }
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountNo != nil {
            map["AccountNo"] = self.accountNo!
        }
        if self.accountPayType != nil {
            map["AccountPayType"] = self.accountPayType!
        }
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.countryOrAreaCode != nil {
            map["CountryOrAreaCode"] = self.countryOrAreaCode!
        }
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountChannel") && dict["AccountChannel"] != nil {
            self.accountChannel = dict["AccountChannel"] as! String
        }
        if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("AccountName") && dict["AccountName"] != nil {
            self.accountName = dict["AccountName"] as! String
        }
        if dict.keys.contains("AccountNo") && dict["AccountNo"] != nil {
            self.accountNo = dict["AccountNo"] as! String
        }
        if dict.keys.contains("AccountPayType") && dict["AccountPayType"] != nil {
            self.accountPayType = dict["AccountPayType"] as! String
        }
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CountryOrAreaCode") && dict["CountryOrAreaCode"] != nil {
            self.countryOrAreaCode = dict["CountryOrAreaCode"] as! String
        }
        if dict.keys.contains("Currency") && dict["Currency"] != nil {
            self.currency = dict["Currency"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
    }
}

public class ModifySettleAccountResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountId: String?

        public var accountNo: String?

        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.accountNo != nil {
                map["AccountNo"] = self.accountNo!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("AccountNo") && dict["AccountNo"] != nil {
                self.accountNo = dict["AccountNo"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: ModifySettleAccountResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = ModifySettleAccountResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifySettleAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySettleAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySettleAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySupplierPriceAndPriceCentRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmItemId: String?

    public var lmShopId: String?

    public var priceCent: String?

    public var skuId: String?

    public var supplierPrice: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.lmShopId != nil {
            map["LmShopId"] = self.lmShopId!
        }
        if self.priceCent != nil {
            map["PriceCent"] = self.priceCent!
        }
        if self.skuId != nil {
            map["SkuId"] = self.skuId!
        }
        if self.supplierPrice != nil {
            map["SupplierPrice"] = self.supplierPrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
            self.lmShopId = dict["LmShopId"] as! String
        }
        if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
            self.priceCent = dict["PriceCent"] as! String
        }
        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
            self.skuId = dict["SkuId"] as! String
        }
        if dict.keys.contains("SupplierPrice") && dict["SupplierPrice"] != nil {
            self.supplierPrice = dict["SupplierPrice"] as! String
        }
    }
}

public class ModifySupplierPriceAndPriceCentResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var model: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySupplierPriceAndPriceCentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySupplierPriceAndPriceCentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySupplierPriceAndPriceCentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class NotifyPayOrderStatusRequest : Tea.TeaModel {
    public var amount: Int64?

    public var channelId: String?

    public var operationDate: String?

    public var payTypes: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.operationDate != nil {
            map["OperationDate"] = self.operationDate!
        }
        if self.payTypes != nil {
            map["PayTypes"] = self.payTypes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OperationDate") && dict["OperationDate"] != nil {
            self.operationDate = dict["OperationDate"] as! String
        }
        if dict.keys.contains("PayTypes") && dict["PayTypes"] != nil {
            self.payTypes = dict["PayTypes"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class NotifyPayOrderStatusResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
    }
}

public class NotifyPayOrderStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: NotifyPayOrderStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = NotifyPayOrderStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class NotifyWithholdFundRequest : Tea.TeaModel {
    public var amount: Int64?

    public var channelId: String?

    public var operationDate: String?

    public var payTypes: String?

    public var requestId: String?

    public var tenantOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.operationDate != nil {
            map["OperationDate"] = self.operationDate!
        }
        if self.payTypes != nil {
            map["PayTypes"] = self.payTypes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantOrderId != nil {
            map["TenantOrderId"] = self.tenantOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OperationDate") && dict["OperationDate"] != nil {
            self.operationDate = dict["OperationDate"] as! String
        }
        if dict.keys.contains("PayTypes") && dict["PayTypes"] != nil {
            self.payTypes = dict["PayTypes"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantOrderId") && dict["TenantOrderId"] != nil {
            self.tenantOrderId = dict["TenantOrderId"] as! String
        }
    }
}

public class NotifyWithholdFundResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class NotifyWithholdFundResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: NotifyWithholdFundResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = NotifyWithholdFundResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenRealTbAccountSupportRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class OpenRealTbAccountSupportResponseBody : Tea.TeaModel {
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: Any?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Any
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class OpenRealTbAccountSupportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenRealTbAccountSupportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenRealTbAccountSupportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushUserGameProcessRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var currentStepId: String?

    public var extInfo: [String: Any]?

    public var processId: String?

    public var thirdPartyUserId: String?

    public var body: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.currentStepId != nil {
            map["CurrentStepId"] = self.currentStepId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.processId != nil {
            map["ProcessId"] = self.processId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CurrentStepId") && dict["CurrentStepId"] != nil {
            self.currentStepId = dict["CurrentStepId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
            self.processId = dict["ProcessId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            self.body = dict["body"] as! [String: Any]
        }
    }
}

public class PushUserGameProcessShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var currentStepId: String?

    public var extInfoShrink: String?

    public var processId: String?

    public var thirdPartyUserId: String?

    public var bodyShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.currentStepId != nil {
            map["CurrentStepId"] = self.currentStepId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.processId != nil {
            map["ProcessId"] = self.processId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.bodyShrink != nil {
            map["body"] = self.bodyShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CurrentStepId") && dict["CurrentStepId"] != nil {
            self.currentStepId = dict["CurrentStepId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
            self.processId = dict["ProcessId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            self.bodyShrink = dict["body"] as! String
        }
    }
}

public class PushUserGameProcessResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var activityId: String?

        public var currentShowContent: String?

        public var currentStepId: String?

        public var currentStepStatus: String?

        public var desc: String?

        public var extInfo: String?

        public var gameId: String?

        public var name: String?

        public var processId: String?

        public var routeId: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.currentShowContent != nil {
                map["CurrentShowContent"] = self.currentShowContent!
            }
            if self.currentStepId != nil {
                map["CurrentStepId"] = self.currentStepId!
            }
            if self.currentStepStatus != nil {
                map["CurrentStepStatus"] = self.currentStepStatus!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.gameId != nil {
                map["GameId"] = self.gameId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("CurrentShowContent") && dict["CurrentShowContent"] != nil {
                self.currentShowContent = dict["CurrentShowContent"] as! String
            }
            if dict.keys.contains("CurrentStepId") && dict["CurrentStepId"] != nil {
                self.currentStepId = dict["CurrentStepId"] as! String
            }
            if dict.keys.contains("CurrentStepStatus") && dict["CurrentStepStatus"] != nil {
                self.currentStepStatus = dict["CurrentStepStatus"] as! String
            }
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! String
            }
            if dict.keys.contains("GameId") && dict["GameId"] != nil {
                self.gameId = dict["GameId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
                self.processId = dict["ProcessId"] as! String
            }
            if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
                self.routeId = dict["RouteId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: PushUserGameProcessResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = PushUserGameProcessResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PushUserGameProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushUserGameProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushUserGameProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryActivityItemsRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmActivityId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmActivityId != nil {
            map["LmActivityId"] = self.lmActivityId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
            self.lmActivityId = dict["LmActivityId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryActivityItemsResponseBody : Tea.TeaModel {
    public class LmActivityItemModelList : Tea.TeaModel {
        public class LmActivityItemModel : Tea.TeaModel {
            public class SkuModelList : Tea.TeaModel {
                public class LmActivityItemSkuModel : Tea.TeaModel {
                    public var activityPrice: Int64?

                    public var activityStatus: String?

                    public var bizId: String?

                    public var itemId: Int64?

                    public var lmActivityId: Int64?

                    public var lmItemId: String?

                    public var reservedPrice: Int64?

                    public var skuId: Int64?

                    public var skuPicUrl: String?

                    public var skuTitle: String?

                    public var tips: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityPrice != nil {
                            map["ActivityPrice"] = self.activityPrice!
                        }
                        if self.activityStatus != nil {
                            map["ActivityStatus"] = self.activityStatus!
                        }
                        if self.bizId != nil {
                            map["BizId"] = self.bizId!
                        }
                        if self.itemId != nil {
                            map["ItemId"] = self.itemId!
                        }
                        if self.lmActivityId != nil {
                            map["LmActivityId"] = self.lmActivityId!
                        }
                        if self.lmItemId != nil {
                            map["LmItemId"] = self.lmItemId!
                        }
                        if self.reservedPrice != nil {
                            map["ReservedPrice"] = self.reservedPrice!
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        if self.skuPicUrl != nil {
                            map["SkuPicUrl"] = self.skuPicUrl!
                        }
                        if self.skuTitle != nil {
                            map["SkuTitle"] = self.skuTitle!
                        }
                        if self.tips != nil {
                            map["Tips"] = self.tips!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityPrice") && dict["ActivityPrice"] != nil {
                            self.activityPrice = dict["ActivityPrice"] as! Int64
                        }
                        if dict.keys.contains("ActivityStatus") && dict["ActivityStatus"] != nil {
                            self.activityStatus = dict["ActivityStatus"] as! String
                        }
                        if dict.keys.contains("BizId") && dict["BizId"] != nil {
                            self.bizId = dict["BizId"] as! String
                        }
                        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                            self.itemId = dict["ItemId"] as! Int64
                        }
                        if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
                            self.lmActivityId = dict["LmActivityId"] as! Int64
                        }
                        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                            self.lmItemId = dict["LmItemId"] as! String
                        }
                        if dict.keys.contains("ReservedPrice") && dict["ReservedPrice"] != nil {
                            self.reservedPrice = dict["ReservedPrice"] as! Int64
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                        if dict.keys.contains("SkuPicUrl") && dict["SkuPicUrl"] != nil {
                            self.skuPicUrl = dict["SkuPicUrl"] as! String
                        }
                        if dict.keys.contains("SkuTitle") && dict["SkuTitle"] != nil {
                            self.skuTitle = dict["SkuTitle"] as! String
                        }
                        if dict.keys.contains("Tips") && dict["Tips"] != nil {
                            self.tips = dict["Tips"] as! String
                        }
                    }
                }
                public var lmActivityItemSkuModel: [QueryActivityItemsResponseBody.LmActivityItemModelList.LmActivityItemModel.SkuModelList.LmActivityItemSkuModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lmActivityItemSkuModel != nil {
                        var tmp : [Any] = []
                        for k in self.lmActivityItemSkuModel! {
                            tmp.append(k.toMap())
                        }
                        map["LmActivityItemSkuModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LmActivityItemSkuModel") && dict["LmActivityItemSkuModel"] != nil {
                        var tmp : [QueryActivityItemsResponseBody.LmActivityItemModelList.LmActivityItemModel.SkuModelList.LmActivityItemSkuModel] = []
                        for v in dict["LmActivityItemSkuModel"] as! [Any] {
                            var model = QueryActivityItemsResponseBody.LmActivityItemModelList.LmActivityItemModel.SkuModelList.LmActivityItemSkuModel()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.lmActivityItemSkuModel = tmp
                    }
                }
            }
            public var canSell: Bool?

            public var itemActivityQuantity: Int32?

            public var itemActivityStatus: String?

            public var itemId: Int64?

            public var itemTitle: String?

            public var lmActivityId: Int64?

            public var lmItemId: String?

            public var lmShopId: String?

            public var mainPicUrl: String?

            public var sellableQuantity: Int32?

            public var skuModelList: QueryActivityItemsResponseBody.LmActivityItemModelList.LmActivityItemModel.SkuModelList?

            public var tbSellerId: Int64?

            public var tbShopId: Int64?

            public var tbShopName: String?

            public var tips: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.skuModelList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canSell != nil {
                    map["CanSell"] = self.canSell!
                }
                if self.itemActivityQuantity != nil {
                    map["ItemActivityQuantity"] = self.itemActivityQuantity!
                }
                if self.itemActivityStatus != nil {
                    map["ItemActivityStatus"] = self.itemActivityStatus!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemTitle != nil {
                    map["ItemTitle"] = self.itemTitle!
                }
                if self.lmActivityId != nil {
                    map["LmActivityId"] = self.lmActivityId!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.lmShopId != nil {
                    map["LmShopId"] = self.lmShopId!
                }
                if self.mainPicUrl != nil {
                    map["MainPicUrl"] = self.mainPicUrl!
                }
                if self.sellableQuantity != nil {
                    map["SellableQuantity"] = self.sellableQuantity!
                }
                if self.skuModelList != nil {
                    map["SkuModelList"] = self.skuModelList?.toMap()
                }
                if self.tbSellerId != nil {
                    map["TbSellerId"] = self.tbSellerId!
                }
                if self.tbShopId != nil {
                    map["TbShopId"] = self.tbShopId!
                }
                if self.tbShopName != nil {
                    map["TbShopName"] = self.tbShopName!
                }
                if self.tips != nil {
                    map["Tips"] = self.tips!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                    self.canSell = dict["CanSell"] as! Bool
                }
                if dict.keys.contains("ItemActivityQuantity") && dict["ItemActivityQuantity"] != nil {
                    self.itemActivityQuantity = dict["ItemActivityQuantity"] as! Int32
                }
                if dict.keys.contains("ItemActivityStatus") && dict["ItemActivityStatus"] != nil {
                    self.itemActivityStatus = dict["ItemActivityStatus"] as! String
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                    self.itemTitle = dict["ItemTitle"] as! String
                }
                if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
                    self.lmActivityId = dict["LmActivityId"] as! Int64
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
                    self.lmShopId = dict["LmShopId"] as! String
                }
                if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                    self.mainPicUrl = dict["MainPicUrl"] as! String
                }
                if dict.keys.contains("SellableQuantity") && dict["SellableQuantity"] != nil {
                    self.sellableQuantity = dict["SellableQuantity"] as! Int32
                }
                if dict.keys.contains("SkuModelList") && dict["SkuModelList"] != nil {
                    var model = QueryActivityItemsResponseBody.LmActivityItemModelList.LmActivityItemModel.SkuModelList()
                    model.fromMap(dict["SkuModelList"] as! [String: Any])
                    self.skuModelList = model
                }
                if dict.keys.contains("TbSellerId") && dict["TbSellerId"] != nil {
                    self.tbSellerId = dict["TbSellerId"] as! Int64
                }
                if dict.keys.contains("TbShopId") && dict["TbShopId"] != nil {
                    self.tbShopId = dict["TbShopId"] as! Int64
                }
                if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                    self.tbShopName = dict["TbShopName"] as! String
                }
                if dict.keys.contains("Tips") && dict["Tips"] != nil {
                    self.tips = dict["Tips"] as! String
                }
            }
        }
        public var lmActivityItemModel: [QueryActivityItemsResponseBody.LmActivityItemModelList.LmActivityItemModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmActivityItemModel != nil {
                var tmp : [Any] = []
                for k in self.lmActivityItemModel! {
                    tmp.append(k.toMap())
                }
                map["LmActivityItemModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmActivityItemModel") && dict["LmActivityItemModel"] != nil {
                var tmp : [QueryActivityItemsResponseBody.LmActivityItemModelList.LmActivityItemModel] = []
                for v in dict["LmActivityItemModel"] as! [Any] {
                    var model = QueryActivityItemsResponseBody.LmActivityItemModelList.LmActivityItemModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmActivityItemModel = tmp
            }
        }
    }
    public var code: String?

    public var lmActivityItemModelList: QueryActivityItemsResponseBody.LmActivityItemModelList?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmActivityItemModelList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmActivityItemModelList != nil {
            map["LmActivityItemModelList"] = self.lmActivityItemModelList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmActivityItemModelList") && dict["LmActivityItemModelList"] != nil {
            var model = QueryActivityItemsResponseBody.LmActivityItemModelList()
            model.fromMap(dict["LmActivityItemModelList"] as! [String: Any])
            self.lmActivityItemModelList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryActivityItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryActivityItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryActivityItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAddressRequest : Tea.TeaModel {
    public var bizId: String?

    public var divisionCode: String?

    public var ip: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.divisionCode != nil {
            map["DivisionCode"] = self.divisionCode!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
            self.divisionCode = dict["DivisionCode"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
    }
}

public class QueryAddressResponseBody : Tea.TeaModel {
    public class DivisionAddress : Tea.TeaModel {
        public class DivisionAddress : Tea.TeaModel {
            public var divisionCode: Int64?

            public var divisionLevel: Int32?

            public var divisionName: String?

            public var parentId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.divisionCode != nil {
                    map["DivisionCode"] = self.divisionCode!
                }
                if self.divisionLevel != nil {
                    map["DivisionLevel"] = self.divisionLevel!
                }
                if self.divisionName != nil {
                    map["DivisionName"] = self.divisionName!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
                    self.divisionCode = dict["DivisionCode"] as! Int64
                }
                if dict.keys.contains("DivisionLevel") && dict["DivisionLevel"] != nil {
                    self.divisionLevel = dict["DivisionLevel"] as! Int32
                }
                if dict.keys.contains("DivisionName") && dict["DivisionName"] != nil {
                    self.divisionName = dict["DivisionName"] as! String
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! Int64
                }
            }
        }
        public var divisionAddress: [QueryAddressResponseBody.DivisionAddress.DivisionAddress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.divisionAddress != nil {
                var tmp : [Any] = []
                for k in self.divisionAddress! {
                    tmp.append(k.toMap())
                }
                map["DivisionAddress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DivisionAddress") && dict["DivisionAddress"] != nil {
                var tmp : [QueryAddressResponseBody.DivisionAddress.DivisionAddress] = []
                for v in dict["DivisionAddress"] as! [Any] {
                    var model = QueryAddressResponseBody.DivisionAddress.DivisionAddress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.divisionAddress = tmp
            }
        }
    }
    public var code: String?

    public var divisionAddress: QueryAddressResponseBody.DivisionAddress?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.divisionAddress?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.divisionAddress != nil {
            map["DivisionAddress"] = self.divisionAddress?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DivisionAddress") && dict["DivisionAddress"] != nil {
            var model = QueryAddressResponseBody.DivisionAddress()
            model.fromMap(dict["DivisionAddress"] as! [String: Any])
            self.divisionAddress = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAddressDetailRequest : Tea.TeaModel {
    public var addressInfo: String?

    public var bizId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressInfo != nil {
            map["AddressInfo"] = self.addressInfo!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressInfo") && dict["AddressInfo"] != nil {
            self.addressInfo = dict["AddressInfo"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryAddressDetailResponseBody : Tea.TeaModel {
    public class DeliveryAddress : Tea.TeaModel {
        public var addressDetail: String?

        public var addressId: Int64?

        public var area: String?

        public var city: String?

        public var country: String?

        public var divisionCode: String?

        public var fullName: String?

        public var mobile: String?

        public var postCode: String?

        public var province: String?

        public var status: Int32?

        public var town: String?

        public var townDivisionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressDetail != nil {
                map["AddressDetail"] = self.addressDetail!
            }
            if self.addressId != nil {
                map["AddressId"] = self.addressId!
            }
            if self.area != nil {
                map["Area"] = self.area!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.country != nil {
                map["Country"] = self.country!
            }
            if self.divisionCode != nil {
                map["DivisionCode"] = self.divisionCode!
            }
            if self.fullName != nil {
                map["FullName"] = self.fullName!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.postCode != nil {
                map["PostCode"] = self.postCode!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.town != nil {
                map["Town"] = self.town!
            }
            if self.townDivisionCode != nil {
                map["TownDivisionCode"] = self.townDivisionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressDetail") && dict["AddressDetail"] != nil {
                self.addressDetail = dict["AddressDetail"] as! String
            }
            if dict.keys.contains("AddressId") && dict["AddressId"] != nil {
                self.addressId = dict["AddressId"] as! Int64
            }
            if dict.keys.contains("Area") && dict["Area"] != nil {
                self.area = dict["Area"] as! String
            }
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("Country") && dict["Country"] != nil {
                self.country = dict["Country"] as! String
            }
            if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
                self.divisionCode = dict["DivisionCode"] as! String
            }
            if dict.keys.contains("FullName") && dict["FullName"] != nil {
                self.fullName = dict["FullName"] as! String
            }
            if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("PostCode") && dict["PostCode"] != nil {
                self.postCode = dict["PostCode"] as! String
            }
            if dict.keys.contains("Province") && dict["Province"] != nil {
                self.province = dict["Province"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Town") && dict["Town"] != nil {
                self.town = dict["Town"] as! String
            }
            if dict.keys.contains("TownDivisionCode") && dict["TownDivisionCode"] != nil {
                self.townDivisionCode = dict["TownDivisionCode"] as! String
            }
        }
    }
    public var code: String?

    public var deliveryAddress: QueryAddressDetailResponseBody.DeliveryAddress?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deliveryAddress?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            var model = QueryAddressDetailResponseBody.DeliveryAddress()
            model.fromMap(dict["DeliveryAddress"] as! [String: Any])
            self.deliveryAddress = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryAddressDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAddressDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAddressDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAddressListRequest : Tea.TeaModel {
    public var bizId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryAddressListResponseBody : Tea.TeaModel {
    public class AddressList : Tea.TeaModel {
        public var addressDetail: String?

        public var addressId: Int64?

        public var area: String?

        public var city: String?

        public var country: String?

        public var divisionCode: String?

        public var fullName: String?

        public var mobile: String?

        public var postCode: String?

        public var province: String?

        public var status: Int32?

        public var town: String?

        public var townDivisionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressDetail != nil {
                map["AddressDetail"] = self.addressDetail!
            }
            if self.addressId != nil {
                map["AddressId"] = self.addressId!
            }
            if self.area != nil {
                map["Area"] = self.area!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.country != nil {
                map["Country"] = self.country!
            }
            if self.divisionCode != nil {
                map["DivisionCode"] = self.divisionCode!
            }
            if self.fullName != nil {
                map["FullName"] = self.fullName!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.postCode != nil {
                map["PostCode"] = self.postCode!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.town != nil {
                map["Town"] = self.town!
            }
            if self.townDivisionCode != nil {
                map["TownDivisionCode"] = self.townDivisionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressDetail") && dict["AddressDetail"] != nil {
                self.addressDetail = dict["AddressDetail"] as! String
            }
            if dict.keys.contains("AddressId") && dict["AddressId"] != nil {
                self.addressId = dict["AddressId"] as! Int64
            }
            if dict.keys.contains("Area") && dict["Area"] != nil {
                self.area = dict["Area"] as! String
            }
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("Country") && dict["Country"] != nil {
                self.country = dict["Country"] as! String
            }
            if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
                self.divisionCode = dict["DivisionCode"] as! String
            }
            if dict.keys.contains("FullName") && dict["FullName"] != nil {
                self.fullName = dict["FullName"] as! String
            }
            if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("PostCode") && dict["PostCode"] != nil {
                self.postCode = dict["PostCode"] as! String
            }
            if dict.keys.contains("Province") && dict["Province"] != nil {
                self.province = dict["Province"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Town") && dict["Town"] != nil {
                self.town = dict["Town"] as! String
            }
            if dict.keys.contains("TownDivisionCode") && dict["TownDivisionCode"] != nil {
                self.townDivisionCode = dict["TownDivisionCode"] as! String
            }
        }
    }
    public var addressList: [QueryAddressListResponseBody.AddressList]?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressList != nil {
            var tmp : [Any] = []
            for k in self.addressList! {
                tmp.append(k.toMap())
            }
            map["AddressList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressList") && dict["AddressList"] != nil {
            var tmp : [QueryAddressListResponseBody.AddressList] = []
            for v in dict["AddressList"] as! [Any] {
                var model = QueryAddressListResponseBody.AddressList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addressList = tmp
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryAddressListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAddressListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAddressListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAdvertisementSettleInfoRequest : Tea.TeaModel {
    public var bizId: String?

    public var channelId: String?

    public var endTime: String?

    public var extInfo: String?

    public var mediaSettleDetailId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var settleNo: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.mediaSettleDetailId != nil {
            map["MediaSettleDetailId"] = self.mediaSettleDetailId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.settleNo != nil {
            map["SettleNo"] = self.settleNo!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("MediaSettleDetailId") && dict["MediaSettleDetailId"] != nil {
            self.mediaSettleDetailId = dict["MediaSettleDetailId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SettleNo") && dict["SettleNo"] != nil {
            self.settleNo = dict["SettleNo"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class QueryAdvertisementSettleInfoResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class AdvertiseSettleInfoList : Tea.TeaModel {
            public var advertiseName: String?

            public var advertiseSettleAmount: String?

            public var advertiseSettleDetailId: String?

            public var channelId: String?

            public var createDate: String?

            public var endTime: String?

            public var extInfo: String?

            public var mediaSettleDetailId: String?

            public var modifiedDate: String?

            public var settleNo: String?

            public var settleStatus: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.advertiseName != nil {
                    map["AdvertiseName"] = self.advertiseName!
                }
                if self.advertiseSettleAmount != nil {
                    map["AdvertiseSettleAmount"] = self.advertiseSettleAmount!
                }
                if self.advertiseSettleDetailId != nil {
                    map["AdvertiseSettleDetailId"] = self.advertiseSettleDetailId!
                }
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.createDate != nil {
                    map["CreateDate"] = self.createDate!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.extInfo != nil {
                    map["ExtInfo"] = self.extInfo!
                }
                if self.mediaSettleDetailId != nil {
                    map["MediaSettleDetailId"] = self.mediaSettleDetailId!
                }
                if self.modifiedDate != nil {
                    map["ModifiedDate"] = self.modifiedDate!
                }
                if self.settleNo != nil {
                    map["SettleNo"] = self.settleNo!
                }
                if self.settleStatus != nil {
                    map["SettleStatus"] = self.settleStatus!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdvertiseName") && dict["AdvertiseName"] != nil {
                    self.advertiseName = dict["AdvertiseName"] as! String
                }
                if dict.keys.contains("AdvertiseSettleAmount") && dict["AdvertiseSettleAmount"] != nil {
                    self.advertiseSettleAmount = dict["AdvertiseSettleAmount"] as! String
                }
                if dict.keys.contains("AdvertiseSettleDetailId") && dict["AdvertiseSettleDetailId"] != nil {
                    self.advertiseSettleDetailId = dict["AdvertiseSettleDetailId"] as! String
                }
                if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                    self.channelId = dict["ChannelId"] as! String
                }
                if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                    self.createDate = dict["CreateDate"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                    self.extInfo = dict["ExtInfo"] as! String
                }
                if dict.keys.contains("MediaSettleDetailId") && dict["MediaSettleDetailId"] != nil {
                    self.mediaSettleDetailId = dict["MediaSettleDetailId"] as! String
                }
                if dict.keys.contains("ModifiedDate") && dict["ModifiedDate"] != nil {
                    self.modifiedDate = dict["ModifiedDate"] as! String
                }
                if dict.keys.contains("SettleNo") && dict["SettleNo"] != nil {
                    self.settleNo = dict["SettleNo"] as! String
                }
                if dict.keys.contains("SettleStatus") && dict["SettleStatus"] != nil {
                    self.settleStatus = dict["SettleStatus"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var advertiseSettleInfoList: [QueryAdvertisementSettleInfoResponseBody.Model.AdvertiseSettleInfoList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advertiseSettleInfoList != nil {
                var tmp : [Any] = []
                for k in self.advertiseSettleInfoList! {
                    tmp.append(k.toMap())
                }
                map["AdvertiseSettleInfoList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdvertiseSettleInfoList") && dict["AdvertiseSettleInfoList"] != nil {
                var tmp : [QueryAdvertisementSettleInfoResponseBody.Model.AdvertiseSettleInfoList] = []
                for v in dict["AdvertiseSettleInfoList"] as! [Any] {
                    var model = QueryAdvertisementSettleInfoResponseBody.Model.AdvertiseSettleInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.advertiseSettleInfoList = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: QueryAdvertisementSettleInfoResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryAdvertisementSettleInfoResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryAdvertisementSettleInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAdvertisementSettleInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAdvertisementSettleInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAgreementRequest : Tea.TeaModel {
    public var agreementNo: String?

    public var externalAgreementNo: String?

    public var merchantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agreementNo != nil {
            map["AgreementNo"] = self.agreementNo!
        }
        if self.externalAgreementNo != nil {
            map["ExternalAgreementNo"] = self.externalAgreementNo!
        }
        if self.merchantId != nil {
            map["MerchantId"] = self.merchantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgreementNo") && dict["AgreementNo"] != nil {
            self.agreementNo = dict["AgreementNo"] as! String
        }
        if dict.keys.contains("ExternalAgreementNo") && dict["ExternalAgreementNo"] != nil {
            self.externalAgreementNo = dict["ExternalAgreementNo"] as! String
        }
        if dict.keys.contains("MerchantId") && dict["MerchantId"] != nil {
            self.merchantId = dict["MerchantId"] as! String
        }
    }
}

public class QueryAgreementResponseBody : Tea.TeaModel {
    public class QueryAgreementResponse : Tea.TeaModel {
        public var agreementNo: String?

        public var externalAgreementNo: String?

        public var invalidTime: String?

        public var signTime: String?

        public var status: String?

        public var validTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementNo != nil {
                map["AgreementNo"] = self.agreementNo!
            }
            if self.externalAgreementNo != nil {
                map["ExternalAgreementNo"] = self.externalAgreementNo!
            }
            if self.invalidTime != nil {
                map["InvalidTime"] = self.invalidTime!
            }
            if self.signTime != nil {
                map["SignTime"] = self.signTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.validTime != nil {
                map["ValidTime"] = self.validTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementNo") && dict["AgreementNo"] != nil {
                self.agreementNo = dict["AgreementNo"] as! String
            }
            if dict.keys.contains("ExternalAgreementNo") && dict["ExternalAgreementNo"] != nil {
                self.externalAgreementNo = dict["ExternalAgreementNo"] as! String
            }
            if dict.keys.contains("InvalidTime") && dict["InvalidTime"] != nil {
                self.invalidTime = dict["InvalidTime"] as! String
            }
            if dict.keys.contains("SignTime") && dict["SignTime"] != nil {
                self.signTime = dict["SignTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("ValidTime") && dict["ValidTime"] != nil {
                self.validTime = dict["ValidTime"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var queryAgreementResponse: QueryAgreementResponseBody.QueryAgreementResponse?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.queryAgreementResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.queryAgreementResponse != nil {
            map["QueryAgreementResponse"] = self.queryAgreementResponse?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("QueryAgreementResponse") && dict["QueryAgreementResponse"] != nil {
            var model = QueryAgreementResponseBody.QueryAgreementResponse()
            model.fromMap(dict["QueryAgreementResponse"] as! [String: Any])
            self.queryAgreementResponse = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryAgreementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAgreementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAgreementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAllCinemasRequest : Tea.TeaModel {
    public var bizId: String?

    public var cityCode: Int64?

    public var extJson: String?

    public var pageNumber: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.cityCode != nil {
            map["CityCode"] = self.cityCode!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
            self.cityCode = dict["CityCode"] as! Int64
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
    }
}

public class QueryAllCinemasResponseBody : Tea.TeaModel {
    public class Cinemas : Tea.TeaModel {
        public class Cinema : Tea.TeaModel {
            public var address: String?

            public var cinemaName: String?

            public var cityId: Int64?

            public var cityName: String?

            public var id: Int64?

            public var latitude: String?

            public var longitude: String?

            public var phone: String?

            public var scheduleCloseTime: Int64?

            public var standardId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.cinemaName != nil {
                    map["CinemaName"] = self.cinemaName!
                }
                if self.cityId != nil {
                    map["CityId"] = self.cityId!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.latitude != nil {
                    map["Latitude"] = self.latitude!
                }
                if self.longitude != nil {
                    map["Longitude"] = self.longitude!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.scheduleCloseTime != nil {
                    map["ScheduleCloseTime"] = self.scheduleCloseTime!
                }
                if self.standardId != nil {
                    map["StandardId"] = self.standardId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("CinemaName") && dict["CinemaName"] != nil {
                    self.cinemaName = dict["CinemaName"] as! String
                }
                if dict.keys.contains("CityId") && dict["CityId"] != nil {
                    self.cityId = dict["CityId"] as! Int64
                }
                if dict.keys.contains("CityName") && dict["CityName"] != nil {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Latitude") && dict["Latitude"] != nil {
                    self.latitude = dict["Latitude"] as! String
                }
                if dict.keys.contains("Longitude") && dict["Longitude"] != nil {
                    self.longitude = dict["Longitude"] as! String
                }
                if dict.keys.contains("Phone") && dict["Phone"] != nil {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("ScheduleCloseTime") && dict["ScheduleCloseTime"] != nil {
                    self.scheduleCloseTime = dict["ScheduleCloseTime"] as! Int64
                }
                if dict.keys.contains("StandardId") && dict["StandardId"] != nil {
                    self.standardId = dict["StandardId"] as! String
                }
            }
        }
        public var cinema: [QueryAllCinemasResponseBody.Cinemas.Cinema]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cinema != nil {
                var tmp : [Any] = []
                for k in self.cinema! {
                    tmp.append(k.toMap())
                }
                map["Cinema"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cinema") && dict["Cinema"] != nil {
                var tmp : [QueryAllCinemasResponseBody.Cinemas.Cinema] = []
                for v in dict["Cinema"] as! [Any] {
                    var model = QueryAllCinemasResponseBody.Cinemas.Cinema()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cinema = tmp
            }
        }
    }
    public var cinemas: QueryAllCinemasResponseBody.Cinemas?

    public var code: String?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cinemas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cinemas != nil {
            map["Cinemas"] = self.cinemas?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cinemas") && dict["Cinemas"] != nil {
            var model = QueryAllCinemasResponseBody.Cinemas()
            model.fromMap(dict["Cinemas"] as! [String: Any])
            self.cinemas = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryAllCinemasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAllCinemasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAllCinemasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAllCitiesRequest : Tea.TeaModel {
    public var bizId: String?

    public var extJson: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! [String: Any]
        }
    }
}

public class QueryAllCitiesShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var extJsonShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extJsonShrink != nil {
            map["ExtJson"] = self.extJsonShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJsonShrink = dict["ExtJson"] as! String
        }
    }
}

public class QueryAllCitiesResponseBody : Tea.TeaModel {
    public class Cities : Tea.TeaModel {
        public class City : Tea.TeaModel {
            public var cityCode: Int64?

            public var id: Int64?

            public var name: String?

            public var parentId: Int64?

            public var pinYin: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.pinYin != nil {
                    map["PinYin"] = self.pinYin!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
                    self.cityCode = dict["CityCode"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("PinYin") && dict["PinYin"] != nil {
                    self.pinYin = dict["PinYin"] as! String
                }
            }
        }
        public var city: [QueryAllCitiesResponseBody.Cities.City]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.city != nil {
                var tmp : [Any] = []
                for k in self.city! {
                    tmp.append(k.toMap())
                }
                map["City"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("City") && dict["City"] != nil {
                var tmp : [QueryAllCitiesResponseBody.Cities.City] = []
                for v in dict["City"] as! [Any] {
                    var model = QueryAllCitiesResponseBody.Cities.City()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.city = tmp
            }
        }
    }
    public var cities: QueryAllCitiesResponseBody.Cities?

    public var code: String?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cities?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cities != nil {
            map["Cities"] = self.cities?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cities") && dict["Cities"] != nil {
            var model = QueryAllCitiesResponseBody.Cities()
            model.fromMap(dict["Cities"] as! [String: Any])
            self.cities = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAllCitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAllCitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAllCitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBatchRegistAnonymousTbAccountResultRequest : Tea.TeaModel {
    public var batchId: String?

    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchId != nil {
            map["BatchId"] = self.batchId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchId") && dict["BatchId"] != nil {
            self.batchId = dict["BatchId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class QueryBatchRegistAnonymousTbAccountResultResponseBody : Tea.TeaModel {
    public class FailIds : Tea.TeaModel {
        public var failId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failId != nil {
                map["FailId"] = self.failId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailId") && dict["FailId"] != nil {
                self.failId = dict["FailId"] as! [String]
            }
        }
    }
    public var batchId: String?

    public var code: String?

    public var failIds: QueryBatchRegistAnonymousTbAccountResultResponseBody.FailIds?

    public var message: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchId != nil {
            map["BatchId"] = self.batchId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.failIds != nil {
            map["FailIds"] = self.failIds?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchId") && dict["BatchId"] != nil {
            self.batchId = dict["BatchId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FailIds") && dict["FailIds"] != nil {
            var model = QueryBatchRegistAnonymousTbAccountResultResponseBody.FailIds()
            model.fromMap(dict["FailIds"] as! [String: Any])
            self.failIds = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class QueryBatchRegistAnonymousTbAccountResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBatchRegistAnonymousTbAccountResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryBatchRegistAnonymousTbAccountResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBestSession4ItemsRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIds: [String: Any]?

    public var lmItemIds: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lmItemIds != nil {
            map["LmItemIds"] = self.lmItemIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [String: Any]
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIds = dict["LmItemIds"] as! [String: Any]
        }
    }
}

public class QueryBestSession4ItemsShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIdsShrink: String?

    public var lmItemIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIdsShrink != nil {
            map["ItemIds"] = self.itemIdsShrink!
        }
        if self.lmItemIdsShrink != nil {
            map["LmItemIds"] = self.lmItemIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIdsShrink = dict["ItemIds"] as! String
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIdsShrink = dict["LmItemIds"] as! String
        }
    }
}

public class QueryBestSession4ItemsResponseBody : Tea.TeaModel {
    public class LmItemActivitySessionModelList : Tea.TeaModel {
        public class LmItemActivitySessionModel : Tea.TeaModel {
            public class LmActivitySessionModel : Tea.TeaModel {
                public var bizId: String?

                public var description_: String?

                public var displayDate: String?

                public var endDate: String?

                public var extInfo: [String: Any]?

                public var lmActivityId: Int64?

                public var lmSessionId: Int64?

                public var name: String?

                public var startDate: String?

                public var subBizCode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizId != nil {
                        map["BizId"] = self.bizId!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.displayDate != nil {
                        map["DisplayDate"] = self.displayDate!
                    }
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.extInfo != nil {
                        map["ExtInfo"] = self.extInfo!
                    }
                    if self.lmActivityId != nil {
                        map["LmActivityId"] = self.lmActivityId!
                    }
                    if self.lmSessionId != nil {
                        map["LmSessionId"] = self.lmSessionId!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.startDate != nil {
                        map["StartDate"] = self.startDate!
                    }
                    if self.subBizCode != nil {
                        map["SubBizCode"] = self.subBizCode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizId") && dict["BizId"] != nil {
                        self.bizId = dict["BizId"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DisplayDate") && dict["DisplayDate"] != nil {
                        self.displayDate = dict["DisplayDate"] as! String
                    }
                    if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                        self.endDate = dict["EndDate"] as! String
                    }
                    if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                        self.extInfo = dict["ExtInfo"] as! [String: Any]
                    }
                    if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
                        self.lmActivityId = dict["LmActivityId"] as! Int64
                    }
                    if dict.keys.contains("LmSessionId") && dict["LmSessionId"] != nil {
                        self.lmSessionId = dict["LmSessionId"] as! Int64
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
                        self.startDate = dict["StartDate"] as! String
                    }
                    if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                        self.subBizCode = dict["SubBizCode"] as! String
                    }
                }
            }
            public var itemId: Int64?

            public var lmActivitySessionModel: QueryBestSession4ItemsResponseBody.LmItemActivitySessionModelList.LmItemActivitySessionModel.LmActivitySessionModel?

            public var lmItemId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lmActivitySessionModel?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.lmActivitySessionModel != nil {
                    map["LmActivitySessionModel"] = self.lmActivitySessionModel?.toMap()
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("LmActivitySessionModel") && dict["LmActivitySessionModel"] != nil {
                    var model = QueryBestSession4ItemsResponseBody.LmItemActivitySessionModelList.LmItemActivitySessionModel.LmActivitySessionModel()
                    model.fromMap(dict["LmActivitySessionModel"] as! [String: Any])
                    self.lmActivitySessionModel = model
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
            }
        }
        public var lmItemActivitySessionModel: [QueryBestSession4ItemsResponseBody.LmItemActivitySessionModelList.LmItemActivitySessionModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmItemActivitySessionModel != nil {
                var tmp : [Any] = []
                for k in self.lmItemActivitySessionModel! {
                    tmp.append(k.toMap())
                }
                map["LmItemActivitySessionModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmItemActivitySessionModel") && dict["LmItemActivitySessionModel"] != nil {
                var tmp : [QueryBestSession4ItemsResponseBody.LmItemActivitySessionModelList.LmItemActivitySessionModel] = []
                for v in dict["LmItemActivitySessionModel"] as! [Any] {
                    var model = QueryBestSession4ItemsResponseBody.LmItemActivitySessionModelList.LmItemActivitySessionModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmItemActivitySessionModel = tmp
            }
        }
    }
    public var code: String?

    public var lmItemActivitySessionModelList: QueryBestSession4ItemsResponseBody.LmItemActivitySessionModelList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmItemActivitySessionModelList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmItemActivitySessionModelList != nil {
            map["LmItemActivitySessionModelList"] = self.lmItemActivitySessionModelList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmItemActivitySessionModelList") && dict["LmItemActivitySessionModelList"] != nil {
            var model = QueryBestSession4ItemsResponseBody.LmItemActivitySessionModelList()
            model.fromMap(dict["LmItemActivitySessionModelList"] as! [String: Any])
            self.lmItemActivitySessionModelList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryBestSession4ItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBestSession4ItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryBestSession4ItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBizItemListRequest : Tea.TeaModel {
    public var bizId: String?

    public var categoryId: Int64?

    public var itemIds: [String: Any]?

    public var lmItemIds: [String: Any]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subBizId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lmItemIds != nil {
            map["LmItemIds"] = self.lmItemIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [String: Any]
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIds = dict["LmItemIds"] as! [String: Any]
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class QueryBizItemListShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var categoryId: Int64?

    public var itemIdsShrink: String?

    public var lmItemIdsShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subBizId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.itemIdsShrink != nil {
            map["ItemIds"] = self.itemIdsShrink!
        }
        if self.lmItemIdsShrink != nil {
            map["LmItemIds"] = self.lmItemIdsShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIdsShrink = dict["ItemIds"] as! String
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIdsShrink = dict["LmItemIds"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class QueryBizItemListResponseBody : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public class SkuList : Tea.TeaModel {
                public class Sku : Tea.TeaModel {
                    public class GradePriceModels : Tea.TeaModel {
                        public class GradePriceModel : Tea.TeaModel {
                            public class UserLabelList : Tea.TeaModel {
                                public var userLabelList: [String]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.userLabelList != nil {
                                        map["UserLabelList"] = self.userLabelList!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("UserLabelList") && dict["UserLabelList"] != nil {
                                        self.userLabelList = dict["UserLabelList"] as! [String]
                                    }
                                }
                            }
                            public var accessUrl: String?

                            public var canBuy: Bool?

                            public var characteristicCode: String?

                            public var characteristicName: String?

                            public var exclusive: Bool?

                            public var icon: String?

                            public var pointPrice: Int64?

                            public var points: Int64?

                            public var pointsAmount: Int64?

                            public var priceCent: Int64?

                            public var recommend: Bool?

                            public var showName: String?

                            public var subBizCode: String?

                            public var userLabelList: QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel.UserLabelList?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.userLabelList?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.accessUrl != nil {
                                    map["AccessUrl"] = self.accessUrl!
                                }
                                if self.canBuy != nil {
                                    map["CanBuy"] = self.canBuy!
                                }
                                if self.characteristicCode != nil {
                                    map["CharacteristicCode"] = self.characteristicCode!
                                }
                                if self.characteristicName != nil {
                                    map["CharacteristicName"] = self.characteristicName!
                                }
                                if self.exclusive != nil {
                                    map["Exclusive"] = self.exclusive!
                                }
                                if self.icon != nil {
                                    map["Icon"] = self.icon!
                                }
                                if self.pointPrice != nil {
                                    map["PointPrice"] = self.pointPrice!
                                }
                                if self.points != nil {
                                    map["Points"] = self.points!
                                }
                                if self.pointsAmount != nil {
                                    map["PointsAmount"] = self.pointsAmount!
                                }
                                if self.priceCent != nil {
                                    map["PriceCent"] = self.priceCent!
                                }
                                if self.recommend != nil {
                                    map["Recommend"] = self.recommend!
                                }
                                if self.showName != nil {
                                    map["ShowName"] = self.showName!
                                }
                                if self.subBizCode != nil {
                                    map["SubBizCode"] = self.subBizCode!
                                }
                                if self.userLabelList != nil {
                                    map["UserLabelList"] = self.userLabelList?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AccessUrl") && dict["AccessUrl"] != nil {
                                    self.accessUrl = dict["AccessUrl"] as! String
                                }
                                if dict.keys.contains("CanBuy") && dict["CanBuy"] != nil {
                                    self.canBuy = dict["CanBuy"] as! Bool
                                }
                                if dict.keys.contains("CharacteristicCode") && dict["CharacteristicCode"] != nil {
                                    self.characteristicCode = dict["CharacteristicCode"] as! String
                                }
                                if dict.keys.contains("CharacteristicName") && dict["CharacteristicName"] != nil {
                                    self.characteristicName = dict["CharacteristicName"] as! String
                                }
                                if dict.keys.contains("Exclusive") && dict["Exclusive"] != nil {
                                    self.exclusive = dict["Exclusive"] as! Bool
                                }
                                if dict.keys.contains("Icon") && dict["Icon"] != nil {
                                    self.icon = dict["Icon"] as! String
                                }
                                if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                                    self.pointPrice = dict["PointPrice"] as! Int64
                                }
                                if dict.keys.contains("Points") && dict["Points"] != nil {
                                    self.points = dict["Points"] as! Int64
                                }
                                if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                                    self.pointsAmount = dict["PointsAmount"] as! Int64
                                }
                                if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                                    self.priceCent = dict["PriceCent"] as! Int64
                                }
                                if dict.keys.contains("Recommend") && dict["Recommend"] != nil {
                                    self.recommend = dict["Recommend"] as! Bool
                                }
                                if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                                    self.showName = dict["ShowName"] as! String
                                }
                                if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                                    self.subBizCode = dict["SubBizCode"] as! String
                                }
                                if dict.keys.contains("UserLabelList") && dict["UserLabelList"] != nil {
                                    var model = QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel.UserLabelList()
                                    model.fromMap(dict["UserLabelList"] as! [String: Any])
                                    self.userLabelList = model
                                }
                            }
                        }
                        public var gradePriceModel: [QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.gradePriceModel != nil {
                                var tmp : [Any] = []
                                for k in self.gradePriceModel! {
                                    tmp.append(k.toMap())
                                }
                                map["GradePriceModel"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("GradePriceModel") && dict["GradePriceModel"] != nil {
                                var tmp : [QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel] = []
                                for v in dict["GradePriceModel"] as! [Any] {
                                    var model = QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.gradePriceModel = tmp
                            }
                        }
                    }
                    public class UserLabelList : Tea.TeaModel {
                        public var userLabelList: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.userLabelList != nil {
                                map["UserLabelList"] = self.userLabelList!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("UserLabelList") && dict["UserLabelList"] != nil {
                                self.userLabelList = dict["UserLabelList"] as! [String]
                            }
                        }
                    }
                    public var benefitId: String?

                    public var canSell: Bool?

                    public var customizedAttributeMap: [String: Any]?

                    public var gradePriceModels: QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels?

                    public var points: Int64?

                    public var pointsAmount: Int64?

                    public var priceCent: Int64?

                    public var skuId: Int64?

                    public var skuPicUrl: String?

                    public var skuTitle: String?

                    public var taoBaoCurrentPrice: Int64?

                    public var userLabelList: QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku.UserLabelList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.gradePriceModels?.validate()
                        try self.userLabelList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.benefitId != nil {
                            map["BenefitId"] = self.benefitId!
                        }
                        if self.canSell != nil {
                            map["CanSell"] = self.canSell!
                        }
                        if self.customizedAttributeMap != nil {
                            map["CustomizedAttributeMap"] = self.customizedAttributeMap!
                        }
                        if self.gradePriceModels != nil {
                            map["GradePriceModels"] = self.gradePriceModels?.toMap()
                        }
                        if self.points != nil {
                            map["Points"] = self.points!
                        }
                        if self.pointsAmount != nil {
                            map["PointsAmount"] = self.pointsAmount!
                        }
                        if self.priceCent != nil {
                            map["PriceCent"] = self.priceCent!
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        if self.skuPicUrl != nil {
                            map["SkuPicUrl"] = self.skuPicUrl!
                        }
                        if self.skuTitle != nil {
                            map["SkuTitle"] = self.skuTitle!
                        }
                        if self.taoBaoCurrentPrice != nil {
                            map["TaoBaoCurrentPrice"] = self.taoBaoCurrentPrice!
                        }
                        if self.userLabelList != nil {
                            map["UserLabelList"] = self.userLabelList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BenefitId") && dict["BenefitId"] != nil {
                            self.benefitId = dict["BenefitId"] as! String
                        }
                        if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                            self.canSell = dict["CanSell"] as! Bool
                        }
                        if dict.keys.contains("CustomizedAttributeMap") && dict["CustomizedAttributeMap"] != nil {
                            self.customizedAttributeMap = dict["CustomizedAttributeMap"] as! [String: Any]
                        }
                        if dict.keys.contains("GradePriceModels") && dict["GradePriceModels"] != nil {
                            var model = QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels()
                            model.fromMap(dict["GradePriceModels"] as! [String: Any])
                            self.gradePriceModels = model
                        }
                        if dict.keys.contains("Points") && dict["Points"] != nil {
                            self.points = dict["Points"] as! Int64
                        }
                        if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                            self.pointsAmount = dict["PointsAmount"] as! Int64
                        }
                        if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                            self.priceCent = dict["PriceCent"] as! Int64
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                        if dict.keys.contains("SkuPicUrl") && dict["SkuPicUrl"] != nil {
                            self.skuPicUrl = dict["SkuPicUrl"] as! String
                        }
                        if dict.keys.contains("SkuTitle") && dict["SkuTitle"] != nil {
                            self.skuTitle = dict["SkuTitle"] as! String
                        }
                        if dict.keys.contains("TaoBaoCurrentPrice") && dict["TaoBaoCurrentPrice"] != nil {
                            self.taoBaoCurrentPrice = dict["TaoBaoCurrentPrice"] as! Int64
                        }
                        if dict.keys.contains("UserLabelList") && dict["UserLabelList"] != nil {
                            var model = QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku.UserLabelList()
                            model.fromMap(dict["UserLabelList"] as! [String: Any])
                            self.userLabelList = model
                        }
                    }
                }
                public var sku: [QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sku != nil {
                        var tmp : [Any] = []
                        for k in self.sku! {
                            tmp.append(k.toMap())
                        }
                        map["Sku"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Sku") && dict["Sku"] != nil {
                        var tmp : [QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku] = []
                        for v in dict["Sku"] as! [Any] {
                            var model = QueryBizItemListResponseBody.ItemList.Item.SkuList.Sku()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.sku = tmp
                    }
                }
            }
            public var canSell: Bool?

            public var categoryId: Int64?

            public var customizedItemName: String?

            public var extJson: String?

            public var itemId: Int64?

            public var itemTitle: String?

            public var lmItemId: String?

            public var mainPicUrl: String?

            public var reservePrice: Int64?

            public var sellerId: Int64?

            public var skuList: QueryBizItemListResponseBody.ItemList.Item.SkuList?

            public var taobaoShopName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.skuList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canSell != nil {
                    map["CanSell"] = self.canSell!
                }
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.customizedItemName != nil {
                    map["CustomizedItemName"] = self.customizedItemName!
                }
                if self.extJson != nil {
                    map["ExtJson"] = self.extJson!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemTitle != nil {
                    map["ItemTitle"] = self.itemTitle!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.mainPicUrl != nil {
                    map["MainPicUrl"] = self.mainPicUrl!
                }
                if self.reservePrice != nil {
                    map["ReservePrice"] = self.reservePrice!
                }
                if self.sellerId != nil {
                    map["SellerId"] = self.sellerId!
                }
                if self.skuList != nil {
                    map["SkuList"] = self.skuList?.toMap()
                }
                if self.taobaoShopName != nil {
                    map["TaobaoShopName"] = self.taobaoShopName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                    self.canSell = dict["CanSell"] as! Bool
                }
                if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                    self.categoryId = dict["CategoryId"] as! Int64
                }
                if dict.keys.contains("CustomizedItemName") && dict["CustomizedItemName"] != nil {
                    self.customizedItemName = dict["CustomizedItemName"] as! String
                }
                if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                    self.extJson = dict["ExtJson"] as! String
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                    self.itemTitle = dict["ItemTitle"] as! String
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                    self.mainPicUrl = dict["MainPicUrl"] as! String
                }
                if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                    self.reservePrice = dict["ReservePrice"] as! Int64
                }
                if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                    self.sellerId = dict["SellerId"] as! Int64
                }
                if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                    var model = QueryBizItemListResponseBody.ItemList.Item.SkuList()
                    model.fromMap(dict["SkuList"] as! [String: Any])
                    self.skuList = model
                }
                if dict.keys.contains("TaobaoShopName") && dict["TaobaoShopName"] != nil {
                    self.taobaoShopName = dict["TaobaoShopName"] as! String
                }
            }
        }
        public var item: [QueryBizItemListResponseBody.ItemList.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [QueryBizItemListResponseBody.ItemList.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = QueryBizItemListResponseBody.ItemList.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var code: String?

    public var itemList: QueryBizItemListResponseBody.ItemList?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemList != nil {
            map["ItemList"] = self.itemList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var model = QueryBizItemListResponseBody.ItemList()
            model.fromMap(dict["ItemList"] as! [String: Any])
            self.itemList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class QueryBizItemListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBizItemListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryBizItemListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBizItemListV2Request : Tea.TeaModel {
    public var bizId: String?

    public var categoryId: Int64?

    public var itemIds: [Int64]?

    public var lmItemIds: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subBizId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lmItemIds != nil {
            map["LmItemIds"] = self.lmItemIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [Int64]
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIds = dict["LmItemIds"] as! [String]
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class QueryBizItemListV2ShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var categoryId: Int64?

    public var itemIdsShrink: String?

    public var lmItemIdsShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subBizId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.itemIdsShrink != nil {
            map["ItemIds"] = self.itemIdsShrink!
        }
        if self.lmItemIdsShrink != nil {
            map["LmItemIds"] = self.lmItemIdsShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
            self.categoryId = dict["CategoryId"] as! Int64
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIdsShrink = dict["ItemIds"] as! String
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIdsShrink = dict["LmItemIds"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class QueryBizItemListV2ResponseBody : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public class SkuList : Tea.TeaModel {
                public class Sku : Tea.TeaModel {
                    public class GradePriceModels : Tea.TeaModel {
                        public class GradePriceModel : Tea.TeaModel {
                            public class UserLabelList : Tea.TeaModel {
                                public var userLabelList: [String]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.userLabelList != nil {
                                        map["UserLabelList"] = self.userLabelList!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("UserLabelList") && dict["UserLabelList"] != nil {
                                        self.userLabelList = dict["UserLabelList"] as! [String]
                                    }
                                }
                            }
                            public var accessUrl: String?

                            public var canBuy: Bool?

                            public var characteristicCode: String?

                            public var characteristicName: String?

                            public var exclusive: Bool?

                            public var icon: String?

                            public var pointPrice: Int64?

                            public var points: Int64?

                            public var pointsAmount: Int64?

                            public var priceCent: Int64?

                            public var recommend: Bool?

                            public var showName: String?

                            public var subBizCode: String?

                            public var userLabelList: QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel.UserLabelList?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.userLabelList?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.accessUrl != nil {
                                    map["AccessUrl"] = self.accessUrl!
                                }
                                if self.canBuy != nil {
                                    map["CanBuy"] = self.canBuy!
                                }
                                if self.characteristicCode != nil {
                                    map["CharacteristicCode"] = self.characteristicCode!
                                }
                                if self.characteristicName != nil {
                                    map["CharacteristicName"] = self.characteristicName!
                                }
                                if self.exclusive != nil {
                                    map["Exclusive"] = self.exclusive!
                                }
                                if self.icon != nil {
                                    map["Icon"] = self.icon!
                                }
                                if self.pointPrice != nil {
                                    map["PointPrice"] = self.pointPrice!
                                }
                                if self.points != nil {
                                    map["Points"] = self.points!
                                }
                                if self.pointsAmount != nil {
                                    map["PointsAmount"] = self.pointsAmount!
                                }
                                if self.priceCent != nil {
                                    map["PriceCent"] = self.priceCent!
                                }
                                if self.recommend != nil {
                                    map["Recommend"] = self.recommend!
                                }
                                if self.showName != nil {
                                    map["ShowName"] = self.showName!
                                }
                                if self.subBizCode != nil {
                                    map["SubBizCode"] = self.subBizCode!
                                }
                                if self.userLabelList != nil {
                                    map["UserLabelList"] = self.userLabelList?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AccessUrl") && dict["AccessUrl"] != nil {
                                    self.accessUrl = dict["AccessUrl"] as! String
                                }
                                if dict.keys.contains("CanBuy") && dict["CanBuy"] != nil {
                                    self.canBuy = dict["CanBuy"] as! Bool
                                }
                                if dict.keys.contains("CharacteristicCode") && dict["CharacteristicCode"] != nil {
                                    self.characteristicCode = dict["CharacteristicCode"] as! String
                                }
                                if dict.keys.contains("CharacteristicName") && dict["CharacteristicName"] != nil {
                                    self.characteristicName = dict["CharacteristicName"] as! String
                                }
                                if dict.keys.contains("Exclusive") && dict["Exclusive"] != nil {
                                    self.exclusive = dict["Exclusive"] as! Bool
                                }
                                if dict.keys.contains("Icon") && dict["Icon"] != nil {
                                    self.icon = dict["Icon"] as! String
                                }
                                if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                                    self.pointPrice = dict["PointPrice"] as! Int64
                                }
                                if dict.keys.contains("Points") && dict["Points"] != nil {
                                    self.points = dict["Points"] as! Int64
                                }
                                if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                                    self.pointsAmount = dict["PointsAmount"] as! Int64
                                }
                                if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                                    self.priceCent = dict["PriceCent"] as! Int64
                                }
                                if dict.keys.contains("Recommend") && dict["Recommend"] != nil {
                                    self.recommend = dict["Recommend"] as! Bool
                                }
                                if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                                    self.showName = dict["ShowName"] as! String
                                }
                                if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                                    self.subBizCode = dict["SubBizCode"] as! String
                                }
                                if dict.keys.contains("UserLabelList") && dict["UserLabelList"] != nil {
                                    var model = QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel.UserLabelList()
                                    model.fromMap(dict["UserLabelList"] as! [String: Any])
                                    self.userLabelList = model
                                }
                            }
                        }
                        public var gradePriceModel: [QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.gradePriceModel != nil {
                                var tmp : [Any] = []
                                for k in self.gradePriceModel! {
                                    tmp.append(k.toMap())
                                }
                                map["GradePriceModel"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("GradePriceModel") && dict["GradePriceModel"] != nil {
                                var tmp : [QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel] = []
                                for v in dict["GradePriceModel"] as! [Any] {
                                    var model = QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels.GradePriceModel()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.gradePriceModel = tmp
                            }
                        }
                    }
                    public class UserLabelList : Tea.TeaModel {
                        public var userLabelList: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.userLabelList != nil {
                                map["UserLabelList"] = self.userLabelList!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("UserLabelList") && dict["UserLabelList"] != nil {
                                self.userLabelList = dict["UserLabelList"] as! [String]
                            }
                        }
                    }
                    public var benefitId: String?

                    public var canSell: Bool?

                    public var customizedAttributeMap: [String: Any]?

                    public var gradePriceModels: QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels?

                    public var points: Int64?

                    public var pointsAmount: Int64?

                    public var priceCent: Int64?

                    public var skuId: Int64?

                    public var skuPicUrl: String?

                    public var skuTitle: String?

                    public var taoBaoCurrentPrice: Int64?

                    public var userLabelList: QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku.UserLabelList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.gradePriceModels?.validate()
                        try self.userLabelList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.benefitId != nil {
                            map["BenefitId"] = self.benefitId!
                        }
                        if self.canSell != nil {
                            map["CanSell"] = self.canSell!
                        }
                        if self.customizedAttributeMap != nil {
                            map["CustomizedAttributeMap"] = self.customizedAttributeMap!
                        }
                        if self.gradePriceModels != nil {
                            map["GradePriceModels"] = self.gradePriceModels?.toMap()
                        }
                        if self.points != nil {
                            map["Points"] = self.points!
                        }
                        if self.pointsAmount != nil {
                            map["PointsAmount"] = self.pointsAmount!
                        }
                        if self.priceCent != nil {
                            map["PriceCent"] = self.priceCent!
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        if self.skuPicUrl != nil {
                            map["SkuPicUrl"] = self.skuPicUrl!
                        }
                        if self.skuTitle != nil {
                            map["SkuTitle"] = self.skuTitle!
                        }
                        if self.taoBaoCurrentPrice != nil {
                            map["TaoBaoCurrentPrice"] = self.taoBaoCurrentPrice!
                        }
                        if self.userLabelList != nil {
                            map["UserLabelList"] = self.userLabelList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BenefitId") && dict["BenefitId"] != nil {
                            self.benefitId = dict["BenefitId"] as! String
                        }
                        if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                            self.canSell = dict["CanSell"] as! Bool
                        }
                        if dict.keys.contains("CustomizedAttributeMap") && dict["CustomizedAttributeMap"] != nil {
                            self.customizedAttributeMap = dict["CustomizedAttributeMap"] as! [String: Any]
                        }
                        if dict.keys.contains("GradePriceModels") && dict["GradePriceModels"] != nil {
                            var model = QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku.GradePriceModels()
                            model.fromMap(dict["GradePriceModels"] as! [String: Any])
                            self.gradePriceModels = model
                        }
                        if dict.keys.contains("Points") && dict["Points"] != nil {
                            self.points = dict["Points"] as! Int64
                        }
                        if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                            self.pointsAmount = dict["PointsAmount"] as! Int64
                        }
                        if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                            self.priceCent = dict["PriceCent"] as! Int64
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                        if dict.keys.contains("SkuPicUrl") && dict["SkuPicUrl"] != nil {
                            self.skuPicUrl = dict["SkuPicUrl"] as! String
                        }
                        if dict.keys.contains("SkuTitle") && dict["SkuTitle"] != nil {
                            self.skuTitle = dict["SkuTitle"] as! String
                        }
                        if dict.keys.contains("TaoBaoCurrentPrice") && dict["TaoBaoCurrentPrice"] != nil {
                            self.taoBaoCurrentPrice = dict["TaoBaoCurrentPrice"] as! Int64
                        }
                        if dict.keys.contains("UserLabelList") && dict["UserLabelList"] != nil {
                            var model = QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku.UserLabelList()
                            model.fromMap(dict["UserLabelList"] as! [String: Any])
                            self.userLabelList = model
                        }
                    }
                }
                public var sku: [QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sku != nil {
                        var tmp : [Any] = []
                        for k in self.sku! {
                            tmp.append(k.toMap())
                        }
                        map["Sku"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Sku") && dict["Sku"] != nil {
                        var tmp : [QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku] = []
                        for v in dict["Sku"] as! [Any] {
                            var model = QueryBizItemListV2ResponseBody.ItemList.Item.SkuList.Sku()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.sku = tmp
                    }
                }
            }
            public var canSell: Bool?

            public var categoryId: Int64?

            public var customizedItemName: String?

            public var extJson: String?

            public var itemId: Int64?

            public var itemTitle: String?

            public var lmItemId: String?

            public var mainPicUrl: String?

            public var reservePrice: Int64?

            public var sellerId: Int64?

            public var skuList: QueryBizItemListV2ResponseBody.ItemList.Item.SkuList?

            public var taobaoShopName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.skuList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canSell != nil {
                    map["CanSell"] = self.canSell!
                }
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.customizedItemName != nil {
                    map["CustomizedItemName"] = self.customizedItemName!
                }
                if self.extJson != nil {
                    map["ExtJson"] = self.extJson!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemTitle != nil {
                    map["ItemTitle"] = self.itemTitle!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.mainPicUrl != nil {
                    map["MainPicUrl"] = self.mainPicUrl!
                }
                if self.reservePrice != nil {
                    map["ReservePrice"] = self.reservePrice!
                }
                if self.sellerId != nil {
                    map["SellerId"] = self.sellerId!
                }
                if self.skuList != nil {
                    map["SkuList"] = self.skuList?.toMap()
                }
                if self.taobaoShopName != nil {
                    map["TaobaoShopName"] = self.taobaoShopName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                    self.canSell = dict["CanSell"] as! Bool
                }
                if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                    self.categoryId = dict["CategoryId"] as! Int64
                }
                if dict.keys.contains("CustomizedItemName") && dict["CustomizedItemName"] != nil {
                    self.customizedItemName = dict["CustomizedItemName"] as! String
                }
                if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                    self.extJson = dict["ExtJson"] as! String
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                    self.itemTitle = dict["ItemTitle"] as! String
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                    self.mainPicUrl = dict["MainPicUrl"] as! String
                }
                if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                    self.reservePrice = dict["ReservePrice"] as! Int64
                }
                if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                    self.sellerId = dict["SellerId"] as! Int64
                }
                if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                    var model = QueryBizItemListV2ResponseBody.ItemList.Item.SkuList()
                    model.fromMap(dict["SkuList"] as! [String: Any])
                    self.skuList = model
                }
                if dict.keys.contains("TaobaoShopName") && dict["TaobaoShopName"] != nil {
                    self.taobaoShopName = dict["TaobaoShopName"] as! String
                }
            }
        }
        public var item: [QueryBizItemListV2ResponseBody.ItemList.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [QueryBizItemListV2ResponseBody.ItemList.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = QueryBizItemListV2ResponseBody.ItemList.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var code: String?

    public var itemList: QueryBizItemListV2ResponseBody.ItemList?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemList != nil {
            map["ItemList"] = self.itemList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var model = QueryBizItemListV2ResponseBody.ItemList()
            model.fromMap(dict["ItemList"] as! [String: Any])
            self.itemList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class QueryBizItemListV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBizItemListV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryBizItemListV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBizItemListWithCacheRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIds: [Int64]?

    public var lmItemIds: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subBizCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lmItemIds != nil {
            map["LmItemIds"] = self.lmItemIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subBizCode != nil {
            map["SubBizCode"] = self.subBizCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [Int64]
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIds = dict["LmItemIds"] as! [String]
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
            self.subBizCode = dict["SubBizCode"] as! String
        }
    }
}

public class QueryBizItemListWithCacheShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIdsShrink: String?

    public var lmItemIdsShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subBizCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIdsShrink != nil {
            map["ItemIds"] = self.itemIdsShrink!
        }
        if self.lmItemIdsShrink != nil {
            map["LmItemIds"] = self.lmItemIdsShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subBizCode != nil {
            map["SubBizCode"] = self.subBizCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIdsShrink = dict["ItemIds"] as! String
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIdsShrink = dict["LmItemIds"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
            self.subBizCode = dict["SubBizCode"] as! String
        }
    }
}

public class QueryBizItemListWithCacheResponseBody : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var canSell: Bool?

        public var itemId: Int64?

        public var itemTitle: String?

        public var lmItemId: String?

        public var mainPicUrl: String?

        public var pointPrice: Int64?

        public var points: Int64?

        public var pointsAmount: Int64?

        public var priceCent: Int64?

        public var reservePrice: Int64?

        public var status: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canSell != nil {
                map["CanSell"] = self.canSell!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.itemTitle != nil {
                map["ItemTitle"] = self.itemTitle!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.mainPicUrl != nil {
                map["MainPicUrl"] = self.mainPicUrl!
            }
            if self.pointPrice != nil {
                map["PointPrice"] = self.pointPrice!
            }
            if self.points != nil {
                map["Points"] = self.points!
            }
            if self.pointsAmount != nil {
                map["PointsAmount"] = self.pointsAmount!
            }
            if self.priceCent != nil {
                map["PriceCent"] = self.priceCent!
            }
            if self.reservePrice != nil {
                map["ReservePrice"] = self.reservePrice!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                self.canSell = dict["CanSell"] as! Bool
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                self.itemTitle = dict["ItemTitle"] as! String
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                self.mainPicUrl = dict["MainPicUrl"] as! String
            }
            if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                self.pointPrice = dict["PointPrice"] as! Int64
            }
            if dict.keys.contains("Points") && dict["Points"] != nil {
                self.points = dict["Points"] as! Int64
            }
            if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                self.pointsAmount = dict["PointsAmount"] as! Int64
            }
            if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                self.priceCent = dict["PriceCent"] as! Int64
            }
            if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                self.reservePrice = dict["ReservePrice"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int64
            }
        }
    }
    public var code: String?

    public var itemList: [QueryBizItemListWithCacheResponseBody.ItemList]?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [QueryBizItemListWithCacheResponseBody.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = QueryBizItemListWithCacheResponseBody.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryBizItemListWithCacheResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBizItemListWithCacheResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryBizItemListWithCacheResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBizItemsRequest : Tea.TeaModel {
    public var bizId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var subBizId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class QueryBizItemsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var model: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class QueryBizItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBizItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryBizItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBizItemsWithActivityRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIds: [String: Any]?

    public var lmItemIds: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lmItemIds != nil {
            map["LmItemIds"] = self.lmItemIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [String: Any]
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIds = dict["LmItemIds"] as! [String: Any]
        }
    }
}

public class QueryBizItemsWithActivityShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIdsShrink: String?

    public var lmItemIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIdsShrink != nil {
            map["ItemIds"] = self.itemIdsShrink!
        }
        if self.lmItemIdsShrink != nil {
            map["LmItemIds"] = self.lmItemIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIdsShrink = dict["ItemIds"] as! String
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIdsShrink = dict["LmItemIds"] as! String
        }
    }
}

public class QueryBizItemsWithActivityResponseBody : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public class Activities : Tea.TeaModel {
                public class Activity : Tea.TeaModel {
                    public class ActivityItem : Tea.TeaModel {
                        public class ActivityItemSkuList : Tea.TeaModel {
                            public class ActivityItemSku : Tea.TeaModel {
                                public var activityPrice: Int64?

                                public var skuId: Int64?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.activityPrice != nil {
                                        map["ActivityPrice"] = self.activityPrice!
                                    }
                                    if self.skuId != nil {
                                        map["SkuId"] = self.skuId!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("ActivityPrice") && dict["ActivityPrice"] != nil {
                                        self.activityPrice = dict["ActivityPrice"] as! Int64
                                    }
                                    if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                                        self.skuId = dict["SkuId"] as! Int64
                                    }
                                }
                            }
                            public var activityItemSku: [QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivityItem.ActivityItemSkuList.ActivityItemSku]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.activityItemSku != nil {
                                    var tmp : [Any] = []
                                    for k in self.activityItemSku! {
                                        tmp.append(k.toMap())
                                    }
                                    map["ActivityItemSku"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ActivityItemSku") && dict["ActivityItemSku"] != nil {
                                    var tmp : [QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivityItem.ActivityItemSkuList.ActivityItemSku] = []
                                    for v in dict["ActivityItemSku"] as! [Any] {
                                        var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivityItem.ActivityItemSkuList.ActivityItemSku()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.activityItemSku = tmp
                                }
                            }
                        }
                        public var activityItemSkuList: QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivityItem.ActivityItemSkuList?

                        public var activityQuantity: Int64?

                        public var limitQuantityForPerson: Int64?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.activityItemSkuList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.activityItemSkuList != nil {
                                map["ActivityItemSkuList"] = self.activityItemSkuList?.toMap()
                            }
                            if self.activityQuantity != nil {
                                map["ActivityQuantity"] = self.activityQuantity!
                            }
                            if self.limitQuantityForPerson != nil {
                                map["LimitQuantityForPerson"] = self.limitQuantityForPerson!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ActivityItemSkuList") && dict["ActivityItemSkuList"] != nil {
                                var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivityItem.ActivityItemSkuList()
                                model.fromMap(dict["ActivityItemSkuList"] as! [String: Any])
                                self.activityItemSkuList = model
                            }
                            if dict.keys.contains("ActivityQuantity") && dict["ActivityQuantity"] != nil {
                                self.activityQuantity = dict["ActivityQuantity"] as! Int64
                            }
                            if dict.keys.contains("LimitQuantityForPerson") && dict["LimitQuantityForPerson"] != nil {
                                self.limitQuantityForPerson = dict["LimitQuantityForPerson"] as! Int64
                            }
                        }
                    }
                    public class ActivitySessions : Tea.TeaModel {
                        public class ActivitySession : Tea.TeaModel {
                            public class ActivitySessionItem : Tea.TeaModel {
                                public class ActivitySessionItemSkuList : Tea.TeaModel {
                                    public var points: Int64?

                                    public var pointsAmount: Int64?

                                    public var priceCent: Int64?

                                    public var skuId: Int64?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.points != nil {
                                            map["Points"] = self.points!
                                        }
                                        if self.pointsAmount != nil {
                                            map["PointsAmount"] = self.pointsAmount!
                                        }
                                        if self.priceCent != nil {
                                            map["PriceCent"] = self.priceCent!
                                        }
                                        if self.skuId != nil {
                                            map["SkuId"] = self.skuId!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Points") && dict["Points"] != nil {
                                            self.points = dict["Points"] as! Int64
                                        }
                                        if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                                            self.pointsAmount = dict["PointsAmount"] as! Int64
                                        }
                                        if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                                            self.priceCent = dict["PriceCent"] as! Int64
                                        }
                                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                                            self.skuId = dict["SkuId"] as! Int64
                                        }
                                    }
                                }
                                public var activitySessionItemSkuList: QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivitySessions.ActivitySession.ActivitySessionItem.ActivitySessionItemSkuList?

                                public var limitQuantityForPerson: Int64?

                                public var saleableQuantity: Int64?

                                public var sessionQuantity: Int64?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.activitySessionItemSkuList?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.activitySessionItemSkuList != nil {
                                        map["ActivitySessionItemSkuList"] = self.activitySessionItemSkuList?.toMap()
                                    }
                                    if self.limitQuantityForPerson != nil {
                                        map["LimitQuantityForPerson"] = self.limitQuantityForPerson!
                                    }
                                    if self.saleableQuantity != nil {
                                        map["SaleableQuantity"] = self.saleableQuantity!
                                    }
                                    if self.sessionQuantity != nil {
                                        map["SessionQuantity"] = self.sessionQuantity!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("ActivitySessionItemSkuList") && dict["ActivitySessionItemSkuList"] != nil {
                                        var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivitySessions.ActivitySession.ActivitySessionItem.ActivitySessionItemSkuList()
                                        model.fromMap(dict["ActivitySessionItemSkuList"] as! [String: Any])
                                        self.activitySessionItemSkuList = model
                                    }
                                    if dict.keys.contains("LimitQuantityForPerson") && dict["LimitQuantityForPerson"] != nil {
                                        self.limitQuantityForPerson = dict["LimitQuantityForPerson"] as! Int64
                                    }
                                    if dict.keys.contains("SaleableQuantity") && dict["SaleableQuantity"] != nil {
                                        self.saleableQuantity = dict["SaleableQuantity"] as! Int64
                                    }
                                    if dict.keys.contains("SessionQuantity") && dict["SessionQuantity"] != nil {
                                        self.sessionQuantity = dict["SessionQuantity"] as! Int64
                                    }
                                }
                            }
                            public var activitySessionItem: QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivitySessions.ActivitySession.ActivitySessionItem?

                            public var description_: String?

                            public var displayDate: Int64?

                            public var endDate: Int64?

                            public var lmSessionId: Int64?

                            public var startDate: Int64?

                            public var subBizCode: String?

                            public var title: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.activitySessionItem?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.activitySessionItem != nil {
                                    map["ActivitySessionItem"] = self.activitySessionItem?.toMap()
                                }
                                if self.description_ != nil {
                                    map["Description"] = self.description_!
                                }
                                if self.displayDate != nil {
                                    map["DisplayDate"] = self.displayDate!
                                }
                                if self.endDate != nil {
                                    map["EndDate"] = self.endDate!
                                }
                                if self.lmSessionId != nil {
                                    map["LmSessionId"] = self.lmSessionId!
                                }
                                if self.startDate != nil {
                                    map["StartDate"] = self.startDate!
                                }
                                if self.subBizCode != nil {
                                    map["SubBizCode"] = self.subBizCode!
                                }
                                if self.title != nil {
                                    map["Title"] = self.title!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ActivitySessionItem") && dict["ActivitySessionItem"] != nil {
                                    var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivitySessions.ActivitySession.ActivitySessionItem()
                                    model.fromMap(dict["ActivitySessionItem"] as! [String: Any])
                                    self.activitySessionItem = model
                                }
                                if dict.keys.contains("Description") && dict["Description"] != nil {
                                    self.description_ = dict["Description"] as! String
                                }
                                if dict.keys.contains("DisplayDate") && dict["DisplayDate"] != nil {
                                    self.displayDate = dict["DisplayDate"] as! Int64
                                }
                                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                                    self.endDate = dict["EndDate"] as! Int64
                                }
                                if dict.keys.contains("LmSessionId") && dict["LmSessionId"] != nil {
                                    self.lmSessionId = dict["LmSessionId"] as! Int64
                                }
                                if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
                                    self.startDate = dict["StartDate"] as! Int64
                                }
                                if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                                    self.subBizCode = dict["SubBizCode"] as! String
                                }
                                if dict.keys.contains("Title") && dict["Title"] != nil {
                                    self.title = dict["Title"] as! String
                                }
                            }
                        }
                        public var activitySession: [QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivitySessions.ActivitySession]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.activitySession != nil {
                                var tmp : [Any] = []
                                for k in self.activitySession! {
                                    tmp.append(k.toMap())
                                }
                                map["ActivitySession"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ActivitySession") && dict["ActivitySession"] != nil {
                                var tmp : [QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivitySessions.ActivitySession] = []
                                for v in dict["ActivitySession"] as! [Any] {
                                    var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivitySessions.ActivitySession()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.activitySession = tmp
                            }
                        }
                    }
                    public var activityItem: QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivityItem?

                    public var activitySessions: QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivitySessions?

                    public var description_: String?

                    public var endDate: Int64?

                    public var lmActivityId: Int64?

                    public var startDate: Int64?

                    public var title: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.activityItem?.validate()
                        try self.activitySessions?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityItem != nil {
                            map["ActivityItem"] = self.activityItem?.toMap()
                        }
                        if self.activitySessions != nil {
                            map["ActivitySessions"] = self.activitySessions?.toMap()
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.endDate != nil {
                            map["EndDate"] = self.endDate!
                        }
                        if self.lmActivityId != nil {
                            map["LmActivityId"] = self.lmActivityId!
                        }
                        if self.startDate != nil {
                            map["StartDate"] = self.startDate!
                        }
                        if self.title != nil {
                            map["Title"] = self.title!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityItem") && dict["ActivityItem"] != nil {
                            var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivityItem()
                            model.fromMap(dict["ActivityItem"] as! [String: Any])
                            self.activityItem = model
                        }
                        if dict.keys.contains("ActivitySessions") && dict["ActivitySessions"] != nil {
                            var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity.ActivitySessions()
                            model.fromMap(dict["ActivitySessions"] as! [String: Any])
                            self.activitySessions = model
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                            self.endDate = dict["EndDate"] as! Int64
                        }
                        if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
                            self.lmActivityId = dict["LmActivityId"] as! Int64
                        }
                        if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
                            self.startDate = dict["StartDate"] as! Int64
                        }
                        if dict.keys.contains("Title") && dict["Title"] != nil {
                            self.title = dict["Title"] as! String
                        }
                    }
                }
                public var activity: [QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activity != nil {
                        var tmp : [Any] = []
                        for k in self.activity! {
                            tmp.append(k.toMap())
                        }
                        map["Activity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Activity") && dict["Activity"] != nil {
                        var tmp : [QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity] = []
                        for v in dict["Activity"] as! [Any] {
                            var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities.Activity()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.activity = tmp
                    }
                }
            }
            public class SkuList : Tea.TeaModel {
                public class Sku : Tea.TeaModel {
                    public var maxAllowedCount: Int32?

                    public var points: Int64?

                    public var pointsAmount: Int64?

                    public var pointsInfo: String?

                    public var pointsKey: String?

                    public var priceCent: Int64?

                    public var quantity: Int64?

                    public var skuId: Int64?

                    public var status: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.maxAllowedCount != nil {
                            map["MaxAllowedCount"] = self.maxAllowedCount!
                        }
                        if self.points != nil {
                            map["Points"] = self.points!
                        }
                        if self.pointsAmount != nil {
                            map["PointsAmount"] = self.pointsAmount!
                        }
                        if self.pointsInfo != nil {
                            map["PointsInfo"] = self.pointsInfo!
                        }
                        if self.pointsKey != nil {
                            map["PointsKey"] = self.pointsKey!
                        }
                        if self.priceCent != nil {
                            map["PriceCent"] = self.priceCent!
                        }
                        if self.quantity != nil {
                            map["Quantity"] = self.quantity!
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MaxAllowedCount") && dict["MaxAllowedCount"] != nil {
                            self.maxAllowedCount = dict["MaxAllowedCount"] as! Int32
                        }
                        if dict.keys.contains("Points") && dict["Points"] != nil {
                            self.points = dict["Points"] as! Int64
                        }
                        if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                            self.pointsAmount = dict["PointsAmount"] as! Int64
                        }
                        if dict.keys.contains("PointsInfo") && dict["PointsInfo"] != nil {
                            self.pointsInfo = dict["PointsInfo"] as! String
                        }
                        if dict.keys.contains("PointsKey") && dict["PointsKey"] != nil {
                            self.pointsKey = dict["PointsKey"] as! String
                        }
                        if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                            self.priceCent = dict["PriceCent"] as! Int64
                        }
                        if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                            self.quantity = dict["Quantity"] as! Int64
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                        if dict.keys.contains("Status") && dict["Status"] != nil {
                            self.status = dict["Status"] as! Int64
                        }
                    }
                }
                public var sku: [QueryBizItemsWithActivityResponseBody.ItemList.Item.SkuList.Sku]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sku != nil {
                        var tmp : [Any] = []
                        for k in self.sku! {
                            tmp.append(k.toMap())
                        }
                        map["Sku"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Sku") && dict["Sku"] != nil {
                        var tmp : [QueryBizItemsWithActivityResponseBody.ItemList.Item.SkuList.Sku] = []
                        for v in dict["Sku"] as! [Any] {
                            var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.SkuList.Sku()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.sku = tmp
                    }
                }
            }
            public var activities: QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities?

            public var categoryId: Int64?

            public var itemId: Int64?

            public var itemTitle: String?

            public var lmItemId: String?

            public var maxAllowedCount: Int32?

            public var picUrl: String?

            public var quantity: Int64?

            public var reservePrice: Int64?

            public var sellerId: Int64?

            public var skuList: QueryBizItemsWithActivityResponseBody.ItemList.Item.SkuList?

            public var taobaoShopName: String?

            public var totalSoldQuantity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.activities?.validate()
                try self.skuList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activities != nil {
                    map["Activities"] = self.activities?.toMap()
                }
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemTitle != nil {
                    map["ItemTitle"] = self.itemTitle!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.maxAllowedCount != nil {
                    map["MaxAllowedCount"] = self.maxAllowedCount!
                }
                if self.picUrl != nil {
                    map["PicUrl"] = self.picUrl!
                }
                if self.quantity != nil {
                    map["Quantity"] = self.quantity!
                }
                if self.reservePrice != nil {
                    map["ReservePrice"] = self.reservePrice!
                }
                if self.sellerId != nil {
                    map["SellerId"] = self.sellerId!
                }
                if self.skuList != nil {
                    map["SkuList"] = self.skuList?.toMap()
                }
                if self.taobaoShopName != nil {
                    map["TaobaoShopName"] = self.taobaoShopName!
                }
                if self.totalSoldQuantity != nil {
                    map["TotalSoldQuantity"] = self.totalSoldQuantity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Activities") && dict["Activities"] != nil {
                    var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.Activities()
                    model.fromMap(dict["Activities"] as! [String: Any])
                    self.activities = model
                }
                if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                    self.categoryId = dict["CategoryId"] as! Int64
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                    self.itemTitle = dict["ItemTitle"] as! String
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("MaxAllowedCount") && dict["MaxAllowedCount"] != nil {
                    self.maxAllowedCount = dict["MaxAllowedCount"] as! Int32
                }
                if dict.keys.contains("PicUrl") && dict["PicUrl"] != nil {
                    self.picUrl = dict["PicUrl"] as! String
                }
                if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                    self.quantity = dict["Quantity"] as! Int64
                }
                if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                    self.reservePrice = dict["ReservePrice"] as! Int64
                }
                if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                    self.sellerId = dict["SellerId"] as! Int64
                }
                if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                    var model = QueryBizItemsWithActivityResponseBody.ItemList.Item.SkuList()
                    model.fromMap(dict["SkuList"] as! [String: Any])
                    self.skuList = model
                }
                if dict.keys.contains("TaobaoShopName") && dict["TaobaoShopName"] != nil {
                    self.taobaoShopName = dict["TaobaoShopName"] as! String
                }
                if dict.keys.contains("TotalSoldQuantity") && dict["TotalSoldQuantity"] != nil {
                    self.totalSoldQuantity = dict["TotalSoldQuantity"] as! Int32
                }
            }
        }
        public var item: [QueryBizItemsWithActivityResponseBody.ItemList.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [QueryBizItemsWithActivityResponseBody.ItemList.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = QueryBizItemsWithActivityResponseBody.ItemList.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var code: String?

    public var itemList: QueryBizItemsWithActivityResponseBody.ItemList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemList != nil {
            map["ItemList"] = self.itemList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var model = QueryBizItemsWithActivityResponseBody.ItemList()
            model.fromMap(dict["ItemList"] as! [String: Any])
            self.itemList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryBizItemsWithActivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBizItemsWithActivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryBizItemsWithActivityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBudgetTicketItemListByBizIdRequest : Tea.TeaModel {
    public var bizId: String?

    public var budgetTicketNo: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.budgetTicketNo != nil {
            map["BudgetTicketNo"] = self.budgetTicketNo!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BudgetTicketNo") && dict["BudgetTicketNo"] != nil {
            self.budgetTicketNo = dict["BudgetTicketNo"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryBudgetTicketItemListByBizIdResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var invalid: Bool?

        public var itemId: Int64?

        public var poCode: String?

        public var promotionId: String?

        public var remnantAmount: Int64?

        public var securityCode: String?

        public var settlementPrice: Int64?

        public var skuId: Int64?

        public var subsidyAmount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.invalid != nil {
                map["Invalid"] = self.invalid!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.poCode != nil {
                map["PoCode"] = self.poCode!
            }
            if self.promotionId != nil {
                map["PromotionId"] = self.promotionId!
            }
            if self.remnantAmount != nil {
                map["RemnantAmount"] = self.remnantAmount!
            }
            if self.securityCode != nil {
                map["SecurityCode"] = self.securityCode!
            }
            if self.settlementPrice != nil {
                map["SettlementPrice"] = self.settlementPrice!
            }
            if self.skuId != nil {
                map["SkuId"] = self.skuId!
            }
            if self.subsidyAmount != nil {
                map["SubsidyAmount"] = self.subsidyAmount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Invalid") && dict["Invalid"] != nil {
                self.invalid = dict["Invalid"] as! Bool
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("PoCode") && dict["PoCode"] != nil {
                self.poCode = dict["PoCode"] as! String
            }
            if dict.keys.contains("PromotionId") && dict["PromotionId"] != nil {
                self.promotionId = dict["PromotionId"] as! String
            }
            if dict.keys.contains("RemnantAmount") && dict["RemnantAmount"] != nil {
                self.remnantAmount = dict["RemnantAmount"] as! Int64
            }
            if dict.keys.contains("SecurityCode") && dict["SecurityCode"] != nil {
                self.securityCode = dict["SecurityCode"] as! String
            }
            if dict.keys.contains("SettlementPrice") && dict["SettlementPrice"] != nil {
                self.settlementPrice = dict["SettlementPrice"] as! Int64
            }
            if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                self.skuId = dict["SkuId"] as! Int64
            }
            if dict.keys.contains("SubsidyAmount") && dict["SubsidyAmount"] != nil {
                self.subsidyAmount = dict["SubsidyAmount"] as! Int64
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: [QueryBudgetTicketItemListByBizIdResponseBody.Model]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [QueryBudgetTicketItemListByBizIdResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = QueryBudgetTicketItemListByBizIdResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryBudgetTicketItemListByBizIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBudgetTicketItemListByBizIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryBudgetTicketItemListByBizIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryChannelItemBillDownloadUrlRequest : Tea.TeaModel {
    public var billId: String?

    public var billPeriod: String?

    public var billStatus: String?

    public var bizId: String?

    public var bizName: String?

    public var lmShopId: Int64?

    public var lmShopName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.billId != nil {
            map["BillId"] = self.billId!
        }
        if self.billPeriod != nil {
            map["BillPeriod"] = self.billPeriod!
        }
        if self.billStatus != nil {
            map["BillStatus"] = self.billStatus!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizName != nil {
            map["BizName"] = self.bizName!
        }
        if self.lmShopId != nil {
            map["LmShopId"] = self.lmShopId!
        }
        if self.lmShopName != nil {
            map["LmShopName"] = self.lmShopName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BillId") && dict["BillId"] != nil {
            self.billId = dict["BillId"] as! String
        }
        if dict.keys.contains("BillPeriod") && dict["BillPeriod"] != nil {
            self.billPeriod = dict["BillPeriod"] as! String
        }
        if dict.keys.contains("BillStatus") && dict["BillStatus"] != nil {
            self.billStatus = dict["BillStatus"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizName") && dict["BizName"] != nil {
            self.bizName = dict["BizName"] as! String
        }
        if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
            self.lmShopId = dict["LmShopId"] as! Int64
        }
        if dict.keys.contains("LmShopName") && dict["LmShopName"] != nil {
            self.lmShopName = dict["LmShopName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class QueryChannelItemBillDownloadUrlResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var billId: String?

            public var fileDownloadUrl: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.billId != nil {
                    map["BillId"] = self.billId!
                }
                if self.fileDownloadUrl != nil {
                    map["FileDownloadUrl"] = self.fileDownloadUrl!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BillId") && dict["BillId"] != nil {
                    self.billId = dict["BillId"] as! String
                }
                if dict.keys.contains("FileDownloadUrl") && dict["FileDownloadUrl"] != nil {
                    self.fileDownloadUrl = dict["FileDownloadUrl"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var data: [QueryChannelItemBillDownloadUrlResponseBody.Model.Data]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var tmp : [QueryChannelItemBillDownloadUrlResponseBody.Model.Data] = []
                for v in dict["Data"] as! [Any] {
                    var model = QueryChannelItemBillDownloadUrlResponseBody.Model.Data()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.data = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: QueryChannelItemBillDownloadUrlResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryChannelItemBillDownloadUrlResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryChannelItemBillDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryChannelItemBillDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryChannelItemBillDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGuideItemGroupRequest : Tea.TeaModel {
    public var bizId: String?

    public var groupId: String?

    public var itemState: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.itemState != nil {
            map["ItemState"] = self.itemState!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ItemState") && dict["ItemState"] != nil {
            self.itemState = dict["ItemState"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class QueryGuideItemGroupResponseBody : Tea.TeaModel {
    public class GuideItemGroup : Tea.TeaModel {
        public class ItemInfo : Tea.TeaModel {
            public var itemId: Int64?

            public var itemTitle: String?

            public var itemUrl: String?

            public var lmItemId: String?

            public var mainPicUrl: String?

            public var pointPrice: Int64?

            public var points: Int64?

            public var pointsAmount: Int64?

            public var priceCent: Int64?

            public var reservePrice: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemTitle != nil {
                    map["ItemTitle"] = self.itemTitle!
                }
                if self.itemUrl != nil {
                    map["ItemUrl"] = self.itemUrl!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.mainPicUrl != nil {
                    map["MainPicUrl"] = self.mainPicUrl!
                }
                if self.pointPrice != nil {
                    map["PointPrice"] = self.pointPrice!
                }
                if self.points != nil {
                    map["Points"] = self.points!
                }
                if self.pointsAmount != nil {
                    map["PointsAmount"] = self.pointsAmount!
                }
                if self.priceCent != nil {
                    map["PriceCent"] = self.priceCent!
                }
                if self.reservePrice != nil {
                    map["ReservePrice"] = self.reservePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                    self.itemTitle = dict["ItemTitle"] as! String
                }
                if dict.keys.contains("ItemUrl") && dict["ItemUrl"] != nil {
                    self.itemUrl = dict["ItemUrl"] as! String
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                    self.mainPicUrl = dict["MainPicUrl"] as! String
                }
                if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                    self.pointPrice = dict["PointPrice"] as! Int64
                }
                if dict.keys.contains("Points") && dict["Points"] != nil {
                    self.points = dict["Points"] as! Int64
                }
                if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                    self.pointsAmount = dict["PointsAmount"] as! Int64
                }
                if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                    self.priceCent = dict["PriceCent"] as! Int64
                }
                if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                    self.reservePrice = dict["ReservePrice"] as! String
                }
            }
        }
        public var itemInfo: [QueryGuideItemGroupResponseBody.GuideItemGroup.ItemInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemInfo != nil {
                var tmp : [Any] = []
                for k in self.itemInfo! {
                    tmp.append(k.toMap())
                }
                map["ItemInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemInfo") && dict["ItemInfo"] != nil {
                var tmp : [QueryGuideItemGroupResponseBody.GuideItemGroup.ItemInfo] = []
                for v in dict["ItemInfo"] as! [Any] {
                    var model = QueryGuideItemGroupResponseBody.GuideItemGroup.ItemInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.itemInfo = tmp
            }
        }
    }
    public var code: String?

    public var guideItemGroup: QueryGuideItemGroupResponseBody.GuideItemGroup?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.guideItemGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.guideItemGroup != nil {
            map["GuideItemGroup"] = self.guideItemGroup?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("GuideItemGroup") && dict["GuideItemGroup"] != nil {
            var model = QueryGuideItemGroupResponseBody.GuideItemGroup()
            model.fromMap(dict["GuideItemGroup"] as! [String: Any])
            self.guideItemGroup = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGuideItemGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGuideItemGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryGuideItemGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGuideItemGroupForCrowdOperationRequest : Tea.TeaModel {
    public var bizId: String?

    public var groupId: String?

    public var itemState: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var userFlag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.itemState != nil {
            map["ItemState"] = self.itemState!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.userFlag != nil {
            map["UserFlag"] = self.userFlag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ItemState") && dict["ItemState"] != nil {
            self.itemState = dict["ItemState"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("UserFlag") && dict["UserFlag"] != nil {
            self.userFlag = dict["UserFlag"] as! String
        }
    }
}

public class QueryGuideItemGroupForCrowdOperationResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var atmospherePicUrl: String?

        public var canSell: Bool?

        public var customizedAttributeMap: [String: String]?

        public var itemId: String?

        public var itemTitle: String?

        public var itemUrl: String?

        public var lmItemId: String?

        public var mainPicUrl: String?

        public var pointPrice: Int64?

        public var points: Int64?

        public var pointsAmount: Int64?

        public var priceCent: Int64?

        public var reservePrice: String?

        public var tags: [Int32]?

        public var whitePicUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.atmospherePicUrl != nil {
                map["AtmospherePicUrl"] = self.atmospherePicUrl!
            }
            if self.canSell != nil {
                map["CanSell"] = self.canSell!
            }
            if self.customizedAttributeMap != nil {
                map["CustomizedAttributeMap"] = self.customizedAttributeMap!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.itemTitle != nil {
                map["ItemTitle"] = self.itemTitle!
            }
            if self.itemUrl != nil {
                map["ItemUrl"] = self.itemUrl!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.mainPicUrl != nil {
                map["MainPicUrl"] = self.mainPicUrl!
            }
            if self.pointPrice != nil {
                map["PointPrice"] = self.pointPrice!
            }
            if self.points != nil {
                map["Points"] = self.points!
            }
            if self.pointsAmount != nil {
                map["PointsAmount"] = self.pointsAmount!
            }
            if self.priceCent != nil {
                map["PriceCent"] = self.priceCent!
            }
            if self.reservePrice != nil {
                map["ReservePrice"] = self.reservePrice!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.whitePicUrl != nil {
                map["WhitePicUrl"] = self.whitePicUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AtmospherePicUrl") && dict["AtmospherePicUrl"] != nil {
                self.atmospherePicUrl = dict["AtmospherePicUrl"] as! String
            }
            if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                self.canSell = dict["CanSell"] as! Bool
            }
            if dict.keys.contains("CustomizedAttributeMap") && dict["CustomizedAttributeMap"] != nil {
                self.customizedAttributeMap = dict["CustomizedAttributeMap"] as! [String: String]
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! String
            }
            if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                self.itemTitle = dict["ItemTitle"] as! String
            }
            if dict.keys.contains("ItemUrl") && dict["ItemUrl"] != nil {
                self.itemUrl = dict["ItemUrl"] as! String
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                self.mainPicUrl = dict["MainPicUrl"] as! String
            }
            if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                self.pointPrice = dict["PointPrice"] as! Int64
            }
            if dict.keys.contains("Points") && dict["Points"] != nil {
                self.points = dict["Points"] as! Int64
            }
            if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                self.pointsAmount = dict["PointsAmount"] as! Int64
            }
            if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                self.priceCent = dict["PriceCent"] as! Int64
            }
            if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                self.reservePrice = dict["ReservePrice"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! [Int32]
            }
            if dict.keys.contains("WhitePicUrl") && dict["WhitePicUrl"] != nil {
                self.whitePicUrl = dict["WhitePicUrl"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: [QueryGuideItemGroupForCrowdOperationResponseBody.Model]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [QueryGuideItemGroupForCrowdOperationResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = QueryGuideItemGroupForCrowdOperationResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryGuideItemGroupForCrowdOperationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGuideItemGroupForCrowdOperationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryGuideItemGroupForCrowdOperationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGuideItemGroupWithOutInventoryRequest : Tea.TeaModel {
    public var bizId: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryGuideItemGroupWithOutInventoryResponseBody : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var customizedAttributeMap: [String: Any]?

        public var itemId: String?

        public var itemTitle: String?

        public var itemUrl: String?

        public var lmItemId: String?

        public var mainPicUrl: String?

        public var pointPrice: Int64?

        public var points: Int64?

        public var pointsAmount: Int64?

        public var priceCent: Int64?

        public var reservePrice: String?

        public var tags: [String]?

        public var whitePicUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customizedAttributeMap != nil {
                map["CustomizedAttributeMap"] = self.customizedAttributeMap!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.itemTitle != nil {
                map["ItemTitle"] = self.itemTitle!
            }
            if self.itemUrl != nil {
                map["ItemUrl"] = self.itemUrl!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.mainPicUrl != nil {
                map["MainPicUrl"] = self.mainPicUrl!
            }
            if self.pointPrice != nil {
                map["PointPrice"] = self.pointPrice!
            }
            if self.points != nil {
                map["Points"] = self.points!
            }
            if self.pointsAmount != nil {
                map["PointsAmount"] = self.pointsAmount!
            }
            if self.priceCent != nil {
                map["PriceCent"] = self.priceCent!
            }
            if self.reservePrice != nil {
                map["ReservePrice"] = self.reservePrice!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.whitePicUrl != nil {
                map["WhitePicUrl"] = self.whitePicUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomizedAttributeMap") && dict["CustomizedAttributeMap"] != nil {
                self.customizedAttributeMap = dict["CustomizedAttributeMap"] as! [String: Any]
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! String
            }
            if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                self.itemTitle = dict["ItemTitle"] as! String
            }
            if dict.keys.contains("ItemUrl") && dict["ItemUrl"] != nil {
                self.itemUrl = dict["ItemUrl"] as! String
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                self.mainPicUrl = dict["MainPicUrl"] as! String
            }
            if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                self.pointPrice = dict["PointPrice"] as! Int64
            }
            if dict.keys.contains("Points") && dict["Points"] != nil {
                self.points = dict["Points"] as! Int64
            }
            if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                self.pointsAmount = dict["PointsAmount"] as! Int64
            }
            if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                self.priceCent = dict["PriceCent"] as! Int64
            }
            if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                self.reservePrice = dict["ReservePrice"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! [String]
            }
            if dict.keys.contains("WhitePicUrl") && dict["WhitePicUrl"] != nil {
                self.whitePicUrl = dict["WhitePicUrl"] as! String
            }
        }
    }
    public var code: String?

    public var itemList: [QueryGuideItemGroupWithOutInventoryResponseBody.ItemList]?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [QueryGuideItemGroupWithOutInventoryResponseBody.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = QueryGuideItemGroupWithOutInventoryResponseBody.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryGuideItemGroupWithOutInventoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGuideItemGroupWithOutInventoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryGuideItemGroupWithOutInventoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryHotMoviesRequest : Tea.TeaModel {
    public var bizId: String?

    public var cityCode: Int64?

    public var extJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.cityCode != nil {
            map["CityCode"] = self.cityCode!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
            self.cityCode = dict["CityCode"] as! Int64
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
    }
}

public class QueryHotMoviesResponseBody : Tea.TeaModel {
    public class Movies : Tea.TeaModel {
        public class Movie : Tea.TeaModel {
            public class MovieTypeList : Tea.TeaModel {
                public var movieTypeList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.movieTypeList != nil {
                        map["MovieTypeList"] = self.movieTypeList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MovieTypeList") && dict["MovieTypeList"] != nil {
                        self.movieTypeList = dict["MovieTypeList"] as! [String]
                    }
                }
            }
            public class TrailerList : Tea.TeaModel {
                public var trailerList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.trailerList != nil {
                        map["TrailerList"] = self.trailerList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TrailerList") && dict["TrailerList"] != nil {
                        self.trailerList = dict["TrailerList"] as! [String]
                    }
                }
            }
            public var backgroundPicture: String?

            public var country: String?

            public var description_: String?

            public var director: String?

            public var duration: Int64?

            public var highlight: String?

            public var id: Int64?

            public var language: String?

            public var leadingRole: String?

            public var movieName: String?

            public var movieNameEn: String?

            public var movieTypeList: QueryHotMoviesResponseBody.Movies.Movie.MovieTypeList?

            public var movieVersion: String?

            public var openDay: String?

            public var openTime: String?

            public var poster: String?

            public var remark: String?

            public var trailerList: QueryHotMoviesResponseBody.Movies.Movie.TrailerList?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.movieTypeList?.validate()
                try self.trailerList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backgroundPicture != nil {
                    map["BackgroundPicture"] = self.backgroundPicture!
                }
                if self.country != nil {
                    map["Country"] = self.country!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.director != nil {
                    map["Director"] = self.director!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.highlight != nil {
                    map["Highlight"] = self.highlight!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.leadingRole != nil {
                    map["LeadingRole"] = self.leadingRole!
                }
                if self.movieName != nil {
                    map["MovieName"] = self.movieName!
                }
                if self.movieNameEn != nil {
                    map["MovieNameEn"] = self.movieNameEn!
                }
                if self.movieTypeList != nil {
                    map["MovieTypeList"] = self.movieTypeList?.toMap()
                }
                if self.movieVersion != nil {
                    map["MovieVersion"] = self.movieVersion!
                }
                if self.openDay != nil {
                    map["OpenDay"] = self.openDay!
                }
                if self.openTime != nil {
                    map["OpenTime"] = self.openTime!
                }
                if self.poster != nil {
                    map["Poster"] = self.poster!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.trailerList != nil {
                    map["TrailerList"] = self.trailerList?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BackgroundPicture") && dict["BackgroundPicture"] != nil {
                    self.backgroundPicture = dict["BackgroundPicture"] as! String
                }
                if dict.keys.contains("Country") && dict["Country"] != nil {
                    self.country = dict["Country"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Director") && dict["Director"] != nil {
                    self.director = dict["Director"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("Highlight") && dict["Highlight"] != nil {
                    self.highlight = dict["Highlight"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Language") && dict["Language"] != nil {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("LeadingRole") && dict["LeadingRole"] != nil {
                    self.leadingRole = dict["LeadingRole"] as! String
                }
                if dict.keys.contains("MovieName") && dict["MovieName"] != nil {
                    self.movieName = dict["MovieName"] as! String
                }
                if dict.keys.contains("MovieNameEn") && dict["MovieNameEn"] != nil {
                    self.movieNameEn = dict["MovieNameEn"] as! String
                }
                if dict.keys.contains("MovieTypeList") && dict["MovieTypeList"] != nil {
                    var model = QueryHotMoviesResponseBody.Movies.Movie.MovieTypeList()
                    model.fromMap(dict["MovieTypeList"] as! [String: Any])
                    self.movieTypeList = model
                }
                if dict.keys.contains("MovieVersion") && dict["MovieVersion"] != nil {
                    self.movieVersion = dict["MovieVersion"] as! String
                }
                if dict.keys.contains("OpenDay") && dict["OpenDay"] != nil {
                    self.openDay = dict["OpenDay"] as! String
                }
                if dict.keys.contains("OpenTime") && dict["OpenTime"] != nil {
                    self.openTime = dict["OpenTime"] as! String
                }
                if dict.keys.contains("Poster") && dict["Poster"] != nil {
                    self.poster = dict["Poster"] as! String
                }
                if dict.keys.contains("Remark") && dict["Remark"] != nil {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("TrailerList") && dict["TrailerList"] != nil {
                    var model = QueryHotMoviesResponseBody.Movies.Movie.TrailerList()
                    model.fromMap(dict["TrailerList"] as! [String: Any])
                    self.trailerList = model
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var movie: [QueryHotMoviesResponseBody.Movies.Movie]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.movie != nil {
                var tmp : [Any] = []
                for k in self.movie! {
                    tmp.append(k.toMap())
                }
                map["Movie"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Movie") && dict["Movie"] != nil {
                var tmp : [QueryHotMoviesResponseBody.Movies.Movie] = []
                for v in dict["Movie"] as! [Any] {
                    var model = QueryHotMoviesResponseBody.Movies.Movie()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.movie = tmp
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var movies: QueryHotMoviesResponseBody.Movies?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.movies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.movies != nil {
            map["Movies"] = self.movies?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Movies") && dict["Movies"] != nil {
            var model = QueryHotMoviesResponseBody.Movies()
            model.fromMap(dict["Movies"] as! [String: Any])
            self.movies = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryHotMoviesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryHotMoviesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryHotMoviesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryInventoryOfItemsInBizItemGroupRequest : Tea.TeaModel {
    public var bizId: String?

    public var divisionCode: String?

    public var itemIds: [Int64]?

    public var lmItemIds: [String]?

    public var subBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.divisionCode != nil {
            map["DivisionCode"] = self.divisionCode!
        }
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lmItemIds != nil {
            map["LmItemIds"] = self.lmItemIds!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
            self.divisionCode = dict["DivisionCode"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [Int64]
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIds = dict["LmItemIds"] as! [String]
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
    }
}

public class QueryInventoryOfItemsInBizItemGroupShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var divisionCode: String?

    public var itemIdsShrink: String?

    public var lmItemIdsShrink: String?

    public var subBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.divisionCode != nil {
            map["DivisionCode"] = self.divisionCode!
        }
        if self.itemIdsShrink != nil {
            map["ItemIds"] = self.itemIdsShrink!
        }
        if self.lmItemIdsShrink != nil {
            map["LmItemIds"] = self.lmItemIdsShrink!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
            self.divisionCode = dict["DivisionCode"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIdsShrink = dict["ItemIds"] as! String
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIdsShrink = dict["LmItemIds"] as! String
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
    }
}

public class QueryInventoryOfItemsInBizItemGroupResponseBody : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public class SkuList : Tea.TeaModel {
            public var quantity: Int32?

            public var skuId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.quantity != nil {
                    map["Quantity"] = self.quantity!
                }
                if self.skuId != nil {
                    map["SkuId"] = self.skuId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                    self.quantity = dict["Quantity"] as! Int32
                }
                if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                    self.skuId = dict["SkuId"] as! Int64
                }
            }
        }
        public var itemId: Int64?

        public var lmItemId: String?

        public var quantity: Int32?

        public var skuList: [QueryInventoryOfItemsInBizItemGroupResponseBody.ItemList.SkuList]?

        public var totalQuantity: Int64?

        public var totalSoldQuantity: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.skuList != nil {
                var tmp : [Any] = []
                for k in self.skuList! {
                    tmp.append(k.toMap())
                }
                map["SkuList"] = tmp
            }
            if self.totalQuantity != nil {
                map["TotalQuantity"] = self.totalQuantity!
            }
            if self.totalSoldQuantity != nil {
                map["TotalSoldQuantity"] = self.totalSoldQuantity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                var tmp : [QueryInventoryOfItemsInBizItemGroupResponseBody.ItemList.SkuList] = []
                for v in dict["SkuList"] as! [Any] {
                    var model = QueryInventoryOfItemsInBizItemGroupResponseBody.ItemList.SkuList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skuList = tmp
            }
            if dict.keys.contains("TotalQuantity") && dict["TotalQuantity"] != nil {
                self.totalQuantity = dict["TotalQuantity"] as! Int64
            }
            if dict.keys.contains("TotalSoldQuantity") && dict["TotalSoldQuantity"] != nil {
                self.totalSoldQuantity = dict["TotalSoldQuantity"] as! Int64
            }
        }
    }
    public var code: String?

    public var itemList: [QueryInventoryOfItemsInBizItemGroupResponseBody.ItemList]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [QueryInventoryOfItemsInBizItemGroupResponseBody.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = QueryInventoryOfItemsInBizItemGroupResponseBody.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryInventoryOfItemsInBizItemGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryInventoryOfItemsInBizItemGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryInventoryOfItemsInBizItemGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryItemDetailRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemId: Int64?

    public var lmItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
    }
}

public class QueryItemDetailResponseBody : Tea.TeaModel {
    public class Item : Tea.TeaModel {
        public class ItemImages : Tea.TeaModel {
            public var itemImage: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemImage != nil {
                    map["ItemImage"] = self.itemImage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemImage") && dict["ItemImage"] != nil {
                    self.itemImage = dict["ItemImage"] as! [String]
                }
            }
        }
        public class Skus : Tea.TeaModel {
            public class Sku : Tea.TeaModel {
                public var canSell: Bool?

                public var customizedAttributeMap: [String: Any]?

                public var extJson: String?

                public var itemId: Int64?

                public var lmItemId: String?

                public var pointPrice: Int64?

                public var points: Int64?

                public var pointsAmount: Int64?

                public var priceCent: Int64?

                public var quantity: Int32?

                public var reservePrice: Int64?

                public var skuId: Int64?

                public var skuPicUrl: String?

                public var skuProperties: String?

                public var skuPropertiesJson: String?

                public var skuTitle: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.canSell != nil {
                        map["CanSell"] = self.canSell!
                    }
                    if self.customizedAttributeMap != nil {
                        map["CustomizedAttributeMap"] = self.customizedAttributeMap!
                    }
                    if self.extJson != nil {
                        map["ExtJson"] = self.extJson!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.lmItemId != nil {
                        map["LmItemId"] = self.lmItemId!
                    }
                    if self.pointPrice != nil {
                        map["PointPrice"] = self.pointPrice!
                    }
                    if self.points != nil {
                        map["Points"] = self.points!
                    }
                    if self.pointsAmount != nil {
                        map["PointsAmount"] = self.pointsAmount!
                    }
                    if self.priceCent != nil {
                        map["PriceCent"] = self.priceCent!
                    }
                    if self.quantity != nil {
                        map["Quantity"] = self.quantity!
                    }
                    if self.reservePrice != nil {
                        map["ReservePrice"] = self.reservePrice!
                    }
                    if self.skuId != nil {
                        map["SkuId"] = self.skuId!
                    }
                    if self.skuPicUrl != nil {
                        map["SkuPicUrl"] = self.skuPicUrl!
                    }
                    if self.skuProperties != nil {
                        map["SkuProperties"] = self.skuProperties!
                    }
                    if self.skuPropertiesJson != nil {
                        map["SkuPropertiesJson"] = self.skuPropertiesJson!
                    }
                    if self.skuTitle != nil {
                        map["SkuTitle"] = self.skuTitle!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                        self.canSell = dict["CanSell"] as! Bool
                    }
                    if dict.keys.contains("CustomizedAttributeMap") && dict["CustomizedAttributeMap"] != nil {
                        self.customizedAttributeMap = dict["CustomizedAttributeMap"] as! [String: Any]
                    }
                    if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                        self.extJson = dict["ExtJson"] as! String
                    }
                    if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                        self.itemId = dict["ItemId"] as! Int64
                    }
                    if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                        self.lmItemId = dict["LmItemId"] as! String
                    }
                    if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                        self.pointPrice = dict["PointPrice"] as! Int64
                    }
                    if dict.keys.contains("Points") && dict["Points"] != nil {
                        self.points = dict["Points"] as! Int64
                    }
                    if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                        self.pointsAmount = dict["PointsAmount"] as! Int64
                    }
                    if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                        self.priceCent = dict["PriceCent"] as! Int64
                    }
                    if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                        self.quantity = dict["Quantity"] as! Int32
                    }
                    if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                        self.reservePrice = dict["ReservePrice"] as! Int64
                    }
                    if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                        self.skuId = dict["SkuId"] as! Int64
                    }
                    if dict.keys.contains("SkuPicUrl") && dict["SkuPicUrl"] != nil {
                        self.skuPicUrl = dict["SkuPicUrl"] as! String
                    }
                    if dict.keys.contains("SkuProperties") && dict["SkuProperties"] != nil {
                        self.skuProperties = dict["SkuProperties"] as! String
                    }
                    if dict.keys.contains("SkuPropertiesJson") && dict["SkuPropertiesJson"] != nil {
                        self.skuPropertiesJson = dict["SkuPropertiesJson"] as! String
                    }
                    if dict.keys.contains("SkuTitle") && dict["SkuTitle"] != nil {
                        self.skuTitle = dict["SkuTitle"] as! String
                    }
                }
            }
            public var sku: [QueryItemDetailResponseBody.Item.Skus.Sku]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sku != nil {
                    var tmp : [Any] = []
                    for k in self.sku! {
                        tmp.append(k.toMap())
                    }
                    map["Sku"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Sku") && dict["Sku"] != nil {
                    var tmp : [QueryItemDetailResponseBody.Item.Skus.Sku] = []
                    for v in dict["Sku"] as! [Any] {
                        var model = QueryItemDetailResponseBody.Item.Skus.Sku()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.sku = tmp
                }
            }
        }
        public var canSell: Bool?

        public var categoryId: Int64?

        public var centerInventory: Bool?

        public var customizedAttributeMap: [String: Any]?

        public var descOption: String?

        public var descPath: String?

        public var extJson: String?

        public var iforestProps: String?

        public var iforestPropsJson: String?

        public var isCanSell: Bool?

        public var isSellerPayPostfee: Bool?

        public var itemId: Int64?

        public var itemImages: QueryItemDetailResponseBody.Item.ItemImages?

        public var itemTitle: String?

        public var lmItemCategory: String?

        public var lmItemId: String?

        public var mainPicUrl: String?

        public var minPoints: Int64?

        public var minPrice: Int64?

        public var properties: String?

        public var propertiesJson: String?

        public var quantity: Int32?

        public var reservePrice: Int64?

        public var sellerId: Int64?

        public var sellerPayPostfee: Bool?

        public var sellerType: Int32?

        public var skus: QueryItemDetailResponseBody.Item.Skus?

        public var tbShopName: String?

        public var totalSoldQuantity: Int32?

        public var videoPicUrl: String?

        public var videoUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.itemImages?.validate()
            try self.skus?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canSell != nil {
                map["CanSell"] = self.canSell!
            }
            if self.categoryId != nil {
                map["CategoryId"] = self.categoryId!
            }
            if self.centerInventory != nil {
                map["CenterInventory"] = self.centerInventory!
            }
            if self.customizedAttributeMap != nil {
                map["CustomizedAttributeMap"] = self.customizedAttributeMap!
            }
            if self.descOption != nil {
                map["DescOption"] = self.descOption!
            }
            if self.descPath != nil {
                map["DescPath"] = self.descPath!
            }
            if self.extJson != nil {
                map["ExtJson"] = self.extJson!
            }
            if self.iforestProps != nil {
                map["IforestProps"] = self.iforestProps!
            }
            if self.iforestPropsJson != nil {
                map["IforestPropsJson"] = self.iforestPropsJson!
            }
            if self.isCanSell != nil {
                map["IsCanSell"] = self.isCanSell!
            }
            if self.isSellerPayPostfee != nil {
                map["IsSellerPayPostfee"] = self.isSellerPayPostfee!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.itemImages != nil {
                map["ItemImages"] = self.itemImages?.toMap()
            }
            if self.itemTitle != nil {
                map["ItemTitle"] = self.itemTitle!
            }
            if self.lmItemCategory != nil {
                map["LmItemCategory"] = self.lmItemCategory!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.mainPicUrl != nil {
                map["MainPicUrl"] = self.mainPicUrl!
            }
            if self.minPoints != nil {
                map["MinPoints"] = self.minPoints!
            }
            if self.minPrice != nil {
                map["MinPrice"] = self.minPrice!
            }
            if self.properties != nil {
                map["Properties"] = self.properties!
            }
            if self.propertiesJson != nil {
                map["PropertiesJson"] = self.propertiesJson!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.reservePrice != nil {
                map["ReservePrice"] = self.reservePrice!
            }
            if self.sellerId != nil {
                map["SellerId"] = self.sellerId!
            }
            if self.sellerPayPostfee != nil {
                map["SellerPayPostfee"] = self.sellerPayPostfee!
            }
            if self.sellerType != nil {
                map["SellerType"] = self.sellerType!
            }
            if self.skus != nil {
                map["Skus"] = self.skus?.toMap()
            }
            if self.tbShopName != nil {
                map["TbShopName"] = self.tbShopName!
            }
            if self.totalSoldQuantity != nil {
                map["TotalSoldQuantity"] = self.totalSoldQuantity!
            }
            if self.videoPicUrl != nil {
                map["VideoPicUrl"] = self.videoPicUrl!
            }
            if self.videoUrl != nil {
                map["VideoUrl"] = self.videoUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                self.canSell = dict["CanSell"] as! Bool
            }
            if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                self.categoryId = dict["CategoryId"] as! Int64
            }
            if dict.keys.contains("CenterInventory") && dict["CenterInventory"] != nil {
                self.centerInventory = dict["CenterInventory"] as! Bool
            }
            if dict.keys.contains("CustomizedAttributeMap") && dict["CustomizedAttributeMap"] != nil {
                self.customizedAttributeMap = dict["CustomizedAttributeMap"] as! [String: Any]
            }
            if dict.keys.contains("DescOption") && dict["DescOption"] != nil {
                self.descOption = dict["DescOption"] as! String
            }
            if dict.keys.contains("DescPath") && dict["DescPath"] != nil {
                self.descPath = dict["DescPath"] as! String
            }
            if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                self.extJson = dict["ExtJson"] as! String
            }
            if dict.keys.contains("IforestProps") && dict["IforestProps"] != nil {
                self.iforestProps = dict["IforestProps"] as! String
            }
            if dict.keys.contains("IforestPropsJson") && dict["IforestPropsJson"] != nil {
                self.iforestPropsJson = dict["IforestPropsJson"] as! String
            }
            if dict.keys.contains("IsCanSell") && dict["IsCanSell"] != nil {
                self.isCanSell = dict["IsCanSell"] as! Bool
            }
            if dict.keys.contains("IsSellerPayPostfee") && dict["IsSellerPayPostfee"] != nil {
                self.isSellerPayPostfee = dict["IsSellerPayPostfee"] as! Bool
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("ItemImages") && dict["ItemImages"] != nil {
                var model = QueryItemDetailResponseBody.Item.ItemImages()
                model.fromMap(dict["ItemImages"] as! [String: Any])
                self.itemImages = model
            }
            if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                self.itemTitle = dict["ItemTitle"] as! String
            }
            if dict.keys.contains("LmItemCategory") && dict["LmItemCategory"] != nil {
                self.lmItemCategory = dict["LmItemCategory"] as! String
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                self.mainPicUrl = dict["MainPicUrl"] as! String
            }
            if dict.keys.contains("MinPoints") && dict["MinPoints"] != nil {
                self.minPoints = dict["MinPoints"] as! Int64
            }
            if dict.keys.contains("MinPrice") && dict["MinPrice"] != nil {
                self.minPrice = dict["MinPrice"] as! Int64
            }
            if dict.keys.contains("Properties") && dict["Properties"] != nil {
                self.properties = dict["Properties"] as! String
            }
            if dict.keys.contains("PropertiesJson") && dict["PropertiesJson"] != nil {
                self.propertiesJson = dict["PropertiesJson"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                self.reservePrice = dict["ReservePrice"] as! Int64
            }
            if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                self.sellerId = dict["SellerId"] as! Int64
            }
            if dict.keys.contains("SellerPayPostfee") && dict["SellerPayPostfee"] != nil {
                self.sellerPayPostfee = dict["SellerPayPostfee"] as! Bool
            }
            if dict.keys.contains("SellerType") && dict["SellerType"] != nil {
                self.sellerType = dict["SellerType"] as! Int32
            }
            if dict.keys.contains("Skus") && dict["Skus"] != nil {
                var model = QueryItemDetailResponseBody.Item.Skus()
                model.fromMap(dict["Skus"] as! [String: Any])
                self.skus = model
            }
            if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                self.tbShopName = dict["TbShopName"] as! String
            }
            if dict.keys.contains("TotalSoldQuantity") && dict["TotalSoldQuantity"] != nil {
                self.totalSoldQuantity = dict["TotalSoldQuantity"] as! Int32
            }
            if dict.keys.contains("VideoPicUrl") && dict["VideoPicUrl"] != nil {
                self.videoPicUrl = dict["VideoPicUrl"] as! String
            }
            if dict.keys.contains("VideoUrl") && dict["VideoUrl"] != nil {
                self.videoUrl = dict["VideoUrl"] as! String
            }
        }
    }
    public var code: String?

    public var item: QueryItemDetailResponseBody.Item?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.item?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.item != nil {
            map["Item"] = self.item?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Item") && dict["Item"] != nil {
            var model = QueryItemDetailResponseBody.Item()
            model.fromMap(dict["Item"] as! [String: Any])
            self.item = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryItemDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryItemDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryItemDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryItemDetailInnerRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var divisionCode: String?

    public var ip: String?

    public var itemId: Int64?

    public var lmItemId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.divisionCode != nil {
            map["DivisionCode"] = self.divisionCode!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
            self.divisionCode = dict["DivisionCode"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryItemDetailInnerResponseBody : Tea.TeaModel {
    public class Item : Tea.TeaModel {
        public class SkuPropertys : Tea.TeaModel {
            public class Values : Tea.TeaModel {
                public var id: Int64?

                public var text: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.text != nil {
                        map["Text"] = self.text!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Text") && dict["Text"] != nil {
                        self.text = dict["Text"] as! String
                    }
                }
            }
            public var id: Int64?

            public var text: String?

            public var values: [QueryItemDetailInnerResponseBody.Item.SkuPropertys.Values]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.text != nil {
                    map["Text"] = self.text!
                }
                if self.values != nil {
                    var tmp : [Any] = []
                    for k in self.values! {
                        tmp.append(k.toMap())
                    }
                    map["Values"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Text") && dict["Text"] != nil {
                    self.text = dict["Text"] as! String
                }
                if dict.keys.contains("Values") && dict["Values"] != nil {
                    var tmp : [QueryItemDetailInnerResponseBody.Item.SkuPropertys.Values] = []
                    for v in dict["Values"] as! [Any] {
                        var model = QueryItemDetailInnerResponseBody.Item.SkuPropertys.Values()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.values = tmp
                }
            }
        }
        public class Skus : Tea.TeaModel {
            public var extJson: String?

            public var itemId: Int64?

            public var lmItemId: String?

            public var pointPrice: Int64?

            public var points: Int64?

            public var pointsAmount: Int64?

            public var priceCent: Int64?

            public var quantity: Int32?

            public var reservePrice: Int64?

            public var skuDesc: String?

            public var skuId: Int64?

            public var skuPicUrl: String?

            public var skuPvs: String?

            public var skuTitle: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extJson != nil {
                    map["ExtJson"] = self.extJson!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.pointPrice != nil {
                    map["PointPrice"] = self.pointPrice!
                }
                if self.points != nil {
                    map["Points"] = self.points!
                }
                if self.pointsAmount != nil {
                    map["PointsAmount"] = self.pointsAmount!
                }
                if self.priceCent != nil {
                    map["PriceCent"] = self.priceCent!
                }
                if self.quantity != nil {
                    map["Quantity"] = self.quantity!
                }
                if self.reservePrice != nil {
                    map["ReservePrice"] = self.reservePrice!
                }
                if self.skuDesc != nil {
                    map["SkuDesc"] = self.skuDesc!
                }
                if self.skuId != nil {
                    map["SkuId"] = self.skuId!
                }
                if self.skuPicUrl != nil {
                    map["SkuPicUrl"] = self.skuPicUrl!
                }
                if self.skuPvs != nil {
                    map["SkuPvs"] = self.skuPvs!
                }
                if self.skuTitle != nil {
                    map["SkuTitle"] = self.skuTitle!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                    self.extJson = dict["ExtJson"] as! String
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                    self.pointPrice = dict["PointPrice"] as! Int64
                }
                if dict.keys.contains("Points") && dict["Points"] != nil {
                    self.points = dict["Points"] as! Int64
                }
                if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                    self.pointsAmount = dict["PointsAmount"] as! Int64
                }
                if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                    self.priceCent = dict["PriceCent"] as! Int64
                }
                if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                    self.quantity = dict["Quantity"] as! Int32
                }
                if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                    self.reservePrice = dict["ReservePrice"] as! Int64
                }
                if dict.keys.contains("SkuDesc") && dict["SkuDesc"] != nil {
                    self.skuDesc = dict["SkuDesc"] as! String
                }
                if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                    self.skuId = dict["SkuId"] as! Int64
                }
                if dict.keys.contains("SkuPicUrl") && dict["SkuPicUrl"] != nil {
                    self.skuPicUrl = dict["SkuPicUrl"] as! String
                }
                if dict.keys.contains("SkuPvs") && dict["SkuPvs"] != nil {
                    self.skuPvs = dict["SkuPvs"] as! String
                }
                if dict.keys.contains("SkuTitle") && dict["SkuTitle"] != nil {
                    self.skuTitle = dict["SkuTitle"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var canSell: Bool?

        public var categoryId: Int64?

        public var categoryIds: [Int64]?

        public var centerInventory: Bool?

        public var city: String?

        public var descOption: String?

        public var descPath: String?

        public var firstPicUrl: String?

        public var iforestProps: [[String: Any]]?

        public var isCanSell: Bool?

        public var isSellerPayPostfee: Bool?

        public var itemId: Int64?

        public var itemImages: [String]?

        public var itemTitle: String?

        public var lmItemCategory: String?

        public var lmShopId: Int64?

        public var mainPicUrl: String?

        public var minPoints: Int64?

        public var minPrice: Int64?

        public var properties: [String: Any]?

        public var province: String?

        public var quantity: Int32?

        public var reservePrice: Int64?

        public var sellerId: Int64?

        public var sellerNick: String?

        public var sellerPayPostfee: Bool?

        public var skuPropertys: [QueryItemDetailInnerResponseBody.Item.SkuPropertys]?

        public var skus: [QueryItemDetailInnerResponseBody.Item.Skus]?

        public var tbShopName: String?

        public var totalSoldQuantity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canSell != nil {
                map["CanSell"] = self.canSell!
            }
            if self.categoryId != nil {
                map["CategoryId"] = self.categoryId!
            }
            if self.categoryIds != nil {
                map["CategoryIds"] = self.categoryIds!
            }
            if self.centerInventory != nil {
                map["CenterInventory"] = self.centerInventory!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.descOption != nil {
                map["DescOption"] = self.descOption!
            }
            if self.descPath != nil {
                map["DescPath"] = self.descPath!
            }
            if self.firstPicUrl != nil {
                map["FirstPicUrl"] = self.firstPicUrl!
            }
            if self.iforestProps != nil {
                map["IforestProps"] = self.iforestProps!
            }
            if self.isCanSell != nil {
                map["IsCanSell"] = self.isCanSell!
            }
            if self.isSellerPayPostfee != nil {
                map["IsSellerPayPostfee"] = self.isSellerPayPostfee!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.itemImages != nil {
                map["ItemImages"] = self.itemImages!
            }
            if self.itemTitle != nil {
                map["ItemTitle"] = self.itemTitle!
            }
            if self.lmItemCategory != nil {
                map["LmItemCategory"] = self.lmItemCategory!
            }
            if self.lmShopId != nil {
                map["LmShopId"] = self.lmShopId!
            }
            if self.mainPicUrl != nil {
                map["MainPicUrl"] = self.mainPicUrl!
            }
            if self.minPoints != nil {
                map["MinPoints"] = self.minPoints!
            }
            if self.minPrice != nil {
                map["MinPrice"] = self.minPrice!
            }
            if self.properties != nil {
                map["Properties"] = self.properties!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.reservePrice != nil {
                map["ReservePrice"] = self.reservePrice!
            }
            if self.sellerId != nil {
                map["SellerId"] = self.sellerId!
            }
            if self.sellerNick != nil {
                map["SellerNick"] = self.sellerNick!
            }
            if self.sellerPayPostfee != nil {
                map["SellerPayPostfee"] = self.sellerPayPostfee!
            }
            if self.skuPropertys != nil {
                var tmp : [Any] = []
                for k in self.skuPropertys! {
                    tmp.append(k.toMap())
                }
                map["SkuPropertys"] = tmp
            }
            if self.skus != nil {
                var tmp : [Any] = []
                for k in self.skus! {
                    tmp.append(k.toMap())
                }
                map["Skus"] = tmp
            }
            if self.tbShopName != nil {
                map["TbShopName"] = self.tbShopName!
            }
            if self.totalSoldQuantity != nil {
                map["TotalSoldQuantity"] = self.totalSoldQuantity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                self.canSell = dict["CanSell"] as! Bool
            }
            if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                self.categoryId = dict["CategoryId"] as! Int64
            }
            if dict.keys.contains("CategoryIds") && dict["CategoryIds"] != nil {
                self.categoryIds = dict["CategoryIds"] as! [Int64]
            }
            if dict.keys.contains("CenterInventory") && dict["CenterInventory"] != nil {
                self.centerInventory = dict["CenterInventory"] as! Bool
            }
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("DescOption") && dict["DescOption"] != nil {
                self.descOption = dict["DescOption"] as! String
            }
            if dict.keys.contains("DescPath") && dict["DescPath"] != nil {
                self.descPath = dict["DescPath"] as! String
            }
            if dict.keys.contains("FirstPicUrl") && dict["FirstPicUrl"] != nil {
                self.firstPicUrl = dict["FirstPicUrl"] as! String
            }
            if dict.keys.contains("IforestProps") && dict["IforestProps"] != nil {
                self.iforestProps = dict["IforestProps"] as! [[String: Any]]
            }
            if dict.keys.contains("IsCanSell") && dict["IsCanSell"] != nil {
                self.isCanSell = dict["IsCanSell"] as! Bool
            }
            if dict.keys.contains("IsSellerPayPostfee") && dict["IsSellerPayPostfee"] != nil {
                self.isSellerPayPostfee = dict["IsSellerPayPostfee"] as! Bool
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("ItemImages") && dict["ItemImages"] != nil {
                self.itemImages = dict["ItemImages"] as! [String]
            }
            if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                self.itemTitle = dict["ItemTitle"] as! String
            }
            if dict.keys.contains("LmItemCategory") && dict["LmItemCategory"] != nil {
                self.lmItemCategory = dict["LmItemCategory"] as! String
            }
            if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
                self.lmShopId = dict["LmShopId"] as! Int64
            }
            if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                self.mainPicUrl = dict["MainPicUrl"] as! String
            }
            if dict.keys.contains("MinPoints") && dict["MinPoints"] != nil {
                self.minPoints = dict["MinPoints"] as! Int64
            }
            if dict.keys.contains("MinPrice") && dict["MinPrice"] != nil {
                self.minPrice = dict["MinPrice"] as! Int64
            }
            if dict.keys.contains("Properties") && dict["Properties"] != nil {
                self.properties = dict["Properties"] as! [String: Any]
            }
            if dict.keys.contains("Province") && dict["Province"] != nil {
                self.province = dict["Province"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                self.reservePrice = dict["ReservePrice"] as! Int64
            }
            if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                self.sellerId = dict["SellerId"] as! Int64
            }
            if dict.keys.contains("SellerNick") && dict["SellerNick"] != nil {
                self.sellerNick = dict["SellerNick"] as! String
            }
            if dict.keys.contains("SellerPayPostfee") && dict["SellerPayPostfee"] != nil {
                self.sellerPayPostfee = dict["SellerPayPostfee"] as! Bool
            }
            if dict.keys.contains("SkuPropertys") && dict["SkuPropertys"] != nil {
                var tmp : [QueryItemDetailInnerResponseBody.Item.SkuPropertys] = []
                for v in dict["SkuPropertys"] as! [Any] {
                    var model = QueryItemDetailInnerResponseBody.Item.SkuPropertys()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skuPropertys = tmp
            }
            if dict.keys.contains("Skus") && dict["Skus"] != nil {
                var tmp : [QueryItemDetailInnerResponseBody.Item.Skus] = []
                for v in dict["Skus"] as! [Any] {
                    var model = QueryItemDetailInnerResponseBody.Item.Skus()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skus = tmp
            }
            if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                self.tbShopName = dict["TbShopName"] as! String
            }
            if dict.keys.contains("TotalSoldQuantity") && dict["TotalSoldQuantity"] != nil {
                self.totalSoldQuantity = dict["TotalSoldQuantity"] as! Int32
            }
        }
    }
    public var code: String?

    public var item: QueryItemDetailInnerResponseBody.Item?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.item?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.item != nil {
            map["Item"] = self.item?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Item") && dict["Item"] != nil {
            var model = QueryItemDetailInnerResponseBody.Item()
            model.fromMap(dict["Item"] as! [String: Any])
            self.item = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryItemDetailInnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryItemDetailInnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryItemDetailInnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryItemDetailTeaRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemId: Int64?

    public var lmItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
    }
}

public class QueryItemDetailTeaResponseBody : Tea.TeaModel {
    public class Item : Tea.TeaModel {
        public class IforestProps : Tea.TeaModel {
            public var iforestProp: [[String: Any]]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.iforestProp != nil {
                    map["IforestProp"] = self.iforestProp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IforestProp") && dict["IforestProp"] != nil {
                    self.iforestProp = dict["IforestProp"] as! [[String: Any]]
                }
            }
        }
        public class ItemImages : Tea.TeaModel {
            public var itemImage: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemImage != nil {
                    map["ItemImage"] = self.itemImage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemImage") && dict["ItemImage"] != nil {
                    self.itemImage = dict["ItemImage"] as! [String]
                }
            }
        }
        public class Skus : Tea.TeaModel {
            public class Sku : Tea.TeaModel {
                public var canSell: Bool?

                public var customizedAttributeMap: [String: Any]?

                public var extJson: String?

                public var hasQuantity: Bool?

                public var itemId: Int64?

                public var lmItemId: String?

                public var pointPrice: Int64?

                public var points: Int64?

                public var pointsAmount: Int64?

                public var priceCent: Int64?

                public var quantity: Int32?

                public var reservePrice: Int64?

                public var simpleQuantity: String?

                public var skuId: Int64?

                public var skuPicUrl: String?

                public var skuProperties: [String: Any]?

                public var skuTitle: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.canSell != nil {
                        map["CanSell"] = self.canSell!
                    }
                    if self.customizedAttributeMap != nil {
                        map["CustomizedAttributeMap"] = self.customizedAttributeMap!
                    }
                    if self.extJson != nil {
                        map["ExtJson"] = self.extJson!
                    }
                    if self.hasQuantity != nil {
                        map["HasQuantity"] = self.hasQuantity!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.lmItemId != nil {
                        map["LmItemId"] = self.lmItemId!
                    }
                    if self.pointPrice != nil {
                        map["PointPrice"] = self.pointPrice!
                    }
                    if self.points != nil {
                        map["Points"] = self.points!
                    }
                    if self.pointsAmount != nil {
                        map["PointsAmount"] = self.pointsAmount!
                    }
                    if self.priceCent != nil {
                        map["PriceCent"] = self.priceCent!
                    }
                    if self.quantity != nil {
                        map["Quantity"] = self.quantity!
                    }
                    if self.reservePrice != nil {
                        map["ReservePrice"] = self.reservePrice!
                    }
                    if self.simpleQuantity != nil {
                        map["SimpleQuantity"] = self.simpleQuantity!
                    }
                    if self.skuId != nil {
                        map["SkuId"] = self.skuId!
                    }
                    if self.skuPicUrl != nil {
                        map["SkuPicUrl"] = self.skuPicUrl!
                    }
                    if self.skuProperties != nil {
                        map["SkuProperties"] = self.skuProperties!
                    }
                    if self.skuTitle != nil {
                        map["SkuTitle"] = self.skuTitle!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                        self.canSell = dict["CanSell"] as! Bool
                    }
                    if dict.keys.contains("CustomizedAttributeMap") && dict["CustomizedAttributeMap"] != nil {
                        self.customizedAttributeMap = dict["CustomizedAttributeMap"] as! [String: Any]
                    }
                    if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                        self.extJson = dict["ExtJson"] as! String
                    }
                    if dict.keys.contains("HasQuantity") && dict["HasQuantity"] != nil {
                        self.hasQuantity = dict["HasQuantity"] as! Bool
                    }
                    if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                        self.itemId = dict["ItemId"] as! Int64
                    }
                    if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                        self.lmItemId = dict["LmItemId"] as! String
                    }
                    if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                        self.pointPrice = dict["PointPrice"] as! Int64
                    }
                    if dict.keys.contains("Points") && dict["Points"] != nil {
                        self.points = dict["Points"] as! Int64
                    }
                    if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                        self.pointsAmount = dict["PointsAmount"] as! Int64
                    }
                    if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                        self.priceCent = dict["PriceCent"] as! Int64
                    }
                    if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                        self.quantity = dict["Quantity"] as! Int32
                    }
                    if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                        self.reservePrice = dict["ReservePrice"] as! Int64
                    }
                    if dict.keys.contains("SimpleQuantity") && dict["SimpleQuantity"] != nil {
                        self.simpleQuantity = dict["SimpleQuantity"] as! String
                    }
                    if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                        self.skuId = dict["SkuId"] as! Int64
                    }
                    if dict.keys.contains("SkuPicUrl") && dict["SkuPicUrl"] != nil {
                        self.skuPicUrl = dict["SkuPicUrl"] as! String
                    }
                    if dict.keys.contains("SkuProperties") && dict["SkuProperties"] != nil {
                        self.skuProperties = dict["SkuProperties"] as! [String: Any]
                    }
                    if dict.keys.contains("SkuTitle") && dict["SkuTitle"] != nil {
                        self.skuTitle = dict["SkuTitle"] as! String
                    }
                }
            }
            public var sku: [QueryItemDetailTeaResponseBody.Item.Skus.Sku]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sku != nil {
                    var tmp : [Any] = []
                    for k in self.sku! {
                        tmp.append(k.toMap())
                    }
                    map["Sku"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Sku") && dict["Sku"] != nil {
                    var tmp : [QueryItemDetailTeaResponseBody.Item.Skus.Sku] = []
                    for v in dict["Sku"] as! [Any] {
                        var model = QueryItemDetailTeaResponseBody.Item.Skus.Sku()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.sku = tmp
                }
            }
        }
        public var canSell: Bool?

        public var categoryId: Int64?

        public var centerInventory: Bool?

        public var customizedAttributeMap: [String: Any]?

        public var descOption: String?

        public var descPath: String?

        public var extJson: String?

        public var firstPicUrl: String?

        public var hasQuantity: Bool?

        public var iforestProps: QueryItemDetailTeaResponseBody.Item.IforestProps?

        public var isCanSell: Bool?

        public var isSellerPayPostfee: Bool?

        public var itemId: Int64?

        public var itemImages: QueryItemDetailTeaResponseBody.Item.ItemImages?

        public var itemTitle: String?

        public var itemTotalSimpleValue: String?

        public var lmItemCategory: String?

        public var lmItemId: String?

        public var mainPicUrl: String?

        public var minPoints: Int64?

        public var minPrice: Int64?

        public var properties: [String: Any]?

        public var quantity: Int32?

        public var reservePrice: Int64?

        public var sellerId: Int64?

        public var sellerPayPostfee: Bool?

        public var sellerType: Int32?

        public var simpleQuantity: String?

        public var skus: QueryItemDetailTeaResponseBody.Item.Skus?

        public var tbShopName: String?

        public var totalSoldQuantity: Int32?

        public var totalSoldSimpleQuantity: String?

        public var videoPicUrl: String?

        public var videoUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.iforestProps?.validate()
            try self.itemImages?.validate()
            try self.skus?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canSell != nil {
                map["CanSell"] = self.canSell!
            }
            if self.categoryId != nil {
                map["CategoryId"] = self.categoryId!
            }
            if self.centerInventory != nil {
                map["CenterInventory"] = self.centerInventory!
            }
            if self.customizedAttributeMap != nil {
                map["CustomizedAttributeMap"] = self.customizedAttributeMap!
            }
            if self.descOption != nil {
                map["DescOption"] = self.descOption!
            }
            if self.descPath != nil {
                map["DescPath"] = self.descPath!
            }
            if self.extJson != nil {
                map["ExtJson"] = self.extJson!
            }
            if self.firstPicUrl != nil {
                map["FirstPicUrl"] = self.firstPicUrl!
            }
            if self.hasQuantity != nil {
                map["HasQuantity"] = self.hasQuantity!
            }
            if self.iforestProps != nil {
                map["IforestProps"] = self.iforestProps?.toMap()
            }
            if self.isCanSell != nil {
                map["IsCanSell"] = self.isCanSell!
            }
            if self.isSellerPayPostfee != nil {
                map["IsSellerPayPostfee"] = self.isSellerPayPostfee!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.itemImages != nil {
                map["ItemImages"] = self.itemImages?.toMap()
            }
            if self.itemTitle != nil {
                map["ItemTitle"] = self.itemTitle!
            }
            if self.itemTotalSimpleValue != nil {
                map["ItemTotalSimpleValue"] = self.itemTotalSimpleValue!
            }
            if self.lmItemCategory != nil {
                map["LmItemCategory"] = self.lmItemCategory!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.mainPicUrl != nil {
                map["MainPicUrl"] = self.mainPicUrl!
            }
            if self.minPoints != nil {
                map["MinPoints"] = self.minPoints!
            }
            if self.minPrice != nil {
                map["MinPrice"] = self.minPrice!
            }
            if self.properties != nil {
                map["Properties"] = self.properties!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.reservePrice != nil {
                map["ReservePrice"] = self.reservePrice!
            }
            if self.sellerId != nil {
                map["SellerId"] = self.sellerId!
            }
            if self.sellerPayPostfee != nil {
                map["SellerPayPostfee"] = self.sellerPayPostfee!
            }
            if self.sellerType != nil {
                map["SellerType"] = self.sellerType!
            }
            if self.simpleQuantity != nil {
                map["SimpleQuantity"] = self.simpleQuantity!
            }
            if self.skus != nil {
                map["Skus"] = self.skus?.toMap()
            }
            if self.tbShopName != nil {
                map["TbShopName"] = self.tbShopName!
            }
            if self.totalSoldQuantity != nil {
                map["TotalSoldQuantity"] = self.totalSoldQuantity!
            }
            if self.totalSoldSimpleQuantity != nil {
                map["TotalSoldSimpleQuantity"] = self.totalSoldSimpleQuantity!
            }
            if self.videoPicUrl != nil {
                map["VideoPicUrl"] = self.videoPicUrl!
            }
            if self.videoUrl != nil {
                map["VideoUrl"] = self.videoUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                self.canSell = dict["CanSell"] as! Bool
            }
            if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                self.categoryId = dict["CategoryId"] as! Int64
            }
            if dict.keys.contains("CenterInventory") && dict["CenterInventory"] != nil {
                self.centerInventory = dict["CenterInventory"] as! Bool
            }
            if dict.keys.contains("CustomizedAttributeMap") && dict["CustomizedAttributeMap"] != nil {
                self.customizedAttributeMap = dict["CustomizedAttributeMap"] as! [String: Any]
            }
            if dict.keys.contains("DescOption") && dict["DescOption"] != nil {
                self.descOption = dict["DescOption"] as! String
            }
            if dict.keys.contains("DescPath") && dict["DescPath"] != nil {
                self.descPath = dict["DescPath"] as! String
            }
            if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                self.extJson = dict["ExtJson"] as! String
            }
            if dict.keys.contains("FirstPicUrl") && dict["FirstPicUrl"] != nil {
                self.firstPicUrl = dict["FirstPicUrl"] as! String
            }
            if dict.keys.contains("HasQuantity") && dict["HasQuantity"] != nil {
                self.hasQuantity = dict["HasQuantity"] as! Bool
            }
            if dict.keys.contains("IforestProps") && dict["IforestProps"] != nil {
                var model = QueryItemDetailTeaResponseBody.Item.IforestProps()
                model.fromMap(dict["IforestProps"] as! [String: Any])
                self.iforestProps = model
            }
            if dict.keys.contains("IsCanSell") && dict["IsCanSell"] != nil {
                self.isCanSell = dict["IsCanSell"] as! Bool
            }
            if dict.keys.contains("IsSellerPayPostfee") && dict["IsSellerPayPostfee"] != nil {
                self.isSellerPayPostfee = dict["IsSellerPayPostfee"] as! Bool
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("ItemImages") && dict["ItemImages"] != nil {
                var model = QueryItemDetailTeaResponseBody.Item.ItemImages()
                model.fromMap(dict["ItemImages"] as! [String: Any])
                self.itemImages = model
            }
            if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                self.itemTitle = dict["ItemTitle"] as! String
            }
            if dict.keys.contains("ItemTotalSimpleValue") && dict["ItemTotalSimpleValue"] != nil {
                self.itemTotalSimpleValue = dict["ItemTotalSimpleValue"] as! String
            }
            if dict.keys.contains("LmItemCategory") && dict["LmItemCategory"] != nil {
                self.lmItemCategory = dict["LmItemCategory"] as! String
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                self.mainPicUrl = dict["MainPicUrl"] as! String
            }
            if dict.keys.contains("MinPoints") && dict["MinPoints"] != nil {
                self.minPoints = dict["MinPoints"] as! Int64
            }
            if dict.keys.contains("MinPrice") && dict["MinPrice"] != nil {
                self.minPrice = dict["MinPrice"] as! Int64
            }
            if dict.keys.contains("Properties") && dict["Properties"] != nil {
                self.properties = dict["Properties"] as! [String: Any]
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                self.reservePrice = dict["ReservePrice"] as! Int64
            }
            if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                self.sellerId = dict["SellerId"] as! Int64
            }
            if dict.keys.contains("SellerPayPostfee") && dict["SellerPayPostfee"] != nil {
                self.sellerPayPostfee = dict["SellerPayPostfee"] as! Bool
            }
            if dict.keys.contains("SellerType") && dict["SellerType"] != nil {
                self.sellerType = dict["SellerType"] as! Int32
            }
            if dict.keys.contains("SimpleQuantity") && dict["SimpleQuantity"] != nil {
                self.simpleQuantity = dict["SimpleQuantity"] as! String
            }
            if dict.keys.contains("Skus") && dict["Skus"] != nil {
                var model = QueryItemDetailTeaResponseBody.Item.Skus()
                model.fromMap(dict["Skus"] as! [String: Any])
                self.skus = model
            }
            if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                self.tbShopName = dict["TbShopName"] as! String
            }
            if dict.keys.contains("TotalSoldQuantity") && dict["TotalSoldQuantity"] != nil {
                self.totalSoldQuantity = dict["TotalSoldQuantity"] as! Int32
            }
            if dict.keys.contains("TotalSoldSimpleQuantity") && dict["TotalSoldSimpleQuantity"] != nil {
                self.totalSoldSimpleQuantity = dict["TotalSoldSimpleQuantity"] as! String
            }
            if dict.keys.contains("VideoPicUrl") && dict["VideoPicUrl"] != nil {
                self.videoPicUrl = dict["VideoPicUrl"] as! String
            }
            if dict.keys.contains("VideoUrl") && dict["VideoUrl"] != nil {
                self.videoUrl = dict["VideoUrl"] as! String
            }
        }
    }
    public var code: String?

    public var item: QueryItemDetailTeaResponseBody.Item?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.item?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.item != nil {
            map["Item"] = self.item?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Item") && dict["Item"] != nil {
            var model = QueryItemDetailTeaResponseBody.Item()
            model.fromMap(dict["Item"] as! [String: Any])
            self.item = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryItemDetailTeaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryItemDetailTeaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryItemDetailTeaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryItemInSubBizsRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemId: Int64?

    public var lmItemId: String?

    public var subBizIds: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.subBizIds != nil {
            map["SubBizIds"] = self.subBizIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("SubBizIds") && dict["SubBizIds"] != nil {
            self.subBizIds = dict["SubBizIds"] as! [String: Any]
        }
    }
}

public class QueryItemInSubBizsShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemId: Int64?

    public var lmItemId: String?

    public var subBizIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.subBizIdsShrink != nil {
            map["SubBizIds"] = self.subBizIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("SubBizIds") && dict["SubBizIds"] != nil {
            self.subBizIdsShrink = dict["SubBizIds"] as! String
        }
    }
}

public class QueryItemInSubBizsResponseBody : Tea.TeaModel {
    public class ItemBizList : Tea.TeaModel {
        public class SkuList : Tea.TeaModel {
            public var benefitId: String?

            public var canSell: Bool?

            public var customizedAttributeMap: [String: Any]?

            public var pointPrice: Int64?

            public var points: Int64?

            public var pointsAmount: Int64?

            public var priceCent: Int64?

            public var reservePrice: Int64?

            public var skuId: Int64?

            public var skuPicUrl: String?

            public var skuProperties: String?

            public var skuPropertiesJson: String?

            public var skuTitle: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.benefitId != nil {
                    map["BenefitId"] = self.benefitId!
                }
                if self.canSell != nil {
                    map["CanSell"] = self.canSell!
                }
                if self.customizedAttributeMap != nil {
                    map["CustomizedAttributeMap"] = self.customizedAttributeMap!
                }
                if self.pointPrice != nil {
                    map["PointPrice"] = self.pointPrice!
                }
                if self.points != nil {
                    map["Points"] = self.points!
                }
                if self.pointsAmount != nil {
                    map["PointsAmount"] = self.pointsAmount!
                }
                if self.priceCent != nil {
                    map["PriceCent"] = self.priceCent!
                }
                if self.reservePrice != nil {
                    map["ReservePrice"] = self.reservePrice!
                }
                if self.skuId != nil {
                    map["SkuId"] = self.skuId!
                }
                if self.skuPicUrl != nil {
                    map["SkuPicUrl"] = self.skuPicUrl!
                }
                if self.skuProperties != nil {
                    map["SkuProperties"] = self.skuProperties!
                }
                if self.skuPropertiesJson != nil {
                    map["SkuPropertiesJson"] = self.skuPropertiesJson!
                }
                if self.skuTitle != nil {
                    map["SkuTitle"] = self.skuTitle!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BenefitId") && dict["BenefitId"] != nil {
                    self.benefitId = dict["BenefitId"] as! String
                }
                if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                    self.canSell = dict["CanSell"] as! Bool
                }
                if dict.keys.contains("CustomizedAttributeMap") && dict["CustomizedAttributeMap"] != nil {
                    self.customizedAttributeMap = dict["CustomizedAttributeMap"] as! [String: Any]
                }
                if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                    self.pointPrice = dict["PointPrice"] as! Int64
                }
                if dict.keys.contains("Points") && dict["Points"] != nil {
                    self.points = dict["Points"] as! Int64
                }
                if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                    self.pointsAmount = dict["PointsAmount"] as! Int64
                }
                if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                    self.priceCent = dict["PriceCent"] as! Int64
                }
                if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                    self.reservePrice = dict["ReservePrice"] as! Int64
                }
                if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                    self.skuId = dict["SkuId"] as! Int64
                }
                if dict.keys.contains("SkuPicUrl") && dict["SkuPicUrl"] != nil {
                    self.skuPicUrl = dict["SkuPicUrl"] as! String
                }
                if dict.keys.contains("SkuProperties") && dict["SkuProperties"] != nil {
                    self.skuProperties = dict["SkuProperties"] as! String
                }
                if dict.keys.contains("SkuPropertiesJson") && dict["SkuPropertiesJson"] != nil {
                    self.skuPropertiesJson = dict["SkuPropertiesJson"] as! String
                }
                if dict.keys.contains("SkuTitle") && dict["SkuTitle"] != nil {
                    self.skuTitle = dict["SkuTitle"] as! String
                }
            }
        }
        public var canSell: Bool?

        public var categoryId: Int64?

        public var descOption: String?

        public var itemId: Int64?

        public var itemImages: [String]?

        public var itemTitle: String?

        public var lmItemId: String?

        public var mainPicUrl: String?

        public var propertiesJson: String?

        public var quantity: Int64?

        public var reservePrice: Int64?

        public var sellerId: Int64?

        public var skuList: [QueryItemInSubBizsResponseBody.ItemBizList.SkuList]?

        public var subBizId: String?

        public var tbShopName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canSell != nil {
                map["CanSell"] = self.canSell!
            }
            if self.categoryId != nil {
                map["CategoryId"] = self.categoryId!
            }
            if self.descOption != nil {
                map["DescOption"] = self.descOption!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.itemImages != nil {
                map["ItemImages"] = self.itemImages!
            }
            if self.itemTitle != nil {
                map["ItemTitle"] = self.itemTitle!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.mainPicUrl != nil {
                map["MainPicUrl"] = self.mainPicUrl!
            }
            if self.propertiesJson != nil {
                map["PropertiesJson"] = self.propertiesJson!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.reservePrice != nil {
                map["ReservePrice"] = self.reservePrice!
            }
            if self.sellerId != nil {
                map["SellerId"] = self.sellerId!
            }
            if self.skuList != nil {
                var tmp : [Any] = []
                for k in self.skuList! {
                    tmp.append(k.toMap())
                }
                map["SkuList"] = tmp
            }
            if self.subBizId != nil {
                map["SubBizId"] = self.subBizId!
            }
            if self.tbShopName != nil {
                map["TbShopName"] = self.tbShopName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                self.canSell = dict["CanSell"] as! Bool
            }
            if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                self.categoryId = dict["CategoryId"] as! Int64
            }
            if dict.keys.contains("DescOption") && dict["DescOption"] != nil {
                self.descOption = dict["DescOption"] as! String
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("ItemImages") && dict["ItemImages"] != nil {
                self.itemImages = dict["ItemImages"] as! [String]
            }
            if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                self.itemTitle = dict["ItemTitle"] as! String
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("MainPicUrl") && dict["MainPicUrl"] != nil {
                self.mainPicUrl = dict["MainPicUrl"] as! String
            }
            if dict.keys.contains("PropertiesJson") && dict["PropertiesJson"] != nil {
                self.propertiesJson = dict["PropertiesJson"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int64
            }
            if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                self.reservePrice = dict["ReservePrice"] as! Int64
            }
            if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                self.sellerId = dict["SellerId"] as! Int64
            }
            if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                var tmp : [QueryItemInSubBizsResponseBody.ItemBizList.SkuList] = []
                for v in dict["SkuList"] as! [Any] {
                    var model = QueryItemInSubBizsResponseBody.ItemBizList.SkuList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skuList = tmp
            }
            if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
                self.subBizId = dict["SubBizId"] as! String
            }
            if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                self.tbShopName = dict["TbShopName"] as! String
            }
        }
    }
    public var code: String?

    public var itemBizList: [QueryItemInSubBizsResponseBody.ItemBizList]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemBizList != nil {
            var tmp : [Any] = []
            for k in self.itemBizList! {
                tmp.append(k.toMap())
            }
            map["ItemBizList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemBizList") && dict["ItemBizList"] != nil {
            var tmp : [QueryItemInSubBizsResponseBody.ItemBizList] = []
            for v in dict["ItemBizList"] as! [Any] {
                var model = QueryItemInSubBizsResponseBody.ItemBizList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemBizList = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryItemInSubBizsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryItemInSubBizsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryItemInSubBizsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryItemInventoryRequest : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var itemId: Int64?

        public var lmItemId: String?

        public var skuIdList: [Int]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.skuIdList != nil {
                map["SkuIdList"] = self.skuIdList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("SkuIdList") && dict["SkuIdList"] != nil {
                self.skuIdList = dict["SkuIdList"] as! [Int]
            }
        }
    }
    public var bizId: String?

    public var divisionCode: String?

    public var ip: String?

    public var itemList: [QueryItemInventoryRequest.ItemList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.divisionCode != nil {
            map["DivisionCode"] = self.divisionCode!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
            self.divisionCode = dict["DivisionCode"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [QueryItemInventoryRequest.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = QueryItemInventoryRequest.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
    }
}

public class QueryItemInventoryResponseBody : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public class SkuList : Tea.TeaModel {
                public class Sku : Tea.TeaModel {
                    public class Inventory : Tea.TeaModel {
                        public var quantity: Int64?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.quantity != nil {
                                map["Quantity"] = self.quantity!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                                self.quantity = dict["Quantity"] as! Int64
                            }
                        }
                    }
                    public var inventory: QueryItemInventoryResponseBody.ItemList.Item.SkuList.Sku.Inventory?

                    public var skuId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.inventory?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.inventory != nil {
                            map["Inventory"] = self.inventory?.toMap()
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Inventory") && dict["Inventory"] != nil {
                            var model = QueryItemInventoryResponseBody.ItemList.Item.SkuList.Sku.Inventory()
                            model.fromMap(dict["Inventory"] as! [String: Any])
                            self.inventory = model
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                    }
                }
                public var sku: [QueryItemInventoryResponseBody.ItemList.Item.SkuList.Sku]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sku != nil {
                        var tmp : [Any] = []
                        for k in self.sku! {
                            tmp.append(k.toMap())
                        }
                        map["Sku"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Sku") && dict["Sku"] != nil {
                        var tmp : [QueryItemInventoryResponseBody.ItemList.Item.SkuList.Sku] = []
                        for v in dict["Sku"] as! [Any] {
                            var model = QueryItemInventoryResponseBody.ItemList.Item.SkuList.Sku()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.sku = tmp
                    }
                }
            }
            public var itemId: Int64?

            public var lmItemId: String?

            public var skuList: QueryItemInventoryResponseBody.ItemList.Item.SkuList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.skuList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.skuList != nil {
                    map["SkuList"] = self.skuList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                    var model = QueryItemInventoryResponseBody.ItemList.Item.SkuList()
                    model.fromMap(dict["SkuList"] as! [String: Any])
                    self.skuList = model
                }
            }
        }
        public var item: [QueryItemInventoryResponseBody.ItemList.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [QueryItemInventoryResponseBody.ItemList.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = QueryItemInventoryResponseBody.ItemList.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var code: String?

    public var itemList: QueryItemInventoryResponseBody.ItemList?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemList != nil {
            map["ItemList"] = self.itemList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var model = QueryItemInventoryResponseBody.ItemList()
            model.fromMap(dict["ItemList"] as! [String: Any])
            self.itemList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryItemInventoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryItemInventoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryItemInventoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryItemInventoryV2Request : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var itemId: Int64?

        public var lmItemId: String?

        public var skuIdList: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.skuIdList != nil {
                map["SkuIdList"] = self.skuIdList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("SkuIdList") && dict["SkuIdList"] != nil {
                self.skuIdList = dict["SkuIdList"] as! [Int64]
            }
        }
    }
    public var bizId: String?

    public var divisionCode: String?

    public var ip: String?

    public var itemList: [QueryItemInventoryV2Request.ItemList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.divisionCode != nil {
            map["DivisionCode"] = self.divisionCode!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
            self.divisionCode = dict["DivisionCode"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [QueryItemInventoryV2Request.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = QueryItemInventoryV2Request.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
    }
}

public class QueryItemInventoryV2ResponseBody : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public class SkuList : Tea.TeaModel {
                public class Sku : Tea.TeaModel {
                    public class Inventory : Tea.TeaModel {
                        public var quantity: Int64?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.quantity != nil {
                                map["Quantity"] = self.quantity!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                                self.quantity = dict["Quantity"] as! Int64
                            }
                        }
                    }
                    public var inventory: QueryItemInventoryV2ResponseBody.ItemList.Item.SkuList.Sku.Inventory?

                    public var skuId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.inventory?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.inventory != nil {
                            map["Inventory"] = self.inventory?.toMap()
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Inventory") && dict["Inventory"] != nil {
                            var model = QueryItemInventoryV2ResponseBody.ItemList.Item.SkuList.Sku.Inventory()
                            model.fromMap(dict["Inventory"] as! [String: Any])
                            self.inventory = model
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                    }
                }
                public var sku: [QueryItemInventoryV2ResponseBody.ItemList.Item.SkuList.Sku]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sku != nil {
                        var tmp : [Any] = []
                        for k in self.sku! {
                            tmp.append(k.toMap())
                        }
                        map["Sku"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Sku") && dict["Sku"] != nil {
                        var tmp : [QueryItemInventoryV2ResponseBody.ItemList.Item.SkuList.Sku] = []
                        for v in dict["Sku"] as! [Any] {
                            var model = QueryItemInventoryV2ResponseBody.ItemList.Item.SkuList.Sku()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.sku = tmp
                    }
                }
            }
            public var itemId: Int64?

            public var lmItemId: String?

            public var skuList: QueryItemInventoryV2ResponseBody.ItemList.Item.SkuList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.skuList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.skuList != nil {
                    map["SkuList"] = self.skuList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("SkuList") && dict["SkuList"] != nil {
                    var model = QueryItemInventoryV2ResponseBody.ItemList.Item.SkuList()
                    model.fromMap(dict["SkuList"] as! [String: Any])
                    self.skuList = model
                }
            }
        }
        public var item: [QueryItemInventoryV2ResponseBody.ItemList.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [QueryItemInventoryV2ResponseBody.ItemList.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = QueryItemInventoryV2ResponseBody.ItemList.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var code: String?

    public var itemList: QueryItemInventoryV2ResponseBody.ItemList?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.itemList != nil {
            map["ItemList"] = self.itemList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var model = QueryItemInventoryV2ResponseBody.ItemList()
            model.fromMap(dict["ItemList"] as! [String: Any])
            self.itemList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryItemInventoryV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryItemInventoryV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryItemInventoryV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryItemNextCycleRestrictionRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmItemId: [String]?

    public var subBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! [String]
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
    }
}

public class QueryItemNextCycleRestrictionShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmItemIdShrink: String?

    public var subBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmItemIdShrink != nil {
            map["LmItemId"] = self.lmItemIdShrink!
        }
        if self.subBizId != nil {
            map["SubBizId"] = self.subBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemIdShrink = dict["LmItemId"] as! String
        }
        if dict.keys.contains("SubBizId") && dict["SubBizId"] != nil {
            self.subBizId = dict["SubBizId"] as! String
        }
    }
}

public class QueryItemNextCycleRestrictionResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var beginTime: Int64?

        public var endTime: Int64?

        public var itemId: Int64?

        public var lmItemId: String?

        public var quantity: Int32?

        public var restrictionQuantity: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginTime != nil {
                map["BeginTime"] = self.beginTime!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.restrictionQuantity != nil {
                map["RestrictionQuantity"] = self.restrictionQuantity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeginTime") && dict["BeginTime"] != nil {
                self.beginTime = dict["BeginTime"] as! Int64
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("RestrictionQuantity") && dict["RestrictionQuantity"] != nil {
                self.restrictionQuantity = dict["RestrictionQuantity"] as! Int32
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: [QueryItemNextCycleRestrictionResponseBody.Model]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [QueryItemNextCycleRestrictionResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = QueryItemNextCycleRestrictionResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryItemNextCycleRestrictionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryItemNextCycleRestrictionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryItemNextCycleRestrictionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLogisticsRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var lmOrderId: Int64?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryLogisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class Goods : Tea.TeaModel {
                public class Goods : Tea.TeaModel {
                    public var goodName: String?

                    public var itemId: Int64?

                    public var quantity: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.goodName != nil {
                            map["GoodName"] = self.goodName!
                        }
                        if self.itemId != nil {
                            map["ItemId"] = self.itemId!
                        }
                        if self.quantity != nil {
                            map["Quantity"] = self.quantity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("GoodName") && dict["GoodName"] != nil {
                            self.goodName = dict["GoodName"] as! String
                        }
                        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                            self.itemId = dict["ItemId"] as! Int64
                        }
                        if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                            self.quantity = dict["Quantity"] as! Int32
                        }
                    }
                }
                public var goods: [QueryLogisticsResponseBody.Data.Data.Goods.Goods]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.goods != nil {
                        var tmp : [Any] = []
                        for k in self.goods! {
                            tmp.append(k.toMap())
                        }
                        map["Goods"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Goods") && dict["Goods"] != nil {
                        var tmp : [QueryLogisticsResponseBody.Data.Data.Goods.Goods] = []
                        for v in dict["Goods"] as! [Any] {
                            var model = QueryLogisticsResponseBody.Data.Data.Goods.Goods()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.goods = tmp
                    }
                }
            }
            public class LogisticsDetailList : Tea.TeaModel {
                public class LogisticsDetailList : Tea.TeaModel {
                    public var ocurrTimeStr: String?

                    public var standerdDesc: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ocurrTimeStr != nil {
                            map["OcurrTimeStr"] = self.ocurrTimeStr!
                        }
                        if self.standerdDesc != nil {
                            map["StanderdDesc"] = self.standerdDesc!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OcurrTimeStr") && dict["OcurrTimeStr"] != nil {
                            self.ocurrTimeStr = dict["OcurrTimeStr"] as! String
                        }
                        if dict.keys.contains("StanderdDesc") && dict["StanderdDesc"] != nil {
                            self.standerdDesc = dict["StanderdDesc"] as! String
                        }
                    }
                }
                public var logisticsDetailList: [QueryLogisticsResponseBody.Data.Data.LogisticsDetailList.LogisticsDetailList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logisticsDetailList != nil {
                        var tmp : [Any] = []
                        for k in self.logisticsDetailList! {
                            tmp.append(k.toMap())
                        }
                        map["LogisticsDetailList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LogisticsDetailList") && dict["LogisticsDetailList"] != nil {
                        var tmp : [QueryLogisticsResponseBody.Data.Data.LogisticsDetailList.LogisticsDetailList] = []
                        for v in dict["LogisticsDetailList"] as! [Any] {
                            var model = QueryLogisticsResponseBody.Data.Data.LogisticsDetailList.LogisticsDetailList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.logisticsDetailList = tmp
                    }
                }
            }
            public var dataProvider: String?

            public var dataProviderTitle: String?

            public var goods: QueryLogisticsResponseBody.Data.Data.Goods?

            public var logisticsCompanyCode: String?

            public var logisticsCompanyName: String?

            public var logisticsDetailList: QueryLogisticsResponseBody.Data.Data.LogisticsDetailList?

            public var mailNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.goods?.validate()
                try self.logisticsDetailList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataProvider != nil {
                    map["DataProvider"] = self.dataProvider!
                }
                if self.dataProviderTitle != nil {
                    map["DataProviderTitle"] = self.dataProviderTitle!
                }
                if self.goods != nil {
                    map["Goods"] = self.goods?.toMap()
                }
                if self.logisticsCompanyCode != nil {
                    map["LogisticsCompanyCode"] = self.logisticsCompanyCode!
                }
                if self.logisticsCompanyName != nil {
                    map["LogisticsCompanyName"] = self.logisticsCompanyName!
                }
                if self.logisticsDetailList != nil {
                    map["LogisticsDetailList"] = self.logisticsDetailList?.toMap()
                }
                if self.mailNo != nil {
                    map["MailNo"] = self.mailNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataProvider") && dict["DataProvider"] != nil {
                    self.dataProvider = dict["DataProvider"] as! String
                }
                if dict.keys.contains("DataProviderTitle") && dict["DataProviderTitle"] != nil {
                    self.dataProviderTitle = dict["DataProviderTitle"] as! String
                }
                if dict.keys.contains("Goods") && dict["Goods"] != nil {
                    var model = QueryLogisticsResponseBody.Data.Data.Goods()
                    model.fromMap(dict["Goods"] as! [String: Any])
                    self.goods = model
                }
                if dict.keys.contains("LogisticsCompanyCode") && dict["LogisticsCompanyCode"] != nil {
                    self.logisticsCompanyCode = dict["LogisticsCompanyCode"] as! String
                }
                if dict.keys.contains("LogisticsCompanyName") && dict["LogisticsCompanyName"] != nil {
                    self.logisticsCompanyName = dict["LogisticsCompanyName"] as! String
                }
                if dict.keys.contains("LogisticsDetailList") && dict["LogisticsDetailList"] != nil {
                    var model = QueryLogisticsResponseBody.Data.Data.LogisticsDetailList()
                    model.fromMap(dict["LogisticsDetailList"] as! [String: Any])
                    self.logisticsDetailList = model
                }
                if dict.keys.contains("MailNo") && dict["MailNo"] != nil {
                    self.mailNo = dict["MailNo"] as! String
                }
            }
        }
        public var data: [QueryLogisticsResponseBody.Data.Data]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var tmp : [QueryLogisticsResponseBody.Data.Data] = []
                for v in dict["Data"] as! [Any] {
                    var model = QueryLogisticsResponseBody.Data.Data()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.data = tmp
            }
        }
    }
    public var code: String?

    public var data: QueryLogisticsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryLogisticsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryLogisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLogisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryLogisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaSettleInfoRequest : Tea.TeaModel {
    public var bizId: String?

    public var channelId: String?

    public var endTime: String?

    public var extInfo: String?

    public var mediaName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var settleNo: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.mediaName != nil {
            map["MediaName"] = self.mediaName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.settleNo != nil {
            map["SettleNo"] = self.settleNo!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("MediaName") && dict["MediaName"] != nil {
            self.mediaName = dict["MediaName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SettleNo") && dict["SettleNo"] != nil {
            self.settleNo = dict["SettleNo"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class QueryMediaSettleInfoResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class MediaSettleInfoList : Tea.TeaModel {
            public var channelId: String?

            public var createDate: String?

            public var endTime: String?

            public var extInfo: String?

            public var mediaName: String?

            public var mediaSettleAmount: String?

            public var mediaSettleDetailId: String?

            public var modifiedDate: String?

            public var settleNo: String?

            public var settleStatus: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.createDate != nil {
                    map["CreateDate"] = self.createDate!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.extInfo != nil {
                    map["ExtInfo"] = self.extInfo!
                }
                if self.mediaName != nil {
                    map["MediaName"] = self.mediaName!
                }
                if self.mediaSettleAmount != nil {
                    map["MediaSettleAmount"] = self.mediaSettleAmount!
                }
                if self.mediaSettleDetailId != nil {
                    map["MediaSettleDetailId"] = self.mediaSettleDetailId!
                }
                if self.modifiedDate != nil {
                    map["ModifiedDate"] = self.modifiedDate!
                }
                if self.settleNo != nil {
                    map["SettleNo"] = self.settleNo!
                }
                if self.settleStatus != nil {
                    map["SettleStatus"] = self.settleStatus!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                    self.channelId = dict["ChannelId"] as! String
                }
                if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                    self.createDate = dict["CreateDate"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                    self.extInfo = dict["ExtInfo"] as! String
                }
                if dict.keys.contains("MediaName") && dict["MediaName"] != nil {
                    self.mediaName = dict["MediaName"] as! String
                }
                if dict.keys.contains("MediaSettleAmount") && dict["MediaSettleAmount"] != nil {
                    self.mediaSettleAmount = dict["MediaSettleAmount"] as! String
                }
                if dict.keys.contains("MediaSettleDetailId") && dict["MediaSettleDetailId"] != nil {
                    self.mediaSettleDetailId = dict["MediaSettleDetailId"] as! String
                }
                if dict.keys.contains("ModifiedDate") && dict["ModifiedDate"] != nil {
                    self.modifiedDate = dict["ModifiedDate"] as! String
                }
                if dict.keys.contains("SettleNo") && dict["SettleNo"] != nil {
                    self.settleNo = dict["SettleNo"] as! String
                }
                if dict.keys.contains("SettleStatus") && dict["SettleStatus"] != nil {
                    self.settleStatus = dict["SettleStatus"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var mediaSettleInfoList: [QueryMediaSettleInfoResponseBody.Model.MediaSettleInfoList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaSettleInfoList != nil {
                var tmp : [Any] = []
                for k in self.mediaSettleInfoList! {
                    tmp.append(k.toMap())
                }
                map["MediaSettleInfoList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaSettleInfoList") && dict["MediaSettleInfoList"] != nil {
                var tmp : [QueryMediaSettleInfoResponseBody.Model.MediaSettleInfoList] = []
                for v in dict["MediaSettleInfoList"] as! [Any] {
                    var model = QueryMediaSettleInfoResponseBody.Model.MediaSettleInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaSettleInfoList = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: QueryMediaSettleInfoResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryMediaSettleInfoResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryMediaSettleInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaSettleInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMediaSettleInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMessagesRequest : Tea.TeaModel {
    public var bizId: String?

    public var extJson: String?

    public var topic: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.topic != nil {
            map["Topic"] = self.topic!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("Topic") && dict["Topic"] != nil {
            self.topic = dict["Topic"] as! String
        }
    }
}

public class QueryMessagesResponseBody : Tea.TeaModel {
    public class BizMessages : Tea.TeaModel {
        public class BizMessage : Tea.TeaModel {
            public var contentMapJson: String?

            public var dataId: Int64?

            public var pubTime: String?

            public var topic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentMapJson != nil {
                    map["ContentMapJson"] = self.contentMapJson!
                }
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.pubTime != nil {
                    map["PubTime"] = self.pubTime!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentMapJson") && dict["ContentMapJson"] != nil {
                    self.contentMapJson = dict["ContentMapJson"] as! String
                }
                if dict.keys.contains("DataId") && dict["DataId"] != nil {
                    self.dataId = dict["DataId"] as! Int64
                }
                if dict.keys.contains("PubTime") && dict["PubTime"] != nil {
                    self.pubTime = dict["PubTime"] as! String
                }
                if dict.keys.contains("Topic") && dict["Topic"] != nil {
                    self.topic = dict["Topic"] as! String
                }
            }
        }
        public var bizMessage: [QueryMessagesResponseBody.BizMessages.BizMessage]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizMessage != nil {
                var tmp : [Any] = []
                for k in self.bizMessage! {
                    tmp.append(k.toMap())
                }
                map["BizMessage"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizMessage") && dict["BizMessage"] != nil {
                var tmp : [QueryMessagesResponseBody.BizMessages.BizMessage] = []
                for v in dict["BizMessage"] as! [Any] {
                    var model = QueryMessagesResponseBody.BizMessages.BizMessage()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bizMessage = tmp
            }
        }
    }
    public var bizMessages: QueryMessagesResponseBody.BizMessages?

    public var code: String?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bizMessages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizMessages != nil {
            map["BizMessages"] = self.bizMessages?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizMessages") && dict["BizMessages"] != nil {
            var model = QueryMessagesResponseBody.BizMessages()
            model.fromMap(dict["BizMessages"] as! [String: Any])
            self.bizMessages = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMessagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMessagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMessagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMovieCommentsRequest : Tea.TeaModel {
    public var bizId: String?

    public var extJson: String?

    public var movieId: Int64?

    public var pageNumber: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.movieId != nil {
            map["MovieId"] = self.movieId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("MovieId") && dict["MovieId"] != nil {
            self.movieId = dict["MovieId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
    }
}

public class QueryMovieCommentsResponseBody : Tea.TeaModel {
    public class CommentList : Tea.TeaModel {
        public class Comment : Tea.TeaModel {
            public var commentTime: String?

            public var content: String?

            public var favorCount: Int64?

            public var id: Int64?

            public var movieId: Int64?

            public var nickName: String?

            public var remark: Int64?

            public var subject: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commentTime != nil {
                    map["CommentTime"] = self.commentTime!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.favorCount != nil {
                    map["FavorCount"] = self.favorCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.movieId != nil {
                    map["MovieId"] = self.movieId!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.subject != nil {
                    map["Subject"] = self.subject!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CommentTime") && dict["CommentTime"] != nil {
                    self.commentTime = dict["CommentTime"] as! String
                }
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("FavorCount") && dict["FavorCount"] != nil {
                    self.favorCount = dict["FavorCount"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MovieId") && dict["MovieId"] != nil {
                    self.movieId = dict["MovieId"] as! Int64
                }
                if dict.keys.contains("NickName") && dict["NickName"] != nil {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("Remark") && dict["Remark"] != nil {
                    self.remark = dict["Remark"] as! Int64
                }
                if dict.keys.contains("Subject") && dict["Subject"] != nil {
                    self.subject = dict["Subject"] as! String
                }
            }
        }
        public var comment: [QueryMovieCommentsResponseBody.CommentList.Comment]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                var tmp : [Any] = []
                for k in self.comment! {
                    tmp.append(k.toMap())
                }
                map["Comment"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                var tmp : [QueryMovieCommentsResponseBody.CommentList.Comment] = []
                for v in dict["Comment"] as! [Any] {
                    var model = QueryMovieCommentsResponseBody.CommentList.Comment()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.comment = tmp
            }
        }
    }
    public var code: String?

    public var commentList: QueryMovieCommentsResponseBody.CommentList?

    public var count: Int64?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commentList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.commentList != nil {
            map["CommentList"] = self.commentList?.toMap()
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CommentList") && dict["CommentList"] != nil {
            var model = QueryMovieCommentsResponseBody.CommentList()
            model.fromMap(dict["CommentList"] as! [String: Any])
            self.commentList = model
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int64
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMovieCommentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMovieCommentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMovieCommentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMovieSchedulesRequest : Tea.TeaModel {
    public var bizId: String?

    public var cinemaId: Int64?

    public var extJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.cinemaId != nil {
            map["CinemaId"] = self.cinemaId!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CinemaId") && dict["CinemaId"] != nil {
            self.cinemaId = dict["CinemaId"] as! Int64
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
    }
}

public class QueryMovieSchedulesResponseBody : Tea.TeaModel {
    public class Schedules : Tea.TeaModel {
        public class Schedule : Tea.TeaModel {
            public var cinemaId: Int64?

            public var hallName: String?

            public var id: Int64?

            public var isExpired: Bool?

            public var maxCanBuy: Int64?

            public var movieId: Int64?

            public var movieVersion: String?

            public var price: Int64?

            public var releaseDate: String?

            public var scheduleArea: String?

            public var sectionId: String?

            public var serviceFee: Int64?

            public var sessionEndingTime: String?

            public var sessionStartingTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cinemaId != nil {
                    map["CinemaId"] = self.cinemaId!
                }
                if self.hallName != nil {
                    map["HallName"] = self.hallName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isExpired != nil {
                    map["IsExpired"] = self.isExpired!
                }
                if self.maxCanBuy != nil {
                    map["MaxCanBuy"] = self.maxCanBuy!
                }
                if self.movieId != nil {
                    map["MovieId"] = self.movieId!
                }
                if self.movieVersion != nil {
                    map["MovieVersion"] = self.movieVersion!
                }
                if self.price != nil {
                    map["Price"] = self.price!
                }
                if self.releaseDate != nil {
                    map["ReleaseDate"] = self.releaseDate!
                }
                if self.scheduleArea != nil {
                    map["ScheduleArea"] = self.scheduleArea!
                }
                if self.sectionId != nil {
                    map["SectionId"] = self.sectionId!
                }
                if self.serviceFee != nil {
                    map["ServiceFee"] = self.serviceFee!
                }
                if self.sessionEndingTime != nil {
                    map["SessionEndingTime"] = self.sessionEndingTime!
                }
                if self.sessionStartingTime != nil {
                    map["SessionStartingTime"] = self.sessionStartingTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CinemaId") && dict["CinemaId"] != nil {
                    self.cinemaId = dict["CinemaId"] as! Int64
                }
                if dict.keys.contains("HallName") && dict["HallName"] != nil {
                    self.hallName = dict["HallName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsExpired") && dict["IsExpired"] != nil {
                    self.isExpired = dict["IsExpired"] as! Bool
                }
                if dict.keys.contains("MaxCanBuy") && dict["MaxCanBuy"] != nil {
                    self.maxCanBuy = dict["MaxCanBuy"] as! Int64
                }
                if dict.keys.contains("MovieId") && dict["MovieId"] != nil {
                    self.movieId = dict["MovieId"] as! Int64
                }
                if dict.keys.contains("MovieVersion") && dict["MovieVersion"] != nil {
                    self.movieVersion = dict["MovieVersion"] as! String
                }
                if dict.keys.contains("Price") && dict["Price"] != nil {
                    self.price = dict["Price"] as! Int64
                }
                if dict.keys.contains("ReleaseDate") && dict["ReleaseDate"] != nil {
                    self.releaseDate = dict["ReleaseDate"] as! String
                }
                if dict.keys.contains("ScheduleArea") && dict["ScheduleArea"] != nil {
                    self.scheduleArea = dict["ScheduleArea"] as! String
                }
                if dict.keys.contains("SectionId") && dict["SectionId"] != nil {
                    self.sectionId = dict["SectionId"] as! String
                }
                if dict.keys.contains("ServiceFee") && dict["ServiceFee"] != nil {
                    self.serviceFee = dict["ServiceFee"] as! Int64
                }
                if dict.keys.contains("SessionEndingTime") && dict["SessionEndingTime"] != nil {
                    self.sessionEndingTime = dict["SessionEndingTime"] as! String
                }
                if dict.keys.contains("SessionStartingTime") && dict["SessionStartingTime"] != nil {
                    self.sessionStartingTime = dict["SessionStartingTime"] as! String
                }
            }
        }
        public var schedule: [QueryMovieSchedulesResponseBody.Schedules.Schedule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schedule != nil {
                var tmp : [Any] = []
                for k in self.schedule! {
                    tmp.append(k.toMap())
                }
                map["Schedule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Schedule") && dict["Schedule"] != nil {
                var tmp : [QueryMovieSchedulesResponseBody.Schedules.Schedule] = []
                for v in dict["Schedule"] as! [Any] {
                    var model = QueryMovieSchedulesResponseBody.Schedules.Schedule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schedule = tmp
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var schedules: QueryMovieSchedulesResponseBody.Schedules?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.schedules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schedules != nil {
            map["Schedules"] = self.schedules?.toMap()
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Schedules") && dict["Schedules"] != nil {
            var model = QueryMovieSchedulesResponseBody.Schedules()
            model.fromMap(dict["Schedules"] as! [String: Any])
            self.schedules = model
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMovieSchedulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMovieSchedulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMovieSchedulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMovieSeatsRequest : Tea.TeaModel {
    public var bizId: String?

    public var extJson: String?

    public var scheduleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.scheduleId != nil {
            map["ScheduleId"] = self.scheduleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("ScheduleId") && dict["ScheduleId"] != nil {
            self.scheduleId = dict["ScheduleId"] as! Int64
        }
    }
}

public class QueryMovieSeatsResponseBody : Tea.TeaModel {
    public class SeatMap : Tea.TeaModel {
        public class Seats : Tea.TeaModel {
            public class Seat : Tea.TeaModel {
                public var area: String?

                public var column: Int64?

                public var extId: String?

                public var flag: Int64?

                public var leftPx: Int64?

                public var name: String?

                public var row: Int64?

                public var rowName: String?

                public var status: Int64?

                public var topPx: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.area != nil {
                        map["Area"] = self.area!
                    }
                    if self.column != nil {
                        map["Column"] = self.column!
                    }
                    if self.extId != nil {
                        map["ExtId"] = self.extId!
                    }
                    if self.flag != nil {
                        map["Flag"] = self.flag!
                    }
                    if self.leftPx != nil {
                        map["LeftPx"] = self.leftPx!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.row != nil {
                        map["Row"] = self.row!
                    }
                    if self.rowName != nil {
                        map["RowName"] = self.rowName!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.topPx != nil {
                        map["TopPx"] = self.topPx!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Area") && dict["Area"] != nil {
                        self.area = dict["Area"] as! String
                    }
                    if dict.keys.contains("Column") && dict["Column"] != nil {
                        self.column = dict["Column"] as! Int64
                    }
                    if dict.keys.contains("ExtId") && dict["ExtId"] != nil {
                        self.extId = dict["ExtId"] as! String
                    }
                    if dict.keys.contains("Flag") && dict["Flag"] != nil {
                        self.flag = dict["Flag"] as! Int64
                    }
                    if dict.keys.contains("LeftPx") && dict["LeftPx"] != nil {
                        self.leftPx = dict["LeftPx"] as! Int64
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Row") && dict["Row"] != nil {
                        self.row = dict["Row"] as! Int64
                    }
                    if dict.keys.contains("RowName") && dict["RowName"] != nil {
                        self.rowName = dict["RowName"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! Int64
                    }
                    if dict.keys.contains("TopPx") && dict["TopPx"] != nil {
                        self.topPx = dict["TopPx"] as! Int64
                    }
                }
            }
            public var seat: [QueryMovieSeatsResponseBody.SeatMap.Seats.Seat]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.seat != nil {
                    var tmp : [Any] = []
                    for k in self.seat! {
                        tmp.append(k.toMap())
                    }
                    map["Seat"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Seat") && dict["Seat"] != nil {
                    var tmp : [QueryMovieSeatsResponseBody.SeatMap.Seats.Seat] = []
                    for v in dict["Seat"] as! [Any] {
                        var model = QueryMovieSeatsResponseBody.SeatMap.Seats.Seat()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.seat = tmp
                }
            }
        }
        public var maxCanBuy: Int64?

        public var maxColumn: Int64?

        public var maxLeftPx: Int64?

        public var maxRow: Int64?

        public var maxTopPx: Int64?

        public var minColumn: Int64?

        public var minLeftPx: Int64?

        public var minRow: Int64?

        public var minTopPx: Int64?

        public var notice: String?

        public var regular: Bool?

        public var seatCount: Int64?

        public var seats: QueryMovieSeatsResponseBody.SeatMap.Seats?

        public var soldCount: Int64?

        public var tipMessage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.seats?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxCanBuy != nil {
                map["MaxCanBuy"] = self.maxCanBuy!
            }
            if self.maxColumn != nil {
                map["MaxColumn"] = self.maxColumn!
            }
            if self.maxLeftPx != nil {
                map["MaxLeftPx"] = self.maxLeftPx!
            }
            if self.maxRow != nil {
                map["MaxRow"] = self.maxRow!
            }
            if self.maxTopPx != nil {
                map["MaxTopPx"] = self.maxTopPx!
            }
            if self.minColumn != nil {
                map["MinColumn"] = self.minColumn!
            }
            if self.minLeftPx != nil {
                map["MinLeftPx"] = self.minLeftPx!
            }
            if self.minRow != nil {
                map["MinRow"] = self.minRow!
            }
            if self.minTopPx != nil {
                map["MinTopPx"] = self.minTopPx!
            }
            if self.notice != nil {
                map["Notice"] = self.notice!
            }
            if self.regular != nil {
                map["Regular"] = self.regular!
            }
            if self.seatCount != nil {
                map["SeatCount"] = self.seatCount!
            }
            if self.seats != nil {
                map["Seats"] = self.seats?.toMap()
            }
            if self.soldCount != nil {
                map["SoldCount"] = self.soldCount!
            }
            if self.tipMessage != nil {
                map["TipMessage"] = self.tipMessage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaxCanBuy") && dict["MaxCanBuy"] != nil {
                self.maxCanBuy = dict["MaxCanBuy"] as! Int64
            }
            if dict.keys.contains("MaxColumn") && dict["MaxColumn"] != nil {
                self.maxColumn = dict["MaxColumn"] as! Int64
            }
            if dict.keys.contains("MaxLeftPx") && dict["MaxLeftPx"] != nil {
                self.maxLeftPx = dict["MaxLeftPx"] as! Int64
            }
            if dict.keys.contains("MaxRow") && dict["MaxRow"] != nil {
                self.maxRow = dict["MaxRow"] as! Int64
            }
            if dict.keys.contains("MaxTopPx") && dict["MaxTopPx"] != nil {
                self.maxTopPx = dict["MaxTopPx"] as! Int64
            }
            if dict.keys.contains("MinColumn") && dict["MinColumn"] != nil {
                self.minColumn = dict["MinColumn"] as! Int64
            }
            if dict.keys.contains("MinLeftPx") && dict["MinLeftPx"] != nil {
                self.minLeftPx = dict["MinLeftPx"] as! Int64
            }
            if dict.keys.contains("MinRow") && dict["MinRow"] != nil {
                self.minRow = dict["MinRow"] as! Int64
            }
            if dict.keys.contains("MinTopPx") && dict["MinTopPx"] != nil {
                self.minTopPx = dict["MinTopPx"] as! Int64
            }
            if dict.keys.contains("Notice") && dict["Notice"] != nil {
                self.notice = dict["Notice"] as! String
            }
            if dict.keys.contains("Regular") && dict["Regular"] != nil {
                self.regular = dict["Regular"] as! Bool
            }
            if dict.keys.contains("SeatCount") && dict["SeatCount"] != nil {
                self.seatCount = dict["SeatCount"] as! Int64
            }
            if dict.keys.contains("Seats") && dict["Seats"] != nil {
                var model = QueryMovieSeatsResponseBody.SeatMap.Seats()
                model.fromMap(dict["Seats"] as! [String: Any])
                self.seats = model
            }
            if dict.keys.contains("SoldCount") && dict["SoldCount"] != nil {
                self.soldCount = dict["SoldCount"] as! Int64
            }
            if dict.keys.contains("TipMessage") && dict["TipMessage"] != nil {
                self.tipMessage = dict["TipMessage"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var seatMap: QueryMovieSeatsResponseBody.SeatMap?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.seatMap?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.seatMap != nil {
            map["SeatMap"] = self.seatMap?.toMap()
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SeatMap") && dict["SeatMap"] != nil {
            var model = QueryMovieSeatsResponseBody.SeatMap()
            model.fromMap(dict["SeatMap"] as! [String: Any])
            self.seatMap = model
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMovieSeatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMovieSeatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMovieSeatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMovieTicketsRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var extJson: String?

    public var orderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
    }
}

public class QueryMovieTicketsResponseBody : Tea.TeaModel {
    public class MovieTicket : Tea.TeaModel {
        public var returnMessage: String?

        public var status: String?

        public var tbOrderId: String?

        public var ticketContents: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.returnMessage != nil {
                map["ReturnMessage"] = self.returnMessage!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tbOrderId != nil {
                map["TbOrderId"] = self.tbOrderId!
            }
            if self.ticketContents != nil {
                map["TicketContents"] = self.ticketContents!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReturnMessage") && dict["ReturnMessage"] != nil {
                self.returnMessage = dict["ReturnMessage"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                self.tbOrderId = dict["TbOrderId"] as! String
            }
            if dict.keys.contains("TicketContents") && dict["TicketContents"] != nil {
                self.ticketContents = dict["TicketContents"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var movieTicket: QueryMovieTicketsResponseBody.MovieTicket?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.movieTicket?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.movieTicket != nil {
            map["MovieTicket"] = self.movieTicket?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("MovieTicket") && dict["MovieTicket"] != nil {
            var model = QueryMovieTicketsResponseBody.MovieTicket()
            model.fromMap(dict["MovieTicket"] as! [String: Any])
            self.movieTicket = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMovieTicketsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMovieTicketsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMovieTicketsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderAndPaymentListRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var filterOption: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.filterOption != nil {
            map["FilterOption"] = self.filterOption!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("FilterOption") && dict["FilterOption"] != nil {
            self.filterOption = dict["FilterOption"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryOrderAndPaymentListResponseBody : Tea.TeaModel {
    public class LmOrderList : Tea.TeaModel {
        public class LmOrderList : Tea.TeaModel {
            public class FundStructureModels : Tea.TeaModel {
                public class FundStructureModels : Tea.TeaModel {
                    public var fundAmount: Int64?

                    public var fundAmountMoney: Int64?

                    public var fundType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fundAmount != nil {
                            map["FundAmount"] = self.fundAmount!
                        }
                        if self.fundAmountMoney != nil {
                            map["FundAmountMoney"] = self.fundAmountMoney!
                        }
                        if self.fundType != nil {
                            map["FundType"] = self.fundType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                            self.fundAmount = dict["FundAmount"] as! Int64
                        }
                        if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                            self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                        }
                        if dict.keys.contains("FundType") && dict["FundType"] != nil {
                            self.fundType = dict["FundType"] as! String
                        }
                    }
                }
                public var fundStructureModels: [QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.FundStructureModels.FundStructureModels]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fundStructureModels != nil {
                        var tmp : [Any] = []
                        for k in self.fundStructureModels! {
                            tmp.append(k.toMap())
                        }
                        map["FundStructureModels"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FundStructureModels") && dict["FundStructureModels"] != nil {
                        var tmp : [QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.FundStructureModels.FundStructureModels] = []
                        for v in dict["FundStructureModels"] as! [Any] {
                            var model = QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.FundStructureModels.FundStructureModels()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.fundStructureModels = tmp
                    }
                }
            }
            public class PostFee : Tea.TeaModel {
                public var fundAmount: Int64?

                public var fundAmountMoney: Int64?

                public var fundType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fundAmount != nil {
                        map["FundAmount"] = self.fundAmount!
                    }
                    if self.fundAmountMoney != nil {
                        map["FundAmountMoney"] = self.fundAmountMoney!
                    }
                    if self.fundType != nil {
                        map["FundType"] = self.fundType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                        self.fundAmount = dict["FundAmount"] as! Int64
                    }
                    if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                        self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                    }
                    if dict.keys.contains("FundType") && dict["FundType"] != nil {
                        self.fundType = dict["FundType"] as! String
                    }
                }
            }
            public class SubOrderList : Tea.TeaModel {
                public class SubOrderList : Tea.TeaModel {
                    public class ItemPriceList : Tea.TeaModel {
                        public class ItemPriceList : Tea.TeaModel {
                            public var fundAmount: Int64?

                            public var fundAmountMoney: Int64?

                            public var fundType: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.fundAmount != nil {
                                    map["FundAmount"] = self.fundAmount!
                                }
                                if self.fundAmountMoney != nil {
                                    map["FundAmountMoney"] = self.fundAmountMoney!
                                }
                                if self.fundType != nil {
                                    map["FundType"] = self.fundType!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                                    self.fundAmount = dict["FundAmount"] as! Int64
                                }
                                if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                                    self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                                }
                                if dict.keys.contains("FundType") && dict["FundType"] != nil {
                                    self.fundType = dict["FundType"] as! String
                                }
                            }
                        }
                        public var itemPriceList: [QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList.ItemPriceList]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.itemPriceList != nil {
                                var tmp : [Any] = []
                                for k in self.itemPriceList! {
                                    tmp.append(k.toMap())
                                }
                                map["ItemPriceList"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ItemPriceList") && dict["ItemPriceList"] != nil {
                                var tmp : [QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList.ItemPriceList] = []
                                for v in dict["ItemPriceList"] as! [Any] {
                                    var model = QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList.ItemPriceList()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.itemPriceList = tmp
                            }
                        }
                    }
                    public var enableStatus: Int32?

                    public var itemId: Int64?

                    public var itemPic: String?

                    public var itemPriceList: QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList?

                    public var itemTitle: String?

                    public var lmItemId: String?

                    public var lmOrderId: Int64?

                    public var number: Int64?

                    public var orderStatus: Int32?

                    public var skuId: Int64?

                    public var skuName: String?

                    public var tbOrderId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.itemPriceList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.itemId != nil {
                            map["ItemId"] = self.itemId!
                        }
                        if self.itemPic != nil {
                            map["ItemPic"] = self.itemPic!
                        }
                        if self.itemPriceList != nil {
                            map["ItemPriceList"] = self.itemPriceList?.toMap()
                        }
                        if self.itemTitle != nil {
                            map["ItemTitle"] = self.itemTitle!
                        }
                        if self.lmItemId != nil {
                            map["LmItemId"] = self.lmItemId!
                        }
                        if self.lmOrderId != nil {
                            map["LmOrderId"] = self.lmOrderId!
                        }
                        if self.number != nil {
                            map["Number"] = self.number!
                        }
                        if self.orderStatus != nil {
                            map["OrderStatus"] = self.orderStatus!
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        if self.skuName != nil {
                            map["SkuName"] = self.skuName!
                        }
                        if self.tbOrderId != nil {
                            map["TbOrderId"] = self.tbOrderId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                            self.enableStatus = dict["EnableStatus"] as! Int32
                        }
                        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                            self.itemId = dict["ItemId"] as! Int64
                        }
                        if dict.keys.contains("ItemPic") && dict["ItemPic"] != nil {
                            self.itemPic = dict["ItemPic"] as! String
                        }
                        if dict.keys.contains("ItemPriceList") && dict["ItemPriceList"] != nil {
                            var model = QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList()
                            model.fromMap(dict["ItemPriceList"] as! [String: Any])
                            self.itemPriceList = model
                        }
                        if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                            self.itemTitle = dict["ItemTitle"] as! String
                        }
                        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                            self.lmItemId = dict["LmItemId"] as! String
                        }
                        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                            self.lmOrderId = dict["LmOrderId"] as! Int64
                        }
                        if dict.keys.contains("Number") && dict["Number"] != nil {
                            self.number = dict["Number"] as! Int64
                        }
                        if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
                            self.orderStatus = dict["OrderStatus"] as! Int32
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                        if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                            self.skuName = dict["SkuName"] as! String
                        }
                        if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                            self.tbOrderId = dict["TbOrderId"] as! Int64
                        }
                    }
                }
                public var subOrderList: [QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.subOrderList != nil {
                        var tmp : [Any] = []
                        for k in self.subOrderList! {
                            tmp.append(k.toMap())
                        }
                        map["SubOrderList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SubOrderList") && dict["SubOrderList"] != nil {
                        var tmp : [QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList] = []
                        for v in dict["SubOrderList"] as! [Any] {
                            var model = QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subOrderList = tmp
                    }
                }
            }
            public var createDate: String?

            public var enableStatus: Int32?

            public var extJson: String?

            public var fundStructureModels: QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.FundStructureModels?

            public var lmOrderId: Int64?

            public var lmPaymentId: String?

            public var logisticsStatus: Int32?

            public var orderAmount: Int64?

            public var orderStatus: Int32?

            public var postFee: QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.PostFee?

            public var shopName: String?

            public var subOrderList: QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList?

            public var tbOrderId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fundStructureModels?.validate()
                try self.postFee?.validate()
                try self.subOrderList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createDate != nil {
                    map["CreateDate"] = self.createDate!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.extJson != nil {
                    map["ExtJson"] = self.extJson!
                }
                if self.fundStructureModels != nil {
                    map["FundStructureModels"] = self.fundStructureModels?.toMap()
                }
                if self.lmOrderId != nil {
                    map["LmOrderId"] = self.lmOrderId!
                }
                if self.lmPaymentId != nil {
                    map["LmPaymentId"] = self.lmPaymentId!
                }
                if self.logisticsStatus != nil {
                    map["LogisticsStatus"] = self.logisticsStatus!
                }
                if self.orderAmount != nil {
                    map["OrderAmount"] = self.orderAmount!
                }
                if self.orderStatus != nil {
                    map["OrderStatus"] = self.orderStatus!
                }
                if self.postFee != nil {
                    map["PostFee"] = self.postFee?.toMap()
                }
                if self.shopName != nil {
                    map["ShopName"] = self.shopName!
                }
                if self.subOrderList != nil {
                    map["SubOrderList"] = self.subOrderList?.toMap()
                }
                if self.tbOrderId != nil {
                    map["TbOrderId"] = self.tbOrderId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                    self.createDate = dict["CreateDate"] as! String
                }
                if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                    self.enableStatus = dict["EnableStatus"] as! Int32
                }
                if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                    self.extJson = dict["ExtJson"] as! String
                }
                if dict.keys.contains("FundStructureModels") && dict["FundStructureModels"] != nil {
                    var model = QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.FundStructureModels()
                    model.fromMap(dict["FundStructureModels"] as! [String: Any])
                    self.fundStructureModels = model
                }
                if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                    self.lmOrderId = dict["LmOrderId"] as! Int64
                }
                if dict.keys.contains("LmPaymentId") && dict["LmPaymentId"] != nil {
                    self.lmPaymentId = dict["LmPaymentId"] as! String
                }
                if dict.keys.contains("LogisticsStatus") && dict["LogisticsStatus"] != nil {
                    self.logisticsStatus = dict["LogisticsStatus"] as! Int32
                }
                if dict.keys.contains("OrderAmount") && dict["OrderAmount"] != nil {
                    self.orderAmount = dict["OrderAmount"] as! Int64
                }
                if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
                    self.orderStatus = dict["OrderStatus"] as! Int32
                }
                if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
                    var model = QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.PostFee()
                    model.fromMap(dict["PostFee"] as! [String: Any])
                    self.postFee = model
                }
                if dict.keys.contains("ShopName") && dict["ShopName"] != nil {
                    self.shopName = dict["ShopName"] as! String
                }
                if dict.keys.contains("SubOrderList") && dict["SubOrderList"] != nil {
                    var model = QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList.SubOrderList()
                    model.fromMap(dict["SubOrderList"] as! [String: Any])
                    self.subOrderList = model
                }
                if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                    self.tbOrderId = dict["TbOrderId"] as! Int64
                }
            }
        }
        public var lmOrderList: [QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderList != nil {
                var tmp : [Any] = []
                for k in self.lmOrderList! {
                    tmp.append(k.toMap())
                }
                map["LmOrderList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                var tmp : [QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList] = []
                for v in dict["LmOrderList"] as! [Any] {
                    var model = QueryOrderAndPaymentListResponseBody.LmOrderList.LmOrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmOrderList = tmp
            }
        }
    }
    public class PostFee : Tea.TeaModel {
        public var fundAmount: Int64?

        public var fundAmountMoney: Int64?

        public var fundType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fundAmount != nil {
                map["FundAmount"] = self.fundAmount!
            }
            if self.fundAmountMoney != nil {
                map["FundAmountMoney"] = self.fundAmountMoney!
            }
            if self.fundType != nil {
                map["FundType"] = self.fundType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                self.fundAmount = dict["FundAmount"] as! Int64
            }
            if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
            }
            if dict.keys.contains("FundType") && dict["FundType"] != nil {
                self.fundType = dict["FundType"] as! String
            }
        }
    }
    public var code: String?

    public var lmOrderList: QueryOrderAndPaymentListResponseBody.LmOrderList?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var postFee: QueryOrderAndPaymentListResponseBody.PostFee?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmOrderList?.validate()
        try self.postFee?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmOrderList != nil {
            map["LmOrderList"] = self.lmOrderList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.postFee != nil {
            map["PostFee"] = self.postFee?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
            var model = QueryOrderAndPaymentListResponseBody.LmOrderList()
            model.fromMap(dict["LmOrderList"] as! [String: Any])
            self.lmOrderList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
            var model = QueryOrderAndPaymentListResponseBody.PostFee()
            model.fromMap(dict["PostFee"] as! [String: Any])
            self.postFee = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryOrderAndPaymentListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderAndPaymentListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderAndPaymentListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderAndPaymentListWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var filterOption: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.filterOption != nil {
            map["FilterOption"] = self.filterOption!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("FilterOption") && dict["FilterOption"] != nil {
            self.filterOption = dict["FilterOption"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class QueryOrderAndPaymentListWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class FundStructureModels : Tea.TeaModel {
            public var fundAmount: Int64?

            public var fundAmountMoney: Int64?

            public var fundType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fundAmount != nil {
                    map["FundAmount"] = self.fundAmount!
                }
                if self.fundAmountMoney != nil {
                    map["FundAmountMoney"] = self.fundAmountMoney!
                }
                if self.fundType != nil {
                    map["FundType"] = self.fundType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                    self.fundAmount = dict["FundAmount"] as! Int64
                }
                if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                    self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                }
                if dict.keys.contains("FundType") && dict["FundType"] != nil {
                    self.fundType = dict["FundType"] as! String
                }
            }
        }
        public class PostFee : Tea.TeaModel {
            public var fundAmount: Int64?

            public var fundAmountMoney: Int64?

            public var fundType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fundAmount != nil {
                    map["FundAmount"] = self.fundAmount!
                }
                if self.fundAmountMoney != nil {
                    map["FundAmountMoney"] = self.fundAmountMoney!
                }
                if self.fundType != nil {
                    map["FundType"] = self.fundType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                    self.fundAmount = dict["FundAmount"] as! Int64
                }
                if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                    self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                }
                if dict.keys.contains("FundType") && dict["FundType"] != nil {
                    self.fundType = dict["FundType"] as! String
                }
            }
        }
        public class SubOrderList : Tea.TeaModel {
            public class ItemPriceList : Tea.TeaModel {
                public var fundAmount: Int64?

                public var fundAmountMoney: Int64?

                public var fundType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fundAmount != nil {
                        map["FundAmount"] = self.fundAmount!
                    }
                    if self.fundAmountMoney != nil {
                        map["FundAmountMoney"] = self.fundAmountMoney!
                    }
                    if self.fundType != nil {
                        map["FundType"] = self.fundType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                        self.fundAmount = dict["FundAmount"] as! Int64
                    }
                    if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                        self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                    }
                    if dict.keys.contains("FundType") && dict["FundType"] != nil {
                        self.fundType = dict["FundType"] as! String
                    }
                }
            }
            public var enableStatus: Int32?

            public var itemId: Int64?

            public var itemPic: String?

            public var itemPriceList: [QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.SubOrderList.ItemPriceList]?

            public var itemTitle: String?

            public var lmItemId: String?

            public var lmOrderId: Int64?

            public var number: Int64?

            public var orderStatus: Int32?

            public var skuId: String?

            public var skuName: String?

            public var tbOrderId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemPic != nil {
                    map["ItemPic"] = self.itemPic!
                }
                if self.itemPriceList != nil {
                    var tmp : [Any] = []
                    for k in self.itemPriceList! {
                        tmp.append(k.toMap())
                    }
                    map["ItemPriceList"] = tmp
                }
                if self.itemTitle != nil {
                    map["ItemTitle"] = self.itemTitle!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.lmOrderId != nil {
                    map["LmOrderId"] = self.lmOrderId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.orderStatus != nil {
                    map["OrderStatus"] = self.orderStatus!
                }
                if self.skuId != nil {
                    map["SkuId"] = self.skuId!
                }
                if self.skuName != nil {
                    map["SkuName"] = self.skuName!
                }
                if self.tbOrderId != nil {
                    map["TbOrderId"] = self.tbOrderId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                    self.enableStatus = dict["EnableStatus"] as! Int32
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ItemPic") && dict["ItemPic"] != nil {
                    self.itemPic = dict["ItemPic"] as! String
                }
                if dict.keys.contains("ItemPriceList") && dict["ItemPriceList"] != nil {
                    var tmp : [QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.SubOrderList.ItemPriceList] = []
                    for v in dict["ItemPriceList"] as! [Any] {
                        var model = QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.SubOrderList.ItemPriceList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.itemPriceList = tmp
                }
                if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                    self.itemTitle = dict["ItemTitle"] as! String
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                    self.lmOrderId = dict["LmOrderId"] as! Int64
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! Int64
                }
                if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
                    self.orderStatus = dict["OrderStatus"] as! Int32
                }
                if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                    self.skuId = dict["SkuId"] as! String
                }
                if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                    self.skuName = dict["SkuName"] as! String
                }
                if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                    self.tbOrderId = dict["TbOrderId"] as! Int64
                }
            }
        }
        public var createTime: String?

        public var enableStatus: Int32?

        public var extJson: String?

        public var fundStructureModels: [QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.FundStructureModels]?

        public var lmOrderId: Int64?

        public var lmPaymentId: String?

        public var logisticsStatus: Int32?

        public var orderAmount: Int64?

        public var orderStatus: Int32?

        public var postFee: QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.PostFee?

        public var shopName: String?

        public var subOrderList: [QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.SubOrderList]?

        public var tbOrderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.postFee?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.enableStatus != nil {
                map["EnableStatus"] = self.enableStatus!
            }
            if self.extJson != nil {
                map["ExtJson"] = self.extJson!
            }
            if self.fundStructureModels != nil {
                var tmp : [Any] = []
                for k in self.fundStructureModels! {
                    tmp.append(k.toMap())
                }
                map["FundStructureModels"] = tmp
            }
            if self.lmOrderId != nil {
                map["LmOrderId"] = self.lmOrderId!
            }
            if self.lmPaymentId != nil {
                map["LmPaymentId"] = self.lmPaymentId!
            }
            if self.logisticsStatus != nil {
                map["LogisticsStatus"] = self.logisticsStatus!
            }
            if self.orderAmount != nil {
                map["OrderAmount"] = self.orderAmount!
            }
            if self.orderStatus != nil {
                map["OrderStatus"] = self.orderStatus!
            }
            if self.postFee != nil {
                map["PostFee"] = self.postFee?.toMap()
            }
            if self.shopName != nil {
                map["ShopName"] = self.shopName!
            }
            if self.subOrderList != nil {
                var tmp : [Any] = []
                for k in self.subOrderList! {
                    tmp.append(k.toMap())
                }
                map["SubOrderList"] = tmp
            }
            if self.tbOrderId != nil {
                map["TbOrderId"] = self.tbOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                self.enableStatus = dict["EnableStatus"] as! Int32
            }
            if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                self.extJson = dict["ExtJson"] as! String
            }
            if dict.keys.contains("FundStructureModels") && dict["FundStructureModels"] != nil {
                var tmp : [QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.FundStructureModels] = []
                for v in dict["FundStructureModels"] as! [Any] {
                    var model = QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.FundStructureModels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fundStructureModels = tmp
            }
            if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                self.lmOrderId = dict["LmOrderId"] as! Int64
            }
            if dict.keys.contains("LmPaymentId") && dict["LmPaymentId"] != nil {
                self.lmPaymentId = dict["LmPaymentId"] as! String
            }
            if dict.keys.contains("LogisticsStatus") && dict["LogisticsStatus"] != nil {
                self.logisticsStatus = dict["LogisticsStatus"] as! Int32
            }
            if dict.keys.contains("OrderAmount") && dict["OrderAmount"] != nil {
                self.orderAmount = dict["OrderAmount"] as! Int64
            }
            if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
                self.orderStatus = dict["OrderStatus"] as! Int32
            }
            if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
                var model = QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.PostFee()
                model.fromMap(dict["PostFee"] as! [String: Any])
                self.postFee = model
            }
            if dict.keys.contains("ShopName") && dict["ShopName"] != nil {
                self.shopName = dict["ShopName"] as! String
            }
            if dict.keys.contains("SubOrderList") && dict["SubOrderList"] != nil {
                var tmp : [QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.SubOrderList] = []
                for v in dict["SubOrderList"] as! [Any] {
                    var model = QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model.SubOrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subOrderList = tmp
            }
            if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                self.tbOrderId = dict["TbOrderId"] as! Int64
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: [QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = QueryOrderAndPaymentListWithDesignatedTbUidResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryOrderAndPaymentListWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderAndPaymentListWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderAndPaymentListWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderCommissionRateRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var lmOrderId: Int64?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryOrderCommissionRateResponseBody : Tea.TeaModel {
    public class CommissionModels : Tea.TeaModel {
        public class CommissionInfo : Tea.TeaModel {
            public class RateConfig : Tea.TeaModel {
                public class Configs : Tea.TeaModel {
                    public var value: Int64?

                    public var valueUnit: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        if self.valueUnit != nil {
                            map["ValueUnit"] = self.valueUnit!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! Int64
                        }
                        if dict.keys.contains("ValueUnit") && dict["ValueUnit"] != nil {
                            self.valueUnit = dict["ValueUnit"] as! String
                        }
                    }
                }
                public var configs: [QueryOrderCommissionRateResponseBody.CommissionModels.CommissionInfo.RateConfig.Configs]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configs != nil {
                        var tmp : [Any] = []
                        for k in self.configs! {
                            tmp.append(k.toMap())
                        }
                        map["Configs"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Configs") && dict["Configs"] != nil {
                        var tmp : [QueryOrderCommissionRateResponseBody.CommissionModels.CommissionInfo.RateConfig.Configs] = []
                        for v in dict["Configs"] as! [Any] {
                            var model = QueryOrderCommissionRateResponseBody.CommissionModels.CommissionInfo.RateConfig.Configs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.configs = tmp
                    }
                }
            }
            public var rateConfig: QueryOrderCommissionRateResponseBody.CommissionModels.CommissionInfo.RateConfig?

            public var rateType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.rateConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rateConfig != nil {
                    map["RateConfig"] = self.rateConfig?.toMap()
                }
                if self.rateType != nil {
                    map["RateType"] = self.rateType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RateConfig") && dict["RateConfig"] != nil {
                    var model = QueryOrderCommissionRateResponseBody.CommissionModels.CommissionInfo.RateConfig()
                    model.fromMap(dict["RateConfig"] as! [String: Any])
                    self.rateConfig = model
                }
                if dict.keys.contains("RateType") && dict["RateType"] != nil {
                    self.rateType = dict["RateType"] as! String
                }
            }
        }
        public var commissionInfo: QueryOrderCommissionRateResponseBody.CommissionModels.CommissionInfo?

        public var lmOrderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commissionInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commissionInfo != nil {
                map["CommissionInfo"] = self.commissionInfo?.toMap()
            }
            if self.lmOrderId != nil {
                map["LmOrderId"] = self.lmOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommissionInfo") && dict["CommissionInfo"] != nil {
                var model = QueryOrderCommissionRateResponseBody.CommissionModels.CommissionInfo()
                model.fromMap(dict["CommissionInfo"] as! [String: Any])
                self.commissionInfo = model
            }
            if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                self.lmOrderId = dict["LmOrderId"] as! Int64
            }
        }
    }
    public var code: String?

    public var commissionModels: [QueryOrderCommissionRateResponseBody.CommissionModels]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.commissionModels != nil {
            var tmp : [Any] = []
            for k in self.commissionModels! {
                tmp.append(k.toMap())
            }
            map["CommissionModels"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CommissionModels") && dict["CommissionModels"] != nil {
            var tmp : [QueryOrderCommissionRateResponseBody.CommissionModels] = []
            for v in dict["CommissionModels"] as! [Any] {
                var model = QueryOrderCommissionRateResponseBody.CommissionModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.commissionModels = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryOrderCommissionRateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderCommissionRateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderCommissionRateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderDetailInnerRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var filterOption: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.filterOption != nil {
            map["FilterOption"] = self.filterOption!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("FilterOption") && dict["FilterOption"] != nil {
            self.filterOption = dict["FilterOption"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryOrderDetailInnerResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class Order : Tea.TeaModel {
            public class FundStructureModels : Tea.TeaModel {
                public class FundStructure : Tea.TeaModel {
                    public var fundAmount: Int64?

                    public var fundAmountMoney: Int64?

                    public var fundType: String?

                    public var lmOrderId: Int64?

                    public var tbSubOrderId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fundAmount != nil {
                            map["FundAmount"] = self.fundAmount!
                        }
                        if self.fundAmountMoney != nil {
                            map["FundAmountMoney"] = self.fundAmountMoney!
                        }
                        if self.fundType != nil {
                            map["FundType"] = self.fundType!
                        }
                        if self.lmOrderId != nil {
                            map["LmOrderId"] = self.lmOrderId!
                        }
                        if self.tbSubOrderId != nil {
                            map["TbSubOrderId"] = self.tbSubOrderId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                            self.fundAmount = dict["FundAmount"] as! Int64
                        }
                        if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                            self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                        }
                        if dict.keys.contains("FundType") && dict["FundType"] != nil {
                            self.fundType = dict["FundType"] as! String
                        }
                        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                            self.lmOrderId = dict["LmOrderId"] as! Int64
                        }
                        if dict.keys.contains("TbSubOrderId") && dict["TbSubOrderId"] != nil {
                            self.tbSubOrderId = dict["TbSubOrderId"] as! Int64
                        }
                    }
                }
                public var fundStructure: [QueryOrderDetailInnerResponseBody.Model.Order.FundStructureModels.FundStructure]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fundStructure != nil {
                        var tmp : [Any] = []
                        for k in self.fundStructure! {
                            tmp.append(k.toMap())
                        }
                        map["FundStructure"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FundStructure") && dict["FundStructure"] != nil {
                        var tmp : [QueryOrderDetailInnerResponseBody.Model.Order.FundStructureModels.FundStructure] = []
                        for v in dict["FundStructure"] as! [Any] {
                            var model = QueryOrderDetailInnerResponseBody.Model.Order.FundStructureModels.FundStructure()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.fundStructure = tmp
                    }
                }
            }
            public class PostFee : Tea.TeaModel {
                public var fundAmount: Int64?

                public var fundAmountMoney: Int64?

                public var fundType: String?

                public var lmOrderId: Int64?

                public var tbSubOrderId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fundAmount != nil {
                        map["FundAmount"] = self.fundAmount!
                    }
                    if self.fundAmountMoney != nil {
                        map["FundAmountMoney"] = self.fundAmountMoney!
                    }
                    if self.fundType != nil {
                        map["FundType"] = self.fundType!
                    }
                    if self.lmOrderId != nil {
                        map["LmOrderId"] = self.lmOrderId!
                    }
                    if self.tbSubOrderId != nil {
                        map["TbSubOrderId"] = self.tbSubOrderId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                        self.fundAmount = dict["FundAmount"] as! Int64
                    }
                    if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                        self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                    }
                    if dict.keys.contains("FundType") && dict["FundType"] != nil {
                        self.fundType = dict["FundType"] as! String
                    }
                    if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                        self.lmOrderId = dict["LmOrderId"] as! Int64
                    }
                    if dict.keys.contains("TbSubOrderId") && dict["TbSubOrderId"] != nil {
                        self.tbSubOrderId = dict["TbSubOrderId"] as! Int64
                    }
                }
            }
            public class SubItemOrderList : Tea.TeaModel {
                public class SubItemOrder : Tea.TeaModel {
                    public class ItemPriceList : Tea.TeaModel {
                        public class ItemPrice : Tea.TeaModel {
                            public var fundAmount: Int64?

                            public var fundAmountMoney: Int64?

                            public var fundType: String?

                            public var tbOrderId: Int64?

                            public var tbSubOrderId: Int64?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.fundAmount != nil {
                                    map["FundAmount"] = self.fundAmount!
                                }
                                if self.fundAmountMoney != nil {
                                    map["FundAmountMoney"] = self.fundAmountMoney!
                                }
                                if self.fundType != nil {
                                    map["FundType"] = self.fundType!
                                }
                                if self.tbOrderId != nil {
                                    map["TbOrderId"] = self.tbOrderId!
                                }
                                if self.tbSubOrderId != nil {
                                    map["TbSubOrderId"] = self.tbSubOrderId!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                                    self.fundAmount = dict["FundAmount"] as! Int64
                                }
                                if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                                    self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                                }
                                if dict.keys.contains("FundType") && dict["FundType"] != nil {
                                    self.fundType = dict["FundType"] as! String
                                }
                                if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                                    self.tbOrderId = dict["TbOrderId"] as! Int64
                                }
                                if dict.keys.contains("TbSubOrderId") && dict["TbSubOrderId"] != nil {
                                    self.tbSubOrderId = dict["TbSubOrderId"] as! Int64
                                }
                            }
                        }
                        public var itemPrice: [QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList.SubItemOrder.ItemPriceList.ItemPrice]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.itemPrice != nil {
                                var tmp : [Any] = []
                                for k in self.itemPrice! {
                                    tmp.append(k.toMap())
                                }
                                map["ItemPrice"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ItemPrice") && dict["ItemPrice"] != nil {
                                var tmp : [QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList.SubItemOrder.ItemPriceList.ItemPrice] = []
                                for v in dict["ItemPrice"] as! [Any] {
                                    var model = QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList.SubItemOrder.ItemPriceList.ItemPrice()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.itemPrice = tmp
                            }
                        }
                    }
                    public var channelCode: String?

                    public var itemId: Int64?

                    public var itemPic: String?

                    public var itemPriceInfo: String?

                    public var itemPriceList: QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList.SubItemOrder.ItemPriceList?

                    public var itemTitle: String?

                    public var lmItemId: String?

                    public var lmOrderId: Int64?

                    public var number: Int32?

                    public var payStatus: Int32?

                    public var skuId: Int64?

                    public var skuName: String?

                    public var tbSubOrderId: Int64?

                    public var totalPaymentInfo: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.itemPriceList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channelCode != nil {
                            map["ChannelCode"] = self.channelCode!
                        }
                        if self.itemId != nil {
                            map["ItemId"] = self.itemId!
                        }
                        if self.itemPic != nil {
                            map["ItemPic"] = self.itemPic!
                        }
                        if self.itemPriceInfo != nil {
                            map["ItemPriceInfo"] = self.itemPriceInfo!
                        }
                        if self.itemPriceList != nil {
                            map["ItemPriceList"] = self.itemPriceList?.toMap()
                        }
                        if self.itemTitle != nil {
                            map["ItemTitle"] = self.itemTitle!
                        }
                        if self.lmItemId != nil {
                            map["LmItemId"] = self.lmItemId!
                        }
                        if self.lmOrderId != nil {
                            map["LmOrderId"] = self.lmOrderId!
                        }
                        if self.number != nil {
                            map["Number"] = self.number!
                        }
                        if self.payStatus != nil {
                            map["PayStatus"] = self.payStatus!
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        if self.skuName != nil {
                            map["SkuName"] = self.skuName!
                        }
                        if self.tbSubOrderId != nil {
                            map["TbSubOrderId"] = self.tbSubOrderId!
                        }
                        if self.totalPaymentInfo != nil {
                            map["TotalPaymentInfo"] = self.totalPaymentInfo!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ChannelCode") && dict["ChannelCode"] != nil {
                            self.channelCode = dict["ChannelCode"] as! String
                        }
                        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                            self.itemId = dict["ItemId"] as! Int64
                        }
                        if dict.keys.contains("ItemPic") && dict["ItemPic"] != nil {
                            self.itemPic = dict["ItemPic"] as! String
                        }
                        if dict.keys.contains("ItemPriceInfo") && dict["ItemPriceInfo"] != nil {
                            self.itemPriceInfo = dict["ItemPriceInfo"] as! String
                        }
                        if dict.keys.contains("ItemPriceList") && dict["ItemPriceList"] != nil {
                            var model = QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList.SubItemOrder.ItemPriceList()
                            model.fromMap(dict["ItemPriceList"] as! [String: Any])
                            self.itemPriceList = model
                        }
                        if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                            self.itemTitle = dict["ItemTitle"] as! String
                        }
                        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                            self.lmItemId = dict["LmItemId"] as! String
                        }
                        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                            self.lmOrderId = dict["LmOrderId"] as! Int64
                        }
                        if dict.keys.contains("Number") && dict["Number"] != nil {
                            self.number = dict["Number"] as! Int32
                        }
                        if dict.keys.contains("PayStatus") && dict["PayStatus"] != nil {
                            self.payStatus = dict["PayStatus"] as! Int32
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                        if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                            self.skuName = dict["SkuName"] as! String
                        }
                        if dict.keys.contains("TbSubOrderId") && dict["TbSubOrderId"] != nil {
                            self.tbSubOrderId = dict["TbSubOrderId"] as! Int64
                        }
                        if dict.keys.contains("TotalPaymentInfo") && dict["TotalPaymentInfo"] != nil {
                            self.totalPaymentInfo = dict["TotalPaymentInfo"] as! String
                        }
                    }
                }
                public var subItemOrder: [QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList.SubItemOrder]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.subItemOrder != nil {
                        var tmp : [Any] = []
                        for k in self.subItemOrder! {
                            tmp.append(k.toMap())
                        }
                        map["SubItemOrder"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SubItemOrder") && dict["SubItemOrder"] != nil {
                        var tmp : [QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList.SubItemOrder] = []
                        for v in dict["SubItemOrder"] as! [Any] {
                            var model = QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList.SubItemOrder()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subItemOrder = tmp
                    }
                }
            }
            public var channelBizType: String?

            public var channelCode: String?

            public var channelOrderId: String?

            public var createDate: String?

            public var enableStatus: Int32?

            public var endTime: Int64?

            public var eticket: Bool?

            public var extInfo: [String: Any]?

            public var fundStructureModels: QueryOrderDetailInnerResponseBody.Model.Order.FundStructureModels?

            public var lmOrderId: Int64?

            public var logisticsAddress: String?

            public var logisticsCompName: String?

            public var logisticsMobilePhone: String?

            public var logisticsNo: String?

            public var logisticsStatus: Int32?

            public var logisticsStatusDesc: String?

            public var logisticsUserName: String?

            public var orderAmount: Int64?

            public var orderPayInfo: String?

            public var payStatus: Int32?

            public var payWaterStatus: Int32?

            public var postFee: QueryOrderDetailInnerResponseBody.Model.Order.PostFee?

            public var refundStatus: Int32?

            public var resExtInfo: String?

            public var sellerId: Int64?

            public var sellerNick: String?

            public var shipping: String?

            public var shopName: String?

            public var subItemOrderList: QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList?

            public var tbOrderId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fundStructureModels?.validate()
                try self.postFee?.validate()
                try self.subItemOrderList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelBizType != nil {
                    map["ChannelBizType"] = self.channelBizType!
                }
                if self.channelCode != nil {
                    map["ChannelCode"] = self.channelCode!
                }
                if self.channelOrderId != nil {
                    map["ChannelOrderId"] = self.channelOrderId!
                }
                if self.createDate != nil {
                    map["CreateDate"] = self.createDate!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.eticket != nil {
                    map["Eticket"] = self.eticket!
                }
                if self.extInfo != nil {
                    map["ExtInfo"] = self.extInfo!
                }
                if self.fundStructureModels != nil {
                    map["FundStructureModels"] = self.fundStructureModels?.toMap()
                }
                if self.lmOrderId != nil {
                    map["LmOrderId"] = self.lmOrderId!
                }
                if self.logisticsAddress != nil {
                    map["LogisticsAddress"] = self.logisticsAddress!
                }
                if self.logisticsCompName != nil {
                    map["LogisticsCompName"] = self.logisticsCompName!
                }
                if self.logisticsMobilePhone != nil {
                    map["LogisticsMobilePhone"] = self.logisticsMobilePhone!
                }
                if self.logisticsNo != nil {
                    map["LogisticsNo"] = self.logisticsNo!
                }
                if self.logisticsStatus != nil {
                    map["LogisticsStatus"] = self.logisticsStatus!
                }
                if self.logisticsStatusDesc != nil {
                    map["LogisticsStatusDesc"] = self.logisticsStatusDesc!
                }
                if self.logisticsUserName != nil {
                    map["LogisticsUserName"] = self.logisticsUserName!
                }
                if self.orderAmount != nil {
                    map["OrderAmount"] = self.orderAmount!
                }
                if self.orderPayInfo != nil {
                    map["OrderPayInfo"] = self.orderPayInfo!
                }
                if self.payStatus != nil {
                    map["PayStatus"] = self.payStatus!
                }
                if self.payWaterStatus != nil {
                    map["PayWaterStatus"] = self.payWaterStatus!
                }
                if self.postFee != nil {
                    map["PostFee"] = self.postFee?.toMap()
                }
                if self.refundStatus != nil {
                    map["RefundStatus"] = self.refundStatus!
                }
                if self.resExtInfo != nil {
                    map["ResExtInfo"] = self.resExtInfo!
                }
                if self.sellerId != nil {
                    map["SellerId"] = self.sellerId!
                }
                if self.sellerNick != nil {
                    map["SellerNick"] = self.sellerNick!
                }
                if self.shipping != nil {
                    map["Shipping"] = self.shipping!
                }
                if self.shopName != nil {
                    map["ShopName"] = self.shopName!
                }
                if self.subItemOrderList != nil {
                    map["SubItemOrderList"] = self.subItemOrderList?.toMap()
                }
                if self.tbOrderId != nil {
                    map["TbOrderId"] = self.tbOrderId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelBizType") && dict["ChannelBizType"] != nil {
                    self.channelBizType = dict["ChannelBizType"] as! String
                }
                if dict.keys.contains("ChannelCode") && dict["ChannelCode"] != nil {
                    self.channelCode = dict["ChannelCode"] as! String
                }
                if dict.keys.contains("ChannelOrderId") && dict["ChannelOrderId"] != nil {
                    self.channelOrderId = dict["ChannelOrderId"] as! String
                }
                if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                    self.createDate = dict["CreateDate"] as! String
                }
                if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                    self.enableStatus = dict["EnableStatus"] as! Int32
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("Eticket") && dict["Eticket"] != nil {
                    self.eticket = dict["Eticket"] as! Bool
                }
                if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                    self.extInfo = dict["ExtInfo"] as! [String: Any]
                }
                if dict.keys.contains("FundStructureModels") && dict["FundStructureModels"] != nil {
                    var model = QueryOrderDetailInnerResponseBody.Model.Order.FundStructureModels()
                    model.fromMap(dict["FundStructureModels"] as! [String: Any])
                    self.fundStructureModels = model
                }
                if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                    self.lmOrderId = dict["LmOrderId"] as! Int64
                }
                if dict.keys.contains("LogisticsAddress") && dict["LogisticsAddress"] != nil {
                    self.logisticsAddress = dict["LogisticsAddress"] as! String
                }
                if dict.keys.contains("LogisticsCompName") && dict["LogisticsCompName"] != nil {
                    self.logisticsCompName = dict["LogisticsCompName"] as! String
                }
                if dict.keys.contains("LogisticsMobilePhone") && dict["LogisticsMobilePhone"] != nil {
                    self.logisticsMobilePhone = dict["LogisticsMobilePhone"] as! String
                }
                if dict.keys.contains("LogisticsNo") && dict["LogisticsNo"] != nil {
                    self.logisticsNo = dict["LogisticsNo"] as! String
                }
                if dict.keys.contains("LogisticsStatus") && dict["LogisticsStatus"] != nil {
                    self.logisticsStatus = dict["LogisticsStatus"] as! Int32
                }
                if dict.keys.contains("LogisticsStatusDesc") && dict["LogisticsStatusDesc"] != nil {
                    self.logisticsStatusDesc = dict["LogisticsStatusDesc"] as! String
                }
                if dict.keys.contains("LogisticsUserName") && dict["LogisticsUserName"] != nil {
                    self.logisticsUserName = dict["LogisticsUserName"] as! String
                }
                if dict.keys.contains("OrderAmount") && dict["OrderAmount"] != nil {
                    self.orderAmount = dict["OrderAmount"] as! Int64
                }
                if dict.keys.contains("OrderPayInfo") && dict["OrderPayInfo"] != nil {
                    self.orderPayInfo = dict["OrderPayInfo"] as! String
                }
                if dict.keys.contains("PayStatus") && dict["PayStatus"] != nil {
                    self.payStatus = dict["PayStatus"] as! Int32
                }
                if dict.keys.contains("PayWaterStatus") && dict["PayWaterStatus"] != nil {
                    self.payWaterStatus = dict["PayWaterStatus"] as! Int32
                }
                if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
                    var model = QueryOrderDetailInnerResponseBody.Model.Order.PostFee()
                    model.fromMap(dict["PostFee"] as! [String: Any])
                    self.postFee = model
                }
                if dict.keys.contains("RefundStatus") && dict["RefundStatus"] != nil {
                    self.refundStatus = dict["RefundStatus"] as! Int32
                }
                if dict.keys.contains("ResExtInfo") && dict["ResExtInfo"] != nil {
                    self.resExtInfo = dict["ResExtInfo"] as! String
                }
                if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                    self.sellerId = dict["SellerId"] as! Int64
                }
                if dict.keys.contains("SellerNick") && dict["SellerNick"] != nil {
                    self.sellerNick = dict["SellerNick"] as! String
                }
                if dict.keys.contains("Shipping") && dict["Shipping"] != nil {
                    self.shipping = dict["Shipping"] as! String
                }
                if dict.keys.contains("ShopName") && dict["ShopName"] != nil {
                    self.shopName = dict["ShopName"] as! String
                }
                if dict.keys.contains("SubItemOrderList") && dict["SubItemOrderList"] != nil {
                    var model = QueryOrderDetailInnerResponseBody.Model.Order.SubItemOrderList()
                    model.fromMap(dict["SubItemOrderList"] as! [String: Any])
                    self.subItemOrderList = model
                }
                if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                    self.tbOrderId = dict["TbOrderId"] as! String
                }
            }
        }
        public var order: QueryOrderDetailInnerResponseBody.Model.Order?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.order?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.order != nil {
                map["order"] = self.order?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("order") && dict["order"] != nil {
                var model = QueryOrderDetailInnerResponseBody.Model.Order()
                model.fromMap(dict["order"] as! [String: Any])
                self.order = model
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: QueryOrderDetailInnerResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryOrderDetailInnerResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryOrderDetailInnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderDetailInnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderDetailInnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderIdByPayIdRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var paymentId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.paymentId != nil {
            map["PaymentId"] = self.paymentId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("PaymentId") && dict["PaymentId"] != nil {
            self.paymentId = dict["PaymentId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryOrderIdByPayIdResponseBody : Tea.TeaModel {
    public class LmOrderIds : Tea.TeaModel {
        public class LmOrderIds : Tea.TeaModel {
            public var lmOrderId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lmOrderId != nil {
                    map["LmOrderId"] = self.lmOrderId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                    self.lmOrderId = dict["LmOrderId"] as! Int64
                }
            }
        }
        public var lmOrderIds: [QueryOrderIdByPayIdResponseBody.LmOrderIds.LmOrderIds]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderIds != nil {
                var tmp : [Any] = []
                for k in self.lmOrderIds! {
                    tmp.append(k.toMap())
                }
                map["LmOrderIds"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderIds") && dict["LmOrderIds"] != nil {
                var tmp : [QueryOrderIdByPayIdResponseBody.LmOrderIds.LmOrderIds] = []
                for v in dict["LmOrderIds"] as! [Any] {
                    var model = QueryOrderIdByPayIdResponseBody.LmOrderIds.LmOrderIds()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmOrderIds = tmp
            }
        }
    }
    public var code: String?

    public var lmOrderIds: QueryOrderIdByPayIdResponseBody.LmOrderIds?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmOrderIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmOrderIds != nil {
            map["LmOrderIds"] = self.lmOrderIds?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmOrderIds") && dict["LmOrderIds"] != nil {
            var model = QueryOrderIdByPayIdResponseBody.LmOrderIds()
            model.fromMap(dict["LmOrderIds"] as! [String: Any])
            self.lmOrderIds = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryOrderIdByPayIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderIdByPayIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderIdByPayIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderInfoAfterSaleRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var channelUserId: String?

    public var lmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.channelUserId != nil {
            map["ChannelUserId"] = self.channelUserId!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ChannelUserId") && dict["ChannelUserId"] != nil {
            self.channelUserId = dict["ChannelUserId"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryOrderInfoAfterSaleResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class LogisticsList : Tea.TeaModel {
            public class Logistics : Tea.TeaModel {
                public var logisticsCompanyCode: String?

                public var logisticsCompanyName: String?

                public var logisticsNo: String?

                public var logisticsStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logisticsCompanyCode != nil {
                        map["LogisticsCompanyCode"] = self.logisticsCompanyCode!
                    }
                    if self.logisticsCompanyName != nil {
                        map["LogisticsCompanyName"] = self.logisticsCompanyName!
                    }
                    if self.logisticsNo != nil {
                        map["LogisticsNo"] = self.logisticsNo!
                    }
                    if self.logisticsStatus != nil {
                        map["LogisticsStatus"] = self.logisticsStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LogisticsCompanyCode") && dict["LogisticsCompanyCode"] != nil {
                        self.logisticsCompanyCode = dict["LogisticsCompanyCode"] as! String
                    }
                    if dict.keys.contains("LogisticsCompanyName") && dict["LogisticsCompanyName"] != nil {
                        self.logisticsCompanyName = dict["LogisticsCompanyName"] as! String
                    }
                    if dict.keys.contains("LogisticsNo") && dict["LogisticsNo"] != nil {
                        self.logisticsNo = dict["LogisticsNo"] as! String
                    }
                    if dict.keys.contains("LogisticsStatus") && dict["LogisticsStatus"] != nil {
                        self.logisticsStatus = dict["LogisticsStatus"] as! String
                    }
                }
            }
            public var logistics: [QueryOrderInfoAfterSaleResponseBody.Model.LogisticsList.Logistics]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logistics != nil {
                    var tmp : [Any] = []
                    for k in self.logistics! {
                        tmp.append(k.toMap())
                    }
                    map["Logistics"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Logistics") && dict["Logistics"] != nil {
                    var tmp : [QueryOrderInfoAfterSaleResponseBody.Model.LogisticsList.Logistics] = []
                    for v in dict["Logistics"] as! [Any] {
                        var model = QueryOrderInfoAfterSaleResponseBody.Model.LogisticsList.Logistics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.logistics = tmp
                }
            }
        }
        public var cashAmount: String?

        public var createDate: String?

        public var extJson: String?

        public var lmOrderId: Int64?

        public var logisticsList: QueryOrderInfoAfterSaleResponseBody.Model.LogisticsList?

        public var orderStatus: String?

        public var points: Int64?

        public var pointsAmount: Int64?

        public var refundAmount: Int64?

        public var refundPoints: Int64?

        public var refundRate: String?

        public var refundStatus: String?

        public var shopName: String?

        public var shopServiceTelephone: String?

        public var tbOrderId: Int64?

        public var xiaomiCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.logisticsList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cashAmount != nil {
                map["CashAmount"] = self.cashAmount!
            }
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.extJson != nil {
                map["ExtJson"] = self.extJson!
            }
            if self.lmOrderId != nil {
                map["LmOrderId"] = self.lmOrderId!
            }
            if self.logisticsList != nil {
                map["LogisticsList"] = self.logisticsList?.toMap()
            }
            if self.orderStatus != nil {
                map["OrderStatus"] = self.orderStatus!
            }
            if self.points != nil {
                map["Points"] = self.points!
            }
            if self.pointsAmount != nil {
                map["PointsAmount"] = self.pointsAmount!
            }
            if self.refundAmount != nil {
                map["RefundAmount"] = self.refundAmount!
            }
            if self.refundPoints != nil {
                map["RefundPoints"] = self.refundPoints!
            }
            if self.refundRate != nil {
                map["RefundRate"] = self.refundRate!
            }
            if self.refundStatus != nil {
                map["RefundStatus"] = self.refundStatus!
            }
            if self.shopName != nil {
                map["ShopName"] = self.shopName!
            }
            if self.shopServiceTelephone != nil {
                map["ShopServiceTelephone"] = self.shopServiceTelephone!
            }
            if self.tbOrderId != nil {
                map["TbOrderId"] = self.tbOrderId!
            }
            if self.xiaomiCode != nil {
                map["XiaomiCode"] = self.xiaomiCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CashAmount") && dict["CashAmount"] != nil {
                self.cashAmount = dict["CashAmount"] as! String
            }
            if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                self.createDate = dict["CreateDate"] as! String
            }
            if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                self.extJson = dict["ExtJson"] as! String
            }
            if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                self.lmOrderId = dict["LmOrderId"] as! Int64
            }
            if dict.keys.contains("LogisticsList") && dict["LogisticsList"] != nil {
                var model = QueryOrderInfoAfterSaleResponseBody.Model.LogisticsList()
                model.fromMap(dict["LogisticsList"] as! [String: Any])
                self.logisticsList = model
            }
            if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
                self.orderStatus = dict["OrderStatus"] as! String
            }
            if dict.keys.contains("Points") && dict["Points"] != nil {
                self.points = dict["Points"] as! Int64
            }
            if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                self.pointsAmount = dict["PointsAmount"] as! Int64
            }
            if dict.keys.contains("RefundAmount") && dict["RefundAmount"] != nil {
                self.refundAmount = dict["RefundAmount"] as! Int64
            }
            if dict.keys.contains("RefundPoints") && dict["RefundPoints"] != nil {
                self.refundPoints = dict["RefundPoints"] as! Int64
            }
            if dict.keys.contains("RefundRate") && dict["RefundRate"] != nil {
                self.refundRate = dict["RefundRate"] as! String
            }
            if dict.keys.contains("RefundStatus") && dict["RefundStatus"] != nil {
                self.refundStatus = dict["RefundStatus"] as! String
            }
            if dict.keys.contains("ShopName") && dict["ShopName"] != nil {
                self.shopName = dict["ShopName"] as! String
            }
            if dict.keys.contains("ShopServiceTelephone") && dict["ShopServiceTelephone"] != nil {
                self.shopServiceTelephone = dict["ShopServiceTelephone"] as! String
            }
            if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                self.tbOrderId = dict["TbOrderId"] as! Int64
            }
            if dict.keys.contains("XiaomiCode") && dict["XiaomiCode"] != nil {
                self.xiaomiCode = dict["XiaomiCode"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: QueryOrderInfoAfterSaleResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryOrderInfoAfterSaleResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryOrderInfoAfterSaleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderInfoAfterSaleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderInfoAfterSaleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderItemInfoByPaymentIdForAiZhanYouRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var paymentId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.paymentId != nil {
            map["PaymentId"] = self.paymentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("PaymentId") && dict["PaymentId"] != nil {
            self.paymentId = dict["PaymentId"] as! String
        }
    }
}

public class QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody : Tea.TeaModel {
    public class LmOrderList : Tea.TeaModel {
        public class LmOrderList : Tea.TeaModel {
            public var itemId: Int64?

            public var itemName: String?

            public var lmItemId: String?

            public var lmOrderId: Int64?

            public var skuId: Int64?

            public var skuName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.lmOrderId != nil {
                    map["LmOrderId"] = self.lmOrderId!
                }
                if self.skuId != nil {
                    map["SkuId"] = self.skuId!
                }
                if self.skuName != nil {
                    map["SkuName"] = self.skuName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ItemName") && dict["ItemName"] != nil {
                    self.itemName = dict["ItemName"] as! String
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                    self.lmOrderId = dict["LmOrderId"] as! Int64
                }
                if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                    self.skuId = dict["SkuId"] as! Int64
                }
                if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                    self.skuName = dict["SkuName"] as! String
                }
            }
        }
        public var lmOrderList: [QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody.LmOrderList.LmOrderList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderList != nil {
                var tmp : [Any] = []
                for k in self.lmOrderList! {
                    tmp.append(k.toMap())
                }
                map["LmOrderList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                var tmp : [QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody.LmOrderList.LmOrderList] = []
                for v in dict["LmOrderList"] as! [Any] {
                    var model = QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody.LmOrderList.LmOrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmOrderList = tmp
            }
        }
    }
    public var code: String?

    public var lmOrderList: QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody.LmOrderList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmOrderList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmOrderList != nil {
            map["LmOrderList"] = self.lmOrderList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
            var model = QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody.LmOrderList()
            model.fromMap(dict["LmOrderList"] as! [String: Any])
            self.lmOrderList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryOrderItemInfoByPaymentIdForAiZhanYouResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderListRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var filterOption: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.filterOption != nil {
            map["FilterOption"] = self.filterOption!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("FilterOption") && dict["FilterOption"] != nil {
            self.filterOption = dict["FilterOption"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryOrderListResponseBody : Tea.TeaModel {
    public class LmOrderList : Tea.TeaModel {
        public class LmOrderList : Tea.TeaModel {
            public class FundStructureModels : Tea.TeaModel {
                public class FundStructureModels : Tea.TeaModel {
                    public var fundAmount: Int64?

                    public var fundAmountMoney: Int64?

                    public var fundType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fundAmount != nil {
                            map["FundAmount"] = self.fundAmount!
                        }
                        if self.fundAmountMoney != nil {
                            map["FundAmountMoney"] = self.fundAmountMoney!
                        }
                        if self.fundType != nil {
                            map["FundType"] = self.fundType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                            self.fundAmount = dict["FundAmount"] as! Int64
                        }
                        if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                            self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                        }
                        if dict.keys.contains("FundType") && dict["FundType"] != nil {
                            self.fundType = dict["FundType"] as! String
                        }
                    }
                }
                public var fundStructureModels: [QueryOrderListResponseBody.LmOrderList.LmOrderList.FundStructureModels.FundStructureModels]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fundStructureModels != nil {
                        var tmp : [Any] = []
                        for k in self.fundStructureModels! {
                            tmp.append(k.toMap())
                        }
                        map["FundStructureModels"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FundStructureModels") && dict["FundStructureModels"] != nil {
                        var tmp : [QueryOrderListResponseBody.LmOrderList.LmOrderList.FundStructureModels.FundStructureModels] = []
                        for v in dict["FundStructureModels"] as! [Any] {
                            var model = QueryOrderListResponseBody.LmOrderList.LmOrderList.FundStructureModels.FundStructureModels()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.fundStructureModels = tmp
                    }
                }
            }
            public class PostFee : Tea.TeaModel {
                public var fundAmount: Int64?

                public var fundAmountMoney: Int64?

                public var fundType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fundAmount != nil {
                        map["FundAmount"] = self.fundAmount!
                    }
                    if self.fundAmountMoney != nil {
                        map["FundAmountMoney"] = self.fundAmountMoney!
                    }
                    if self.fundType != nil {
                        map["FundType"] = self.fundType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                        self.fundAmount = dict["FundAmount"] as! Int64
                    }
                    if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                        self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                    }
                    if dict.keys.contains("FundType") && dict["FundType"] != nil {
                        self.fundType = dict["FundType"] as! String
                    }
                }
            }
            public class SubOrderList : Tea.TeaModel {
                public class SubOrderList : Tea.TeaModel {
                    public class ItemPriceList : Tea.TeaModel {
                        public class ItemPriceList : Tea.TeaModel {
                            public var fundAmount: Int64?

                            public var fundAmountMoney: Int64?

                            public var fundType: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.fundAmount != nil {
                                    map["FundAmount"] = self.fundAmount!
                                }
                                if self.fundAmountMoney != nil {
                                    map["FundAmountMoney"] = self.fundAmountMoney!
                                }
                                if self.fundType != nil {
                                    map["FundType"] = self.fundType!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                                    self.fundAmount = dict["FundAmount"] as! Int64
                                }
                                if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                                    self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                                }
                                if dict.keys.contains("FundType") && dict["FundType"] != nil {
                                    self.fundType = dict["FundType"] as! String
                                }
                            }
                        }
                        public var itemPriceList: [QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList.ItemPriceList]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.itemPriceList != nil {
                                var tmp : [Any] = []
                                for k in self.itemPriceList! {
                                    tmp.append(k.toMap())
                                }
                                map["ItemPriceList"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ItemPriceList") && dict["ItemPriceList"] != nil {
                                var tmp : [QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList.ItemPriceList] = []
                                for v in dict["ItemPriceList"] as! [Any] {
                                    var model = QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList.ItemPriceList()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.itemPriceList = tmp
                            }
                        }
                    }
                    public var enableStatus: Int32?

                    public var itemId: Int64?

                    public var itemPic: String?

                    public var itemPriceList: QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList?

                    public var itemTitle: String?

                    public var lmItemId: String?

                    public var lmOrderId: Int64?

                    public var number: Int64?

                    public var orderStatus: Int32?

                    public var skuId: Int64?

                    public var skuName: String?

                    public var tbOrderId: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.itemPriceList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.itemId != nil {
                            map["ItemId"] = self.itemId!
                        }
                        if self.itemPic != nil {
                            map["ItemPic"] = self.itemPic!
                        }
                        if self.itemPriceList != nil {
                            map["ItemPriceList"] = self.itemPriceList?.toMap()
                        }
                        if self.itemTitle != nil {
                            map["ItemTitle"] = self.itemTitle!
                        }
                        if self.lmItemId != nil {
                            map["LmItemId"] = self.lmItemId!
                        }
                        if self.lmOrderId != nil {
                            map["LmOrderId"] = self.lmOrderId!
                        }
                        if self.number != nil {
                            map["Number"] = self.number!
                        }
                        if self.orderStatus != nil {
                            map["OrderStatus"] = self.orderStatus!
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        if self.skuName != nil {
                            map["SkuName"] = self.skuName!
                        }
                        if self.tbOrderId != nil {
                            map["TbOrderId"] = self.tbOrderId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                            self.enableStatus = dict["EnableStatus"] as! Int32
                        }
                        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                            self.itemId = dict["ItemId"] as! Int64
                        }
                        if dict.keys.contains("ItemPic") && dict["ItemPic"] != nil {
                            self.itemPic = dict["ItemPic"] as! String
                        }
                        if dict.keys.contains("ItemPriceList") && dict["ItemPriceList"] != nil {
                            var model = QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList.ItemPriceList()
                            model.fromMap(dict["ItemPriceList"] as! [String: Any])
                            self.itemPriceList = model
                        }
                        if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                            self.itemTitle = dict["ItemTitle"] as! String
                        }
                        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                            self.lmItemId = dict["LmItemId"] as! String
                        }
                        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                            self.lmOrderId = dict["LmOrderId"] as! Int64
                        }
                        if dict.keys.contains("Number") && dict["Number"] != nil {
                            self.number = dict["Number"] as! Int64
                        }
                        if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
                            self.orderStatus = dict["OrderStatus"] as! Int32
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                        if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                            self.skuName = dict["SkuName"] as! String
                        }
                        if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                            self.tbOrderId = dict["TbOrderId"] as! Int64
                        }
                    }
                }
                public var subOrderList: [QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.subOrderList != nil {
                        var tmp : [Any] = []
                        for k in self.subOrderList! {
                            tmp.append(k.toMap())
                        }
                        map["SubOrderList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SubOrderList") && dict["SubOrderList"] != nil {
                        var tmp : [QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList] = []
                        for v in dict["SubOrderList"] as! [Any] {
                            var model = QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList.SubOrderList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.subOrderList = tmp
                    }
                }
            }
            public var createDate: String?

            public var enableStatus: Int32?

            public var extJson: String?

            public var fundStructureModels: QueryOrderListResponseBody.LmOrderList.LmOrderList.FundStructureModels?

            public var lmOrderId: Int64?

            public var logisticsStatus: Int32?

            public var orderAmount: Int64?

            public var orderStatus: Int32?

            public var postFee: QueryOrderListResponseBody.LmOrderList.LmOrderList.PostFee?

            public var shopName: String?

            public var subOrderList: QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList?

            public var tbOrderId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fundStructureModels?.validate()
                try self.postFee?.validate()
                try self.subOrderList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createDate != nil {
                    map["CreateDate"] = self.createDate!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.extJson != nil {
                    map["ExtJson"] = self.extJson!
                }
                if self.fundStructureModels != nil {
                    map["FundStructureModels"] = self.fundStructureModels?.toMap()
                }
                if self.lmOrderId != nil {
                    map["LmOrderId"] = self.lmOrderId!
                }
                if self.logisticsStatus != nil {
                    map["LogisticsStatus"] = self.logisticsStatus!
                }
                if self.orderAmount != nil {
                    map["OrderAmount"] = self.orderAmount!
                }
                if self.orderStatus != nil {
                    map["OrderStatus"] = self.orderStatus!
                }
                if self.postFee != nil {
                    map["PostFee"] = self.postFee?.toMap()
                }
                if self.shopName != nil {
                    map["ShopName"] = self.shopName!
                }
                if self.subOrderList != nil {
                    map["SubOrderList"] = self.subOrderList?.toMap()
                }
                if self.tbOrderId != nil {
                    map["TbOrderId"] = self.tbOrderId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                    self.createDate = dict["CreateDate"] as! String
                }
                if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                    self.enableStatus = dict["EnableStatus"] as! Int32
                }
                if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                    self.extJson = dict["ExtJson"] as! String
                }
                if dict.keys.contains("FundStructureModels") && dict["FundStructureModels"] != nil {
                    var model = QueryOrderListResponseBody.LmOrderList.LmOrderList.FundStructureModels()
                    model.fromMap(dict["FundStructureModels"] as! [String: Any])
                    self.fundStructureModels = model
                }
                if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                    self.lmOrderId = dict["LmOrderId"] as! Int64
                }
                if dict.keys.contains("LogisticsStatus") && dict["LogisticsStatus"] != nil {
                    self.logisticsStatus = dict["LogisticsStatus"] as! Int32
                }
                if dict.keys.contains("OrderAmount") && dict["OrderAmount"] != nil {
                    self.orderAmount = dict["OrderAmount"] as! Int64
                }
                if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
                    self.orderStatus = dict["OrderStatus"] as! Int32
                }
                if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
                    var model = QueryOrderListResponseBody.LmOrderList.LmOrderList.PostFee()
                    model.fromMap(dict["PostFee"] as! [String: Any])
                    self.postFee = model
                }
                if dict.keys.contains("ShopName") && dict["ShopName"] != nil {
                    self.shopName = dict["ShopName"] as! String
                }
                if dict.keys.contains("SubOrderList") && dict["SubOrderList"] != nil {
                    var model = QueryOrderListResponseBody.LmOrderList.LmOrderList.SubOrderList()
                    model.fromMap(dict["SubOrderList"] as! [String: Any])
                    self.subOrderList = model
                }
                if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                    self.tbOrderId = dict["TbOrderId"] as! Int64
                }
            }
        }
        public var lmOrderList: [QueryOrderListResponseBody.LmOrderList.LmOrderList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmOrderList != nil {
                var tmp : [Any] = []
                for k in self.lmOrderList! {
                    tmp.append(k.toMap())
                }
                map["LmOrderList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
                var tmp : [QueryOrderListResponseBody.LmOrderList.LmOrderList] = []
                for v in dict["LmOrderList"] as! [Any] {
                    var model = QueryOrderListResponseBody.LmOrderList.LmOrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmOrderList = tmp
            }
        }
    }
    public class PostFee : Tea.TeaModel {
        public var fundAmount: Int64?

        public var fundAmountMoney: Int64?

        public var fundType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fundAmount != nil {
                map["FundAmount"] = self.fundAmount!
            }
            if self.fundAmountMoney != nil {
                map["FundAmountMoney"] = self.fundAmountMoney!
            }
            if self.fundType != nil {
                map["FundType"] = self.fundType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                self.fundAmount = dict["FundAmount"] as! Int64
            }
            if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
            }
            if dict.keys.contains("FundType") && dict["FundType"] != nil {
                self.fundType = dict["FundType"] as! String
            }
        }
    }
    public var code: String?

    public var lmOrderList: QueryOrderListResponseBody.LmOrderList?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var postFee: QueryOrderListResponseBody.PostFee?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmOrderList?.validate()
        try self.postFee?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmOrderList != nil {
            map["LmOrderList"] = self.lmOrderList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.postFee != nil {
            map["PostFee"] = self.postFee?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmOrderList") && dict["LmOrderList"] != nil {
            var model = QueryOrderListResponseBody.LmOrderList()
            model.fromMap(dict["LmOrderList"] as! [String: Any])
            self.lmOrderList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
            var model = QueryOrderListResponseBody.PostFee()
            model.fromMap(dict["PostFee"] as! [String: Any])
            self.postFee = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryOrderListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderListWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var filterOption: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.filterOption != nil {
            map["FilterOption"] = self.filterOption!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("FilterOption") && dict["FilterOption"] != nil {
            self.filterOption = dict["FilterOption"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class QueryOrderListWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class FundStructureModels : Tea.TeaModel {
            public var fundAmount: Int64?

            public var fundAmountMoney: Int64?

            public var fundType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fundAmount != nil {
                    map["FundAmount"] = self.fundAmount!
                }
                if self.fundAmountMoney != nil {
                    map["FundAmountMoney"] = self.fundAmountMoney!
                }
                if self.fundType != nil {
                    map["FundType"] = self.fundType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                    self.fundAmount = dict["FundAmount"] as! Int64
                }
                if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                    self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                }
                if dict.keys.contains("FundType") && dict["FundType"] != nil {
                    self.fundType = dict["FundType"] as! String
                }
            }
        }
        public class PostFee : Tea.TeaModel {
            public var fundAmount: Int64?

            public var fundAmountMoney: Int64?

            public var fundType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fundAmount != nil {
                    map["FundAmount"] = self.fundAmount!
                }
                if self.fundAmountMoney != nil {
                    map["FundAmountMoney"] = self.fundAmountMoney!
                }
                if self.fundType != nil {
                    map["FundType"] = self.fundType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                    self.fundAmount = dict["FundAmount"] as! Int64
                }
                if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                    self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                }
                if dict.keys.contains("FundType") && dict["FundType"] != nil {
                    self.fundType = dict["FundType"] as! String
                }
            }
        }
        public class SubOrderList : Tea.TeaModel {
            public class ItemPriceList : Tea.TeaModel {
                public var fundAmount: Int64?

                public var fundAmountMoney: Int64?

                public var fundType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fundAmount != nil {
                        map["FundAmount"] = self.fundAmount!
                    }
                    if self.fundAmountMoney != nil {
                        map["FundAmountMoney"] = self.fundAmountMoney!
                    }
                    if self.fundType != nil {
                        map["FundType"] = self.fundType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FundAmount") && dict["FundAmount"] != nil {
                        self.fundAmount = dict["FundAmount"] as! Int64
                    }
                    if dict.keys.contains("FundAmountMoney") && dict["FundAmountMoney"] != nil {
                        self.fundAmountMoney = dict["FundAmountMoney"] as! Int64
                    }
                    if dict.keys.contains("FundType") && dict["FundType"] != nil {
                        self.fundType = dict["FundType"] as! String
                    }
                }
            }
            public var enableStatus: Int32?

            public var itemId: Int64?

            public var itemPic: String?

            public var itemPriceList: [QueryOrderListWithDesignatedTbUidResponseBody.Model.SubOrderList.ItemPriceList]?

            public var itemTitle: String?

            public var lmItemId: String?

            public var lmOrderId: Int64?

            public var number: Int64?

            public var orderStatus: Int32?

            public var skuId: String?

            public var skuName: String?

            public var tbOrderId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemPic != nil {
                    map["ItemPic"] = self.itemPic!
                }
                if self.itemPriceList != nil {
                    var tmp : [Any] = []
                    for k in self.itemPriceList! {
                        tmp.append(k.toMap())
                    }
                    map["ItemPriceList"] = tmp
                }
                if self.itemTitle != nil {
                    map["ItemTitle"] = self.itemTitle!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.lmOrderId != nil {
                    map["LmOrderId"] = self.lmOrderId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.orderStatus != nil {
                    map["OrderStatus"] = self.orderStatus!
                }
                if self.skuId != nil {
                    map["SkuId"] = self.skuId!
                }
                if self.skuName != nil {
                    map["SkuName"] = self.skuName!
                }
                if self.tbOrderId != nil {
                    map["TbOrderId"] = self.tbOrderId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                    self.enableStatus = dict["EnableStatus"] as! Int32
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ItemPic") && dict["ItemPic"] != nil {
                    self.itemPic = dict["ItemPic"] as! String
                }
                if dict.keys.contains("ItemPriceList") && dict["ItemPriceList"] != nil {
                    var tmp : [QueryOrderListWithDesignatedTbUidResponseBody.Model.SubOrderList.ItemPriceList] = []
                    for v in dict["ItemPriceList"] as! [Any] {
                        var model = QueryOrderListWithDesignatedTbUidResponseBody.Model.SubOrderList.ItemPriceList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.itemPriceList = tmp
                }
                if dict.keys.contains("ItemTitle") && dict["ItemTitle"] != nil {
                    self.itemTitle = dict["ItemTitle"] as! String
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                    self.lmOrderId = dict["LmOrderId"] as! Int64
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! Int64
                }
                if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
                    self.orderStatus = dict["OrderStatus"] as! Int32
                }
                if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                    self.skuId = dict["SkuId"] as! String
                }
                if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                    self.skuName = dict["SkuName"] as! String
                }
                if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                    self.tbOrderId = dict["TbOrderId"] as! Int64
                }
            }
        }
        public var createTime: String?

        public var enableStatus: Int32?

        public var extJson: String?

        public var fundStructureModels: [QueryOrderListWithDesignatedTbUidResponseBody.Model.FundStructureModels]?

        public var lmOrderId: Int64?

        public var logisticsStatus: Int32?

        public var orderAmount: Int64?

        public var orderStatus: Int32?

        public var postFee: QueryOrderListWithDesignatedTbUidResponseBody.Model.PostFee?

        public var shopName: String?

        public var subOrderList: [QueryOrderListWithDesignatedTbUidResponseBody.Model.SubOrderList]?

        public var tbOrderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.postFee?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.enableStatus != nil {
                map["EnableStatus"] = self.enableStatus!
            }
            if self.extJson != nil {
                map["ExtJson"] = self.extJson!
            }
            if self.fundStructureModels != nil {
                var tmp : [Any] = []
                for k in self.fundStructureModels! {
                    tmp.append(k.toMap())
                }
                map["FundStructureModels"] = tmp
            }
            if self.lmOrderId != nil {
                map["LmOrderId"] = self.lmOrderId!
            }
            if self.logisticsStatus != nil {
                map["LogisticsStatus"] = self.logisticsStatus!
            }
            if self.orderAmount != nil {
                map["OrderAmount"] = self.orderAmount!
            }
            if self.orderStatus != nil {
                map["OrderStatus"] = self.orderStatus!
            }
            if self.postFee != nil {
                map["PostFee"] = self.postFee?.toMap()
            }
            if self.shopName != nil {
                map["ShopName"] = self.shopName!
            }
            if self.subOrderList != nil {
                var tmp : [Any] = []
                for k in self.subOrderList! {
                    tmp.append(k.toMap())
                }
                map["SubOrderList"] = tmp
            }
            if self.tbOrderId != nil {
                map["TbOrderId"] = self.tbOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                self.enableStatus = dict["EnableStatus"] as! Int32
            }
            if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
                self.extJson = dict["ExtJson"] as! String
            }
            if dict.keys.contains("FundStructureModels") && dict["FundStructureModels"] != nil {
                var tmp : [QueryOrderListWithDesignatedTbUidResponseBody.Model.FundStructureModels] = []
                for v in dict["FundStructureModels"] as! [Any] {
                    var model = QueryOrderListWithDesignatedTbUidResponseBody.Model.FundStructureModels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fundStructureModels = tmp
            }
            if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                self.lmOrderId = dict["LmOrderId"] as! Int64
            }
            if dict.keys.contains("LogisticsStatus") && dict["LogisticsStatus"] != nil {
                self.logisticsStatus = dict["LogisticsStatus"] as! Int32
            }
            if dict.keys.contains("OrderAmount") && dict["OrderAmount"] != nil {
                self.orderAmount = dict["OrderAmount"] as! Int64
            }
            if dict.keys.contains("OrderStatus") && dict["OrderStatus"] != nil {
                self.orderStatus = dict["OrderStatus"] as! Int32
            }
            if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
                var model = QueryOrderListWithDesignatedTbUidResponseBody.Model.PostFee()
                model.fromMap(dict["PostFee"] as! [String: Any])
                self.postFee = model
            }
            if dict.keys.contains("ShopName") && dict["ShopName"] != nil {
                self.shopName = dict["ShopName"] as! String
            }
            if dict.keys.contains("SubOrderList") && dict["SubOrderList"] != nil {
                var tmp : [QueryOrderListWithDesignatedTbUidResponseBody.Model.SubOrderList] = []
                for v in dict["SubOrderList"] as! [Any] {
                    var model = QueryOrderListWithDesignatedTbUidResponseBody.Model.SubOrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subOrderList = tmp
            }
            if dict.keys.contains("TbOrderId") && dict["TbOrderId"] != nil {
                self.tbOrderId = dict["TbOrderId"] as! Int64
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: [QueryOrderListWithDesignatedTbUidResponseBody.Model]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [QueryOrderListWithDesignatedTbUidResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = QueryOrderListWithDesignatedTbUidResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryOrderListWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderListWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderListWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderLogisticsRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var lmOrderId: Int64?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryOrderLogisticsResponseBody : Tea.TeaModel {
    public class OrderLogistics : Tea.TeaModel {
        public class Fetcher : Tea.TeaModel {
            public var address: String?

            public var name: String?

            public var phoneNumber: String?

            public var zipCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.zipCode != nil {
                    map["ZipCode"] = self.zipCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("ZipCode") && dict["ZipCode"] != nil {
                    self.zipCode = dict["ZipCode"] as! String
                }
            }
        }
        public class LogisticsDetailList : Tea.TeaModel {
            public class LogisticsDetailList : Tea.TeaModel {
                public var ocurrTimeStr: String?

                public var standerdDesc: String?

                public var statusIcon: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ocurrTimeStr != nil {
                        map["OcurrTimeStr"] = self.ocurrTimeStr!
                    }
                    if self.standerdDesc != nil {
                        map["StanderdDesc"] = self.standerdDesc!
                    }
                    if self.statusIcon != nil {
                        map["StatusIcon"] = self.statusIcon!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OcurrTimeStr") && dict["OcurrTimeStr"] != nil {
                        self.ocurrTimeStr = dict["OcurrTimeStr"] as! String
                    }
                    if dict.keys.contains("StanderdDesc") && dict["StanderdDesc"] != nil {
                        self.standerdDesc = dict["StanderdDesc"] as! String
                    }
                    if dict.keys.contains("StatusIcon") && dict["StatusIcon"] != nil {
                        self.statusIcon = dict["StatusIcon"] as! String
                    }
                }
            }
            public var logisticsDetailList: [QueryOrderLogisticsResponseBody.OrderLogistics.LogisticsDetailList.LogisticsDetailList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logisticsDetailList != nil {
                    var tmp : [Any] = []
                    for k in self.logisticsDetailList! {
                        tmp.append(k.toMap())
                    }
                    map["LogisticsDetailList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LogisticsDetailList") && dict["LogisticsDetailList"] != nil {
                    var tmp : [QueryOrderLogisticsResponseBody.OrderLogistics.LogisticsDetailList.LogisticsDetailList] = []
                    for v in dict["LogisticsDetailList"] as! [Any] {
                        var model = QueryOrderLogisticsResponseBody.OrderLogistics.LogisticsDetailList.LogisticsDetailList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.logisticsDetailList = tmp
                }
            }
        }
        public class Receiver : Tea.TeaModel {
            public var address: String?

            public var name: String?

            public var phoneNumber: String?

            public var zipCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.zipCode != nil {
                    map["ZipCode"] = self.zipCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("ZipCode") && dict["ZipCode"] != nil {
                    self.zipCode = dict["ZipCode"] as! String
                }
            }
        }
        public var dataProvider: String?

        public var dataProviderTitle: String?

        public var fetcher: QueryOrderLogisticsResponseBody.OrderLogistics.Fetcher?

        public var logisticsCompanyCode: String?

        public var logisticsCompanyName: String?

        public var logisticsDetailList: QueryOrderLogisticsResponseBody.OrderLogistics.LogisticsDetailList?

        public var receiver: QueryOrderLogisticsResponseBody.OrderLogistics.Receiver?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.fetcher?.validate()
            try self.logisticsDetailList?.validate()
            try self.receiver?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataProvider != nil {
                map["DataProvider"] = self.dataProvider!
            }
            if self.dataProviderTitle != nil {
                map["DataProviderTitle"] = self.dataProviderTitle!
            }
            if self.fetcher != nil {
                map["Fetcher"] = self.fetcher?.toMap()
            }
            if self.logisticsCompanyCode != nil {
                map["LogisticsCompanyCode"] = self.logisticsCompanyCode!
            }
            if self.logisticsCompanyName != nil {
                map["LogisticsCompanyName"] = self.logisticsCompanyName!
            }
            if self.logisticsDetailList != nil {
                map["LogisticsDetailList"] = self.logisticsDetailList?.toMap()
            }
            if self.receiver != nil {
                map["Receiver"] = self.receiver?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataProvider") && dict["DataProvider"] != nil {
                self.dataProvider = dict["DataProvider"] as! String
            }
            if dict.keys.contains("DataProviderTitle") && dict["DataProviderTitle"] != nil {
                self.dataProviderTitle = dict["DataProviderTitle"] as! String
            }
            if dict.keys.contains("Fetcher") && dict["Fetcher"] != nil {
                var model = QueryOrderLogisticsResponseBody.OrderLogistics.Fetcher()
                model.fromMap(dict["Fetcher"] as! [String: Any])
                self.fetcher = model
            }
            if dict.keys.contains("LogisticsCompanyCode") && dict["LogisticsCompanyCode"] != nil {
                self.logisticsCompanyCode = dict["LogisticsCompanyCode"] as! String
            }
            if dict.keys.contains("LogisticsCompanyName") && dict["LogisticsCompanyName"] != nil {
                self.logisticsCompanyName = dict["LogisticsCompanyName"] as! String
            }
            if dict.keys.contains("LogisticsDetailList") && dict["LogisticsDetailList"] != nil {
                var model = QueryOrderLogisticsResponseBody.OrderLogistics.LogisticsDetailList()
                model.fromMap(dict["LogisticsDetailList"] as! [String: Any])
                self.logisticsDetailList = model
            }
            if dict.keys.contains("Receiver") && dict["Receiver"] != nil {
                var model = QueryOrderLogisticsResponseBody.OrderLogistics.Receiver()
                model.fromMap(dict["Receiver"] as! [String: Any])
                self.receiver = model
            }
        }
    }
    public var code: String?

    public var message: String?

    public var orderLogistics: QueryOrderLogisticsResponseBody.OrderLogistics?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.orderLogistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.orderLogistics != nil {
            map["OrderLogistics"] = self.orderLogistics?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OrderLogistics") && dict["OrderLogistics"] != nil {
            var model = QueryOrderLogisticsResponseBody.OrderLogistics()
            model.fromMap(dict["OrderLogistics"] as! [String: Any])
            self.orderLogistics = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryOrderLogisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderLogisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderLogisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrderLogisticsWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmOrderId: Int64?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class QueryOrderLogisticsWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class Fetcher : Tea.TeaModel {
            public var address: String?

            public var name: String?

            public var phoneNumber: String?

            public var requestId: String?

            public var zipCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.zipCode != nil {
                    map["ZipCode"] = self.zipCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ZipCode") && dict["ZipCode"] != nil {
                    self.zipCode = dict["ZipCode"] as! String
                }
            }
        }
        public class LogisticsDetailList : Tea.TeaModel {
            public var ocurrTimeStr: String?

            public var requestId: String?

            public var standerdDesc: String?

            public var statusIcon: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ocurrTimeStr != nil {
                    map["OcurrTimeStr"] = self.ocurrTimeStr!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.standerdDesc != nil {
                    map["StanderdDesc"] = self.standerdDesc!
                }
                if self.statusIcon != nil {
                    map["StatusIcon"] = self.statusIcon!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OcurrTimeStr") && dict["OcurrTimeStr"] != nil {
                    self.ocurrTimeStr = dict["OcurrTimeStr"] as! String
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("StanderdDesc") && dict["StanderdDesc"] != nil {
                    self.standerdDesc = dict["StanderdDesc"] as! String
                }
                if dict.keys.contains("StatusIcon") && dict["StatusIcon"] != nil {
                    self.statusIcon = dict["StatusIcon"] as! String
                }
            }
        }
        public class PackageGoodItems : Tea.TeaModel {
            public var itemId: Int64?

            public var lmItemId: String?

            public var name: String?

            public var quantity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.quantity != nil {
                    map["Quantity"] = self.quantity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                    self.quantity = dict["Quantity"] as! Int32
                }
            }
        }
        public class Receiver : Tea.TeaModel {
            public var address: String?

            public var name: String?

            public var phoneNumber: String?

            public var requestId: String?

            public var zipCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.zipCode != nil {
                    map["ZipCode"] = self.zipCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ZipCode") && dict["ZipCode"] != nil {
                    self.zipCode = dict["ZipCode"] as! String
                }
            }
        }
        public var dataProvider: String?

        public var dataProviderTitle: String?

        public var fetcher: QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.Fetcher?

        public var logisticsCompanyCode: String?

        public var logisticsCompanyName: String?

        public var logisticsDetailList: [QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.LogisticsDetailList]?

        public var mailNo: String?

        public var packageGoodItems: [QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.PackageGoodItems]?

        public var receiver: QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.Receiver?

        public var requestId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.fetcher?.validate()
            try self.receiver?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataProvider != nil {
                map["DataProvider"] = self.dataProvider!
            }
            if self.dataProviderTitle != nil {
                map["DataProviderTitle"] = self.dataProviderTitle!
            }
            if self.fetcher != nil {
                map["Fetcher"] = self.fetcher?.toMap()
            }
            if self.logisticsCompanyCode != nil {
                map["LogisticsCompanyCode"] = self.logisticsCompanyCode!
            }
            if self.logisticsCompanyName != nil {
                map["LogisticsCompanyName"] = self.logisticsCompanyName!
            }
            if self.logisticsDetailList != nil {
                var tmp : [Any] = []
                for k in self.logisticsDetailList! {
                    tmp.append(k.toMap())
                }
                map["LogisticsDetailList"] = tmp
            }
            if self.mailNo != nil {
                map["MailNo"] = self.mailNo!
            }
            if self.packageGoodItems != nil {
                var tmp : [Any] = []
                for k in self.packageGoodItems! {
                    tmp.append(k.toMap())
                }
                map["PackageGoodItems"] = tmp
            }
            if self.receiver != nil {
                map["Receiver"] = self.receiver?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataProvider") && dict["DataProvider"] != nil {
                self.dataProvider = dict["DataProvider"] as! String
            }
            if dict.keys.contains("DataProviderTitle") && dict["DataProviderTitle"] != nil {
                self.dataProviderTitle = dict["DataProviderTitle"] as! String
            }
            if dict.keys.contains("Fetcher") && dict["Fetcher"] != nil {
                var model = QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.Fetcher()
                model.fromMap(dict["Fetcher"] as! [String: Any])
                self.fetcher = model
            }
            if dict.keys.contains("LogisticsCompanyCode") && dict["LogisticsCompanyCode"] != nil {
                self.logisticsCompanyCode = dict["LogisticsCompanyCode"] as! String
            }
            if dict.keys.contains("LogisticsCompanyName") && dict["LogisticsCompanyName"] != nil {
                self.logisticsCompanyName = dict["LogisticsCompanyName"] as! String
            }
            if dict.keys.contains("LogisticsDetailList") && dict["LogisticsDetailList"] != nil {
                var tmp : [QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.LogisticsDetailList] = []
                for v in dict["LogisticsDetailList"] as! [Any] {
                    var model = QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.LogisticsDetailList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logisticsDetailList = tmp
            }
            if dict.keys.contains("MailNo") && dict["MailNo"] != nil {
                self.mailNo = dict["MailNo"] as! String
            }
            if dict.keys.contains("PackageGoodItems") && dict["PackageGoodItems"] != nil {
                var tmp : [QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.PackageGoodItems] = []
                for v in dict["PackageGoodItems"] as! [Any] {
                    var model = QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.PackageGoodItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.packageGoodItems = tmp
            }
            if dict.keys.contains("Receiver") && dict["Receiver"] != nil {
                var model = QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model.Receiver()
                model.fromMap(dict["Receiver"] as! [String: Any])
                self.receiver = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: [QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = QueryOrderLogisticsWithDesignatedTbUidResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryOrderLogisticsWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrderLogisticsWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrderLogisticsWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRealTbAccountSupportRequest : Tea.TeaModel {
    public var bizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
    }
}

public class QueryRealTbAccountSupportResponseBody : Tea.TeaModel {
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: Bool?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Bool
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryRealTbAccountSupportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRealTbAccountSupportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryRealTbAccountSupportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRefundApplicationDetailRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var subLmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class QueryRefundApplicationDetailResponseBody : Tea.TeaModel {
    public class RefundApplicationDetail : Tea.TeaModel {
        public class ApplyReasonText : Tea.TeaModel {
            public var reasonTextId: Int64?

            public var reasonTips: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.reasonTextId != nil {
                    map["ReasonTextId"] = self.reasonTextId!
                }
                if self.reasonTips != nil {
                    map["ReasonTips"] = self.reasonTips!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReasonTextId") && dict["ReasonTextId"] != nil {
                    self.reasonTextId = dict["ReasonTextId"] as! Int64
                }
                if dict.keys.contains("ReasonTips") && dict["ReasonTips"] != nil {
                    self.reasonTips = dict["ReasonTips"] as! String
                }
            }
        }
        public class MaxRefundFeeData : Tea.TeaModel {
            public var maxRefundFee: Int32?

            public var minRefundFee: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxRefundFee != nil {
                    map["MaxRefundFee"] = self.maxRefundFee!
                }
                if self.minRefundFee != nil {
                    map["MinRefundFee"] = self.minRefundFee!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxRefundFee") && dict["MaxRefundFee"] != nil {
                    self.maxRefundFee = dict["MaxRefundFee"] as! Int32
                }
                if dict.keys.contains("MinRefundFee") && dict["MinRefundFee"] != nil {
                    self.minRefundFee = dict["MinRefundFee"] as! Int32
                }
            }
        }
        public var applyDisputeDesc: String?

        public var applyReasonText: QueryRefundApplicationDetailResponseBody.RefundApplicationDetail.ApplyReasonText?

        public var bizClaimType: Int32?

        public var disputeCreateTime: String?

        public var disputeDesc: String?

        public var disputeEndTime: String?

        public var disputeId: Int64?

        public var disputeStatus: Int32?

        public var disputeType: Int32?

        public var lmOrderId: String?

        public var maxRefundFeeData: QueryRefundApplicationDetailResponseBody.RefundApplicationDetail.MaxRefundFeeData?

        public var orderLogisticsStatus: Int32?

        public var realRefundFee: Int64?

        public var refundFee: Int64?

        public var refunderAddress: String?

        public var refunderName: String?

        public var refunderTel: String?

        public var refunderZipCode: String?

        public var returnGoodCount: Int32?

        public var returnGoodLogisticsStatus: Int32?

        public var sellerAgreeMsg: String?

        public var sellerRefuseAgreementMessage: String?

        public var sellerRefuseReason: String?

        public var subLmOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.applyReasonText?.validate()
            try self.maxRefundFeeData?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyDisputeDesc != nil {
                map["ApplyDisputeDesc"] = self.applyDisputeDesc!
            }
            if self.applyReasonText != nil {
                map["ApplyReasonText"] = self.applyReasonText?.toMap()
            }
            if self.bizClaimType != nil {
                map["BizClaimType"] = self.bizClaimType!
            }
            if self.disputeCreateTime != nil {
                map["DisputeCreateTime"] = self.disputeCreateTime!
            }
            if self.disputeDesc != nil {
                map["DisputeDesc"] = self.disputeDesc!
            }
            if self.disputeEndTime != nil {
                map["DisputeEndTime"] = self.disputeEndTime!
            }
            if self.disputeId != nil {
                map["DisputeId"] = self.disputeId!
            }
            if self.disputeStatus != nil {
                map["DisputeStatus"] = self.disputeStatus!
            }
            if self.disputeType != nil {
                map["DisputeType"] = self.disputeType!
            }
            if self.lmOrderId != nil {
                map["LmOrderId"] = self.lmOrderId!
            }
            if self.maxRefundFeeData != nil {
                map["MaxRefundFeeData"] = self.maxRefundFeeData?.toMap()
            }
            if self.orderLogisticsStatus != nil {
                map["OrderLogisticsStatus"] = self.orderLogisticsStatus!
            }
            if self.realRefundFee != nil {
                map["RealRefundFee"] = self.realRefundFee!
            }
            if self.refundFee != nil {
                map["RefundFee"] = self.refundFee!
            }
            if self.refunderAddress != nil {
                map["RefunderAddress"] = self.refunderAddress!
            }
            if self.refunderName != nil {
                map["RefunderName"] = self.refunderName!
            }
            if self.refunderTel != nil {
                map["RefunderTel"] = self.refunderTel!
            }
            if self.refunderZipCode != nil {
                map["RefunderZipCode"] = self.refunderZipCode!
            }
            if self.returnGoodCount != nil {
                map["ReturnGoodCount"] = self.returnGoodCount!
            }
            if self.returnGoodLogisticsStatus != nil {
                map["ReturnGoodLogisticsStatus"] = self.returnGoodLogisticsStatus!
            }
            if self.sellerAgreeMsg != nil {
                map["SellerAgreeMsg"] = self.sellerAgreeMsg!
            }
            if self.sellerRefuseAgreementMessage != nil {
                map["SellerRefuseAgreementMessage"] = self.sellerRefuseAgreementMessage!
            }
            if self.sellerRefuseReason != nil {
                map["SellerRefuseReason"] = self.sellerRefuseReason!
            }
            if self.subLmOrderId != nil {
                map["SubLmOrderId"] = self.subLmOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyDisputeDesc") && dict["ApplyDisputeDesc"] != nil {
                self.applyDisputeDesc = dict["ApplyDisputeDesc"] as! String
            }
            if dict.keys.contains("ApplyReasonText") && dict["ApplyReasonText"] != nil {
                var model = QueryRefundApplicationDetailResponseBody.RefundApplicationDetail.ApplyReasonText()
                model.fromMap(dict["ApplyReasonText"] as! [String: Any])
                self.applyReasonText = model
            }
            if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
                self.bizClaimType = dict["BizClaimType"] as! Int32
            }
            if dict.keys.contains("DisputeCreateTime") && dict["DisputeCreateTime"] != nil {
                self.disputeCreateTime = dict["DisputeCreateTime"] as! String
            }
            if dict.keys.contains("DisputeDesc") && dict["DisputeDesc"] != nil {
                self.disputeDesc = dict["DisputeDesc"] as! String
            }
            if dict.keys.contains("DisputeEndTime") && dict["DisputeEndTime"] != nil {
                self.disputeEndTime = dict["DisputeEndTime"] as! String
            }
            if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
                self.disputeId = dict["DisputeId"] as! Int64
            }
            if dict.keys.contains("DisputeStatus") && dict["DisputeStatus"] != nil {
                self.disputeStatus = dict["DisputeStatus"] as! Int32
            }
            if dict.keys.contains("DisputeType") && dict["DisputeType"] != nil {
                self.disputeType = dict["DisputeType"] as! Int32
            }
            if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                self.lmOrderId = dict["LmOrderId"] as! String
            }
            if dict.keys.contains("MaxRefundFeeData") && dict["MaxRefundFeeData"] != nil {
                var model = QueryRefundApplicationDetailResponseBody.RefundApplicationDetail.MaxRefundFeeData()
                model.fromMap(dict["MaxRefundFeeData"] as! [String: Any])
                self.maxRefundFeeData = model
            }
            if dict.keys.contains("OrderLogisticsStatus") && dict["OrderLogisticsStatus"] != nil {
                self.orderLogisticsStatus = dict["OrderLogisticsStatus"] as! Int32
            }
            if dict.keys.contains("RealRefundFee") && dict["RealRefundFee"] != nil {
                self.realRefundFee = dict["RealRefundFee"] as! Int64
            }
            if dict.keys.contains("RefundFee") && dict["RefundFee"] != nil {
                self.refundFee = dict["RefundFee"] as! Int64
            }
            if dict.keys.contains("RefunderAddress") && dict["RefunderAddress"] != nil {
                self.refunderAddress = dict["RefunderAddress"] as! String
            }
            if dict.keys.contains("RefunderName") && dict["RefunderName"] != nil {
                self.refunderName = dict["RefunderName"] as! String
            }
            if dict.keys.contains("RefunderTel") && dict["RefunderTel"] != nil {
                self.refunderTel = dict["RefunderTel"] as! String
            }
            if dict.keys.contains("RefunderZipCode") && dict["RefunderZipCode"] != nil {
                self.refunderZipCode = dict["RefunderZipCode"] as! String
            }
            if dict.keys.contains("ReturnGoodCount") && dict["ReturnGoodCount"] != nil {
                self.returnGoodCount = dict["ReturnGoodCount"] as! Int32
            }
            if dict.keys.contains("ReturnGoodLogisticsStatus") && dict["ReturnGoodLogisticsStatus"] != nil {
                self.returnGoodLogisticsStatus = dict["ReturnGoodLogisticsStatus"] as! Int32
            }
            if dict.keys.contains("SellerAgreeMsg") && dict["SellerAgreeMsg"] != nil {
                self.sellerAgreeMsg = dict["SellerAgreeMsg"] as! String
            }
            if dict.keys.contains("SellerRefuseAgreementMessage") && dict["SellerRefuseAgreementMessage"] != nil {
                self.sellerRefuseAgreementMessage = dict["SellerRefuseAgreementMessage"] as! String
            }
            if dict.keys.contains("SellerRefuseReason") && dict["SellerRefuseReason"] != nil {
                self.sellerRefuseReason = dict["SellerRefuseReason"] as! String
            }
            if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
                self.subLmOrderId = dict["SubLmOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var refundApplicationDetail: QueryRefundApplicationDetailResponseBody.RefundApplicationDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.refundApplicationDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.refundApplicationDetail != nil {
            map["RefundApplicationDetail"] = self.refundApplicationDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RefundApplicationDetail") && dict["RefundApplicationDetail"] != nil {
            var model = QueryRefundApplicationDetailResponseBody.RefundApplicationDetail()
            model.fromMap(dict["RefundApplicationDetail"] as! [String: Any])
            self.refundApplicationDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryRefundApplicationDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRefundApplicationDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryRefundApplicationDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRefundApplyWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var subLmOrderId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class QueryRefundApplyWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class ApplyReasonText : Tea.TeaModel {
            public var proofRequired: Bool?

            public var reasonTextId: Int64?

            public var reasonTips: String?

            public var refundDescRequired: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.proofRequired != nil {
                    map["ProofRequired"] = self.proofRequired!
                }
                if self.reasonTextId != nil {
                    map["ReasonTextId"] = self.reasonTextId!
                }
                if self.reasonTips != nil {
                    map["ReasonTips"] = self.reasonTips!
                }
                if self.refundDescRequired != nil {
                    map["RefundDescRequired"] = self.refundDescRequired!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ProofRequired") && dict["ProofRequired"] != nil {
                    self.proofRequired = dict["ProofRequired"] as! Bool
                }
                if dict.keys.contains("ReasonTextId") && dict["ReasonTextId"] != nil {
                    self.reasonTextId = dict["ReasonTextId"] as! Int64
                }
                if dict.keys.contains("ReasonTips") && dict["ReasonTips"] != nil {
                    self.reasonTips = dict["ReasonTips"] as! String
                }
                if dict.keys.contains("RefundDescRequired") && dict["RefundDescRequired"] != nil {
                    self.refundDescRequired = dict["RefundDescRequired"] as! Bool
                }
            }
        }
        public class MaxRefundFeeData : Tea.TeaModel {
            public var maxRefundFee: Int64?

            public var minRefundFee: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxRefundFee != nil {
                    map["MaxRefundFee"] = self.maxRefundFee!
                }
                if self.minRefundFee != nil {
                    map["MinRefundFee"] = self.minRefundFee!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxRefundFee") && dict["MaxRefundFee"] != nil {
                    self.maxRefundFee = dict["MaxRefundFee"] as! Int64
                }
                if dict.keys.contains("MinRefundFee") && dict["MinRefundFee"] != nil {
                    self.minRefundFee = dict["MinRefundFee"] as! Int64
                }
            }
        }
        public var applyDisputeDesc: String?

        public var applyReasonText: QueryRefundApplyWithDesignatedTbUidResponseBody.Model.ApplyReasonText?

        public var bizClaimType: Int32?

        public var disputeCreateTime: String?

        public var disputeDesc: String?

        public var disputeEndTime: String?

        public var disputeId: Int64?

        public var disputeStatus: Int32?

        public var disputeType: Int32?

        public var lmOrderId: String?

        public var maxRefundFeeData: QueryRefundApplyWithDesignatedTbUidResponseBody.Model.MaxRefundFeeData?

        public var orderLogisticsStatus: Int32?

        public var realRefundFee: Int64?

        public var refundFee: Int64?

        public var refunderAddress: String?

        public var refunderName: String?

        public var refunderTel: String?

        public var refunderZipCode: String?

        public var returnGoodCount: Int32?

        public var returnGoodLogisticsStatus: Int32?

        public var sellerAgreeMsg: String?

        public var sellerRefuseAgreementMessage: String?

        public var sellerRefuseReason: String?

        public var subLmOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.applyReasonText?.validate()
            try self.maxRefundFeeData?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyDisputeDesc != nil {
                map["ApplyDisputeDesc"] = self.applyDisputeDesc!
            }
            if self.applyReasonText != nil {
                map["ApplyReasonText"] = self.applyReasonText?.toMap()
            }
            if self.bizClaimType != nil {
                map["BizClaimType"] = self.bizClaimType!
            }
            if self.disputeCreateTime != nil {
                map["DisputeCreateTime"] = self.disputeCreateTime!
            }
            if self.disputeDesc != nil {
                map["DisputeDesc"] = self.disputeDesc!
            }
            if self.disputeEndTime != nil {
                map["DisputeEndTime"] = self.disputeEndTime!
            }
            if self.disputeId != nil {
                map["DisputeId"] = self.disputeId!
            }
            if self.disputeStatus != nil {
                map["DisputeStatus"] = self.disputeStatus!
            }
            if self.disputeType != nil {
                map["DisputeType"] = self.disputeType!
            }
            if self.lmOrderId != nil {
                map["LmOrderId"] = self.lmOrderId!
            }
            if self.maxRefundFeeData != nil {
                map["MaxRefundFeeData"] = self.maxRefundFeeData?.toMap()
            }
            if self.orderLogisticsStatus != nil {
                map["OrderLogisticsStatus"] = self.orderLogisticsStatus!
            }
            if self.realRefundFee != nil {
                map["RealRefundFee"] = self.realRefundFee!
            }
            if self.refundFee != nil {
                map["RefundFee"] = self.refundFee!
            }
            if self.refunderAddress != nil {
                map["RefunderAddress"] = self.refunderAddress!
            }
            if self.refunderName != nil {
                map["RefunderName"] = self.refunderName!
            }
            if self.refunderTel != nil {
                map["RefunderTel"] = self.refunderTel!
            }
            if self.refunderZipCode != nil {
                map["RefunderZipCode"] = self.refunderZipCode!
            }
            if self.returnGoodCount != nil {
                map["ReturnGoodCount"] = self.returnGoodCount!
            }
            if self.returnGoodLogisticsStatus != nil {
                map["ReturnGoodLogisticsStatus"] = self.returnGoodLogisticsStatus!
            }
            if self.sellerAgreeMsg != nil {
                map["SellerAgreeMsg"] = self.sellerAgreeMsg!
            }
            if self.sellerRefuseAgreementMessage != nil {
                map["SellerRefuseAgreementMessage"] = self.sellerRefuseAgreementMessage!
            }
            if self.sellerRefuseReason != nil {
                map["SellerRefuseReason"] = self.sellerRefuseReason!
            }
            if self.subLmOrderId != nil {
                map["SubLmOrderId"] = self.subLmOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyDisputeDesc") && dict["ApplyDisputeDesc"] != nil {
                self.applyDisputeDesc = dict["ApplyDisputeDesc"] as! String
            }
            if dict.keys.contains("ApplyReasonText") && dict["ApplyReasonText"] != nil {
                var model = QueryRefundApplyWithDesignatedTbUidResponseBody.Model.ApplyReasonText()
                model.fromMap(dict["ApplyReasonText"] as! [String: Any])
                self.applyReasonText = model
            }
            if dict.keys.contains("BizClaimType") && dict["BizClaimType"] != nil {
                self.bizClaimType = dict["BizClaimType"] as! Int32
            }
            if dict.keys.contains("DisputeCreateTime") && dict["DisputeCreateTime"] != nil {
                self.disputeCreateTime = dict["DisputeCreateTime"] as! String
            }
            if dict.keys.contains("DisputeDesc") && dict["DisputeDesc"] != nil {
                self.disputeDesc = dict["DisputeDesc"] as! String
            }
            if dict.keys.contains("DisputeEndTime") && dict["DisputeEndTime"] != nil {
                self.disputeEndTime = dict["DisputeEndTime"] as! String
            }
            if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
                self.disputeId = dict["DisputeId"] as! Int64
            }
            if dict.keys.contains("DisputeStatus") && dict["DisputeStatus"] != nil {
                self.disputeStatus = dict["DisputeStatus"] as! Int32
            }
            if dict.keys.contains("DisputeType") && dict["DisputeType"] != nil {
                self.disputeType = dict["DisputeType"] as! Int32
            }
            if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
                self.lmOrderId = dict["LmOrderId"] as! String
            }
            if dict.keys.contains("MaxRefundFeeData") && dict["MaxRefundFeeData"] != nil {
                var model = QueryRefundApplyWithDesignatedTbUidResponseBody.Model.MaxRefundFeeData()
                model.fromMap(dict["MaxRefundFeeData"] as! [String: Any])
                self.maxRefundFeeData = model
            }
            if dict.keys.contains("OrderLogisticsStatus") && dict["OrderLogisticsStatus"] != nil {
                self.orderLogisticsStatus = dict["OrderLogisticsStatus"] as! Int32
            }
            if dict.keys.contains("RealRefundFee") && dict["RealRefundFee"] != nil {
                self.realRefundFee = dict["RealRefundFee"] as! Int64
            }
            if dict.keys.contains("RefundFee") && dict["RefundFee"] != nil {
                self.refundFee = dict["RefundFee"] as! Int64
            }
            if dict.keys.contains("RefunderAddress") && dict["RefunderAddress"] != nil {
                self.refunderAddress = dict["RefunderAddress"] as! String
            }
            if dict.keys.contains("RefunderName") && dict["RefunderName"] != nil {
                self.refunderName = dict["RefunderName"] as! String
            }
            if dict.keys.contains("RefunderTel") && dict["RefunderTel"] != nil {
                self.refunderTel = dict["RefunderTel"] as! String
            }
            if dict.keys.contains("RefunderZipCode") && dict["RefunderZipCode"] != nil {
                self.refunderZipCode = dict["RefunderZipCode"] as! String
            }
            if dict.keys.contains("ReturnGoodCount") && dict["ReturnGoodCount"] != nil {
                self.returnGoodCount = dict["ReturnGoodCount"] as! Int32
            }
            if dict.keys.contains("ReturnGoodLogisticsStatus") && dict["ReturnGoodLogisticsStatus"] != nil {
                self.returnGoodLogisticsStatus = dict["ReturnGoodLogisticsStatus"] as! Int32
            }
            if dict.keys.contains("SellerAgreeMsg") && dict["SellerAgreeMsg"] != nil {
                self.sellerAgreeMsg = dict["SellerAgreeMsg"] as! String
            }
            if dict.keys.contains("SellerRefuseAgreementMessage") && dict["SellerRefuseAgreementMessage"] != nil {
                self.sellerRefuseAgreementMessage = dict["SellerRefuseAgreementMessage"] as! String
            }
            if dict.keys.contains("SellerRefuseReason") && dict["SellerRefuseReason"] != nil {
                self.sellerRefuseReason = dict["SellerRefuseReason"] as! String
            }
            if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
                self.subLmOrderId = dict["SubLmOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: QueryRefundApplyWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryRefundApplyWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryRefundApplyWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRefundApplyWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryRefundApplyWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySellerLicenseRequest : Tea.TeaModel {
    public var bizId: String?

    public var sellerId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.sellerId != nil {
            map["SellerId"] = self.sellerId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
            self.sellerId = dict["SellerId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class QuerySellerLicenseResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var licenseUrl: String?

        public var sellerId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.licenseUrl != nil {
                map["LicenseUrl"] = self.licenseUrl!
            }
            if self.sellerId != nil {
                map["SellerId"] = self.sellerId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LicenseUrl") && dict["LicenseUrl"] != nil {
                self.licenseUrl = dict["LicenseUrl"] as! String
            }
            if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                self.sellerId = dict["SellerId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: QuerySellerLicenseResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QuerySellerLicenseResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QuerySellerLicenseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySellerLicenseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QuerySellerLicenseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryStatementsRequest : Tea.TeaModel {
    public var bizId: String?

    public var currency: String?

    public var endTime: String?

    public var extInfo: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var payeeIds: String?

    public var settleNoes: String?

    public var settleStatus: String?

    public var settleType: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.payeeIds != nil {
            map["PayeeIds"] = self.payeeIds!
        }
        if self.settleNoes != nil {
            map["SettleNoes"] = self.settleNoes!
        }
        if self.settleStatus != nil {
            map["SettleStatus"] = self.settleStatus!
        }
        if self.settleType != nil {
            map["SettleType"] = self.settleType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("Currency") && dict["Currency"] != nil {
            self.currency = dict["Currency"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PayeeIds") && dict["PayeeIds"] != nil {
            self.payeeIds = dict["PayeeIds"] as! String
        }
        if dict.keys.contains("SettleNoes") && dict["SettleNoes"] != nil {
            self.settleNoes = dict["SettleNoes"] as! String
        }
        if dict.keys.contains("SettleStatus") && dict["SettleStatus"] != nil {
            self.settleStatus = dict["SettleStatus"] as! String
        }
        if dict.keys.contains("SettleType") && dict["SettleType"] != nil {
            self.settleType = dict["SettleType"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class QueryStatementsResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class StatementList : Tea.TeaModel {
            public var attributes: String?

            public var createDate: String?

            public var currency: String?

            public var endTime: String?

            public var extInfo: String?

            public var kpNoGenerateTime: String?

            public var modifiedDate: String?

            public var payeeAccountId: String?

            public var payeeAccountName: String?

            public var payeeAccountNo: String?

            public var payeeId: String?

            public var payeeName: String?

            public var settleAmount: String?

            public var settleNo: String?

            public var settleStatus: String?

            public var startTime: String?

            public var statusMessage: String?

            public var tenantId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attributes != nil {
                    map["Attributes"] = self.attributes!
                }
                if self.createDate != nil {
                    map["CreateDate"] = self.createDate!
                }
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.extInfo != nil {
                    map["ExtInfo"] = self.extInfo!
                }
                if self.kpNoGenerateTime != nil {
                    map["KpNoGenerateTime"] = self.kpNoGenerateTime!
                }
                if self.modifiedDate != nil {
                    map["ModifiedDate"] = self.modifiedDate!
                }
                if self.payeeAccountId != nil {
                    map["PayeeAccountId"] = self.payeeAccountId!
                }
                if self.payeeAccountName != nil {
                    map["PayeeAccountName"] = self.payeeAccountName!
                }
                if self.payeeAccountNo != nil {
                    map["PayeeAccountNo"] = self.payeeAccountNo!
                }
                if self.payeeId != nil {
                    map["PayeeId"] = self.payeeId!
                }
                if self.payeeName != nil {
                    map["PayeeName"] = self.payeeName!
                }
                if self.settleAmount != nil {
                    map["SettleAmount"] = self.settleAmount!
                }
                if self.settleNo != nil {
                    map["SettleNo"] = self.settleNo!
                }
                if self.settleStatus != nil {
                    map["SettleStatus"] = self.settleStatus!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.statusMessage != nil {
                    map["StatusMessage"] = self.statusMessage!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attributes") && dict["Attributes"] != nil {
                    self.attributes = dict["Attributes"] as! String
                }
                if dict.keys.contains("CreateDate") && dict["CreateDate"] != nil {
                    self.createDate = dict["CreateDate"] as! String
                }
                if dict.keys.contains("Currency") && dict["Currency"] != nil {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                    self.extInfo = dict["ExtInfo"] as! String
                }
                if dict.keys.contains("KpNoGenerateTime") && dict["KpNoGenerateTime"] != nil {
                    self.kpNoGenerateTime = dict["KpNoGenerateTime"] as! String
                }
                if dict.keys.contains("ModifiedDate") && dict["ModifiedDate"] != nil {
                    self.modifiedDate = dict["ModifiedDate"] as! String
                }
                if dict.keys.contains("PayeeAccountId") && dict["PayeeAccountId"] != nil {
                    self.payeeAccountId = dict["PayeeAccountId"] as! String
                }
                if dict.keys.contains("PayeeAccountName") && dict["PayeeAccountName"] != nil {
                    self.payeeAccountName = dict["PayeeAccountName"] as! String
                }
                if dict.keys.contains("PayeeAccountNo") && dict["PayeeAccountNo"] != nil {
                    self.payeeAccountNo = dict["PayeeAccountNo"] as! String
                }
                if dict.keys.contains("PayeeId") && dict["PayeeId"] != nil {
                    self.payeeId = dict["PayeeId"] as! String
                }
                if dict.keys.contains("PayeeName") && dict["PayeeName"] != nil {
                    self.payeeName = dict["PayeeName"] as! String
                }
                if dict.keys.contains("SettleAmount") && dict["SettleAmount"] != nil {
                    self.settleAmount = dict["SettleAmount"] as! String
                }
                if dict.keys.contains("SettleNo") && dict["SettleNo"] != nil {
                    self.settleNo = dict["SettleNo"] as! String
                }
                if dict.keys.contains("SettleStatus") && dict["SettleStatus"] != nil {
                    self.settleStatus = dict["SettleStatus"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StatusMessage") && dict["StatusMessage"] != nil {
                    self.statusMessage = dict["StatusMessage"] as! String
                }
                if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                    self.tenantId = dict["TenantId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var statementList: [QueryStatementsResponseBody.Model.StatementList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.statementList != nil {
                var tmp : [Any] = []
                for k in self.statementList! {
                    tmp.append(k.toMap())
                }
                map["StatementList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("StatementList") && dict["StatementList"] != nil {
                var tmp : [QueryStatementsResponseBody.Model.StatementList] = []
                for v in dict["StatementList"] as! [Any] {
                    var model = QueryStatementsResponseBody.Model.StatementList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.statementList = tmp
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: QueryStatementsResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryStatementsResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryStatementsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryStatementsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryStatementsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySupplierItemBillDownloadUrlRequest : Tea.TeaModel {
    public var billId: String?

    public var billPeriod: String?

    public var billStatus: String?

    public var bizId: String?

    public var bizName: String?

    public var lmShopId: Int64?

    public var lmShopName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.billId != nil {
            map["BillId"] = self.billId!
        }
        if self.billPeriod != nil {
            map["BillPeriod"] = self.billPeriod!
        }
        if self.billStatus != nil {
            map["BillStatus"] = self.billStatus!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizName != nil {
            map["BizName"] = self.bizName!
        }
        if self.lmShopId != nil {
            map["LmShopId"] = self.lmShopId!
        }
        if self.lmShopName != nil {
            map["LmShopName"] = self.lmShopName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BillId") && dict["BillId"] != nil {
            self.billId = dict["BillId"] as! String
        }
        if dict.keys.contains("BillPeriod") && dict["BillPeriod"] != nil {
            self.billPeriod = dict["BillPeriod"] as! String
        }
        if dict.keys.contains("BillStatus") && dict["BillStatus"] != nil {
            self.billStatus = dict["BillStatus"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizName") && dict["BizName"] != nil {
            self.bizName = dict["BizName"] as! String
        }
        if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
            self.lmShopId = dict["LmShopId"] as! Int64
        }
        if dict.keys.contains("LmShopName") && dict["LmShopName"] != nil {
            self.lmShopName = dict["LmShopName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QuerySupplierItemBillDownloadUrlResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var billId: String?

            public var fileDownloadUrl: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.billId != nil {
                    map["BillId"] = self.billId!
                }
                if self.fileDownloadUrl != nil {
                    map["FileDownloadUrl"] = self.fileDownloadUrl!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BillId") && dict["BillId"] != nil {
                    self.billId = dict["BillId"] as! String
                }
                if dict.keys.contains("FileDownloadUrl") && dict["FileDownloadUrl"] != nil {
                    self.fileDownloadUrl = dict["FileDownloadUrl"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var data: [QuerySupplierItemBillDownloadUrlResponseBody.Model.Data]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var tmp : [QuerySupplierItemBillDownloadUrlResponseBody.Model.Data] = []
                for v in dict["Data"] as! [Any] {
                    var model = QuerySupplierItemBillDownloadUrlResponseBody.Model.Data()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.data = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: QuerySupplierItemBillDownloadUrlResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QuerySupplierItemBillDownloadUrlResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QuerySupplierItemBillDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySupplierItemBillDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QuerySupplierItemBillDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUnfinishedActivitiesRequest : Tea.TeaModel {
    public var bizId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryUnfinishedActivitiesResponseBody : Tea.TeaModel {
    public class LmActivityModelExtList : Tea.TeaModel {
        public class LmActivityModelV2Ext : Tea.TeaModel {
            public class LmActivitySessionModels : Tea.TeaModel {
                public class LmActivitySessionModel : Tea.TeaModel {
                    public var bizId: String?

                    public var description_: String?

                    public var displayDate: String?

                    public var endDate: String?

                    public var extInfo: [String: Any]?

                    public var lmActivityId: Int64?

                    public var lmSessionId: Int64?

                    public var name: String?

                    public var startDate: String?

                    public var subBizCode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bizId != nil {
                            map["BizId"] = self.bizId!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.displayDate != nil {
                            map["DisplayDate"] = self.displayDate!
                        }
                        if self.endDate != nil {
                            map["EndDate"] = self.endDate!
                        }
                        if self.extInfo != nil {
                            map["ExtInfo"] = self.extInfo!
                        }
                        if self.lmActivityId != nil {
                            map["LmActivityId"] = self.lmActivityId!
                        }
                        if self.lmSessionId != nil {
                            map["LmSessionId"] = self.lmSessionId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.startDate != nil {
                            map["StartDate"] = self.startDate!
                        }
                        if self.subBizCode != nil {
                            map["SubBizCode"] = self.subBizCode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BizId") && dict["BizId"] != nil {
                            self.bizId = dict["BizId"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("DisplayDate") && dict["DisplayDate"] != nil {
                            self.displayDate = dict["DisplayDate"] as! String
                        }
                        if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                            self.endDate = dict["EndDate"] as! String
                        }
                        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                            self.extInfo = dict["ExtInfo"] as! [String: Any]
                        }
                        if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
                            self.lmActivityId = dict["LmActivityId"] as! Int64
                        }
                        if dict.keys.contains("LmSessionId") && dict["LmSessionId"] != nil {
                            self.lmSessionId = dict["LmSessionId"] as! Int64
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
                            self.startDate = dict["StartDate"] as! String
                        }
                        if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                            self.subBizCode = dict["SubBizCode"] as! String
                        }
                    }
                }
                public var lmActivitySessionModel: [QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList.LmActivityModelV2Ext.LmActivitySessionModels.LmActivitySessionModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lmActivitySessionModel != nil {
                        var tmp : [Any] = []
                        for k in self.lmActivitySessionModel! {
                            tmp.append(k.toMap())
                        }
                        map["LmActivitySessionModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LmActivitySessionModel") && dict["LmActivitySessionModel"] != nil {
                        var tmp : [QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList.LmActivityModelV2Ext.LmActivitySessionModels.LmActivitySessionModel] = []
                        for v in dict["LmActivitySessionModel"] as! [Any] {
                            var model = QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList.LmActivityModelV2Ext.LmActivitySessionModels.LmActivitySessionModel()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.lmActivitySessionModel = tmp
                    }
                }
            }
            public var activityPicUrl: String?

            public var bizId: String?

            public var description_: String?

            public var endDate: String?

            public var lmActivityId: Int64?

            public var lmActivitySessionModels: QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList.LmActivityModelV2Ext.LmActivitySessionModels?

            public var name: String?

            public var startDate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lmActivitySessionModels?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityPicUrl != nil {
                    map["ActivityPicUrl"] = self.activityPicUrl!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.lmActivityId != nil {
                    map["LmActivityId"] = self.lmActivityId!
                }
                if self.lmActivitySessionModels != nil {
                    map["LmActivitySessionModels"] = self.lmActivitySessionModels?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.startDate != nil {
                    map["StartDate"] = self.startDate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityPicUrl") && dict["ActivityPicUrl"] != nil {
                    self.activityPicUrl = dict["ActivityPicUrl"] as! String
                }
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
                    self.lmActivityId = dict["LmActivityId"] as! Int64
                }
                if dict.keys.contains("LmActivitySessionModels") && dict["LmActivitySessionModels"] != nil {
                    var model = QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList.LmActivityModelV2Ext.LmActivitySessionModels()
                    model.fromMap(dict["LmActivitySessionModels"] as! [String: Any])
                    self.lmActivitySessionModels = model
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
                    self.startDate = dict["StartDate"] as! String
                }
            }
        }
        public var lmActivityModelV2Ext: [QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList.LmActivityModelV2Ext]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmActivityModelV2Ext != nil {
                var tmp : [Any] = []
                for k in self.lmActivityModelV2Ext! {
                    tmp.append(k.toMap())
                }
                map["LmActivityModelV2Ext"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmActivityModelV2Ext") && dict["LmActivityModelV2Ext"] != nil {
                var tmp : [QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList.LmActivityModelV2Ext] = []
                for v in dict["LmActivityModelV2Ext"] as! [Any] {
                    var model = QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList.LmActivityModelV2Ext()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmActivityModelV2Ext = tmp
            }
        }
    }
    public var code: String?

    public var lmActivityModelExtList: QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmActivityModelExtList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmActivityModelExtList != nil {
            map["LmActivityModelExtList"] = self.lmActivityModelExtList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmActivityModelExtList") && dict["LmActivityModelExtList"] != nil {
            var model = QueryUnfinishedActivitiesResponseBody.LmActivityModelExtList()
            model.fromMap(dict["LmActivityModelExtList"] as! [String: Any])
            self.lmActivityModelExtList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryUnfinishedActivitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUnfinishedActivitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryUnfinishedActivitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUnfinishedSessionsRequest : Tea.TeaModel {
    public var bizId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var queryTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryTime != nil {
            map["QueryTime"] = self.queryTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueryTime") && dict["QueryTime"] != nil {
            self.queryTime = dict["QueryTime"] as! Int64
        }
    }
}

public class QueryUnfinishedSessionsResponseBody : Tea.TeaModel {
    public class LmActivitySessionModelList : Tea.TeaModel {
        public class LmActivitySessionModel : Tea.TeaModel {
            public var bizId: String?

            public var description_: String?

            public var displayDate: String?

            public var endDate: String?

            public var lmActivityId: Int64?

            public var lmSessionId: Int64?

            public var name: String?

            public var startDate: String?

            public var subBizCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.displayDate != nil {
                    map["DisplayDate"] = self.displayDate!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.lmActivityId != nil {
                    map["LmActivityId"] = self.lmActivityId!
                }
                if self.lmSessionId != nil {
                    map["LmSessionId"] = self.lmSessionId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.startDate != nil {
                    map["StartDate"] = self.startDate!
                }
                if self.subBizCode != nil {
                    map["SubBizCode"] = self.subBizCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DisplayDate") && dict["DisplayDate"] != nil {
                    self.displayDate = dict["DisplayDate"] as! String
                }
                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
                    self.lmActivityId = dict["LmActivityId"] as! Int64
                }
                if dict.keys.contains("LmSessionId") && dict["LmSessionId"] != nil {
                    self.lmSessionId = dict["LmSessionId"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
                    self.startDate = dict["StartDate"] as! String
                }
                if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                    self.subBizCode = dict["SubBizCode"] as! String
                }
            }
        }
        public var lmActivitySessionModel: [QueryUnfinishedSessionsResponseBody.LmActivitySessionModelList.LmActivitySessionModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmActivitySessionModel != nil {
                var tmp : [Any] = []
                for k in self.lmActivitySessionModel! {
                    tmp.append(k.toMap())
                }
                map["LmActivitySessionModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmActivitySessionModel") && dict["LmActivitySessionModel"] != nil {
                var tmp : [QueryUnfinishedSessionsResponseBody.LmActivitySessionModelList.LmActivitySessionModel] = []
                for v in dict["LmActivitySessionModel"] as! [Any] {
                    var model = QueryUnfinishedSessionsResponseBody.LmActivitySessionModelList.LmActivitySessionModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmActivitySessionModel = tmp
            }
        }
    }
    public var code: String?

    public var lmActivitySessionModelList: QueryUnfinishedSessionsResponseBody.LmActivitySessionModelList?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmActivitySessionModelList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmActivitySessionModelList != nil {
            map["LmActivitySessionModelList"] = self.lmActivitySessionModelList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmActivitySessionModelList") && dict["LmActivitySessionModelList"] != nil {
            var model = QueryUnfinishedSessionsResponseBody.LmActivitySessionModelList()
            model.fromMap(dict["LmActivitySessionModelList"] as! [String: Any])
            self.lmActivitySessionModelList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryUnfinishedSessionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUnfinishedSessionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryUnfinishedSessionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUnfinishedSessions4ItemsRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIds: [String: Any]?

    public var lmItemIds: [String: Any]?

    public var queryTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lmItemIds != nil {
            map["LmItemIds"] = self.lmItemIds!
        }
        if self.queryTime != nil {
            map["QueryTime"] = self.queryTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [String: Any]
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIds = dict["LmItemIds"] as! [String: Any]
        }
        if dict.keys.contains("QueryTime") && dict["QueryTime"] != nil {
            self.queryTime = dict["QueryTime"] as! Int64
        }
    }
}

public class QueryUnfinishedSessions4ItemsShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemIdsShrink: String?

    public var lmItemIdsShrink: String?

    public var queryTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemIdsShrink != nil {
            map["ItemIds"] = self.itemIdsShrink!
        }
        if self.lmItemIdsShrink != nil {
            map["LmItemIds"] = self.lmItemIdsShrink!
        }
        if self.queryTime != nil {
            map["QueryTime"] = self.queryTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIdsShrink = dict["ItemIds"] as! String
        }
        if dict.keys.contains("LmItemIds") && dict["LmItemIds"] != nil {
            self.lmItemIdsShrink = dict["LmItemIds"] as! String
        }
        if dict.keys.contains("QueryTime") && dict["QueryTime"] != nil {
            self.queryTime = dict["QueryTime"] as! Int64
        }
    }
}

public class QueryUnfinishedSessions4ItemsResponseBody : Tea.TeaModel {
    public class LmItemActivitySessionModelListList : Tea.TeaModel {
        public class LmItemActivitySessionModelList : Tea.TeaModel {
            public class LmActivitySessionModels : Tea.TeaModel {
                public class LmActivitySessionModel : Tea.TeaModel {
                    public var bizId: String?

                    public var description_: String?

                    public var displayDate: String?

                    public var endDate: String?

                    public var extInfo: [String: Any]?

                    public var lmActivityId: Int64?

                    public var lmSessionId: Int64?

                    public var name: String?

                    public var startDate: String?

                    public var subBizCode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bizId != nil {
                            map["BizId"] = self.bizId!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.displayDate != nil {
                            map["DisplayDate"] = self.displayDate!
                        }
                        if self.endDate != nil {
                            map["EndDate"] = self.endDate!
                        }
                        if self.extInfo != nil {
                            map["ExtInfo"] = self.extInfo!
                        }
                        if self.lmActivityId != nil {
                            map["LmActivityId"] = self.lmActivityId!
                        }
                        if self.lmSessionId != nil {
                            map["LmSessionId"] = self.lmSessionId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.startDate != nil {
                            map["StartDate"] = self.startDate!
                        }
                        if self.subBizCode != nil {
                            map["SubBizCode"] = self.subBizCode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BizId") && dict["BizId"] != nil {
                            self.bizId = dict["BizId"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("DisplayDate") && dict["DisplayDate"] != nil {
                            self.displayDate = dict["DisplayDate"] as! String
                        }
                        if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                            self.endDate = dict["EndDate"] as! String
                        }
                        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                            self.extInfo = dict["ExtInfo"] as! [String: Any]
                        }
                        if dict.keys.contains("LmActivityId") && dict["LmActivityId"] != nil {
                            self.lmActivityId = dict["LmActivityId"] as! Int64
                        }
                        if dict.keys.contains("LmSessionId") && dict["LmSessionId"] != nil {
                            self.lmSessionId = dict["LmSessionId"] as! Int64
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
                            self.startDate = dict["StartDate"] as! String
                        }
                        if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                            self.subBizCode = dict["SubBizCode"] as! String
                        }
                    }
                }
                public var lmActivitySessionModel: [QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList.LmItemActivitySessionModelList.LmActivitySessionModels.LmActivitySessionModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lmActivitySessionModel != nil {
                        var tmp : [Any] = []
                        for k in self.lmActivitySessionModel! {
                            tmp.append(k.toMap())
                        }
                        map["LmActivitySessionModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LmActivitySessionModel") && dict["LmActivitySessionModel"] != nil {
                        var tmp : [QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList.LmItemActivitySessionModelList.LmActivitySessionModels.LmActivitySessionModel] = []
                        for v in dict["LmActivitySessionModel"] as! [Any] {
                            var model = QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList.LmItemActivitySessionModelList.LmActivitySessionModels.LmActivitySessionModel()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.lmActivitySessionModel = tmp
                    }
                }
            }
            public var itemId: Int64?

            public var lmActivitySessionModels: QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList.LmItemActivitySessionModelList.LmActivitySessionModels?

            public var lmItemId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lmActivitySessionModels?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.lmActivitySessionModels != nil {
                    map["LmActivitySessionModels"] = self.lmActivitySessionModels?.toMap()
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("LmActivitySessionModels") && dict["LmActivitySessionModels"] != nil {
                    var model = QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList.LmItemActivitySessionModelList.LmActivitySessionModels()
                    model.fromMap(dict["LmActivitySessionModels"] as! [String: Any])
                    self.lmActivitySessionModels = model
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
            }
        }
        public var lmItemActivitySessionModelList: [QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList.LmItemActivitySessionModelList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lmItemActivitySessionModelList != nil {
                var tmp : [Any] = []
                for k in self.lmItemActivitySessionModelList! {
                    tmp.append(k.toMap())
                }
                map["LmItemActivitySessionModelList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LmItemActivitySessionModelList") && dict["LmItemActivitySessionModelList"] != nil {
                var tmp : [QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList.LmItemActivitySessionModelList] = []
                for v in dict["LmItemActivitySessionModelList"] as! [Any] {
                    var model = QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList.LmItemActivitySessionModelList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmItemActivitySessionModelList = tmp
            }
        }
    }
    public var code: String?

    public var lmItemActivitySessionModelListList: QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lmItemActivitySessionModelListList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.lmItemActivitySessionModelListList != nil {
            map["LmItemActivitySessionModelListList"] = self.lmItemActivitySessionModelListList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LmItemActivitySessionModelListList") && dict["LmItemActivitySessionModelListList"] != nil {
            var model = QueryUnfinishedSessions4ItemsResponseBody.LmItemActivitySessionModelListList()
            model.fromMap(dict["LmItemActivitySessionModelListList"] as! [String: Any])
            self.lmItemActivitySessionModelListList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryUnfinishedSessions4ItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUnfinishedSessions4ItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryUnfinishedSessions4ItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUpcomingMoviesRequest : Tea.TeaModel {
    public var bizId: String?

    public var cityCode: Int64?

    public var extJson: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.cityCode != nil {
            map["CityCode"] = self.cityCode!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
            self.cityCode = dict["CityCode"] as! Int64
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! [String: Any]
        }
    }
}

public class QueryUpcomingMoviesShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var cityCode: Int64?

    public var extJsonShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.cityCode != nil {
            map["CityCode"] = self.cityCode!
        }
        if self.extJsonShrink != nil {
            map["ExtJson"] = self.extJsonShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
            self.cityCode = dict["CityCode"] as! Int64
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJsonShrink = dict["ExtJson"] as! String
        }
    }
}

public class QueryUpcomingMoviesResponseBody : Tea.TeaModel {
    public class Movies : Tea.TeaModel {
        public class Movie : Tea.TeaModel {
            public var backgroundPicture: String?

            public var country: String?

            public var description_: String?

            public var director: String?

            public var duration: Int64?

            public var highlight: String?

            public var id: Int64?

            public var language: String?

            public var leadingRole: String?

            public var movieName: String?

            public var movieNameEn: String?

            public var movieTypeList: String?

            public var movieVersion: String?

            public var openDay: String?

            public var openTime: String?

            public var poster: String?

            public var remark: String?

            public var trailerList: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backgroundPicture != nil {
                    map["BackgroundPicture"] = self.backgroundPicture!
                }
                if self.country != nil {
                    map["Country"] = self.country!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.director != nil {
                    map["Director"] = self.director!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.highlight != nil {
                    map["Highlight"] = self.highlight!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.leadingRole != nil {
                    map["LeadingRole"] = self.leadingRole!
                }
                if self.movieName != nil {
                    map["MovieName"] = self.movieName!
                }
                if self.movieNameEn != nil {
                    map["MovieNameEn"] = self.movieNameEn!
                }
                if self.movieTypeList != nil {
                    map["MovieTypeList"] = self.movieTypeList!
                }
                if self.movieVersion != nil {
                    map["MovieVersion"] = self.movieVersion!
                }
                if self.openDay != nil {
                    map["OpenDay"] = self.openDay!
                }
                if self.openTime != nil {
                    map["OpenTime"] = self.openTime!
                }
                if self.poster != nil {
                    map["Poster"] = self.poster!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.trailerList != nil {
                    map["TrailerList"] = self.trailerList!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BackgroundPicture") && dict["BackgroundPicture"] != nil {
                    self.backgroundPicture = dict["BackgroundPicture"] as! String
                }
                if dict.keys.contains("Country") && dict["Country"] != nil {
                    self.country = dict["Country"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Director") && dict["Director"] != nil {
                    self.director = dict["Director"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("Highlight") && dict["Highlight"] != nil {
                    self.highlight = dict["Highlight"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Language") && dict["Language"] != nil {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("LeadingRole") && dict["LeadingRole"] != nil {
                    self.leadingRole = dict["LeadingRole"] as! String
                }
                if dict.keys.contains("MovieName") && dict["MovieName"] != nil {
                    self.movieName = dict["MovieName"] as! String
                }
                if dict.keys.contains("MovieNameEn") && dict["MovieNameEn"] != nil {
                    self.movieNameEn = dict["MovieNameEn"] as! String
                }
                if dict.keys.contains("MovieTypeList") && dict["MovieTypeList"] != nil {
                    self.movieTypeList = dict["MovieTypeList"] as! String
                }
                if dict.keys.contains("MovieVersion") && dict["MovieVersion"] != nil {
                    self.movieVersion = dict["MovieVersion"] as! String
                }
                if dict.keys.contains("OpenDay") && dict["OpenDay"] != nil {
                    self.openDay = dict["OpenDay"] as! String
                }
                if dict.keys.contains("OpenTime") && dict["OpenTime"] != nil {
                    self.openTime = dict["OpenTime"] as! String
                }
                if dict.keys.contains("Poster") && dict["Poster"] != nil {
                    self.poster = dict["Poster"] as! String
                }
                if dict.keys.contains("Remark") && dict["Remark"] != nil {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("TrailerList") && dict["TrailerList"] != nil {
                    self.trailerList = dict["TrailerList"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var movie: [QueryUpcomingMoviesResponseBody.Movies.Movie]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.movie != nil {
                var tmp : [Any] = []
                for k in self.movie! {
                    tmp.append(k.toMap())
                }
                map["Movie"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Movie") && dict["Movie"] != nil {
                var tmp : [QueryUpcomingMoviesResponseBody.Movies.Movie] = []
                for v in dict["Movie"] as! [Any] {
                    var model = QueryUpcomingMoviesResponseBody.Movies.Movie()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.movie = tmp
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var movies: QueryUpcomingMoviesResponseBody.Movies?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.movies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.movies != nil {
            map["Movies"] = self.movies?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Movies") && dict["Movies"] != nil {
            var model = QueryUpcomingMoviesResponseBody.Movies()
            model.fromMap(dict["Movies"] as! [String: Any])
            self.movies = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryUpcomingMoviesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUpcomingMoviesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryUpcomingMoviesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUserAccountRequest : Tea.TeaModel {
    public var bizId: String?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class QueryUserAccountResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var bizId: String?

        public var CUserId: String?

        public var extInfo: String?

        public var lmUid: Int64?

        public var requestId: String?

        public var tbAccountType: String?

        public var tbUserId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.CUserId != nil {
                map["CUserId"] = self.CUserId!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.lmUid != nil {
                map["LmUid"] = self.lmUid!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.tbAccountType != nil {
                map["TbAccountType"] = self.tbAccountType!
            }
            if self.tbUserId != nil {
                map["TbUserId"] = self.tbUserId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("CUserId") && dict["CUserId"] != nil {
                self.CUserId = dict["CUserId"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! String
            }
            if dict.keys.contains("LmUid") && dict["LmUid"] != nil {
                self.lmUid = dict["LmUid"] as! Int64
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
                self.tbAccountType = dict["TbAccountType"] as! String
            }
            if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
                self.tbUserId = dict["TbUserId"] as! Int64
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: QueryUserAccountResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryUserAccountResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class QueryUserAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUserAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryUserAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUserGameProcessRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var processId: String?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.processId != nil {
            map["ProcessId"] = self.processId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
            self.processId = dict["ProcessId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class QueryUserGameProcessShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var extInfoShrink: String?

    public var processId: String?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.processId != nil {
            map["ProcessId"] = self.processId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
            self.processId = dict["ProcessId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class QueryUserGameProcessResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var activityId: String?

        public var createTime: Int64?

        public var currentShowContent: String?

        public var currentStepId: String?

        public var currentStepStatus: String?

        public var desc: String?

        public var extInfo: String?

        public var gameId: String?

        public var modifyTime: Int64?

        public var name: String?

        public var processId: String?

        public var routeId: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentShowContent != nil {
                map["CurrentShowContent"] = self.currentShowContent!
            }
            if self.currentStepId != nil {
                map["CurrentStepId"] = self.currentStepId!
            }
            if self.currentStepStatus != nil {
                map["CurrentStepStatus"] = self.currentStepStatus!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.gameId != nil {
                map["GameId"] = self.gameId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CurrentShowContent") && dict["CurrentShowContent"] != nil {
                self.currentShowContent = dict["CurrentShowContent"] as! String
            }
            if dict.keys.contains("CurrentStepId") && dict["CurrentStepId"] != nil {
                self.currentStepId = dict["CurrentStepId"] as! String
            }
            if dict.keys.contains("CurrentStepStatus") && dict["CurrentStepStatus"] != nil {
                self.currentStepStatus = dict["CurrentStepStatus"] as! String
            }
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! String
            }
            if dict.keys.contains("GameId") && dict["GameId"] != nil {
                self.gameId = dict["GameId"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
                self.processId = dict["ProcessId"] as! String
            }
            if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
                self.routeId = dict["RouteId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: QueryUserGameProcessResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryUserGameProcessResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryUserGameProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUserGameProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryUserGameProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUserPointRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class QueryUserPointShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var extInfoShrink: String?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class QueryUserPointResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountId: String?

        public var bizId: String?

        public var bizUid: String?

        public var createTime: Int64?

        public var currentAmount: Int64?

        public var frozenAmount: Int64?

        public var historyAmount: Int64?

        public var level: String?

        public var modifyTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizUid != nil {
                map["BizUid"] = self.bizUid!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentAmount != nil {
                map["CurrentAmount"] = self.currentAmount!
            }
            if self.frozenAmount != nil {
                map["FrozenAmount"] = self.frozenAmount!
            }
            if self.historyAmount != nil {
                map["HistoryAmount"] = self.historyAmount!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
                self.bizUid = dict["BizUid"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CurrentAmount") && dict["CurrentAmount"] != nil {
                self.currentAmount = dict["CurrentAmount"] as! Int64
            }
            if dict.keys.contains("FrozenAmount") && dict["FrozenAmount"] != nil {
                self.frozenAmount = dict["FrozenAmount"] as! Int64
            }
            if dict.keys.contains("HistoryAmount") && dict["HistoryAmount"] != nil {
                self.historyAmount = dict["HistoryAmount"] as! Int64
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: QueryUserPointResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = QueryUserPointResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryUserPointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUserPointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryUserPointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryWithholdTradeRequest : Tea.TeaModel {
    public var merchantId: String?

    public var outTradeNo: String?

    public var tradeNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.merchantId != nil {
            map["MerchantId"] = self.merchantId!
        }
        if self.outTradeNo != nil {
            map["OutTradeNo"] = self.outTradeNo!
        }
        if self.tradeNo != nil {
            map["TradeNo"] = self.tradeNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MerchantId") && dict["MerchantId"] != nil {
            self.merchantId = dict["MerchantId"] as! String
        }
        if dict.keys.contains("OutTradeNo") && dict["OutTradeNo"] != nil {
            self.outTradeNo = dict["OutTradeNo"] as! String
        }
        if dict.keys.contains("TradeNo") && dict["TradeNo"] != nil {
            self.tradeNo = dict["TradeNo"] as! String
        }
    }
}

public class QueryWithholdTradeResponseBody : Tea.TeaModel {
    public class QueryWithholdTradeResponse : Tea.TeaModel {
        public var outTradeNo: String?

        public var paymentDate: String?

        public var settleStatus: String?

        public var totalAmount: String?

        public var tradeNo: String?

        public var tradeStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.outTradeNo != nil {
                map["OutTradeNo"] = self.outTradeNo!
            }
            if self.paymentDate != nil {
                map["PaymentDate"] = self.paymentDate!
            }
            if self.settleStatus != nil {
                map["SettleStatus"] = self.settleStatus!
            }
            if self.totalAmount != nil {
                map["TotalAmount"] = self.totalAmount!
            }
            if self.tradeNo != nil {
                map["TradeNo"] = self.tradeNo!
            }
            if self.tradeStatus != nil {
                map["TradeStatus"] = self.tradeStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OutTradeNo") && dict["OutTradeNo"] != nil {
                self.outTradeNo = dict["OutTradeNo"] as! String
            }
            if dict.keys.contains("PaymentDate") && dict["PaymentDate"] != nil {
                self.paymentDate = dict["PaymentDate"] as! String
            }
            if dict.keys.contains("SettleStatus") && dict["SettleStatus"] != nil {
                self.settleStatus = dict["SettleStatus"] as! String
            }
            if dict.keys.contains("TotalAmount") && dict["TotalAmount"] != nil {
                self.totalAmount = dict["TotalAmount"] as! String
            }
            if dict.keys.contains("TradeNo") && dict["TradeNo"] != nil {
                self.tradeNo = dict["TradeNo"] as! String
            }
            if dict.keys.contains("TradeStatus") && dict["TradeStatus"] != nil {
                self.tradeStatus = dict["TradeStatus"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var queryWithholdTradeResponse: QueryWithholdTradeResponseBody.QueryWithholdTradeResponse?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.queryWithholdTradeResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.queryWithholdTradeResponse != nil {
            map["QueryWithholdTradeResponse"] = self.queryWithholdTradeResponse?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("QueryWithholdTradeResponse") && dict["QueryWithholdTradeResponse"] != nil {
            var model = QueryWithholdTradeResponseBody.QueryWithholdTradeResponse()
            model.fromMap(dict["QueryWithholdTradeResponse"] as! [String: Any])
            self.queryWithholdTradeResponse = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryWithholdTradeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryWithholdTradeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryWithholdTradeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebindTbAccountRequest : Tea.TeaModel {
    public var bizId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class RebindTbAccountResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var bizId: String?

        public var CUserId: String?

        public var extInfo: String?

        public var lmUid: Int64?

        public var requestId: String?

        public var tbAccountType: String?

        public var tbUserId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.CUserId != nil {
                map["CUserId"] = self.CUserId!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.lmUid != nil {
                map["LmUid"] = self.lmUid!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.tbAccountType != nil {
                map["TbAccountType"] = self.tbAccountType!
            }
            if self.tbUserId != nil {
                map["TbUserId"] = self.tbUserId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("CUserId") && dict["CUserId"] != nil {
                self.CUserId = dict["CUserId"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! String
            }
            if dict.keys.contains("LmUid") && dict["LmUid"] != nil {
                self.lmUid = dict["LmUid"] as! Int64
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
                self.tbAccountType = dict["TbAccountType"] as! String
            }
            if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
                self.tbUserId = dict["TbUserId"] as! Int64
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: RebindTbAccountResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = RebindTbAccountResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class RebindTbAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebindTbAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RebindTbAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshSettlementOrderAccountRequest : Tea.TeaModel {
    public var accountId: String?

    public var bizId: String?

    public var extInfo: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class RefreshSettlementOrderAccountResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountNo: String?

        public var message: String?

        public var result: String?

        public var settleNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountNo != nil {
                map["AccountNo"] = self.accountNo!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.settleNo != nil {
                map["SettleNo"] = self.settleNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountNo") && dict["AccountNo"] != nil {
                self.accountNo = dict["AccountNo"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("SettleNo") && dict["SettleNo"] != nil {
                self.settleNo = dict["SettleNo"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: [RefreshSettlementOrderAccountResponseBody.Model]?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            var tmp : [Any] = []
            for k in self.model! {
                tmp.append(k.toMap())
            }
            map["Model"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var tmp : [RefreshSettlementOrderAccountResponseBody.Model] = []
            for v in dict["Model"] as! [Any] {
                var model = RefreshSettlementOrderAccountResponseBody.Model()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.model = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RefreshSettlementOrderAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshSettlementOrderAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefreshSettlementOrderAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefundOrderRequest : Tea.TeaModel {
    public var extInfo: String?

    public var merchantId: String?

    public var outRequestNo: String?

    public var outTradeNo: String?

    public var refundAmount: String?

    public var refundReason: String?

    public var refundRoyaltyParameters: String?

    public var tradeNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.merchantId != nil {
            map["MerchantId"] = self.merchantId!
        }
        if self.outRequestNo != nil {
            map["OutRequestNo"] = self.outRequestNo!
        }
        if self.outTradeNo != nil {
            map["OutTradeNo"] = self.outTradeNo!
        }
        if self.refundAmount != nil {
            map["RefundAmount"] = self.refundAmount!
        }
        if self.refundReason != nil {
            map["RefundReason"] = self.refundReason!
        }
        if self.refundRoyaltyParameters != nil {
            map["RefundRoyaltyParameters"] = self.refundRoyaltyParameters!
        }
        if self.tradeNo != nil {
            map["TradeNo"] = self.tradeNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("MerchantId") && dict["MerchantId"] != nil {
            self.merchantId = dict["MerchantId"] as! String
        }
        if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
            self.outRequestNo = dict["OutRequestNo"] as! String
        }
        if dict.keys.contains("OutTradeNo") && dict["OutTradeNo"] != nil {
            self.outTradeNo = dict["OutTradeNo"] as! String
        }
        if dict.keys.contains("RefundAmount") && dict["RefundAmount"] != nil {
            self.refundAmount = dict["RefundAmount"] as! String
        }
        if dict.keys.contains("RefundReason") && dict["RefundReason"] != nil {
            self.refundReason = dict["RefundReason"] as! String
        }
        if dict.keys.contains("RefundRoyaltyParameters") && dict["RefundRoyaltyParameters"] != nil {
            self.refundRoyaltyParameters = dict["RefundRoyaltyParameters"] as! String
        }
        if dict.keys.contains("TradeNo") && dict["TradeNo"] != nil {
            self.tradeNo = dict["TradeNo"] as! String
        }
    }
}

public class RefundOrderResponseBody : Tea.TeaModel {
    public class RefundResponse : Tea.TeaModel {
        public var fundChange: String?

        public var gmtRefundPay: String?

        public var outRequestNo: String?

        public var outTradeNo: String?

        public var tradeNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fundChange != nil {
                map["FundChange"] = self.fundChange!
            }
            if self.gmtRefundPay != nil {
                map["GmtRefundPay"] = self.gmtRefundPay!
            }
            if self.outRequestNo != nil {
                map["OutRequestNo"] = self.outRequestNo!
            }
            if self.outTradeNo != nil {
                map["OutTradeNo"] = self.outTradeNo!
            }
            if self.tradeNo != nil {
                map["TradeNo"] = self.tradeNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FundChange") && dict["FundChange"] != nil {
                self.fundChange = dict["FundChange"] as! String
            }
            if dict.keys.contains("GmtRefundPay") && dict["GmtRefundPay"] != nil {
                self.gmtRefundPay = dict["GmtRefundPay"] as! String
            }
            if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
                self.outRequestNo = dict["OutRequestNo"] as! String
            }
            if dict.keys.contains("OutTradeNo") && dict["OutTradeNo"] != nil {
                self.outTradeNo = dict["OutTradeNo"] as! String
            }
            if dict.keys.contains("TradeNo") && dict["TradeNo"] != nil {
                self.tradeNo = dict["TradeNo"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var refundResponse: RefundOrderResponseBody.RefundResponse?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.refundResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.refundResponse != nil {
            map["RefundResponse"] = self.refundResponse?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RefundResponse") && dict["RefundResponse"] != nil {
            var model = RefundOrderResponseBody.RefundResponse()
            model.fromMap(dict["RefundResponse"] as! [String: Any])
            self.refundResponse = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefundOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefundOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefundOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefundPointRequest : Tea.TeaModel {
    public var bizId: String?

    public var lmOrderId: String?

    public var reason: String?

    public var sellerId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.sellerId != nil {
            map["SellerId"] = self.sellerId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
            self.sellerId = dict["SellerId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class RefundPointResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefundPointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefundPointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefundPointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefundUserPointRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var idempotentId: String?

    public var message: String?

    public var originRecordId: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.originRecordId != nil {
            map["OriginRecordId"] = self.originRecordId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OriginRecordId") && dict["OriginRecordId"] != nil {
            self.originRecordId = dict["OriginRecordId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class RefundUserPointShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfoShrink: String?

    public var idempotentId: String?

    public var message: String?

    public var originRecordId: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.originRecordId != nil {
            map["OriginRecordId"] = self.originRecordId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OriginRecordId") && dict["OriginRecordId"] != nil {
            self.originRecordId = dict["OriginRecordId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class RefundUserPointResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountId: String?

        public var action: String?

        public var amount: Int64?

        public var bizId: String?

        public var bizUid: String?

        public var description_: String?

        public var extInfo: [String: Any]?

        public var idempotentId: String?

        public var name: String?

        public var recordId: String?

        public var rest: Int64?

        public var ruleId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizUid != nil {
                map["BizUid"] = self.bizUid!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.idempotentId != nil {
                map["IdempotentId"] = self.idempotentId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.rest != nil {
                map["Rest"] = self.rest!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Amount") && dict["Amount"] != nil {
                self.amount = dict["Amount"] as! Int64
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
                self.bizUid = dict["BizUid"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
                self.idempotentId = dict["IdempotentId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("Rest") && dict["Rest"] != nil {
                self.rest = dict["Rest"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: RefundUserPointResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = RefundUserPointResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefundUserPointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefundUserPointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefundUserPointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefuseMerchantSyncTaskRequest : Tea.TeaModel {
    public var bizId: String?

    public var sellerNick: String?

    public var taskId: String?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.sellerNick != nil {
            map["SellerNick"] = self.sellerNick!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("SellerNick") && dict["SellerNick"] != nil {
            self.sellerNick = dict["SellerNick"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class RefuseMerchantSyncTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefuseMerchantSyncTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefuseMerchantSyncTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefuseMerchantSyncTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegistAnonymousTbAccountRequest : Tea.TeaModel {
    public var bizId: String?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class RegistAnonymousTbAccountResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegistAnonymousTbAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegistAnonymousTbAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegistAnonymousTbAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterSettleAccountRequest : Tea.TeaModel {
    public var accountChannel: String?

    public var accountName: String?

    public var accountNo: String?

    public var accountPayType: String?

    public var accountType: String?

    public var bizId: String?

    public var countryOrAreaCode: String?

    public var currency: String?

    public var extInfo: String?

    public var idempotentId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountChannel != nil {
            map["AccountChannel"] = self.accountChannel!
        }
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountNo != nil {
            map["AccountNo"] = self.accountNo!
        }
        if self.accountPayType != nil {
            map["AccountPayType"] = self.accountPayType!
        }
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.countryOrAreaCode != nil {
            map["CountryOrAreaCode"] = self.countryOrAreaCode!
        }
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountChannel") && dict["AccountChannel"] != nil {
            self.accountChannel = dict["AccountChannel"] as! String
        }
        if dict.keys.contains("AccountName") && dict["AccountName"] != nil {
            self.accountName = dict["AccountName"] as! String
        }
        if dict.keys.contains("AccountNo") && dict["AccountNo"] != nil {
            self.accountNo = dict["AccountNo"] as! String
        }
        if dict.keys.contains("AccountPayType") && dict["AccountPayType"] != nil {
            self.accountPayType = dict["AccountPayType"] as! String
        }
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CountryOrAreaCode") && dict["CountryOrAreaCode"] != nil {
            self.countryOrAreaCode = dict["CountryOrAreaCode"] as! String
        }
        if dict.keys.contains("Currency") && dict["Currency"] != nil {
            self.currency = dict["Currency"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
    }
}

public class RegisterSettleAccountResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountId: String?

        public var accountNo: String?

        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.accountNo != nil {
                map["AccountNo"] = self.accountNo!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("AccountNo") && dict["AccountNo"] != nil {
                self.accountNo = dict["AccountNo"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: RegisterSettleAccountResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = RegisterSettleAccountResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RegisterSettleAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterSettleAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegisterSettleAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterUserAccountRequest : Tea.TeaModel {
    public var bizId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class RegisterUserAccountResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var bizId: String?

        public var CUserId: String?

        public var extInfo: String?

        public var lmUid: Int64?

        public var requestId: String?

        public var tbAccountType: String?

        public var tbUserId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.CUserId != nil {
                map["CUserId"] = self.CUserId!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.lmUid != nil {
                map["LmUid"] = self.lmUid!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.tbAccountType != nil {
                map["TbAccountType"] = self.tbAccountType!
            }
            if self.tbUserId != nil {
                map["TbUserId"] = self.tbUserId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("CUserId") && dict["CUserId"] != nil {
                self.CUserId = dict["CUserId"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! String
            }
            if dict.keys.contains("LmUid") && dict["LmUid"] != nil {
                self.lmUid = dict["LmUid"] as! Int64
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
                self.tbAccountType = dict["TbAccountType"] as! String
            }
            if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
                self.tbUserId = dict["TbUserId"] as! Int64
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: RegisterUserAccountResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = RegisterUserAccountResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class RegisterUserAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterUserAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegisterUserAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseMovieSeatRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var extJson: String?

    public var lockSeatApplyKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.lockSeatApplyKey != nil {
            map["LockSeatApplyKey"] = self.lockSeatApplyKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("LockSeatApplyKey") && dict["LockSeatApplyKey"] != nil {
            self.lockSeatApplyKey = dict["LockSeatApplyKey"] as! String
        }
    }
}

public class ReleaseMovieSeatResponseBody : Tea.TeaModel {
    public class ActionResult : Tea.TeaModel {
        public var returnCode: String?

        public var returnMessage: String?

        public var returnValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.returnCode != nil {
                map["ReturnCode"] = self.returnCode!
            }
            if self.returnMessage != nil {
                map["ReturnMessage"] = self.returnMessage!
            }
            if self.returnValue != nil {
                map["ReturnValue"] = self.returnValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReturnCode") && dict["ReturnCode"] != nil {
                self.returnCode = dict["ReturnCode"] as! String
            }
            if dict.keys.contains("ReturnMessage") && dict["ReturnMessage"] != nil {
                self.returnMessage = dict["ReturnMessage"] as! String
            }
            if dict.keys.contains("ReturnValue") && dict["ReturnValue"] != nil {
                self.returnValue = dict["ReturnValue"] as! String
            }
        }
    }
    public var actionResult: ReleaseMovieSeatResponseBody.ActionResult?

    public var code: String?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.actionResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionResult != nil {
            map["ActionResult"] = self.actionResult?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionResult") && dict["ActionResult"] != nil {
            var model = ReleaseMovieSeatResponseBody.ActionResult()
            model.fromMap(dict["ActionResult"] as! [String: Any])
            self.actionResult = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ReleaseMovieSeatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseMovieSeatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReleaseMovieSeatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAddressRequest : Tea.TeaModel {
    public var addressInfo: String?

    public var bizId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressInfo != nil {
            map["AddressInfo"] = self.addressInfo!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressInfo") && dict["AddressInfo"] != nil {
            self.addressInfo = dict["AddressInfo"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class RemoveAddressResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveMessagesRequest : Tea.TeaModel {
    public var bizId: String?

    public var extJson: String?

    public var messageIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.messageIds != nil {
            map["MessageIds"] = self.messageIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("MessageIds") && dict["MessageIds"] != nil {
            self.messageIds = dict["MessageIds"] as! String
        }
    }
}

public class RemoveMessagesResponseBody : Tea.TeaModel {
    public class ActionResult : Tea.TeaModel {
        public var returnCode: String?

        public var returnMessage: String?

        public var returnValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.returnCode != nil {
                map["ReturnCode"] = self.returnCode!
            }
            if self.returnMessage != nil {
                map["ReturnMessage"] = self.returnMessage!
            }
            if self.returnValue != nil {
                map["ReturnValue"] = self.returnValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReturnCode") && dict["ReturnCode"] != nil {
                self.returnCode = dict["ReturnCode"] as! String
            }
            if dict.keys.contains("ReturnMessage") && dict["ReturnMessage"] != nil {
                self.returnMessage = dict["ReturnMessage"] as! String
            }
            if dict.keys.contains("ReturnValue") && dict["ReturnValue"] != nil {
                self.returnValue = dict["ReturnValue"] as! String
            }
        }
    }
    public var actionResult: RemoveMessagesResponseBody.ActionResult?

    public var code: String?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.actionResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionResult != nil {
            map["ActionResult"] = self.actionResult?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionResult") && dict["ActionResult"] != nil {
            var model = RemoveMessagesResponseBody.ActionResult()
            model.fromMap(dict["ActionResult"] as! [String: Any])
            self.actionResult = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveMessagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveMessagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveMessagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenderH5OrderRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var buyOrderRequestModel: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.buyOrderRequestModel != nil {
            map["BuyOrderRequestModel"] = self.buyOrderRequestModel!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("BuyOrderRequestModel") && dict["BuyOrderRequestModel"] != nil {
            self.buyOrderRequestModel = dict["BuyOrderRequestModel"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class RenderH5OrderResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class AddressInfoList : Tea.TeaModel {
            public var addressDetail: String?

            public var addressId: Int64?

            public var default_: Bool?

            public var divisionCode: String?

            public var receiver: String?

            public var receiverPhone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressDetail != nil {
                    map["AddressDetail"] = self.addressDetail!
                }
                if self.addressId != nil {
                    map["AddressId"] = self.addressId!
                }
                if self.default_ != nil {
                    map["Default"] = self.default_!
                }
                if self.divisionCode != nil {
                    map["DivisionCode"] = self.divisionCode!
                }
                if self.receiver != nil {
                    map["Receiver"] = self.receiver!
                }
                if self.receiverPhone != nil {
                    map["ReceiverPhone"] = self.receiverPhone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressDetail") && dict["AddressDetail"] != nil {
                    self.addressDetail = dict["AddressDetail"] as! String
                }
                if dict.keys.contains("AddressId") && dict["AddressId"] != nil {
                    self.addressId = dict["AddressId"] as! Int64
                }
                if dict.keys.contains("Default") && dict["Default"] != nil {
                    self.default_ = dict["Default"] as! Bool
                }
                if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
                    self.divisionCode = dict["DivisionCode"] as! String
                }
                if dict.keys.contains("Receiver") && dict["Receiver"] != nil {
                    self.receiver = dict["Receiver"] as! String
                }
                if dict.keys.contains("ReceiverPhone") && dict["ReceiverPhone"] != nil {
                    self.receiverPhone = dict["ReceiverPhone"] as! String
                }
            }
        }
        public class DeliveryInfoList : Tea.TeaModel {
            public var displayName: String?

            public var id: String?

            public var postFee: Int64?

            public var serviceType: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.postFee != nil {
                    map["PostFee"] = self.postFee!
                }
                if self.serviceType != nil {
                    map["ServiceType"] = self.serviceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
                    self.postFee = dict["PostFee"] as! Int64
                }
                if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
                    self.serviceType = dict["ServiceType"] as! Int64
                }
            }
        }
        public class InvoiceInfo : Tea.TeaModel {
            public var desc: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Desc") && dict["Desc"] != nil {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class LmItemInfoList : Tea.TeaModel {
            public var actualPrice: Int64?

            public var canSell: Bool?

            public var cash: Int64?

            public var features: [String: Any]?

            public var itemId: Int64?

            public var itemName: String?

            public var itemPicUrl: String?

            public var itemUrl: String?

            public var lmItemId: String?

            public var message: String?

            public var points: Int64?

            public var quantity: Int32?

            public var sellerId: Int64?

            public var sellerNick: String?

            public var skuId: Int64?

            public var skuName: String?

            public var tbShopName: String?

            public var virtualItemType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualPrice != nil {
                    map["ActualPrice"] = self.actualPrice!
                }
                if self.canSell != nil {
                    map["CanSell"] = self.canSell!
                }
                if self.cash != nil {
                    map["Cash"] = self.cash!
                }
                if self.features != nil {
                    map["Features"] = self.features!
                }
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                if self.itemPicUrl != nil {
                    map["ItemPicUrl"] = self.itemPicUrl!
                }
                if self.itemUrl != nil {
                    map["ItemUrl"] = self.itemUrl!
                }
                if self.lmItemId != nil {
                    map["LmItemId"] = self.lmItemId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.points != nil {
                    map["Points"] = self.points!
                }
                if self.quantity != nil {
                    map["Quantity"] = self.quantity!
                }
                if self.sellerId != nil {
                    map["SellerId"] = self.sellerId!
                }
                if self.sellerNick != nil {
                    map["SellerNick"] = self.sellerNick!
                }
                if self.skuId != nil {
                    map["SkuId"] = self.skuId!
                }
                if self.skuName != nil {
                    map["SkuName"] = self.skuName!
                }
                if self.tbShopName != nil {
                    map["TbShopName"] = self.tbShopName!
                }
                if self.virtualItemType != nil {
                    map["VirtualItemType"] = self.virtualItemType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualPrice") && dict["ActualPrice"] != nil {
                    self.actualPrice = dict["ActualPrice"] as! Int64
                }
                if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                    self.canSell = dict["CanSell"] as! Bool
                }
                if dict.keys.contains("Cash") && dict["Cash"] != nil {
                    self.cash = dict["Cash"] as! Int64
                }
                if dict.keys.contains("Features") && dict["Features"] != nil {
                    self.features = dict["Features"] as! [String: Any]
                }
                if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                    self.itemId = dict["ItemId"] as! Int64
                }
                if dict.keys.contains("ItemName") && dict["ItemName"] != nil {
                    self.itemName = dict["ItemName"] as! String
                }
                if dict.keys.contains("ItemPicUrl") && dict["ItemPicUrl"] != nil {
                    self.itemPicUrl = dict["ItemPicUrl"] as! String
                }
                if dict.keys.contains("ItemUrl") && dict["ItemUrl"] != nil {
                    self.itemUrl = dict["ItemUrl"] as! String
                }
                if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                    self.lmItemId = dict["LmItemId"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Points") && dict["Points"] != nil {
                    self.points = dict["Points"] as! Int64
                }
                if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                    self.quantity = dict["Quantity"] as! Int32
                }
                if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                    self.sellerId = dict["SellerId"] as! Int64
                }
                if dict.keys.contains("SellerNick") && dict["SellerNick"] != nil {
                    self.sellerNick = dict["SellerNick"] as! String
                }
                if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                    self.skuId = dict["SkuId"] as! Int64
                }
                if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                    self.skuName = dict["SkuName"] as! String
                }
                if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                    self.tbShopName = dict["TbShopName"] as! String
                }
                if dict.keys.contains("VirtualItemType") && dict["VirtualItemType"] != nil {
                    self.virtualItemType = dict["VirtualItemType"] as! String
                }
            }
        }
        public var addressInfoList: [RenderH5OrderResponseBody.Model.AddressInfoList]?

        public var buyerCurrentPoints: Int64?

        public var deliveryInfoList: [RenderH5OrderResponseBody.Model.DeliveryInfoList]?

        public var extInfo: [String: Any]?

        public var invoiceInfo: RenderH5OrderResponseBody.Model.InvoiceInfo?

        public var lmItemInfoList: [RenderH5OrderResponseBody.Model.LmItemInfoList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.invoiceInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressInfoList != nil {
                var tmp : [Any] = []
                for k in self.addressInfoList! {
                    tmp.append(k.toMap())
                }
                map["AddressInfoList"] = tmp
            }
            if self.buyerCurrentPoints != nil {
                map["BuyerCurrentPoints"] = self.buyerCurrentPoints!
            }
            if self.deliveryInfoList != nil {
                var tmp : [Any] = []
                for k in self.deliveryInfoList! {
                    tmp.append(k.toMap())
                }
                map["DeliveryInfoList"] = tmp
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.invoiceInfo != nil {
                map["InvoiceInfo"] = self.invoiceInfo?.toMap()
            }
            if self.lmItemInfoList != nil {
                var tmp : [Any] = []
                for k in self.lmItemInfoList! {
                    tmp.append(k.toMap())
                }
                map["LmItemInfoList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressInfoList") && dict["AddressInfoList"] != nil {
                var tmp : [RenderH5OrderResponseBody.Model.AddressInfoList] = []
                for v in dict["AddressInfoList"] as! [Any] {
                    var model = RenderH5OrderResponseBody.Model.AddressInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addressInfoList = tmp
            }
            if dict.keys.contains("BuyerCurrentPoints") && dict["BuyerCurrentPoints"] != nil {
                self.buyerCurrentPoints = dict["BuyerCurrentPoints"] as! Int64
            }
            if dict.keys.contains("DeliveryInfoList") && dict["DeliveryInfoList"] != nil {
                var tmp : [RenderH5OrderResponseBody.Model.DeliveryInfoList] = []
                for v in dict["DeliveryInfoList"] as! [Any] {
                    var model = RenderH5OrderResponseBody.Model.DeliveryInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deliveryInfoList = tmp
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("InvoiceInfo") && dict["InvoiceInfo"] != nil {
                var model = RenderH5OrderResponseBody.Model.InvoiceInfo()
                model.fromMap(dict["InvoiceInfo"] as! [String: Any])
                self.invoiceInfo = model
            }
            if dict.keys.contains("LmItemInfoList") && dict["LmItemInfoList"] != nil {
                var tmp : [RenderH5OrderResponseBody.Model.LmItemInfoList] = []
                for v in dict["LmItemInfoList"] as! [Any] {
                    var model = RenderH5OrderResponseBody.Model.LmItemInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lmItemInfoList = tmp
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: RenderH5OrderResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = RenderH5OrderResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class RenderH5OrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenderH5OrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RenderH5OrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenderOrderRequest : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var itemId: Int64?

        public var lmItemId: String?

        public var quantity: Int32?

        public var skuId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.skuId != nil {
                map["SkuId"] = self.skuId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                self.skuId = dict["SkuId"] as! Int64
            }
        }
    }
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var deliveryAddress: String?

    public var extJson: String?

    public var itemList: [RenderOrderRequest.ItemList]?

    public var lmItemId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.lmItemId != nil {
            map["LmItemId"] = self.lmItemId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            self.deliveryAddress = dict["DeliveryAddress"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [RenderOrderRequest.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = RenderOrderRequest.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
            self.lmItemId = dict["LmItemId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class RenderOrderResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class RenderOrderInfos : Tea.TeaModel {
            public class RenderOrderInfos : Tea.TeaModel {
                public class DeliveryInfos : Tea.TeaModel {
                    public class DeliveryInfos : Tea.TeaModel {
                        public var displayName: String?

                        public var id: String?

                        public var postFee: Int64?

                        public var serviceType: Int64?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.displayName != nil {
                                map["DisplayName"] = self.displayName!
                            }
                            if self.id != nil {
                                map["Id"] = self.id!
                            }
                            if self.postFee != nil {
                                map["PostFee"] = self.postFee!
                            }
                            if self.serviceType != nil {
                                map["ServiceType"] = self.serviceType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                                self.displayName = dict["DisplayName"] as! String
                            }
                            if dict.keys.contains("Id") && dict["Id"] != nil {
                                self.id = dict["Id"] as! String
                            }
                            if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
                                self.postFee = dict["PostFee"] as! Int64
                            }
                            if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
                                self.serviceType = dict["ServiceType"] as! Int64
                            }
                        }
                    }
                    public var deliveryInfos: [RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.DeliveryInfos.DeliveryInfos]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.deliveryInfos != nil {
                            var tmp : [Any] = []
                            for k in self.deliveryInfos! {
                                tmp.append(k.toMap())
                            }
                            map["DeliveryInfos"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DeliveryInfos") && dict["DeliveryInfos"] != nil {
                            var tmp : [RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.DeliveryInfos.DeliveryInfos] = []
                            for v in dict["DeliveryInfos"] as! [Any] {
                                var model = RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.DeliveryInfos.DeliveryInfos()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.deliveryInfos = tmp
                        }
                    }
                }
                public class LmItemInfos : Tea.TeaModel {
                    public class LmItemInfos : Tea.TeaModel {
                        public var actualPrice: Int64?

                        public var canSell: Bool?

                        public var cash: Int64?

                        public var itemId: Int64?

                        public var itemName: String?

                        public var itemPicUrl: String?

                        public var lmItemId: String?

                        public var message: String?

                        public var points: Int64?

                        public var quantity: Int32?

                        public var sellerId: Int64?

                        public var sellerNick: String?

                        public var skuId: Int64?

                        public var skuName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.actualPrice != nil {
                                map["ActualPrice"] = self.actualPrice!
                            }
                            if self.canSell != nil {
                                map["CanSell"] = self.canSell!
                            }
                            if self.cash != nil {
                                map["Cash"] = self.cash!
                            }
                            if self.itemId != nil {
                                map["ItemId"] = self.itemId!
                            }
                            if self.itemName != nil {
                                map["ItemName"] = self.itemName!
                            }
                            if self.itemPicUrl != nil {
                                map["ItemPicUrl"] = self.itemPicUrl!
                            }
                            if self.lmItemId != nil {
                                map["LmItemId"] = self.lmItemId!
                            }
                            if self.message != nil {
                                map["Message"] = self.message!
                            }
                            if self.points != nil {
                                map["Points"] = self.points!
                            }
                            if self.quantity != nil {
                                map["Quantity"] = self.quantity!
                            }
                            if self.sellerId != nil {
                                map["SellerId"] = self.sellerId!
                            }
                            if self.sellerNick != nil {
                                map["SellerNick"] = self.sellerNick!
                            }
                            if self.skuId != nil {
                                map["SkuId"] = self.skuId!
                            }
                            if self.skuName != nil {
                                map["SkuName"] = self.skuName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ActualPrice") && dict["ActualPrice"] != nil {
                                self.actualPrice = dict["ActualPrice"] as! Int64
                            }
                            if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                                self.canSell = dict["CanSell"] as! Bool
                            }
                            if dict.keys.contains("Cash") && dict["Cash"] != nil {
                                self.cash = dict["Cash"] as! Int64
                            }
                            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                                self.itemId = dict["ItemId"] as! Int64
                            }
                            if dict.keys.contains("ItemName") && dict["ItemName"] != nil {
                                self.itemName = dict["ItemName"] as! String
                            }
                            if dict.keys.contains("ItemPicUrl") && dict["ItemPicUrl"] != nil {
                                self.itemPicUrl = dict["ItemPicUrl"] as! String
                            }
                            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                                self.lmItemId = dict["LmItemId"] as! String
                            }
                            if dict.keys.contains("Message") && dict["Message"] != nil {
                                self.message = dict["Message"] as! String
                            }
                            if dict.keys.contains("Points") && dict["Points"] != nil {
                                self.points = dict["Points"] as! Int64
                            }
                            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                                self.quantity = dict["Quantity"] as! Int32
                            }
                            if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                                self.sellerId = dict["SellerId"] as! Int64
                            }
                            if dict.keys.contains("SellerNick") && dict["SellerNick"] != nil {
                                self.sellerNick = dict["SellerNick"] as! String
                            }
                            if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                                self.skuId = dict["SkuId"] as! Int64
                            }
                            if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                                self.skuName = dict["SkuName"] as! String
                            }
                        }
                    }
                    public var lmItemInfos: [RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.LmItemInfos.LmItemInfos]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lmItemInfos != nil {
                            var tmp : [Any] = []
                            for k in self.lmItemInfos! {
                                tmp.append(k.toMap())
                            }
                            map["LmItemInfos"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LmItemInfos") && dict["LmItemInfos"] != nil {
                            var tmp : [RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.LmItemInfos.LmItemInfos] = []
                            for v in dict["LmItemInfos"] as! [Any] {
                                var model = RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.LmItemInfos.LmItemInfos()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.lmItemInfos = tmp
                        }
                    }
                }
                public var deliveryInfos: RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.DeliveryInfos?

                public var extInfo: [String: Any]?

                public var lmItemInfos: RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.LmItemInfos?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.deliveryInfos?.validate()
                    try self.lmItemInfos?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.deliveryInfos != nil {
                        map["DeliveryInfos"] = self.deliveryInfos?.toMap()
                    }
                    if self.extInfo != nil {
                        map["ExtInfo"] = self.extInfo!
                    }
                    if self.lmItemInfos != nil {
                        map["LmItemInfos"] = self.lmItemInfos?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DeliveryInfos") && dict["DeliveryInfos"] != nil {
                        var model = RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.DeliveryInfos()
                        model.fromMap(dict["DeliveryInfos"] as! [String: Any])
                        self.deliveryInfos = model
                    }
                    if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                        self.extInfo = dict["ExtInfo"] as! [String: Any]
                    }
                    if dict.keys.contains("LmItemInfos") && dict["LmItemInfos"] != nil {
                        var model = RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos.LmItemInfos()
                        model.fromMap(dict["LmItemInfos"] as! [String: Any])
                        self.lmItemInfos = model
                    }
                }
            }
            public var renderOrderInfos: [RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.renderOrderInfos != nil {
                    var tmp : [Any] = []
                    for k in self.renderOrderInfos! {
                        tmp.append(k.toMap())
                    }
                    map["RenderOrderInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RenderOrderInfos") && dict["RenderOrderInfos"] != nil {
                    var tmp : [RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos] = []
                    for v in dict["RenderOrderInfos"] as! [Any] {
                        var model = RenderOrderResponseBody.Model.RenderOrderInfos.RenderOrderInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.renderOrderInfos = tmp
                }
            }
        }
        public var renderOrderInfos: RenderOrderResponseBody.Model.RenderOrderInfos?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.renderOrderInfos?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.renderOrderInfos != nil {
                map["RenderOrderInfos"] = self.renderOrderInfos?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RenderOrderInfos") && dict["RenderOrderInfos"] != nil {
                var model = RenderOrderResponseBody.Model.RenderOrderInfos()
                model.fromMap(dict["RenderOrderInfos"] as! [String: Any])
                self.renderOrderInfos = model
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: RenderOrderResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = RenderOrderResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class RenderOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenderOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RenderOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenderOrderWithDesignatedTbUidRequest : Tea.TeaModel {
    public class ItemList : Tea.TeaModel {
        public var itemId: Int64?

        public var lmItemId: String?

        public var quantity: Int32?

        public var skuId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.lmItemId != nil {
                map["LmItemId"] = self.lmItemId!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.skuId != nil {
                map["SkuId"] = self.skuId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                self.lmItemId = dict["LmItemId"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int32
            }
            if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                self.skuId = dict["SkuId"] as! Int64
            }
        }
    }
    public var bizId: String?

    public var deliveryAddress: String?

    public var itemList: [RenderOrderWithDesignatedTbUidRequest.ItemList]?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress!
        }
        if self.itemList != nil {
            var tmp : [Any] = []
            for k in self.itemList! {
                tmp.append(k.toMap())
            }
            map["ItemList"] = tmp
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            self.deliveryAddress = dict["DeliveryAddress"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            var tmp : [RenderOrderWithDesignatedTbUidRequest.ItemList] = []
            for v in dict["ItemList"] as! [Any] {
                var model = RenderOrderWithDesignatedTbUidRequest.ItemList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.itemList = tmp
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class RenderOrderWithDesignatedTbUidShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var deliveryAddress: String?

    public var itemListShrink: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.deliveryAddress != nil {
            map["DeliveryAddress"] = self.deliveryAddress!
        }
        if self.itemListShrink != nil {
            map["ItemList"] = self.itemListShrink!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("DeliveryAddress") && dict["DeliveryAddress"] != nil {
            self.deliveryAddress = dict["DeliveryAddress"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            self.itemListShrink = dict["ItemList"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class RenderOrderWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public class AddressInfos : Tea.TeaModel {
            public var addressDetail: String?

            public var addressId: Int64?

            public var divisionCode: String?

            public var isDefault: Bool?

            public var receiver: String?

            public var receiverPhone: String?

            public var townDivisionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressDetail != nil {
                    map["AddressDetail"] = self.addressDetail!
                }
                if self.addressId != nil {
                    map["AddressId"] = self.addressId!
                }
                if self.divisionCode != nil {
                    map["DivisionCode"] = self.divisionCode!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.receiver != nil {
                    map["Receiver"] = self.receiver!
                }
                if self.receiverPhone != nil {
                    map["ReceiverPhone"] = self.receiverPhone!
                }
                if self.townDivisionCode != nil {
                    map["TownDivisionCode"] = self.townDivisionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressDetail") && dict["AddressDetail"] != nil {
                    self.addressDetail = dict["AddressDetail"] as! String
                }
                if dict.keys.contains("AddressId") && dict["AddressId"] != nil {
                    self.addressId = dict["AddressId"] as! Int64
                }
                if dict.keys.contains("DivisionCode") && dict["DivisionCode"] != nil {
                    self.divisionCode = dict["DivisionCode"] as! String
                }
                if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                    self.isDefault = dict["IsDefault"] as! Bool
                }
                if dict.keys.contains("Receiver") && dict["Receiver"] != nil {
                    self.receiver = dict["Receiver"] as! String
                }
                if dict.keys.contains("ReceiverPhone") && dict["ReceiverPhone"] != nil {
                    self.receiverPhone = dict["ReceiverPhone"] as! String
                }
                if dict.keys.contains("TownDivisionCode") && dict["TownDivisionCode"] != nil {
                    self.townDivisionCode = dict["TownDivisionCode"] as! String
                }
            }
        }
        public class RenderOrderInfos : Tea.TeaModel {
            public class DeliveryInfos : Tea.TeaModel {
                public var displayName: String?

                public var id: String?

                public var postFee: Int64?

                public var serviceType: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.postFee != nil {
                        map["PostFee"] = self.postFee!
                    }
                    if self.serviceType != nil {
                        map["ServiceType"] = self.serviceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
                        self.postFee = dict["PostFee"] as! Int64
                    }
                    if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
                        self.serviceType = dict["ServiceType"] as! Int64
                    }
                }
            }
            public class InvoiceInfo : Tea.TeaModel {
                public var desc: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desc != nil {
                        map["Desc"] = self.desc!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Desc") && dict["Desc"] != nil {
                        self.desc = dict["Desc"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class LmItemInfos : Tea.TeaModel {
                public class ItemPromInstVOS : Tea.TeaModel {
                    public class AvailableItems : Tea.TeaModel {
                        public var itemId: Int64?

                        public var lmItemId: String?

                        public var lmShopId: Int64?

                        public var number: Int32?

                        public var points: Int64?

                        public var pointsAmount: Int64?

                        public var priceCent: Int64?

                        public var removed: Bool?

                        public var skuId: Int64?

                        public var tbSellerId: Int64?

                        public var userPayFee: Int64?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.itemId != nil {
                                map["ItemId"] = self.itemId!
                            }
                            if self.lmItemId != nil {
                                map["LmItemId"] = self.lmItemId!
                            }
                            if self.lmShopId != nil {
                                map["LmShopId"] = self.lmShopId!
                            }
                            if self.number != nil {
                                map["Number"] = self.number!
                            }
                            if self.points != nil {
                                map["Points"] = self.points!
                            }
                            if self.pointsAmount != nil {
                                map["PointsAmount"] = self.pointsAmount!
                            }
                            if self.priceCent != nil {
                                map["PriceCent"] = self.priceCent!
                            }
                            if self.removed != nil {
                                map["Removed"] = self.removed!
                            }
                            if self.skuId != nil {
                                map["SkuId"] = self.skuId!
                            }
                            if self.tbSellerId != nil {
                                map["TbSellerId"] = self.tbSellerId!
                            }
                            if self.userPayFee != nil {
                                map["UserPayFee"] = self.userPayFee!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                                self.itemId = dict["ItemId"] as! Int64
                            }
                            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                                self.lmItemId = dict["LmItemId"] as! String
                            }
                            if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
                                self.lmShopId = dict["LmShopId"] as! Int64
                            }
                            if dict.keys.contains("Number") && dict["Number"] != nil {
                                self.number = dict["Number"] as! Int32
                            }
                            if dict.keys.contains("Points") && dict["Points"] != nil {
                                self.points = dict["Points"] as! Int64
                            }
                            if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                                self.pointsAmount = dict["PointsAmount"] as! Int64
                            }
                            if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                                self.priceCent = dict["PriceCent"] as! Int64
                            }
                            if dict.keys.contains("Removed") && dict["Removed"] != nil {
                                self.removed = dict["Removed"] as! Bool
                            }
                            if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                                self.skuId = dict["SkuId"] as! Int64
                            }
                            if dict.keys.contains("TbSellerId") && dict["TbSellerId"] != nil {
                                self.tbSellerId = dict["TbSellerId"] as! Int64
                            }
                            if dict.keys.contains("UserPayFee") && dict["UserPayFee"] != nil {
                                self.userPayFee = dict["UserPayFee"] as! Int64
                            }
                        }
                    }
                    public var availableItems: [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.LmItemInfos.ItemPromInstVOS.AvailableItems]?

                    public var canUse: Bool?

                    public var discountPrice: Int64?

                    public var expireTime: Int64?

                    public var instanceId: String?

                    public var level: String?

                    public var lmItemId: String?

                    public var promotionName: String?

                    public var promotionType: String?

                    public var reason: String?

                    public var selected: Bool?

                    public var skuIds: [Int64]?

                    public var specialPrice: Int64?

                    public var subBizCode: String?

                    public var tbSellerId: Int64?

                    public var thresholdPrice: Int64?

                    public var useStartTime: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableItems != nil {
                            var tmp : [Any] = []
                            for k in self.availableItems! {
                                tmp.append(k.toMap())
                            }
                            map["AvailableItems"] = tmp
                        }
                        if self.canUse != nil {
                            map["CanUse"] = self.canUse!
                        }
                        if self.discountPrice != nil {
                            map["DiscountPrice"] = self.discountPrice!
                        }
                        if self.expireTime != nil {
                            map["ExpireTime"] = self.expireTime!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.lmItemId != nil {
                            map["LmItemId"] = self.lmItemId!
                        }
                        if self.promotionName != nil {
                            map["PromotionName"] = self.promotionName!
                        }
                        if self.promotionType != nil {
                            map["PromotionType"] = self.promotionType!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        if self.selected != nil {
                            map["Selected"] = self.selected!
                        }
                        if self.skuIds != nil {
                            map["SkuIds"] = self.skuIds!
                        }
                        if self.specialPrice != nil {
                            map["SpecialPrice"] = self.specialPrice!
                        }
                        if self.subBizCode != nil {
                            map["SubBizCode"] = self.subBizCode!
                        }
                        if self.tbSellerId != nil {
                            map["TbSellerId"] = self.tbSellerId!
                        }
                        if self.thresholdPrice != nil {
                            map["ThresholdPrice"] = self.thresholdPrice!
                        }
                        if self.useStartTime != nil {
                            map["UseStartTime"] = self.useStartTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AvailableItems") && dict["AvailableItems"] != nil {
                            var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.LmItemInfos.ItemPromInstVOS.AvailableItems] = []
                            for v in dict["AvailableItems"] as! [Any] {
                                var model = RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.LmItemInfos.ItemPromInstVOS.AvailableItems()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.availableItems = tmp
                        }
                        if dict.keys.contains("CanUse") && dict["CanUse"] != nil {
                            self.canUse = dict["CanUse"] as! Bool
                        }
                        if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
                            self.discountPrice = dict["DiscountPrice"] as! Int64
                        }
                        if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                            self.expireTime = dict["ExpireTime"] as! Int64
                        }
                        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("Level") && dict["Level"] != nil {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                            self.lmItemId = dict["LmItemId"] as! String
                        }
                        if dict.keys.contains("PromotionName") && dict["PromotionName"] != nil {
                            self.promotionName = dict["PromotionName"] as! String
                        }
                        if dict.keys.contains("PromotionType") && dict["PromotionType"] != nil {
                            self.promotionType = dict["PromotionType"] as! String
                        }
                        if dict.keys.contains("Reason") && dict["Reason"] != nil {
                            self.reason = dict["Reason"] as! String
                        }
                        if dict.keys.contains("Selected") && dict["Selected"] != nil {
                            self.selected = dict["Selected"] as! Bool
                        }
                        if dict.keys.contains("SkuIds") && dict["SkuIds"] != nil {
                            self.skuIds = dict["SkuIds"] as! [Int64]
                        }
                        if dict.keys.contains("SpecialPrice") && dict["SpecialPrice"] != nil {
                            self.specialPrice = dict["SpecialPrice"] as! Int64
                        }
                        if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                            self.subBizCode = dict["SubBizCode"] as! String
                        }
                        if dict.keys.contains("TbSellerId") && dict["TbSellerId"] != nil {
                            self.tbSellerId = dict["TbSellerId"] as! Int64
                        }
                        if dict.keys.contains("ThresholdPrice") && dict["ThresholdPrice"] != nil {
                            self.thresholdPrice = dict["ThresholdPrice"] as! Int64
                        }
                        if dict.keys.contains("UseStartTime") && dict["UseStartTime"] != nil {
                            self.useStartTime = dict["UseStartTime"] as! Int64
                        }
                    }
                }
                public var actualPrice: Int64?

                public var canSell: Bool?

                public var cash: Int64?

                public var features: [String: String]?

                public var itemId: Int64?

                public var itemName: String?

                public var itemPicUrl: String?

                public var itemPromInstVOS: [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.LmItemInfos.ItemPromInstVOS]?

                public var itemUrl: String?

                public var lmItemId: String?

                public var message: String?

                public var pointPrice: Int64?

                public var points: Int64?

                public var promotionFee: Int64?

                public var quantity: Int32?

                public var reservePrice: Int64?

                public var sellerId: Int64?

                public var sellerNick: String?

                public var skuId: Int64?

                public var skuName: String?

                public var tbShopName: String?

                public var virtualItemType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.actualPrice != nil {
                        map["ActualPrice"] = self.actualPrice!
                    }
                    if self.canSell != nil {
                        map["CanSell"] = self.canSell!
                    }
                    if self.cash != nil {
                        map["Cash"] = self.cash!
                    }
                    if self.features != nil {
                        map["Features"] = self.features!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.itemName != nil {
                        map["ItemName"] = self.itemName!
                    }
                    if self.itemPicUrl != nil {
                        map["ItemPicUrl"] = self.itemPicUrl!
                    }
                    if self.itemPromInstVOS != nil {
                        var tmp : [Any] = []
                        for k in self.itemPromInstVOS! {
                            tmp.append(k.toMap())
                        }
                        map["ItemPromInstVOS"] = tmp
                    }
                    if self.itemUrl != nil {
                        map["ItemUrl"] = self.itemUrl!
                    }
                    if self.lmItemId != nil {
                        map["LmItemId"] = self.lmItemId!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.pointPrice != nil {
                        map["PointPrice"] = self.pointPrice!
                    }
                    if self.points != nil {
                        map["Points"] = self.points!
                    }
                    if self.promotionFee != nil {
                        map["PromotionFee"] = self.promotionFee!
                    }
                    if self.quantity != nil {
                        map["Quantity"] = self.quantity!
                    }
                    if self.reservePrice != nil {
                        map["ReservePrice"] = self.reservePrice!
                    }
                    if self.sellerId != nil {
                        map["SellerId"] = self.sellerId!
                    }
                    if self.sellerNick != nil {
                        map["SellerNick"] = self.sellerNick!
                    }
                    if self.skuId != nil {
                        map["SkuId"] = self.skuId!
                    }
                    if self.skuName != nil {
                        map["SkuName"] = self.skuName!
                    }
                    if self.tbShopName != nil {
                        map["TbShopName"] = self.tbShopName!
                    }
                    if self.virtualItemType != nil {
                        map["VirtualItemType"] = self.virtualItemType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActualPrice") && dict["ActualPrice"] != nil {
                        self.actualPrice = dict["ActualPrice"] as! Int64
                    }
                    if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                        self.canSell = dict["CanSell"] as! Bool
                    }
                    if dict.keys.contains("Cash") && dict["Cash"] != nil {
                        self.cash = dict["Cash"] as! Int64
                    }
                    if dict.keys.contains("Features") && dict["Features"] != nil {
                        self.features = dict["Features"] as! [String: String]
                    }
                    if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                        self.itemId = dict["ItemId"] as! Int64
                    }
                    if dict.keys.contains("ItemName") && dict["ItemName"] != nil {
                        self.itemName = dict["ItemName"] as! String
                    }
                    if dict.keys.contains("ItemPicUrl") && dict["ItemPicUrl"] != nil {
                        self.itemPicUrl = dict["ItemPicUrl"] as! String
                    }
                    if dict.keys.contains("ItemPromInstVOS") && dict["ItemPromInstVOS"] != nil {
                        var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.LmItemInfos.ItemPromInstVOS] = []
                        for v in dict["ItemPromInstVOS"] as! [Any] {
                            var model = RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.LmItemInfos.ItemPromInstVOS()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.itemPromInstVOS = tmp
                    }
                    if dict.keys.contains("ItemUrl") && dict["ItemUrl"] != nil {
                        self.itemUrl = dict["ItemUrl"] as! String
                    }
                    if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                        self.lmItemId = dict["LmItemId"] as! String
                    }
                    if dict.keys.contains("Message") && dict["Message"] != nil {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                        self.pointPrice = dict["PointPrice"] as! Int64
                    }
                    if dict.keys.contains("Points") && dict["Points"] != nil {
                        self.points = dict["Points"] as! Int64
                    }
                    if dict.keys.contains("PromotionFee") && dict["PromotionFee"] != nil {
                        self.promotionFee = dict["PromotionFee"] as! Int64
                    }
                    if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                        self.quantity = dict["Quantity"] as! Int32
                    }
                    if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                        self.reservePrice = dict["ReservePrice"] as! Int64
                    }
                    if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                        self.sellerId = dict["SellerId"] as! Int64
                    }
                    if dict.keys.contains("SellerNick") && dict["SellerNick"] != nil {
                        self.sellerNick = dict["SellerNick"] as! String
                    }
                    if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                        self.skuId = dict["SkuId"] as! Int64
                    }
                    if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                        self.skuName = dict["SkuName"] as! String
                    }
                    if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                        self.tbShopName = dict["TbShopName"] as! String
                    }
                    if dict.keys.contains("VirtualItemType") && dict["VirtualItemType"] != nil {
                        self.virtualItemType = dict["VirtualItemType"] as! String
                    }
                }
            }
            public class ShopPromInstVOS : Tea.TeaModel {
                public class AvailableItems : Tea.TeaModel {
                    public var itemId: Int64?

                    public var lmItemId: String?

                    public var lmShopId: Int64?

                    public var number: Int32?

                    public var points: Int64?

                    public var pointsAmount: Int64?

                    public var priceCent: Int64?

                    public var removed: Bool?

                    public var skuId: Int64?

                    public var tbSellerId: Int64?

                    public var userPayFee: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.itemId != nil {
                            map["ItemId"] = self.itemId!
                        }
                        if self.lmItemId != nil {
                            map["LmItemId"] = self.lmItemId!
                        }
                        if self.lmShopId != nil {
                            map["LmShopId"] = self.lmShopId!
                        }
                        if self.number != nil {
                            map["Number"] = self.number!
                        }
                        if self.points != nil {
                            map["Points"] = self.points!
                        }
                        if self.pointsAmount != nil {
                            map["PointsAmount"] = self.pointsAmount!
                        }
                        if self.priceCent != nil {
                            map["PriceCent"] = self.priceCent!
                        }
                        if self.removed != nil {
                            map["Removed"] = self.removed!
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        if self.tbSellerId != nil {
                            map["TbSellerId"] = self.tbSellerId!
                        }
                        if self.userPayFee != nil {
                            map["UserPayFee"] = self.userPayFee!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                            self.itemId = dict["ItemId"] as! Int64
                        }
                        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                            self.lmItemId = dict["LmItemId"] as! String
                        }
                        if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
                            self.lmShopId = dict["LmShopId"] as! Int64
                        }
                        if dict.keys.contains("Number") && dict["Number"] != nil {
                            self.number = dict["Number"] as! Int32
                        }
                        if dict.keys.contains("Points") && dict["Points"] != nil {
                            self.points = dict["Points"] as! Int64
                        }
                        if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                            self.pointsAmount = dict["PointsAmount"] as! Int64
                        }
                        if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                            self.priceCent = dict["PriceCent"] as! Int64
                        }
                        if dict.keys.contains("Removed") && dict["Removed"] != nil {
                            self.removed = dict["Removed"] as! Bool
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                        if dict.keys.contains("TbSellerId") && dict["TbSellerId"] != nil {
                            self.tbSellerId = dict["TbSellerId"] as! Int64
                        }
                        if dict.keys.contains("UserPayFee") && dict["UserPayFee"] != nil {
                            self.userPayFee = dict["UserPayFee"] as! Int64
                        }
                    }
                }
                public var availableItems: [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.ShopPromInstVOS.AvailableItems]?

                public var canUse: Bool?

                public var discountPrice: Int64?

                public var expireTime: Int64?

                public var instanceId: String?

                public var level: String?

                public var lmItemId: String?

                public var promotionName: String?

                public var promotionType: String?

                public var reason: String?

                public var selected: Bool?

                public var skuIds: [Int64]?

                public var specialPrice: Int64?

                public var subBizCode: String?

                public var tbSellerId: Int64?

                public var thresholdPrice: Int64?

                public var useStartTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableItems != nil {
                        var tmp : [Any] = []
                        for k in self.availableItems! {
                            tmp.append(k.toMap())
                        }
                        map["AvailableItems"] = tmp
                    }
                    if self.canUse != nil {
                        map["CanUse"] = self.canUse!
                    }
                    if self.discountPrice != nil {
                        map["DiscountPrice"] = self.discountPrice!
                    }
                    if self.expireTime != nil {
                        map["ExpireTime"] = self.expireTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.lmItemId != nil {
                        map["LmItemId"] = self.lmItemId!
                    }
                    if self.promotionName != nil {
                        map["PromotionName"] = self.promotionName!
                    }
                    if self.promotionType != nil {
                        map["PromotionType"] = self.promotionType!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.selected != nil {
                        map["Selected"] = self.selected!
                    }
                    if self.skuIds != nil {
                        map["SkuIds"] = self.skuIds!
                    }
                    if self.specialPrice != nil {
                        map["SpecialPrice"] = self.specialPrice!
                    }
                    if self.subBizCode != nil {
                        map["SubBizCode"] = self.subBizCode!
                    }
                    if self.tbSellerId != nil {
                        map["TbSellerId"] = self.tbSellerId!
                    }
                    if self.thresholdPrice != nil {
                        map["ThresholdPrice"] = self.thresholdPrice!
                    }
                    if self.useStartTime != nil {
                        map["UseStartTime"] = self.useStartTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableItems") && dict["AvailableItems"] != nil {
                        var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.ShopPromInstVOS.AvailableItems] = []
                        for v in dict["AvailableItems"] as! [Any] {
                            var model = RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.ShopPromInstVOS.AvailableItems()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.availableItems = tmp
                    }
                    if dict.keys.contains("CanUse") && dict["CanUse"] != nil {
                        self.canUse = dict["CanUse"] as! Bool
                    }
                    if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
                        self.discountPrice = dict["DiscountPrice"] as! Int64
                    }
                    if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                        self.expireTime = dict["ExpireTime"] as! Int64
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                        self.lmItemId = dict["LmItemId"] as! String
                    }
                    if dict.keys.contains("PromotionName") && dict["PromotionName"] != nil {
                        self.promotionName = dict["PromotionName"] as! String
                    }
                    if dict.keys.contains("PromotionType") && dict["PromotionType"] != nil {
                        self.promotionType = dict["PromotionType"] as! String
                    }
                    if dict.keys.contains("Reason") && dict["Reason"] != nil {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("Selected") && dict["Selected"] != nil {
                        self.selected = dict["Selected"] as! Bool
                    }
                    if dict.keys.contains("SkuIds") && dict["SkuIds"] != nil {
                        self.skuIds = dict["SkuIds"] as! [Int64]
                    }
                    if dict.keys.contains("SpecialPrice") && dict["SpecialPrice"] != nil {
                        self.specialPrice = dict["SpecialPrice"] as! Int64
                    }
                    if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                        self.subBizCode = dict["SubBizCode"] as! String
                    }
                    if dict.keys.contains("TbSellerId") && dict["TbSellerId"] != nil {
                        self.tbSellerId = dict["TbSellerId"] as! Int64
                    }
                    if dict.keys.contains("ThresholdPrice") && dict["ThresholdPrice"] != nil {
                        self.thresholdPrice = dict["ThresholdPrice"] as! Int64
                    }
                    if dict.keys.contains("UseStartTime") && dict["UseStartTime"] != nil {
                        self.useStartTime = dict["UseStartTime"] as! Int64
                    }
                }
            }
            public var canSell: Bool?

            public var deliveryInfos: [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.DeliveryInfos]?

            public var extInfo: [String: String]?

            public var invoiceInfo: RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.InvoiceInfo?

            public var lmItemInfos: [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.LmItemInfos]?

            public var message: String?

            public var sellerId: Int64?

            public var shopPromInstVOS: [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.ShopPromInstVOS]?

            public var tbShopName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.invoiceInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canSell != nil {
                    map["CanSell"] = self.canSell!
                }
                if self.deliveryInfos != nil {
                    var tmp : [Any] = []
                    for k in self.deliveryInfos! {
                        tmp.append(k.toMap())
                    }
                    map["DeliveryInfos"] = tmp
                }
                if self.extInfo != nil {
                    map["ExtInfo"] = self.extInfo!
                }
                if self.invoiceInfo != nil {
                    map["InvoiceInfo"] = self.invoiceInfo?.toMap()
                }
                if self.lmItemInfos != nil {
                    var tmp : [Any] = []
                    for k in self.lmItemInfos! {
                        tmp.append(k.toMap())
                    }
                    map["LmItemInfos"] = tmp
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.sellerId != nil {
                    map["SellerId"] = self.sellerId!
                }
                if self.shopPromInstVOS != nil {
                    var tmp : [Any] = []
                    for k in self.shopPromInstVOS! {
                        tmp.append(k.toMap())
                    }
                    map["ShopPromInstVOS"] = tmp
                }
                if self.tbShopName != nil {
                    map["TbShopName"] = self.tbShopName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                    self.canSell = dict["CanSell"] as! Bool
                }
                if dict.keys.contains("DeliveryInfos") && dict["DeliveryInfos"] != nil {
                    var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.DeliveryInfos] = []
                    for v in dict["DeliveryInfos"] as! [Any] {
                        var model = RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.DeliveryInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.deliveryInfos = tmp
                }
                if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                    self.extInfo = dict["ExtInfo"] as! [String: String]
                }
                if dict.keys.contains("InvoiceInfo") && dict["InvoiceInfo"] != nil {
                    var model = RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.InvoiceInfo()
                    model.fromMap(dict["InvoiceInfo"] as! [String: Any])
                    self.invoiceInfo = model
                }
                if dict.keys.contains("LmItemInfos") && dict["LmItemInfos"] != nil {
                    var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.LmItemInfos] = []
                    for v in dict["LmItemInfos"] as! [Any] {
                        var model = RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.LmItemInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.lmItemInfos = tmp
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                    self.sellerId = dict["SellerId"] as! Int64
                }
                if dict.keys.contains("ShopPromInstVOS") && dict["ShopPromInstVOS"] != nil {
                    var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.ShopPromInstVOS] = []
                    for v in dict["ShopPromInstVOS"] as! [Any] {
                        var model = RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos.ShopPromInstVOS()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.shopPromInstVOS = tmp
                }
                if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                    self.tbShopName = dict["TbShopName"] as! String
                }
            }
        }
        public class UnsellableRenderOrderInfos : Tea.TeaModel {
            public class DeliveryInfos : Tea.TeaModel {
                public var displayName: String?

                public var id: String?

                public var postFee: Int64?

                public var serviceType: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.postFee != nil {
                        map["PostFee"] = self.postFee!
                    }
                    if self.serviceType != nil {
                        map["ServiceType"] = self.serviceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("PostFee") && dict["PostFee"] != nil {
                        self.postFee = dict["PostFee"] as! Int64
                    }
                    if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
                        self.serviceType = dict["ServiceType"] as! Int64
                    }
                }
            }
            public class InvoiceInfo : Tea.TeaModel {
                public var desc: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desc != nil {
                        map["Desc"] = self.desc!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Desc") && dict["Desc"] != nil {
                        self.desc = dict["Desc"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class LmItemInfos : Tea.TeaModel {
                public class ItemPromInstVOS : Tea.TeaModel {
                    public class AvailableItems : Tea.TeaModel {
                        public var itemId: Int64?

                        public var lmItemId: String?

                        public var lmShopId: Int64?

                        public var number: Int32?

                        public var points: Int64?

                        public var pointsAmount: Int64?

                        public var priceCent: Int64?

                        public var removed: Bool?

                        public var skuId: Int64?

                        public var tbSellerId: Int64?

                        public var userPayFee: Int64?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.itemId != nil {
                                map["ItemId"] = self.itemId!
                            }
                            if self.lmItemId != nil {
                                map["LmItemId"] = self.lmItemId!
                            }
                            if self.lmShopId != nil {
                                map["LmShopId"] = self.lmShopId!
                            }
                            if self.number != nil {
                                map["Number"] = self.number!
                            }
                            if self.points != nil {
                                map["Points"] = self.points!
                            }
                            if self.pointsAmount != nil {
                                map["PointsAmount"] = self.pointsAmount!
                            }
                            if self.priceCent != nil {
                                map["PriceCent"] = self.priceCent!
                            }
                            if self.removed != nil {
                                map["Removed"] = self.removed!
                            }
                            if self.skuId != nil {
                                map["SkuId"] = self.skuId!
                            }
                            if self.tbSellerId != nil {
                                map["TbSellerId"] = self.tbSellerId!
                            }
                            if self.userPayFee != nil {
                                map["UserPayFee"] = self.userPayFee!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                                self.itemId = dict["ItemId"] as! Int64
                            }
                            if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                                self.lmItemId = dict["LmItemId"] as! String
                            }
                            if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
                                self.lmShopId = dict["LmShopId"] as! Int64
                            }
                            if dict.keys.contains("Number") && dict["Number"] != nil {
                                self.number = dict["Number"] as! Int32
                            }
                            if dict.keys.contains("Points") && dict["Points"] != nil {
                                self.points = dict["Points"] as! Int64
                            }
                            if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                                self.pointsAmount = dict["PointsAmount"] as! Int64
                            }
                            if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                                self.priceCent = dict["PriceCent"] as! Int64
                            }
                            if dict.keys.contains("Removed") && dict["Removed"] != nil {
                                self.removed = dict["Removed"] as! Bool
                            }
                            if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                                self.skuId = dict["SkuId"] as! Int64
                            }
                            if dict.keys.contains("TbSellerId") && dict["TbSellerId"] != nil {
                                self.tbSellerId = dict["TbSellerId"] as! Int64
                            }
                            if dict.keys.contains("UserPayFee") && dict["UserPayFee"] != nil {
                                self.userPayFee = dict["UserPayFee"] as! Int64
                            }
                        }
                    }
                    public var availableItems: [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.LmItemInfos.ItemPromInstVOS.AvailableItems]?

                    public var canUse: Bool?

                    public var discountPrice: Int64?

                    public var expireTime: Int64?

                    public var instanceId: String?

                    public var level: String?

                    public var lmItemId: String?

                    public var promotionName: String?

                    public var promotionType: String?

                    public var reason: String?

                    public var selected: Bool?

                    public var skuIds: [Int64]?

                    public var specialPrice: Int64?

                    public var subBizCode: String?

                    public var tbSellerId: Int64?

                    public var thresholdPrice: Int64?

                    public var useStartTime: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableItems != nil {
                            var tmp : [Any] = []
                            for k in self.availableItems! {
                                tmp.append(k.toMap())
                            }
                            map["AvailableItems"] = tmp
                        }
                        if self.canUse != nil {
                            map["CanUse"] = self.canUse!
                        }
                        if self.discountPrice != nil {
                            map["DiscountPrice"] = self.discountPrice!
                        }
                        if self.expireTime != nil {
                            map["ExpireTime"] = self.expireTime!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.lmItemId != nil {
                            map["LmItemId"] = self.lmItemId!
                        }
                        if self.promotionName != nil {
                            map["PromotionName"] = self.promotionName!
                        }
                        if self.promotionType != nil {
                            map["PromotionType"] = self.promotionType!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        if self.selected != nil {
                            map["Selected"] = self.selected!
                        }
                        if self.skuIds != nil {
                            map["SkuIds"] = self.skuIds!
                        }
                        if self.specialPrice != nil {
                            map["SpecialPrice"] = self.specialPrice!
                        }
                        if self.subBizCode != nil {
                            map["SubBizCode"] = self.subBizCode!
                        }
                        if self.tbSellerId != nil {
                            map["TbSellerId"] = self.tbSellerId!
                        }
                        if self.thresholdPrice != nil {
                            map["ThresholdPrice"] = self.thresholdPrice!
                        }
                        if self.useStartTime != nil {
                            map["UseStartTime"] = self.useStartTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AvailableItems") && dict["AvailableItems"] != nil {
                            var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.LmItemInfos.ItemPromInstVOS.AvailableItems] = []
                            for v in dict["AvailableItems"] as! [Any] {
                                var model = RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.LmItemInfos.ItemPromInstVOS.AvailableItems()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.availableItems = tmp
                        }
                        if dict.keys.contains("CanUse") && dict["CanUse"] != nil {
                            self.canUse = dict["CanUse"] as! Bool
                        }
                        if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
                            self.discountPrice = dict["DiscountPrice"] as! Int64
                        }
                        if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                            self.expireTime = dict["ExpireTime"] as! Int64
                        }
                        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("Level") && dict["Level"] != nil {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                            self.lmItemId = dict["LmItemId"] as! String
                        }
                        if dict.keys.contains("PromotionName") && dict["PromotionName"] != nil {
                            self.promotionName = dict["PromotionName"] as! String
                        }
                        if dict.keys.contains("PromotionType") && dict["PromotionType"] != nil {
                            self.promotionType = dict["PromotionType"] as! String
                        }
                        if dict.keys.contains("Reason") && dict["Reason"] != nil {
                            self.reason = dict["Reason"] as! String
                        }
                        if dict.keys.contains("Selected") && dict["Selected"] != nil {
                            self.selected = dict["Selected"] as! Bool
                        }
                        if dict.keys.contains("SkuIds") && dict["SkuIds"] != nil {
                            self.skuIds = dict["SkuIds"] as! [Int64]
                        }
                        if dict.keys.contains("SpecialPrice") && dict["SpecialPrice"] != nil {
                            self.specialPrice = dict["SpecialPrice"] as! Int64
                        }
                        if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                            self.subBizCode = dict["SubBizCode"] as! String
                        }
                        if dict.keys.contains("TbSellerId") && dict["TbSellerId"] != nil {
                            self.tbSellerId = dict["TbSellerId"] as! Int64
                        }
                        if dict.keys.contains("ThresholdPrice") && dict["ThresholdPrice"] != nil {
                            self.thresholdPrice = dict["ThresholdPrice"] as! Int64
                        }
                        if dict.keys.contains("UseStartTime") && dict["UseStartTime"] != nil {
                            self.useStartTime = dict["UseStartTime"] as! Int64
                        }
                    }
                }
                public var actualPrice: Int64?

                public var canSell: Bool?

                public var cash: Int64?

                public var features: [String: String]?

                public var itemId: Int64?

                public var itemName: String?

                public var itemPicUrl: String?

                public var itemPromInstVOS: [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.LmItemInfos.ItemPromInstVOS]?

                public var itemUrl: String?

                public var lmItemId: String?

                public var message: String?

                public var pointPrice: Int64?

                public var points: Int64?

                public var promotionFee: Int64?

                public var quantity: Int32?

                public var reservePrice: Int64?

                public var sellerId: Int64?

                public var sellerNick: String?

                public var skuId: Int64?

                public var skuName: String?

                public var tbShopName: String?

                public var virtualItemType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.actualPrice != nil {
                        map["ActualPrice"] = self.actualPrice!
                    }
                    if self.canSell != nil {
                        map["CanSell"] = self.canSell!
                    }
                    if self.cash != nil {
                        map["Cash"] = self.cash!
                    }
                    if self.features != nil {
                        map["Features"] = self.features!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.itemName != nil {
                        map["ItemName"] = self.itemName!
                    }
                    if self.itemPicUrl != nil {
                        map["ItemPicUrl"] = self.itemPicUrl!
                    }
                    if self.itemPromInstVOS != nil {
                        var tmp : [Any] = []
                        for k in self.itemPromInstVOS! {
                            tmp.append(k.toMap())
                        }
                        map["ItemPromInstVOS"] = tmp
                    }
                    if self.itemUrl != nil {
                        map["ItemUrl"] = self.itemUrl!
                    }
                    if self.lmItemId != nil {
                        map["LmItemId"] = self.lmItemId!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.pointPrice != nil {
                        map["PointPrice"] = self.pointPrice!
                    }
                    if self.points != nil {
                        map["Points"] = self.points!
                    }
                    if self.promotionFee != nil {
                        map["PromotionFee"] = self.promotionFee!
                    }
                    if self.quantity != nil {
                        map["Quantity"] = self.quantity!
                    }
                    if self.reservePrice != nil {
                        map["ReservePrice"] = self.reservePrice!
                    }
                    if self.sellerId != nil {
                        map["SellerId"] = self.sellerId!
                    }
                    if self.sellerNick != nil {
                        map["SellerNick"] = self.sellerNick!
                    }
                    if self.skuId != nil {
                        map["SkuId"] = self.skuId!
                    }
                    if self.skuName != nil {
                        map["SkuName"] = self.skuName!
                    }
                    if self.tbShopName != nil {
                        map["TbShopName"] = self.tbShopName!
                    }
                    if self.virtualItemType != nil {
                        map["VirtualItemType"] = self.virtualItemType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActualPrice") && dict["ActualPrice"] != nil {
                        self.actualPrice = dict["ActualPrice"] as! Int64
                    }
                    if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                        self.canSell = dict["CanSell"] as! Bool
                    }
                    if dict.keys.contains("Cash") && dict["Cash"] != nil {
                        self.cash = dict["Cash"] as! Int64
                    }
                    if dict.keys.contains("Features") && dict["Features"] != nil {
                        self.features = dict["Features"] as! [String: String]
                    }
                    if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                        self.itemId = dict["ItemId"] as! Int64
                    }
                    if dict.keys.contains("ItemName") && dict["ItemName"] != nil {
                        self.itemName = dict["ItemName"] as! String
                    }
                    if dict.keys.contains("ItemPicUrl") && dict["ItemPicUrl"] != nil {
                        self.itemPicUrl = dict["ItemPicUrl"] as! String
                    }
                    if dict.keys.contains("ItemPromInstVOS") && dict["ItemPromInstVOS"] != nil {
                        var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.LmItemInfos.ItemPromInstVOS] = []
                        for v in dict["ItemPromInstVOS"] as! [Any] {
                            var model = RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.LmItemInfos.ItemPromInstVOS()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.itemPromInstVOS = tmp
                    }
                    if dict.keys.contains("ItemUrl") && dict["ItemUrl"] != nil {
                        self.itemUrl = dict["ItemUrl"] as! String
                    }
                    if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                        self.lmItemId = dict["LmItemId"] as! String
                    }
                    if dict.keys.contains("Message") && dict["Message"] != nil {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("PointPrice") && dict["PointPrice"] != nil {
                        self.pointPrice = dict["PointPrice"] as! Int64
                    }
                    if dict.keys.contains("Points") && dict["Points"] != nil {
                        self.points = dict["Points"] as! Int64
                    }
                    if dict.keys.contains("PromotionFee") && dict["PromotionFee"] != nil {
                        self.promotionFee = dict["PromotionFee"] as! Int64
                    }
                    if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                        self.quantity = dict["Quantity"] as! Int32
                    }
                    if dict.keys.contains("ReservePrice") && dict["ReservePrice"] != nil {
                        self.reservePrice = dict["ReservePrice"] as! Int64
                    }
                    if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                        self.sellerId = dict["SellerId"] as! Int64
                    }
                    if dict.keys.contains("SellerNick") && dict["SellerNick"] != nil {
                        self.sellerNick = dict["SellerNick"] as! String
                    }
                    if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                        self.skuId = dict["SkuId"] as! Int64
                    }
                    if dict.keys.contains("SkuName") && dict["SkuName"] != nil {
                        self.skuName = dict["SkuName"] as! String
                    }
                    if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                        self.tbShopName = dict["TbShopName"] as! String
                    }
                    if dict.keys.contains("VirtualItemType") && dict["VirtualItemType"] != nil {
                        self.virtualItemType = dict["VirtualItemType"] as! String
                    }
                }
            }
            public class ShopPromInstVOS : Tea.TeaModel {
                public class AvailableItems : Tea.TeaModel {
                    public var itemId: Int64?

                    public var lmItemId: String?

                    public var lmShopId: Int64?

                    public var number: Int32?

                    public var points: Int64?

                    public var pointsAmount: Int64?

                    public var priceCent: Int64?

                    public var removed: Bool?

                    public var skuId: Int64?

                    public var tbSellerId: Int64?

                    public var userPayFee: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.itemId != nil {
                            map["ItemId"] = self.itemId!
                        }
                        if self.lmItemId != nil {
                            map["LmItemId"] = self.lmItemId!
                        }
                        if self.lmShopId != nil {
                            map["LmShopId"] = self.lmShopId!
                        }
                        if self.number != nil {
                            map["Number"] = self.number!
                        }
                        if self.points != nil {
                            map["Points"] = self.points!
                        }
                        if self.pointsAmount != nil {
                            map["PointsAmount"] = self.pointsAmount!
                        }
                        if self.priceCent != nil {
                            map["PriceCent"] = self.priceCent!
                        }
                        if self.removed != nil {
                            map["Removed"] = self.removed!
                        }
                        if self.skuId != nil {
                            map["SkuId"] = self.skuId!
                        }
                        if self.tbSellerId != nil {
                            map["TbSellerId"] = self.tbSellerId!
                        }
                        if self.userPayFee != nil {
                            map["UserPayFee"] = self.userPayFee!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                            self.itemId = dict["ItemId"] as! Int64
                        }
                        if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                            self.lmItemId = dict["LmItemId"] as! String
                        }
                        if dict.keys.contains("LmShopId") && dict["LmShopId"] != nil {
                            self.lmShopId = dict["LmShopId"] as! Int64
                        }
                        if dict.keys.contains("Number") && dict["Number"] != nil {
                            self.number = dict["Number"] as! Int32
                        }
                        if dict.keys.contains("Points") && dict["Points"] != nil {
                            self.points = dict["Points"] as! Int64
                        }
                        if dict.keys.contains("PointsAmount") && dict["PointsAmount"] != nil {
                            self.pointsAmount = dict["PointsAmount"] as! Int64
                        }
                        if dict.keys.contains("PriceCent") && dict["PriceCent"] != nil {
                            self.priceCent = dict["PriceCent"] as! Int64
                        }
                        if dict.keys.contains("Removed") && dict["Removed"] != nil {
                            self.removed = dict["Removed"] as! Bool
                        }
                        if dict.keys.contains("SkuId") && dict["SkuId"] != nil {
                            self.skuId = dict["SkuId"] as! Int64
                        }
                        if dict.keys.contains("TbSellerId") && dict["TbSellerId"] != nil {
                            self.tbSellerId = dict["TbSellerId"] as! Int64
                        }
                        if dict.keys.contains("UserPayFee") && dict["UserPayFee"] != nil {
                            self.userPayFee = dict["UserPayFee"] as! Int64
                        }
                    }
                }
                public var availableItems: [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.ShopPromInstVOS.AvailableItems]?

                public var canUse: Bool?

                public var discountPrice: Int64?

                public var expireTime: Int64?

                public var instanceId: String?

                public var level: String?

                public var lmItemId: String?

                public var promotionName: String?

                public var promotionType: String?

                public var reason: String?

                public var selected: Bool?

                public var skuIds: [Int64]?

                public var specialPrice: Int64?

                public var subBizCode: String?

                public var tbSellerId: Int64?

                public var thresholdPrice: Int64?

                public var useStartTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableItems != nil {
                        var tmp : [Any] = []
                        for k in self.availableItems! {
                            tmp.append(k.toMap())
                        }
                        map["AvailableItems"] = tmp
                    }
                    if self.canUse != nil {
                        map["CanUse"] = self.canUse!
                    }
                    if self.discountPrice != nil {
                        map["DiscountPrice"] = self.discountPrice!
                    }
                    if self.expireTime != nil {
                        map["ExpireTime"] = self.expireTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.lmItemId != nil {
                        map["LmItemId"] = self.lmItemId!
                    }
                    if self.promotionName != nil {
                        map["PromotionName"] = self.promotionName!
                    }
                    if self.promotionType != nil {
                        map["PromotionType"] = self.promotionType!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.selected != nil {
                        map["Selected"] = self.selected!
                    }
                    if self.skuIds != nil {
                        map["SkuIds"] = self.skuIds!
                    }
                    if self.specialPrice != nil {
                        map["SpecialPrice"] = self.specialPrice!
                    }
                    if self.subBizCode != nil {
                        map["SubBizCode"] = self.subBizCode!
                    }
                    if self.tbSellerId != nil {
                        map["TbSellerId"] = self.tbSellerId!
                    }
                    if self.thresholdPrice != nil {
                        map["ThresholdPrice"] = self.thresholdPrice!
                    }
                    if self.useStartTime != nil {
                        map["UseStartTime"] = self.useStartTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableItems") && dict["AvailableItems"] != nil {
                        var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.ShopPromInstVOS.AvailableItems] = []
                        for v in dict["AvailableItems"] as! [Any] {
                            var model = RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.ShopPromInstVOS.AvailableItems()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.availableItems = tmp
                    }
                    if dict.keys.contains("CanUse") && dict["CanUse"] != nil {
                        self.canUse = dict["CanUse"] as! Bool
                    }
                    if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
                        self.discountPrice = dict["DiscountPrice"] as! Int64
                    }
                    if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                        self.expireTime = dict["ExpireTime"] as! Int64
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("LmItemId") && dict["LmItemId"] != nil {
                        self.lmItemId = dict["LmItemId"] as! String
                    }
                    if dict.keys.contains("PromotionName") && dict["PromotionName"] != nil {
                        self.promotionName = dict["PromotionName"] as! String
                    }
                    if dict.keys.contains("PromotionType") && dict["PromotionType"] != nil {
                        self.promotionType = dict["PromotionType"] as! String
                    }
                    if dict.keys.contains("Reason") && dict["Reason"] != nil {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("Selected") && dict["Selected"] != nil {
                        self.selected = dict["Selected"] as! Bool
                    }
                    if dict.keys.contains("SkuIds") && dict["SkuIds"] != nil {
                        self.skuIds = dict["SkuIds"] as! [Int64]
                    }
                    if dict.keys.contains("SpecialPrice") && dict["SpecialPrice"] != nil {
                        self.specialPrice = dict["SpecialPrice"] as! Int64
                    }
                    if dict.keys.contains("SubBizCode") && dict["SubBizCode"] != nil {
                        self.subBizCode = dict["SubBizCode"] as! String
                    }
                    if dict.keys.contains("TbSellerId") && dict["TbSellerId"] != nil {
                        self.tbSellerId = dict["TbSellerId"] as! Int64
                    }
                    if dict.keys.contains("ThresholdPrice") && dict["ThresholdPrice"] != nil {
                        self.thresholdPrice = dict["ThresholdPrice"] as! Int64
                    }
                    if dict.keys.contains("UseStartTime") && dict["UseStartTime"] != nil {
                        self.useStartTime = dict["UseStartTime"] as! Int64
                    }
                }
            }
            public var canSell: Bool?

            public var deliveryInfos: [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.DeliveryInfos]?

            public var extInfo: [String: String]?

            public var invoiceInfo: RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.InvoiceInfo?

            public var lmItemInfos: [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.LmItemInfos]?

            public var message: String?

            public var sellerId: Int64?

            public var shopPromInstVOS: [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.ShopPromInstVOS]?

            public var tbShopName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.invoiceInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canSell != nil {
                    map["CanSell"] = self.canSell!
                }
                if self.deliveryInfos != nil {
                    var tmp : [Any] = []
                    for k in self.deliveryInfos! {
                        tmp.append(k.toMap())
                    }
                    map["DeliveryInfos"] = tmp
                }
                if self.extInfo != nil {
                    map["ExtInfo"] = self.extInfo!
                }
                if self.invoiceInfo != nil {
                    map["InvoiceInfo"] = self.invoiceInfo?.toMap()
                }
                if self.lmItemInfos != nil {
                    var tmp : [Any] = []
                    for k in self.lmItemInfos! {
                        tmp.append(k.toMap())
                    }
                    map["LmItemInfos"] = tmp
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.sellerId != nil {
                    map["SellerId"] = self.sellerId!
                }
                if self.shopPromInstVOS != nil {
                    var tmp : [Any] = []
                    for k in self.shopPromInstVOS! {
                        tmp.append(k.toMap())
                    }
                    map["ShopPromInstVOS"] = tmp
                }
                if self.tbShopName != nil {
                    map["TbShopName"] = self.tbShopName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                    self.canSell = dict["CanSell"] as! Bool
                }
                if dict.keys.contains("DeliveryInfos") && dict["DeliveryInfos"] != nil {
                    var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.DeliveryInfos] = []
                    for v in dict["DeliveryInfos"] as! [Any] {
                        var model = RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.DeliveryInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.deliveryInfos = tmp
                }
                if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                    self.extInfo = dict["ExtInfo"] as! [String: String]
                }
                if dict.keys.contains("InvoiceInfo") && dict["InvoiceInfo"] != nil {
                    var model = RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.InvoiceInfo()
                    model.fromMap(dict["InvoiceInfo"] as! [String: Any])
                    self.invoiceInfo = model
                }
                if dict.keys.contains("LmItemInfos") && dict["LmItemInfos"] != nil {
                    var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.LmItemInfos] = []
                    for v in dict["LmItemInfos"] as! [Any] {
                        var model = RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.LmItemInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.lmItemInfos = tmp
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("SellerId") && dict["SellerId"] != nil {
                    self.sellerId = dict["SellerId"] as! Int64
                }
                if dict.keys.contains("ShopPromInstVOS") && dict["ShopPromInstVOS"] != nil {
                    var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.ShopPromInstVOS] = []
                    for v in dict["ShopPromInstVOS"] as! [Any] {
                        var model = RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos.ShopPromInstVOS()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.shopPromInstVOS = tmp
                }
                if dict.keys.contains("TbShopName") && dict["TbShopName"] != nil {
                    self.tbShopName = dict["TbShopName"] as! String
                }
            }
        }
        public var addressInfos: [RenderOrderWithDesignatedTbUidResponseBody.Model.AddressInfos]?

        public var buyerCurrentPoints: Int64?

        public var canSell: Bool?

        public var extInfo: [String: String]?

        public var message: String?

        public var renderOrderInfos: [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos]?

        public var unsellableRenderOrderInfos: [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressInfos != nil {
                var tmp : [Any] = []
                for k in self.addressInfos! {
                    tmp.append(k.toMap())
                }
                map["AddressInfos"] = tmp
            }
            if self.buyerCurrentPoints != nil {
                map["BuyerCurrentPoints"] = self.buyerCurrentPoints!
            }
            if self.canSell != nil {
                map["CanSell"] = self.canSell!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.renderOrderInfos != nil {
                var tmp : [Any] = []
                for k in self.renderOrderInfos! {
                    tmp.append(k.toMap())
                }
                map["RenderOrderInfos"] = tmp
            }
            if self.unsellableRenderOrderInfos != nil {
                var tmp : [Any] = []
                for k in self.unsellableRenderOrderInfos! {
                    tmp.append(k.toMap())
                }
                map["UnsellableRenderOrderInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressInfos") && dict["AddressInfos"] != nil {
                var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.AddressInfos] = []
                for v in dict["AddressInfos"] as! [Any] {
                    var model = RenderOrderWithDesignatedTbUidResponseBody.Model.AddressInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addressInfos = tmp
            }
            if dict.keys.contains("BuyerCurrentPoints") && dict["BuyerCurrentPoints"] != nil {
                self.buyerCurrentPoints = dict["BuyerCurrentPoints"] as! Int64
            }
            if dict.keys.contains("CanSell") && dict["CanSell"] != nil {
                self.canSell = dict["CanSell"] as! Bool
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: String]
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RenderOrderInfos") && dict["RenderOrderInfos"] != nil {
                var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos] = []
                for v in dict["RenderOrderInfos"] as! [Any] {
                    var model = RenderOrderWithDesignatedTbUidResponseBody.Model.RenderOrderInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.renderOrderInfos = tmp
            }
            if dict.keys.contains("UnsellableRenderOrderInfos") && dict["UnsellableRenderOrderInfos"] != nil {
                var tmp : [RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos] = []
                for v in dict["UnsellableRenderOrderInfos"] as! [Any] {
                    var model = RenderOrderWithDesignatedTbUidResponseBody.Model.UnsellableRenderOrderInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.unsellableRenderOrderInfos = tmp
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: RenderOrderWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = RenderOrderWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class RenderOrderWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenderOrderWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RenderOrderWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RepayForPayUrlRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var lmOrderId: Int64?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class RepayForPayUrlResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var frontUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.frontUrl != nil {
                map["FrontUrl"] = self.frontUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FrontUrl") && dict["FrontUrl"] != nil {
                self.frontUrl = dict["FrontUrl"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: RepayForPayUrlResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = RepayForPayUrlResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RepayForPayUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RepayForPayUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RepayForPayUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RepayOrderRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var lmOrderId: Int64?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class RepayOrderResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RepayOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RepayOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RepayOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RepayWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var extJson: String?

    public var lmOrderId: Int64?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.lmOrderId != nil {
            map["LmOrderId"] = self.lmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("LmOrderId") && dict["LmOrderId"] != nil {
            self.lmOrderId = dict["LmOrderId"] as! Int64
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class RepayWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var app: String?

        public var frontUrl: String?

        public var isOnlyPaidPoint: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.frontUrl != nil {
                map["FrontUrl"] = self.frontUrl!
            }
            if self.isOnlyPaidPoint != nil {
                map["IsOnlyPaidPoint"] = self.isOnlyPaidPoint!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") && dict["App"] != nil {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("FrontUrl") && dict["FrontUrl"] != nil {
                self.frontUrl = dict["FrontUrl"] as! String
            }
            if dict.keys.contains("IsOnlyPaidPoint") && dict["IsOnlyPaidPoint"] != nil {
                self.isOnlyPaidPoint = dict["IsOnlyPaidPoint"] as! Bool
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: RepayWithDesignatedTbUidResponseBody.Model?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = RepayWithDesignatedTbUidResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class RepayWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RepayWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RepayWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReserveMovieSeatRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var extJson: String?

    public var mobile: String?

    public var scheduleId: Int64?

    public var seatIds: String?

    public var seatNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.scheduleId != nil {
            map["ScheduleId"] = self.scheduleId!
        }
        if self.seatIds != nil {
            map["SeatIds"] = self.seatIds!
        }
        if self.seatNames != nil {
            map["SeatNames"] = self.seatNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("ScheduleId") && dict["ScheduleId"] != nil {
            self.scheduleId = dict["ScheduleId"] as! Int64
        }
        if dict.keys.contains("SeatIds") && dict["SeatIds"] != nil {
            self.seatIds = dict["SeatIds"] as! String
        }
        if dict.keys.contains("SeatNames") && dict["SeatNames"] != nil {
            self.seatNames = dict["SeatNames"] as! String
        }
    }
}

public class ReserveMovieSeatResponseBody : Tea.TeaModel {
    public class ReservedSeat : Tea.TeaModel {
        public var applyKey: String?

        public var defaultLockSecond: Int64?

        public var reservedTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyKey != nil {
                map["ApplyKey"] = self.applyKey!
            }
            if self.defaultLockSecond != nil {
                map["DefaultLockSecond"] = self.defaultLockSecond!
            }
            if self.reservedTime != nil {
                map["ReservedTime"] = self.reservedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyKey") && dict["ApplyKey"] != nil {
                self.applyKey = dict["ApplyKey"] as! String
            }
            if dict.keys.contains("DefaultLockSecond") && dict["DefaultLockSecond"] != nil {
                self.defaultLockSecond = dict["DefaultLockSecond"] as! Int64
            }
            if dict.keys.contains("ReservedTime") && dict["ReservedTime"] != nil {
                self.reservedTime = dict["ReservedTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var requestId: String?

    public var reservedSeat: ReserveMovieSeatResponseBody.ReservedSeat?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedSeat?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedSeat != nil {
            map["ReservedSeat"] = self.reservedSeat?.toMap()
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedSeat") && dict["ReservedSeat"] != nil {
            var model = ReserveMovieSeatResponseBody.ReservedSeat()
            model.fromMap(dict["ReservedSeat"] as! [String: Any])
            self.reservedSeat = model
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ReserveMovieSeatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReserveMovieSeatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReserveMovieSeatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SettleOrderRequest : Tea.TeaModel {
    public var extInfo: String?

    public var merchantId: String?

    public var outRequestNo: String?

    public var outTradeNo: String?

    public var royaltyParameters: String?

    public var tradeNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.merchantId != nil {
            map["MerchantId"] = self.merchantId!
        }
        if self.outRequestNo != nil {
            map["OutRequestNo"] = self.outRequestNo!
        }
        if self.outTradeNo != nil {
            map["OutTradeNo"] = self.outTradeNo!
        }
        if self.royaltyParameters != nil {
            map["RoyaltyParameters"] = self.royaltyParameters!
        }
        if self.tradeNo != nil {
            map["TradeNo"] = self.tradeNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("MerchantId") && dict["MerchantId"] != nil {
            self.merchantId = dict["MerchantId"] as! String
        }
        if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
            self.outRequestNo = dict["OutRequestNo"] as! String
        }
        if dict.keys.contains("OutTradeNo") && dict["OutTradeNo"] != nil {
            self.outTradeNo = dict["OutTradeNo"] as! String
        }
        if dict.keys.contains("RoyaltyParameters") && dict["RoyaltyParameters"] != nil {
            self.royaltyParameters = dict["RoyaltyParameters"] as! String
        }
        if dict.keys.contains("TradeNo") && dict["TradeNo"] != nil {
            self.tradeNo = dict["TradeNo"] as! String
        }
    }
}

public class SettleOrderResponseBody : Tea.TeaModel {
    public class TradeOrderSettleResponse : Tea.TeaModel {
        public var outRequestNo: String?

        public var tradeNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.outRequestNo != nil {
                map["OutRequestNo"] = self.outRequestNo!
            }
            if self.tradeNo != nil {
                map["TradeNo"] = self.tradeNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
                self.outRequestNo = dict["OutRequestNo"] as! String
            }
            if dict.keys.contains("TradeNo") && dict["TradeNo"] != nil {
                self.tradeNo = dict["TradeNo"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var tradeOrderSettleResponse: SettleOrderResponseBody.TradeOrderSettleResponse?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tradeOrderSettleResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tradeOrderSettleResponse != nil {
            map["TradeOrderSettleResponse"] = self.tradeOrderSettleResponse?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TradeOrderSettleResponse") && dict["TradeOrderSettleResponse"] != nil {
            var model = SettleOrderResponseBody.TradeOrderSettleResponse()
            model.fromMap(dict["TradeOrderSettleResponse"] as! [String: Any])
            self.tradeOrderSettleResponse = model
        }
    }
}

public class SettleOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SettleOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SettleOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartUserGameRequest : Tea.TeaModel {
    public var accountType: String?

    public var activityId: String?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var gameId: String?

    public var routeId: String?

    public var thirdPartyUserId: String?

    public var userApp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.gameId != nil {
            map["GameId"] = self.gameId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.userApp != nil {
            map["UserApp"] = self.userApp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
            self.activityId = dict["ActivityId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("GameId") && dict["GameId"] != nil {
            self.gameId = dict["GameId"] as! String
        }
        if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
            self.routeId = dict["RouteId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UserApp") && dict["UserApp"] != nil {
            self.userApp = dict["UserApp"] as! String
        }
    }
}

public class StartUserGameShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var activityId: String?

    public var bizId: String?

    public var extInfoShrink: String?

    public var gameId: String?

    public var routeId: String?

    public var thirdPartyUserId: String?

    public var userApp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.gameId != nil {
            map["GameId"] = self.gameId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.userApp != nil {
            map["UserApp"] = self.userApp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
            self.activityId = dict["ActivityId"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("GameId") && dict["GameId"] != nil {
            self.gameId = dict["GameId"] as! String
        }
        if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
            self.routeId = dict["RouteId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UserApp") && dict["UserApp"] != nil {
            self.userApp = dict["UserApp"] as! String
        }
    }
}

public class StartUserGameResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var activityId: String?

        public var bizId: String?

        public var currentShowContent: String?

        public var currentStepId: String?

        public var currentStepStatus: String?

        public var desc: String?

        public var extInfo: String?

        public var gameId: String?

        public var name: String?

        public var processId: String?

        public var routeId: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.currentShowContent != nil {
                map["CurrentShowContent"] = self.currentShowContent!
            }
            if self.currentStepId != nil {
                map["CurrentStepId"] = self.currentStepId!
            }
            if self.currentStepStatus != nil {
                map["CurrentStepStatus"] = self.currentStepStatus!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.gameId != nil {
                map["GameId"] = self.gameId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("CurrentShowContent") && dict["CurrentShowContent"] != nil {
                self.currentShowContent = dict["CurrentShowContent"] as! String
            }
            if dict.keys.contains("CurrentStepId") && dict["CurrentStepId"] != nil {
                self.currentStepId = dict["CurrentStepId"] as! String
            }
            if dict.keys.contains("CurrentStepStatus") && dict["CurrentStepStatus"] != nil {
                self.currentStepStatus = dict["CurrentStepStatus"] as! String
            }
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! String
            }
            if dict.keys.contains("GameId") && dict["GameId"] != nil {
                self.gameId = dict["GameId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
                self.processId = dict["ProcessId"] as! String
            }
            if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
                self.routeId = dict["RouteId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: StartUserGameResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = StartUserGameResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartUserGameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartUserGameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartUserGameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitReturnGoodLogisticsRequest : Tea.TeaModel {
    public var accountType: String?

    public var bizId: String?

    public var bizUid: String?

    public var cpCode: String?

    public var disputeId: Int64?

    public var logisticsNo: String?

    public var subLmOrderId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.cpCode != nil {
            map["CpCode"] = self.cpCode!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.logisticsNo != nil {
            map["LogisticsNo"] = self.logisticsNo!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("CpCode") && dict["CpCode"] != nil {
            self.cpCode = dict["CpCode"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("LogisticsNo") && dict["LogisticsNo"] != nil {
            self.logisticsNo = dict["LogisticsNo"] as! String
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class SubmitReturnGoodLogisticsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitReturnGoodLogisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitReturnGoodLogisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitReturnGoodLogisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitReturnGoodLogisticsWithDesignatedTbUidRequest : Tea.TeaModel {
    public var bizId: String?

    public var cpCode: String?

    public var disputeId: Int64?

    public var logisticsNo: String?

    public var subLmOrderId: String?

    public var tbAccountType: String?

    public var tbUserId: Int64?

    public var thirdPartyUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.cpCode != nil {
            map["CpCode"] = self.cpCode!
        }
        if self.disputeId != nil {
            map["DisputeId"] = self.disputeId!
        }
        if self.logisticsNo != nil {
            map["LogisticsNo"] = self.logisticsNo!
        }
        if self.subLmOrderId != nil {
            map["SubLmOrderId"] = self.subLmOrderId!
        }
        if self.tbAccountType != nil {
            map["TbAccountType"] = self.tbAccountType!
        }
        if self.tbUserId != nil {
            map["TbUserId"] = self.tbUserId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CpCode") && dict["CpCode"] != nil {
            self.cpCode = dict["CpCode"] as! String
        }
        if dict.keys.contains("DisputeId") && dict["DisputeId"] != nil {
            self.disputeId = dict["DisputeId"] as! Int64
        }
        if dict.keys.contains("LogisticsNo") && dict["LogisticsNo"] != nil {
            self.logisticsNo = dict["LogisticsNo"] as! String
        }
        if dict.keys.contains("SubLmOrderId") && dict["SubLmOrderId"] != nil {
            self.subLmOrderId = dict["SubLmOrderId"] as! String
        }
        if dict.keys.contains("TbAccountType") && dict["TbAccountType"] != nil {
            self.tbAccountType = dict["TbAccountType"] as! String
        }
        if dict.keys.contains("TbUserId") && dict["TbUserId"] != nil {
            self.tbUserId = dict["TbUserId"] as! Int64
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
    }
}

public class SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody : Tea.TeaModel {
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: Any?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! Any
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SubmitReturnGoodLogisticsWithDesignatedTbUidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncMerchantInfoRequest : Tea.TeaModel {
    public var bizId: String?

    public var itemList: String?

    public var sellerNick: String?

    public var taskId: String?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.itemList != nil {
            map["ItemList"] = self.itemList!
        }
        if self.sellerNick != nil {
            map["SellerNick"] = self.sellerNick!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ItemList") && dict["ItemList"] != nil {
            self.itemList = dict["ItemList"] as! String
        }
        if dict.keys.contains("SellerNick") && dict["SellerNick"] != nil {
            self.sellerNick = dict["SellerNick"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class SyncMerchantInfoResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var status: String?

        public var taskId: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: SyncMerchantInfoResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = SyncMerchantInfoResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SyncMerchantInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncMerchantInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SyncMerchantInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnFreezeUserPointRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfo: [String: Any]?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfo != nil {
            map["ExtInfo"] = self.extInfo!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfo = dict["ExtInfo"] as! [String: Any]
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UnFreezeUserPointShrinkRequest : Tea.TeaModel {
    public var accountType: String?

    public var amount: Int64?

    public var bizId: String?

    public var extInfoShrink: String?

    public var idempotentId: String?

    public var message: String?

    public var ruleId: String?

    public var thirdPartyUserId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.extInfoShrink != nil {
            map["ExtInfo"] = self.extInfoShrink!
        }
        if self.idempotentId != nil {
            map["IdempotentId"] = self.idempotentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountType") && dict["AccountType"] != nil {
            self.accountType = dict["AccountType"] as! String
        }
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
            self.extInfoShrink = dict["ExtInfo"] as! String
        }
        if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
            self.idempotentId = dict["IdempotentId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UnFreezeUserPointResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var accountId: String?

        public var action: String?

        public var amount: Int64?

        public var bizId: String?

        public var bizUid: String?

        public var description_: String?

        public var extInfo: [String: Any]?

        public var idempotentId: String?

        public var name: String?

        public var recordId: String?

        public var rest: Int64?

        public var ruleId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.bizUid != nil {
                map["BizUid"] = self.bizUid!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo!
            }
            if self.idempotentId != nil {
                map["IdempotentId"] = self.idempotentId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.rest != nil {
                map["Rest"] = self.rest!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Amount") && dict["Amount"] != nil {
                self.amount = dict["Amount"] as! Int64
            }
            if dict.keys.contains("BizId") && dict["BizId"] != nil {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
                self.bizUid = dict["BizUid"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                self.extInfo = dict["ExtInfo"] as! [String: Any]
            }
            if dict.keys.contains("IdempotentId") && dict["IdempotentId"] != nil {
                self.idempotentId = dict["IdempotentId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("Rest") && dict["Rest"] != nil {
                self.rest = dict["Rest"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var model: UnFreezeUserPointResponseBody.Model?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = UnFreezeUserPointResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnFreezeUserPointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnFreezeUserPointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnFreezeUserPointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnsignWithholdAgreementRequest : Tea.TeaModel {
    public var agreementNo: String?

    public var externalAgreementNo: String?

    public var merchantId: String?

    public var outRequestNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agreementNo != nil {
            map["AgreementNo"] = self.agreementNo!
        }
        if self.externalAgreementNo != nil {
            map["ExternalAgreementNo"] = self.externalAgreementNo!
        }
        if self.merchantId != nil {
            map["MerchantId"] = self.merchantId!
        }
        if self.outRequestNo != nil {
            map["OutRequestNo"] = self.outRequestNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgreementNo") && dict["AgreementNo"] != nil {
            self.agreementNo = dict["AgreementNo"] as! String
        }
        if dict.keys.contains("ExternalAgreementNo") && dict["ExternalAgreementNo"] != nil {
            self.externalAgreementNo = dict["ExternalAgreementNo"] as! String
        }
        if dict.keys.contains("MerchantId") && dict["MerchantId"] != nil {
            self.merchantId = dict["MerchantId"] as! String
        }
        if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
            self.outRequestNo = dict["OutRequestNo"] as! String
        }
    }
}

public class UnsignWithholdAgreementResponseBody : Tea.TeaModel {
    public class WithholdSignResponse : Tea.TeaModel {
        public var outRequestNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.outRequestNo != nil {
                map["OutRequestNo"] = self.outRequestNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OutRequestNo") && dict["OutRequestNo"] != nil {
                self.outRequestNo = dict["OutRequestNo"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var withholdSignResponse: UnsignWithholdAgreementResponseBody.WithholdSignResponse?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.withholdSignResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.withholdSignResponse != nil {
            map["WithholdSignResponse"] = self.withholdSignResponse?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WithholdSignResponse") && dict["WithholdSignResponse"] != nil {
            var model = UnsignWithholdAgreementResponseBody.WithholdSignResponse()
            model.fromMap(dict["WithholdSignResponse"] as! [String: Any])
            self.withholdSignResponse = model
        }
    }
}

public class UnsignWithholdAgreementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnsignWithholdAgreementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnsignWithholdAgreementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAddressRequest : Tea.TeaModel {
    public var addressInfo: String?

    public var bizId: String?

    public var thirdPartyUserId: String?

    public var useAnonymousTbAccount: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressInfo != nil {
            map["AddressInfo"] = self.addressInfo!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.thirdPartyUserId != nil {
            map["ThirdPartyUserId"] = self.thirdPartyUserId!
        }
        if self.useAnonymousTbAccount != nil {
            map["UseAnonymousTbAccount"] = self.useAnonymousTbAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressInfo") && dict["AddressInfo"] != nil {
            self.addressInfo = dict["AddressInfo"] as! String
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ThirdPartyUserId") && dict["ThirdPartyUserId"] != nil {
            self.thirdPartyUserId = dict["ThirdPartyUserId"] as! String
        }
        if dict.keys.contains("UseAnonymousTbAccount") && dict["UseAnonymousTbAccount"] != nil {
            self.useAnonymousTbAccount = dict["UseAnonymousTbAccount"] as! Bool
        }
    }
}

public class UpdateAddressResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidateTaobaoAccountRequest : Tea.TeaModel {
    public var bizId: String?

    public var bizUid: String?

    public var extJson: String?

    public var mobileNo: String?

    public var tbUserNick: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bizUid != nil {
            map["BizUid"] = self.bizUid!
        }
        if self.extJson != nil {
            map["ExtJson"] = self.extJson!
        }
        if self.mobileNo != nil {
            map["MobileNo"] = self.mobileNo!
        }
        if self.tbUserNick != nil {
            map["TbUserNick"] = self.tbUserNick!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BizUid") && dict["BizUid"] != nil {
            self.bizUid = dict["BizUid"] as! String
        }
        if dict.keys.contains("ExtJson") && dict["ExtJson"] != nil {
            self.extJson = dict["ExtJson"] as! String
        }
        if dict.keys.contains("MobileNo") && dict["MobileNo"] != nil {
            self.mobileNo = dict["MobileNo"] as! String
        }
        if dict.keys.contains("TbUserNick") && dict["TbUserNick"] != nil {
            self.tbUserNick = dict["TbUserNick"] as! String
        }
    }
}

public class ValidateTaobaoAccountResponseBody : Tea.TeaModel {
    public class Model : Tea.TeaModel {
        public var match: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.match != nil {
                map["Match"] = self.match!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Match") && dict["Match"] != nil {
                self.match = dict["Match"] as! Bool
            }
        }
    }
    public var code: String?

    public var logsId: String?

    public var message: String?

    public var model: ValidateTaobaoAccountResponseBody.Model?

    public var requestId: String?

    public var subCode: String?

    public var subMessage: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.model?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.logsId != nil {
            map["LogsId"] = self.logsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.model != nil {
            map["Model"] = self.model?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCode != nil {
            map["SubCode"] = self.subCode!
        }
        if self.subMessage != nil {
            map["SubMessage"] = self.subMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("LogsId") && dict["LogsId"] != nil {
            self.logsId = dict["LogsId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            var model = ValidateTaobaoAccountResponseBody.Model()
            model.fromMap(dict["Model"] as! [String: Any])
            self.model = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCode") && dict["SubCode"] != nil {
            self.subCode = dict["SubCode"] as! String
        }
        if dict.keys.contains("SubMessage") && dict["SubMessage"] != nil {
            self.subMessage = dict["SubMessage"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ValidateTaobaoAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateTaobaoAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ValidateTaobaoAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
