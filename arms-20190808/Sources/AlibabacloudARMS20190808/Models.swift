import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class CallChainInfo : Tea.TeaModel {
    public var additionalInfo: String?

    public var appName: String?

    public var appType: String?

    public var children: [CallChainInfo]?

    public var haveSpan: Bool?

    public var logMap: [String: [String: Any]]?

    public var logTime: Int64?

    public var parentSpanId: String?

    public var pid: String?

    public var regionId: String?

    public var resultCode: String?

    public var rpc: String?

    public var rpcId: String?

    public var rpcType: Int64?

    public var serverIp: String?

    public var span: Int64?

    public var spanId: String?

    public var tagMap: [String: String]?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalInfo != nil {
            map["AdditionalInfo"] = self.additionalInfo!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.children != nil {
            var tmp : [Any] = []
            for k in self.children! {
                tmp.append(k.toMap())
            }
            map["Children"] = tmp
        }
        if self.haveSpan != nil {
            map["HaveSpan"] = self.haveSpan!
        }
        if self.logMap != nil {
            map["LogMap"] = self.logMap!
        }
        if self.logTime != nil {
            map["LogTime"] = self.logTime!
        }
        if self.parentSpanId != nil {
            map["ParentSpanId"] = self.parentSpanId!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.rpc != nil {
            map["Rpc"] = self.rpc!
        }
        if self.rpcId != nil {
            map["RpcId"] = self.rpcId!
        }
        if self.rpcType != nil {
            map["RpcType"] = self.rpcType!
        }
        if self.serverIp != nil {
            map["ServerIp"] = self.serverIp!
        }
        if self.span != nil {
            map["Span"] = self.span!
        }
        if self.spanId != nil {
            map["SpanId"] = self.spanId!
        }
        if self.tagMap != nil {
            map["TagMap"] = self.tagMap!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionalInfo") {
            self.additionalInfo = dict["AdditionalInfo"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Children") {
            var tmp : [CallChainInfo] = []
            for v in dict["Children"] as! [Any] {
                var model = CallChainInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.children = tmp
        }
        if dict.keys.contains("HaveSpan") {
            self.haveSpan = dict["HaveSpan"] as! Bool
        }
        if dict.keys.contains("LogMap") {
            self.logMap = dict["LogMap"] as! [String: [String: Any]]
        }
        if dict.keys.contains("LogTime") {
            self.logTime = dict["LogTime"] as! Int64
        }
        if dict.keys.contains("ParentSpanId") {
            self.parentSpanId = dict["ParentSpanId"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("Rpc") {
            self.rpc = dict["Rpc"] as! String
        }
        if dict.keys.contains("RpcId") {
            self.rpcId = dict["RpcId"] as! String
        }
        if dict.keys.contains("RpcType") {
            self.rpcType = dict["RpcType"] as! Int64
        }
        if dict.keys.contains("ServerIp") {
            self.serverIp = dict["ServerIp"] as! String
        }
        if dict.keys.contains("Span") {
            self.span = dict["Span"] as! Int64
        }
        if dict.keys.contains("SpanId") {
            self.spanId = dict["SpanId"] as! String
        }
        if dict.keys.contains("TagMap") {
            self.tagMap = dict["TagMap"] as! [String: String]
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class GrafanaWorkspace : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("key") {
                self.key = dict["key"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var commercial: Bool?

    public var deployType: String?

    public var description_: String?

    public var endTime: Double?

    public var gmtCreate: Double?

    public var grafanaVersion: String?

    public var grafanaWorkspaceDomain: String?

    public var grafanaWorkspaceEdition: String?

    public var grafanaWorkspaceId: String?

    public var grafanaWorkspaceIp: String?

    public var grafanaWorkspaceName: String?

    public var maxAccount: String?

    public var ntmId: String?

    public var personalDomain: String?

    public var personalDomainPrefix: String?

    public var privateDomain: String?

    public var privateIp: String?

    public var protocol_: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var shareSynced: Bool?

    public var snatIp: String?

    public var status: String?

    public var tags: [GrafanaWorkspace.Tags]?

    public var upgradeVersion: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commercial != nil {
            map["commercial"] = self.commercial!
        }
        if self.deployType != nil {
            map["deployType"] = self.deployType!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.grafanaVersion != nil {
            map["grafanaVersion"] = self.grafanaVersion!
        }
        if self.grafanaWorkspaceDomain != nil {
            map["grafanaWorkspaceDomain"] = self.grafanaWorkspaceDomain!
        }
        if self.grafanaWorkspaceEdition != nil {
            map["grafanaWorkspaceEdition"] = self.grafanaWorkspaceEdition!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.grafanaWorkspaceIp != nil {
            map["grafanaWorkspaceIp"] = self.grafanaWorkspaceIp!
        }
        if self.grafanaWorkspaceName != nil {
            map["grafanaWorkspaceName"] = self.grafanaWorkspaceName!
        }
        if self.maxAccount != nil {
            map["maxAccount"] = self.maxAccount!
        }
        if self.ntmId != nil {
            map["ntmId"] = self.ntmId!
        }
        if self.personalDomain != nil {
            map["personalDomain"] = self.personalDomain!
        }
        if self.personalDomainPrefix != nil {
            map["personalDomainPrefix"] = self.personalDomainPrefix!
        }
        if self.privateDomain != nil {
            map["privateDomain"] = self.privateDomain!
        }
        if self.privateIp != nil {
            map["privateIp"] = self.privateIp!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.shareSynced != nil {
            map["shareSynced"] = self.shareSynced!
        }
        if self.snatIp != nil {
            map["snatIp"] = self.snatIp!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["tags"] = tmp
        }
        if self.upgradeVersion != nil {
            map["upgradeVersion"] = self.upgradeVersion!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commercial") {
            self.commercial = dict["commercial"] as! Bool
        }
        if dict.keys.contains("deployType") {
            self.deployType = dict["deployType"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Double
        }
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! Double
        }
        if dict.keys.contains("grafanaVersion") {
            self.grafanaVersion = dict["grafanaVersion"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceDomain") {
            self.grafanaWorkspaceDomain = dict["grafanaWorkspaceDomain"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceEdition") {
            self.grafanaWorkspaceEdition = dict["grafanaWorkspaceEdition"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceIp") {
            self.grafanaWorkspaceIp = dict["grafanaWorkspaceIp"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceName") {
            self.grafanaWorkspaceName = dict["grafanaWorkspaceName"] as! String
        }
        if dict.keys.contains("maxAccount") {
            self.maxAccount = dict["maxAccount"] as! String
        }
        if dict.keys.contains("ntmId") {
            self.ntmId = dict["ntmId"] as! String
        }
        if dict.keys.contains("personalDomain") {
            self.personalDomain = dict["personalDomain"] as! String
        }
        if dict.keys.contains("personalDomainPrefix") {
            self.personalDomainPrefix = dict["personalDomainPrefix"] as! String
        }
        if dict.keys.contains("privateDomain") {
            self.privateDomain = dict["privateDomain"] as! String
        }
        if dict.keys.contains("privateIp") {
            self.privateIp = dict["privateIp"] as! String
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("resourceGroupId") {
            self.resourceGroupId = dict["resourceGroupId"] as! String
        }
        if dict.keys.contains("shareSynced") {
            self.shareSynced = dict["shareSynced"] as! Bool
        }
        if dict.keys.contains("snatIp") {
            self.snatIp = dict["snatIp"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("tags") {
            var tmp : [GrafanaWorkspace.Tags] = []
            for v in dict["tags"] as! [Any] {
                var model = GrafanaWorkspace.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("upgradeVersion") {
            self.upgradeVersion = dict["upgradeVersion"] as! [String]
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceAccount : Tea.TeaModel {
    public var accountId: Int64?

    public var accountNotes: String?

    public var aliyunUid: String?

    public var aliyunUserName: String?

    public var gmtCreate: Double?

    public var orgs: [GrafanaWorkspaceUserOrg]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        if self.accountNotes != nil {
            map["accountNotes"] = self.accountNotes!
        }
        if self.aliyunUid != nil {
            map["aliyunUid"] = self.aliyunUid!
        }
        if self.aliyunUserName != nil {
            map["aliyunUserName"] = self.aliyunUserName!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.orgs != nil {
            var tmp : [Any] = []
            for k in self.orgs! {
                tmp.append(k.toMap())
            }
            map["orgs"] = tmp
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! Int64
        }
        if dict.keys.contains("accountNotes") {
            self.accountNotes = dict["accountNotes"] as! String
        }
        if dict.keys.contains("aliyunUid") {
            self.aliyunUid = dict["aliyunUid"] as! String
        }
        if dict.keys.contains("aliyunUserName") {
            self.aliyunUserName = dict["aliyunUserName"] as! String
        }
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! Double
        }
        if dict.keys.contains("orgs") {
            var tmp : [GrafanaWorkspaceUserOrg] = []
            for v in dict["orgs"] as! [Any] {
                var model = GrafanaWorkspaceUserOrg()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orgs = tmp
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class GrafanaWorkspaceAlertNotification : Tea.TeaModel {
    public var id: Int64?

    public var isArms: Bool?

    public var isDefault: Bool?

    public var name: String?

    public var sendReminder: Bool?

    public var settings: String?

    public var type: String?

    public var uid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isArms != nil {
            map["isArms"] = self.isArms!
        }
        if self.isDefault != nil {
            map["isDefault"] = self.isDefault!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.sendReminder != nil {
            map["sendReminder"] = self.sendReminder!
        }
        if self.settings != nil {
            map["settings"] = self.settings!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.uid != nil {
            map["uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("isArms") {
            self.isArms = dict["isArms"] as! Bool
        }
        if dict.keys.contains("isDefault") {
            self.isDefault = dict["isDefault"] as! Bool
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("sendReminder") {
            self.sendReminder = dict["sendReminder"] as! Bool
        }
        if dict.keys.contains("settings") {
            self.settings = dict["settings"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("uid") {
            self.uid = dict["uid"] as! String
        }
    }
}

public class GrafanaWorkspaceArmsAlertConfig : Tea.TeaModel {
    public var armsAlertsEnable: String?

    public var armsAlertsWebhookUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.armsAlertsEnable != nil {
            map["armsAlertsEnable"] = self.armsAlertsEnable!
        }
        if self.armsAlertsWebhookUrl != nil {
            map["armsAlertsWebhookUrl"] = self.armsAlertsWebhookUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("armsAlertsEnable") {
            self.armsAlertsEnable = dict["armsAlertsEnable"] as! String
        }
        if dict.keys.contains("armsAlertsWebhookUrl") {
            self.armsAlertsWebhookUrl = dict["armsAlertsWebhookUrl"] as! String
        }
    }
}

public class GrafanaWorkspaceCustomDomain : Tea.TeaModel {
    public var cert: String?

    public var date: Int64?

    public var domain: String?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var key: String?

    public var privateZone: String?

    public var protocol_: String?

    public var status: String?

    public var uri: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cert != nil {
            map["cert"] = self.cert!
        }
        if self.date != nil {
            map["date"] = self.date!
        }
        if self.domain != nil {
            map["domain"] = self.domain!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.key != nil {
            map["key"] = self.key!
        }
        if self.privateZone != nil {
            map["privateZone"] = self.privateZone!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.uri != nil {
            map["uri"] = self.uri!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("cert") {
            self.cert = dict["cert"] as! String
        }
        if dict.keys.contains("date") {
            self.date = dict["date"] as! Int64
        }
        if dict.keys.contains("domain") {
            self.domain = dict["domain"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("key") {
            self.key = dict["key"] as! String
        }
        if dict.keys.contains("privateZone") {
            self.privateZone = dict["privateZone"] as! String
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("uri") {
            self.uri = dict["uri"] as! String
        }
    }
}

public class GrafanaWorkspaceDashboardReport : Tea.TeaModel {
    public var gmtCreate: Int64?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var lastSendTime: Int64?

    public var msg: String?

    public var name: String?

    public var reportChannelTarget: String?

    public var reportChannelType: String?

    public var reportStyle: String?

    public var reportType: String?

    public var status: String?

    public var triggerDay: String?

    public var triggerTime: String?

    public var triggerType: String?

    public var url: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.lastSendTime != nil {
            map["lastSendTime"] = self.lastSendTime!
        }
        if self.msg != nil {
            map["msg"] = self.msg!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.reportChannelTarget != nil {
            map["reportChannelTarget"] = self.reportChannelTarget!
        }
        if self.reportChannelType != nil {
            map["reportChannelType"] = self.reportChannelType!
        }
        if self.reportStyle != nil {
            map["reportStyle"] = self.reportStyle!
        }
        if self.reportType != nil {
            map["reportType"] = self.reportType!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.triggerDay != nil {
            map["triggerDay"] = self.triggerDay!
        }
        if self.triggerTime != nil {
            map["triggerTime"] = self.triggerTime!
        }
        if self.triggerType != nil {
            map["triggerType"] = self.triggerType!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! Int64
        }
        if dict.keys.contains("grafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("lastSendTime") {
            self.lastSendTime = dict["lastSendTime"] as! Int64
        }
        if dict.keys.contains("msg") {
            self.msg = dict["msg"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("reportChannelTarget") {
            self.reportChannelTarget = dict["reportChannelTarget"] as! String
        }
        if dict.keys.contains("reportChannelType") {
            self.reportChannelType = dict["reportChannelType"] as! String
        }
        if dict.keys.contains("reportStyle") {
            self.reportStyle = dict["reportStyle"] as! String
        }
        if dict.keys.contains("reportType") {
            self.reportType = dict["reportType"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("triggerDay") {
            self.triggerDay = dict["triggerDay"] as! String
        }
        if dict.keys.contains("triggerTime") {
            self.triggerTime = dict["triggerTime"] as! String
        }
        if dict.keys.contains("triggerType") {
            self.triggerType = dict["triggerType"] as! String
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceDashboardSync : Tea.TeaModel {
    public var dashboardTitle: String?

    public var dashboardURL: String?

    public var dashboardUid: String?

    public var folderId: String?

    public var folderTitle: String?

    public var folderURL: String?

    public var folderUid: String?

    public var orgId: String?

    public var orgName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dashboardTitle != nil {
            map["dashboardTitle"] = self.dashboardTitle!
        }
        if self.dashboardURL != nil {
            map["dashboardURL"] = self.dashboardURL!
        }
        if self.dashboardUid != nil {
            map["dashboardUid"] = self.dashboardUid!
        }
        if self.folderId != nil {
            map["folderId"] = self.folderId!
        }
        if self.folderTitle != nil {
            map["folderTitle"] = self.folderTitle!
        }
        if self.folderURL != nil {
            map["folderURL"] = self.folderURL!
        }
        if self.folderUid != nil {
            map["folderUid"] = self.folderUid!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.orgName != nil {
            map["orgName"] = self.orgName!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dashboardTitle") {
            self.dashboardTitle = dict["dashboardTitle"] as! String
        }
        if dict.keys.contains("dashboardURL") {
            self.dashboardURL = dict["dashboardURL"] as! String
        }
        if dict.keys.contains("dashboardUid") {
            self.dashboardUid = dict["dashboardUid"] as! String
        }
        if dict.keys.contains("folderId") {
            self.folderId = dict["folderId"] as! String
        }
        if dict.keys.contains("folderTitle") {
            self.folderTitle = dict["folderTitle"] as! String
        }
        if dict.keys.contains("folderURL") {
            self.folderURL = dict["folderURL"] as! String
        }
        if dict.keys.contains("folderUid") {
            self.folderUid = dict["folderUid"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! String
        }
        if dict.keys.contains("orgName") {
            self.orgName = dict["orgName"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class GrafanaWorkspaceDataBackup : Tea.TeaModel {
    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var msg: String?

    public var processName: String?

    public var processStatus: String?

    public var subType: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["gmtModified"] = self.gmtModified!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.msg != nil {
            map["msg"] = self.msg!
        }
        if self.processName != nil {
            map["processName"] = self.processName!
        }
        if self.processStatus != nil {
            map["processStatus"] = self.processStatus!
        }
        if self.subType != nil {
            map["subType"] = self.subType!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! Int64
        }
        if dict.keys.contains("gmtModified") {
            self.gmtModified = dict["gmtModified"] as! Int64
        }
        if dict.keys.contains("grafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("msg") {
            self.msg = dict["msg"] as! String
        }
        if dict.keys.contains("processName") {
            self.processName = dict["processName"] as! String
        }
        if dict.keys.contains("processStatus") {
            self.processStatus = dict["processStatus"] as! String
        }
        if dict.keys.contains("subType") {
            self.subType = dict["subType"] as! String
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceIniBackup : Tea.TeaModel {
    public var ext: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var msg: String?

    public var processName: String?

    public var processStatus: String?

    public var subType: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ext != nil {
            map["ext"] = self.ext!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["gmtModified"] = self.gmtModified!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.msg != nil {
            map["msg"] = self.msg!
        }
        if self.processName != nil {
            map["processName"] = self.processName!
        }
        if self.processStatus != nil {
            map["processStatus"] = self.processStatus!
        }
        if self.subType != nil {
            map["subType"] = self.subType!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ext") {
            self.ext = dict["ext"] as! String
        }
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! Int64
        }
        if dict.keys.contains("gmtModified") {
            self.gmtModified = dict["gmtModified"] as! Int64
        }
        if dict.keys.contains("grafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("msg") {
            self.msg = dict["msg"] as! String
        }
        if dict.keys.contains("processName") {
            self.processName = dict["processName"] as! String
        }
        if dict.keys.contains("processStatus") {
            self.processStatus = dict["processStatus"] as! String
        }
        if dict.keys.contains("subType") {
            self.subType = dict["subType"] as! String
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceIniProperty : Tea.TeaModel {
    public var defaultValue: String?

    public var description_: String?

    public var example: String?

    public var key: String?

    public var secret: Bool?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultValue != nil {
            map["defaultValue"] = self.defaultValue!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.example != nil {
            map["example"] = self.example!
        }
        if self.key != nil {
            map["key"] = self.key!
        }
        if self.secret != nil {
            map["secret"] = self.secret!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("defaultValue") {
            self.defaultValue = dict["defaultValue"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("example") {
            self.example = dict["example"] as! String
        }
        if dict.keys.contains("key") {
            self.key = dict["key"] as! String
        }
        if dict.keys.contains("secret") {
            self.secret = dict["secret"] as! Bool
        }
        if dict.keys.contains("value") {
            self.value = dict["value"] as! String
        }
    }
}

public class GrafanaWorkspaceIniSection : Tea.TeaModel {
    public var propertys: [GrafanaWorkspaceIniProperty]?

    public var section: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.propertys != nil {
            var tmp : [Any] = []
            for k in self.propertys! {
                tmp.append(k.toMap())
            }
            map["propertys"] = tmp
        }
        if self.section != nil {
            map["section"] = self.section!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("propertys") {
            var tmp : [GrafanaWorkspaceIniProperty] = []
            for v in dict["propertys"] as! [Any] {
                var model = GrafanaWorkspaceIniProperty()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertys = tmp
        }
        if dict.keys.contains("section") {
            self.section = dict["section"] as! String
        }
    }
}

public class GrafanaWorkspaceIntegration : Tea.TeaModel {
    public var datasourceAmount: Int64?

    public var integrationId: String?

    public var integrationName: String?

    public var previews: [GrafanaWorkspaceIntegrationPreview]?

    public var status: String?

    public var supportRegions: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceAmount != nil {
            map["datasourceAmount"] = self.datasourceAmount!
        }
        if self.integrationId != nil {
            map["integrationId"] = self.integrationId!
        }
        if self.integrationName != nil {
            map["integrationName"] = self.integrationName!
        }
        if self.previews != nil {
            var tmp : [Any] = []
            for k in self.previews! {
                tmp.append(k.toMap())
            }
            map["previews"] = tmp
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.supportRegions != nil {
            map["supportRegions"] = self.supportRegions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("datasourceAmount") {
            self.datasourceAmount = dict["datasourceAmount"] as! Int64
        }
        if dict.keys.contains("integrationId") {
            self.integrationId = dict["integrationId"] as! String
        }
        if dict.keys.contains("integrationName") {
            self.integrationName = dict["integrationName"] as! String
        }
        if dict.keys.contains("previews") {
            var tmp : [GrafanaWorkspaceIntegrationPreview] = []
            for v in dict["previews"] as! [Any] {
                var model = GrafanaWorkspaceIntegrationPreview()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.previews = tmp
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("supportRegions") {
            self.supportRegions = dict["supportRegions"] as! [String]
        }
    }
}

public class GrafanaWorkspaceIntegrationDataSource : Tea.TeaModel {
    public var clusterType: String?

    public var datasourceId: String?

    public var datasourceName: String?

    public var datasourceUrl: String?

    public var description_: String?

    public var exploreUrl: String?

    public var extra: [String: String]?

    public var folderUrl: String?

    public var regionId: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["clusterType"] = self.clusterType!
        }
        if self.datasourceId != nil {
            map["datasourceId"] = self.datasourceId!
        }
        if self.datasourceName != nil {
            map["datasourceName"] = self.datasourceName!
        }
        if self.datasourceUrl != nil {
            map["datasourceUrl"] = self.datasourceUrl!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.exploreUrl != nil {
            map["exploreUrl"] = self.exploreUrl!
        }
        if self.extra != nil {
            map["extra"] = self.extra!
        }
        if self.folderUrl != nil {
            map["folderUrl"] = self.folderUrl!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clusterType") {
            self.clusterType = dict["clusterType"] as! String
        }
        if dict.keys.contains("datasourceId") {
            self.datasourceId = dict["datasourceId"] as! String
        }
        if dict.keys.contains("datasourceName") {
            self.datasourceName = dict["datasourceName"] as! String
        }
        if dict.keys.contains("datasourceUrl") {
            self.datasourceUrl = dict["datasourceUrl"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("exploreUrl") {
            self.exploreUrl = dict["exploreUrl"] as! String
        }
        if dict.keys.contains("extra") {
            self.extra = dict["extra"] as! [String: String]
        }
        if dict.keys.contains("folderUrl") {
            self.folderUrl = dict["folderUrl"] as! String
        }
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class GrafanaWorkspaceIntegrationDetail : Tea.TeaModel {
    public var dataSources: [GrafanaWorkspaceIntegrationDataSource]?

    public var integrationId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSources != nil {
            var tmp : [Any] = []
            for k in self.dataSources! {
                tmp.append(k.toMap())
            }
            map["dataSources"] = tmp
        }
        if self.integrationId != nil {
            map["integrationId"] = self.integrationId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dataSources") {
            var tmp : [GrafanaWorkspaceIntegrationDataSource] = []
            for v in dict["dataSources"] as! [Any] {
                var model = GrafanaWorkspaceIntegrationDataSource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataSources = tmp
        }
        if dict.keys.contains("integrationId") {
            self.integrationId = dict["integrationId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class GrafanaWorkspaceIntegrationPreview : Tea.TeaModel {
    public var id: String?

    public var image: String?

    public var name: String?

    public var thumbnail: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.image != nil {
            map["image"] = self.image!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.thumbnail != nil {
            map["thumbnail"] = self.thumbnail!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("image") {
            self.image = dict["image"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("thumbnail") {
            self.thumbnail = dict["thumbnail"] as! String
        }
    }
}

public class GrafanaWorkspaceMoveProcess : Tea.TeaModel {
    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var msg: String?

    public var processName: String?

    public var processStatus: String?

    public var subType: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["gmtModified"] = self.gmtModified!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.msg != nil {
            map["msg"] = self.msg!
        }
        if self.processName != nil {
            map["processName"] = self.processName!
        }
        if self.processStatus != nil {
            map["processStatus"] = self.processStatus!
        }
        if self.subType != nil {
            map["subType"] = self.subType!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! Int64
        }
        if dict.keys.contains("gmtModified") {
            self.gmtModified = dict["gmtModified"] as! Int64
        }
        if dict.keys.contains("grafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("msg") {
            self.msg = dict["msg"] as! String
        }
        if dict.keys.contains("processName") {
            self.processName = dict["processName"] as! String
        }
        if dict.keys.contains("processStatus") {
            self.processStatus = dict["processStatus"] as! String
        }
        if dict.keys.contains("subType") {
            self.subType = dict["subType"] as! String
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceNews : Tea.TeaModel {
    public var date: Int64?

    public var description_: String?

    public var image: String?

    public var link: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["date"] = self.date!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.image != nil {
            map["image"] = self.image!
        }
        if self.link != nil {
            map["link"] = self.link!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("date") {
            self.date = dict["date"] as! Int64
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("image") {
            self.image = dict["image"] as! String
        }
        if dict.keys.contains("link") {
            self.link = dict["link"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
    }
}

public class GrafanaWorkspaceOperateLog : Tea.TeaModel {
    public var date: Double?

    public var detail: String?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var operatorId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["date"] = self.date!
        }
        if self.detail != nil {
            map["detail"] = self.detail!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("date") {
            self.date = dict["date"] as! Double
        }
        if dict.keys.contains("detail") {
            self.detail = dict["detail"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("operatorId") {
            self.operatorId = dict["operatorId"] as! String
        }
    }
}

public class GrafanaWorkspaceOrg : Tea.TeaModel {
    public var id: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class GrafanaWorkspaceTrans : Tea.TeaModel {
    public var apiUrl: String?

    public var authType: String?

    public var gmtCreate: Double?

    public var gmtModified: Double?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var msg: String?

    public var processStatus: String?

    public var transDetails: [GrafanaWorkspaceTransDetail]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiUrl != nil {
            map["apiUrl"] = self.apiUrl!
        }
        if self.authType != nil {
            map["authType"] = self.authType!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["gmtModified"] = self.gmtModified!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.msg != nil {
            map["msg"] = self.msg!
        }
        if self.processStatus != nil {
            map["processStatus"] = self.processStatus!
        }
        if self.transDetails != nil {
            var tmp : [Any] = []
            for k in self.transDetails! {
                tmp.append(k.toMap())
            }
            map["transDetails"] = tmp
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("apiUrl") {
            self.apiUrl = dict["apiUrl"] as! String
        }
        if dict.keys.contains("authType") {
            self.authType = dict["authType"] as! String
        }
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! Double
        }
        if dict.keys.contains("gmtModified") {
            self.gmtModified = dict["gmtModified"] as! Double
        }
        if dict.keys.contains("grafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("msg") {
            self.msg = dict["msg"] as! String
        }
        if dict.keys.contains("processStatus") {
            self.processStatus = dict["processStatus"] as! String
        }
        if dict.keys.contains("transDetails") {
            var tmp : [GrafanaWorkspaceTransDetail] = []
            for v in dict["transDetails"] as! [Any] {
                var model = GrafanaWorkspaceTransDetail()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transDetails = tmp
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceTransDetail : Tea.TeaModel {
    public var dashboardAmount: Int32?

    public var dataSourceAmount: Int32?

    public var original: Int64?

    public var originalName: String?

    public var target: Int64?

    public var targetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dashboardAmount != nil {
            map["dashboardAmount"] = self.dashboardAmount!
        }
        if self.dataSourceAmount != nil {
            map["dataSourceAmount"] = self.dataSourceAmount!
        }
        if self.original != nil {
            map["original"] = self.original!
        }
        if self.originalName != nil {
            map["originalName"] = self.originalName!
        }
        if self.target != nil {
            map["target"] = self.target!
        }
        if self.targetName != nil {
            map["targetName"] = self.targetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dashboardAmount") {
            self.dashboardAmount = dict["dashboardAmount"] as! Int32
        }
        if dict.keys.contains("dataSourceAmount") {
            self.dataSourceAmount = dict["dataSourceAmount"] as! Int32
        }
        if dict.keys.contains("original") {
            self.original = dict["original"] as! Int64
        }
        if dict.keys.contains("originalName") {
            self.originalName = dict["originalName"] as! String
        }
        if dict.keys.contains("target") {
            self.target = dict["target"] as! Int64
        }
        if dict.keys.contains("targetName") {
            self.targetName = dict["targetName"] as! String
        }
    }
}

public class GrafanaWorkspaceUserCert : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class GrafanaWorkspaceUserOrg : Tea.TeaModel {
    public var orgId: Int64?

    public var orgName: String?

    public var role: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.orgName != nil {
            map["orgName"] = self.orgName!
        }
        if self.role != nil {
            map["role"] = self.role!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("orgName") {
            self.orgName = dict["orgName"] as! String
        }
        if dict.keys.contains("role") {
            self.role = dict["role"] as! String
        }
    }
}

public class GrafanaWorkspaceVpcConfig : Tea.TeaModel {
    public var fcConfig: String?

    public var id: Int64?

    public var installMsg: String?

    public var installStatus: String?

    public var name: String?

    public var regionId: String?

    public var securityGroupId: String?

    public var userId: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fcConfig != nil {
            map["fcConfig"] = self.fcConfig!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.installMsg != nil {
            map["installMsg"] = self.installMsg!
        }
        if self.installStatus != nil {
            map["installStatus"] = self.installStatus!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["securityGroupId"] = self.securityGroupId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.vSwitchId != nil {
            map["vSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fcConfig") {
            self.fcConfig = dict["fcConfig"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("installMsg") {
            self.installMsg = dict["installMsg"] as! String
        }
        if dict.keys.contains("installStatus") {
            self.installStatus = dict["installStatus"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("securityGroupId") {
            self.securityGroupId = dict["securityGroupId"] as! String
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("vSwitchId") {
            self.vSwitchId = dict["vSwitchId"] as! String
        }
        if dict.keys.contains("vpcId") {
            self.vpcId = dict["vpcId"] as! String
        }
    }
}

public class GrafanaWorkspaceVpcRegion : Tea.TeaModel {
    public var regionId: String?

    public var regionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.regionName != nil {
            map["regionName"] = self.regionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("regionName") {
            self.regionName = dict["regionName"] as! String
        }
    }
}

public class GrafanaWorkspaceVpcRegionDetail : Tea.TeaModel {
    public var fcConfig: String?

    public var id: Int64?

    public var installStatus: String?

    public var name: String?

    public var regionId: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var userId: String?

    public var vSwitchId: String?

    public var vSwitchIds: [String]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fcConfig != nil {
            map["fcConfig"] = self.fcConfig!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.installStatus != nil {
            map["installStatus"] = self.installStatus!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["securityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["securityGroupIds"] = self.securityGroupIds!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.vSwitchId != nil {
            map["vSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchIds != nil {
            map["vSwitchIds"] = self.vSwitchIds!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fcConfig") {
            self.fcConfig = dict["fcConfig"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("installStatus") {
            self.installStatus = dict["installStatus"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("securityGroupId") {
            self.securityGroupId = dict["securityGroupId"] as! String
        }
        if dict.keys.contains("securityGroupIds") {
            self.securityGroupIds = dict["securityGroupIds"] as! [String]
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("vSwitchId") {
            self.vSwitchId = dict["vSwitchId"] as! String
        }
        if dict.keys.contains("vSwitchIds") {
            self.vSwitchIds = dict["vSwitchIds"] as! [String]
        }
        if dict.keys.contains("vpcId") {
            self.vpcId = dict["vpcId"] as! String
        }
    }
}

public class QueryDataResponse : Tea.TeaModel {
    public var results: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.results != nil {
            map["results"] = self.results!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("results") {
            self.results = dict["results"] as! String
        }
    }
}

public class AddAliClusterIdsToPrometheusGlobalViewRequest : Tea.TeaModel {
    public var clusterIds: String?

    public var globalViewClusterId: String?

    public var groupName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") {
            self.clusterIds = dict["ClusterIds"] as! String
        }
        if dict.keys.contains("GlobalViewClusterId") {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddAliClusterIdsToPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: AddAliClusterIdsToPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = AddAliClusterIdsToPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAliClusterIdsToPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAliClusterIdsToPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAliClusterIdsToPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGrafanaRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integration: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integration != nil {
            map["Integration"] = self.integration!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Integration") {
            self.integration = dict["Integration"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddGrafanaResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddGrafanaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGrafanaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGrafanaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integration: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integration != nil {
            map["Integration"] = self.integration!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Integration") {
            self.integration = dict["Integration"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddIntegrationResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusGlobalViewRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clusters: String?

    public var groupName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [AddPrometheusGlobalViewRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            map["Clusters"] = self.clusters!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") {
            self.clusters = dict["Clusters"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [AddPrometheusGlobalViewRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AddPrometheusGlobalViewRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class AddPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Info : Tea.TeaModel {
            public var failedInstances: String?

            public var globalViewClusterId: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedInstances != nil {
                    map["FailedInstances"] = self.failedInstances!
                }
                if self.globalViewClusterId != nil {
                    map["GlobalViewClusterId"] = self.globalViewClusterId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedInstances") {
                    self.failedInstances = dict["FailedInstances"] as! String
                }
                if dict.keys.contains("GlobalViewClusterId") {
                    self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var info: AddPrometheusGlobalViewResponseBody.Data.Info?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.info?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info?.toMap()
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") {
                var model = AddPrometheusGlobalViewResponseBody.Data.Info()
                model.fromMap(dict["Info"] as! [String: Any])
                self.info = model
            }
            if dict.keys.contains("Msg") {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: AddPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = AddPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusGlobalViewByAliClusterIdsRequest : Tea.TeaModel {
    public var clusterIds: String?

    public var groupName: String?

    public var productCode: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") {
            self.clusterIds = dict["ClusterIds"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("ProductCode") {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddPrometheusGlobalViewByAliClusterIdsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: AddPrometheusGlobalViewByAliClusterIdsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = AddPrometheusGlobalViewByAliClusterIdsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPrometheusGlobalViewByAliClusterIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusGlobalViewByAliClusterIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPrometheusGlobalViewByAliClusterIdsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusInstanceRequest : Tea.TeaModel {
    public var name: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddPrometheusInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddPrometheusInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPrometheusInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integrationType: String?

    public var param: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.param != nil {
            map["Param"] = self.param!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("IntegrationType") {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("Param") {
            self.param = dict["Param"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddPrometheusIntegrationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: Int64?

        public var instanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AddPrometheusIntegrationResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = AddPrometheusIntegrationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusRemoteWriteRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var remoteWriteYaml: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteWriteYaml != nil {
            map["RemoteWriteYaml"] = self.remoteWriteYaml!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteWriteYaml") {
            self.remoteWriteYaml = dict["RemoteWriteYaml"] as! String
        }
    }
}

public class AddPrometheusRemoteWriteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddPrometheusRemoteWriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusRemoteWriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPrometheusRemoteWriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddRecordingRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var ruleYaml: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleYaml != nil {
            map["RuleYaml"] = self.ruleYaml!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleYaml") {
            self.ruleYaml = dict["RuleYaml"] as! String
        }
    }
}

public class AddRecordingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddRecordingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRecordingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddRecordingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTagToFlinkClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var flinkWorkSpaceId: String?

    public var flinkWorkSpaceName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var targetUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.flinkWorkSpaceId != nil {
            map["FlinkWorkSpaceId"] = self.flinkWorkSpaceId!
        }
        if self.flinkWorkSpaceName != nil {
            map["FlinkWorkSpaceName"] = self.flinkWorkSpaceName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("FlinkWorkSpaceId") {
            self.flinkWorkSpaceId = dict["FlinkWorkSpaceId"] as! String
        }
        if dict.keys.contains("FlinkWorkSpaceName") {
            self.flinkWorkSpaceName = dict["FlinkWorkSpaceName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TargetUserId") {
            self.targetUserId = dict["TargetUserId"] as! String
        }
    }
}

public class AddTagToFlinkClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddTagToFlinkClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTagToFlinkClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTagToFlinkClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AppendInstancesToPrometheusGlobalViewRequest : Tea.TeaModel {
    public var clusters: String?

    public var globalViewClusterId: String?

    public var groupName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            map["Clusters"] = self.clusters!
        }
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") {
            self.clusters = dict["Clusters"] as! String
        }
        if dict.keys.contains("GlobalViewClusterId") {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AppendInstancesToPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: AppendInstancesToPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = AppendInstancesToPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AppendInstancesToPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AppendInstancesToPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AppendInstancesToPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyScenarioRequest : Tea.TeaModel {
    public var appId: String?

    public var config: [String: Any]?

    public var name: String?

    public var regionId: String?

    public var scenario: String?

    public var sign: String?

    public var snDump: Bool?

    public var snForce: Bool?

    public var snStat: Bool?

    public var snTransfer: Bool?

    public var updateOption: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        if self.sign != nil {
            map["Sign"] = self.sign!
        }
        if self.snDump != nil {
            map["SnDump"] = self.snDump!
        }
        if self.snForce != nil {
            map["SnForce"] = self.snForce!
        }
        if self.snStat != nil {
            map["SnStat"] = self.snStat!
        }
        if self.snTransfer != nil {
            map["SnTransfer"] = self.snTransfer!
        }
        if self.updateOption != nil {
            map["UpdateOption"] = self.updateOption!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! [String: Any]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scenario") {
            self.scenario = dict["Scenario"] as! String
        }
        if dict.keys.contains("Sign") {
            self.sign = dict["Sign"] as! String
        }
        if dict.keys.contains("SnDump") {
            self.snDump = dict["SnDump"] as! Bool
        }
        if dict.keys.contains("SnForce") {
            self.snForce = dict["SnForce"] as! Bool
        }
        if dict.keys.contains("SnStat") {
            self.snStat = dict["SnStat"] as! Bool
        }
        if dict.keys.contains("SnTransfer") {
            self.snTransfer = dict["SnTransfer"] as! Bool
        }
        if dict.keys.contains("UpdateOption") {
            self.updateOption = dict["UpdateOption"] as! Bool
        }
    }
}

public class ApplyScenarioShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var configShrink: String?

    public var name: String?

    public var regionId: String?

    public var scenario: String?

    public var sign: String?

    public var snDump: Bool?

    public var snForce: Bool?

    public var snStat: Bool?

    public var snTransfer: Bool?

    public var updateOption: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.configShrink != nil {
            map["Config"] = self.configShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        if self.sign != nil {
            map["Sign"] = self.sign!
        }
        if self.snDump != nil {
            map["SnDump"] = self.snDump!
        }
        if self.snForce != nil {
            map["SnForce"] = self.snForce!
        }
        if self.snStat != nil {
            map["SnStat"] = self.snStat!
        }
        if self.snTransfer != nil {
            map["SnTransfer"] = self.snTransfer!
        }
        if self.updateOption != nil {
            map["UpdateOption"] = self.updateOption!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Config") {
            self.configShrink = dict["Config"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scenario") {
            self.scenario = dict["Scenario"] as! String
        }
        if dict.keys.contains("Sign") {
            self.sign = dict["Sign"] as! String
        }
        if dict.keys.contains("SnDump") {
            self.snDump = dict["SnDump"] as! Bool
        }
        if dict.keys.contains("SnForce") {
            self.snForce = dict["SnForce"] as! Bool
        }
        if dict.keys.contains("SnStat") {
            self.snStat = dict["SnStat"] as! Bool
        }
        if dict.keys.contains("SnTransfer") {
            self.snTransfer = dict["SnTransfer"] as! Bool
        }
        if dict.keys.contains("UpdateOption") {
            self.updateOption = dict["UpdateOption"] as! Bool
        }
    }
}

public class ApplyScenarioResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ApplyScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindPrometheusGrafanaInstanceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var grafanaInstanceId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.grafanaInstanceId != nil {
            map["GrafanaInstanceId"] = self.grafanaInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("GrafanaInstanceId") {
            self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class BindPrometheusGrafanaInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindPrometheusGrafanaInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindPrometheusGrafanaInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindPrometheusGrafanaInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BlockAlarmNotificationRequest : Tea.TeaModel {
    public var alarmId: Int64?

    public var handlerId: Int64?

    public var regionId: String?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmId != nil {
            map["AlarmId"] = self.alarmId!
        }
        if self.handlerId != nil {
            map["HandlerId"] = self.handlerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmId") {
            self.alarmId = dict["AlarmId"] as! Int64
        }
        if dict.keys.contains("HandlerId") {
            self.handlerId = dict["HandlerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class BlockAlarmNotificationResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BlockAlarmNotificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BlockAlarmNotificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BlockAlarmNotificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeAlarmSeverityRequest : Tea.TeaModel {
    public var alarmId: Int64?

    public var handlerId: Int64?

    public var regionId: String?

    public var severity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmId != nil {
            map["AlarmId"] = self.alarmId!
        }
        if self.handlerId != nil {
            map["HandlerId"] = self.handlerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmId") {
            self.alarmId = dict["AlarmId"] as! Int64
        }
        if dict.keys.contains("HandlerId") {
            self.handlerId = dict["HandlerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
    }
}

public class ChangeAlarmSeverityResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ChangeAlarmSeverityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeAlarmSeverityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeAlarmSeverityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var resourceGroupId: String?

        public var resourceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
        }
    }
    public var code: String?

    public var data: ChangeResourceGroupResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ChangeResourceGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckCommercialStatusRequest : Tea.TeaModel {
    public var regionId: String?

    public var service: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.service != nil {
            map["Service"] = self.service!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Service") {
            self.service = dict["Service"] as! String
        }
    }
}

public class CheckCommercialStatusResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckCommercialStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckCommercialStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckCommercialStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckServiceStatusRequest : Tea.TeaModel {
    public var regionId: String?

    public var svcCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.svcCode != nil {
            map["SvcCode"] = self.svcCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SvcCode") {
            self.svcCode = dict["SvcCode"] as! String
        }
    }
}

public class CheckServiceStatusResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckServiceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClaimAlarmRequest : Tea.TeaModel {
    public var alarmId: Int64?

    public var handlerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmId != nil {
            map["AlarmId"] = self.alarmId!
        }
        if self.handlerId != nil {
            map["HandlerId"] = self.handlerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmId") {
            self.alarmId = dict["AlarmId"] as! Int64
        }
        if dict.keys.contains("HandlerId") {
            self.handlerId = dict["HandlerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ClaimAlarmResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ClaimAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClaimAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ClaimAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseAlarmRequest : Tea.TeaModel {
    public var alarmId: Int64?

    public var handlerId: Int64?

    public var regionId: String?

    public var solution: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmId != nil {
            map["AlarmId"] = self.alarmId!
        }
        if self.handlerId != nil {
            map["HandlerId"] = self.handlerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.solution != nil {
            map["Solution"] = self.solution!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmId") {
            self.alarmId = dict["AlarmId"] as! Int64
        }
        if dict.keys.contains("HandlerId") {
            self.handlerId = dict["HandlerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Solution") {
            self.solution = dict["Solution"] as! String
        }
    }
}

public class CloseAlarmResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CloseAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloseAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigAppRequest : Tea.TeaModel {
    public var appIds: String?

    public var enable: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ConfigAppResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfigAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAlertContactRequest : Tea.TeaModel {
    public var contactName: String?

    public var dingRobotWebhookUrl: String?

    public var email: String?

    public var phoneNum: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var systemNoc: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.dingRobotWebhookUrl != nil {
            map["DingRobotWebhookUrl"] = self.dingRobotWebhookUrl!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.phoneNum != nil {
            map["PhoneNum"] = self.phoneNum!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.systemNoc != nil {
            map["SystemNoc"] = self.systemNoc!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("DingRobotWebhookUrl") {
            self.dingRobotWebhookUrl = dict["DingRobotWebhookUrl"] as! String
        }
        if dict.keys.contains("Email") {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("PhoneNum") {
            self.phoneNum = dict["PhoneNum"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SystemNoc") {
            self.systemNoc = dict["SystemNoc"] as! Bool
        }
    }
}

public class CreateAlertContactResponseBody : Tea.TeaModel {
    public var contactId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAlertContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAlertContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAlertContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAlertContactGroupRequest : Tea.TeaModel {
    public var contactGroupName: String?

    public var contactIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupName") {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactIds") {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateAlertContactGroupResponseBody : Tea.TeaModel {
    public var contactGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") {
            self.contactGroupId = dict["ContactGroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAlertContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAlertContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAlertContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDispatchRuleRequest : Tea.TeaModel {
    public var dispatchRule: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRule != nil {
            map["DispatchRule"] = self.dispatchRule!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRule") {
            self.dispatchRule = dict["DispatchRule"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateDispatchRuleResponseBody : Tea.TeaModel {
    public var dispatchRuleId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRuleId != nil {
            map["DispatchRuleId"] = self.dispatchRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRuleId") {
            self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnvCustomJobRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var customJobName: String?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.customJobName != nil {
            map["CustomJobName"] = self.customJobName!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("CustomJobName") {
            self.customJobName = dict["CustomJobName"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateEnvCustomJobResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnvCustomJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnvCustomJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEnvCustomJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnvPodMonitorRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateEnvPodMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var matchedMsg: String?

        public var matchedTargetCount: String?

        public var namespace: String?

        public var podMonitorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchedMsg != nil {
                map["MatchedMsg"] = self.matchedMsg!
            }
            if self.matchedTargetCount != nil {
                map["MatchedTargetCount"] = self.matchedTargetCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.podMonitorName != nil {
                map["PodMonitorName"] = self.podMonitorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchedMsg") {
                self.matchedMsg = dict["MatchedMsg"] as! String
            }
            if dict.keys.contains("MatchedTargetCount") {
                self.matchedTargetCount = dict["MatchedTargetCount"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PodMonitorName") {
                self.podMonitorName = dict["PodMonitorName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateEnvPodMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = CreateEnvPodMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnvPodMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnvPodMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEnvPodMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnvServiceMonitorRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateEnvServiceMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var matchedMsg: String?

        public var matchedTargetCount: Int32?

        public var namespace: String?

        public var serviceMonitorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchedMsg != nil {
                map["MatchedMsg"] = self.matchedMsg!
            }
            if self.matchedTargetCount != nil {
                map["MatchedTargetCount"] = self.matchedTargetCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.serviceMonitorName != nil {
                map["ServiceMonitorName"] = self.serviceMonitorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchedMsg") {
                self.matchedMsg = dict["MatchedMsg"] as! String
            }
            if dict.keys.contains("MatchedTargetCount") {
                self.matchedTargetCount = dict["MatchedTargetCount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServiceMonitorName") {
                self.serviceMonitorName = dict["ServiceMonitorName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateEnvServiceMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = CreateEnvServiceMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnvServiceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnvServiceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEnvServiceMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnvironmentRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aliyunLang: String?

    public var bindResourceId: String?

    public var environmentName: String?

    public var environmentSubType: String?

    public var environmentType: String?

    public var feePackage: String?

    public var grafanaWorkspaceId: String?

    public var managedType: String?

    public var prometheusInstanceId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [CreateEnvironmentRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.bindResourceId != nil {
            map["BindResourceId"] = self.bindResourceId!
        }
        if self.environmentName != nil {
            map["EnvironmentName"] = self.environmentName!
        }
        if self.environmentSubType != nil {
            map["EnvironmentSubType"] = self.environmentSubType!
        }
        if self.environmentType != nil {
            map["EnvironmentType"] = self.environmentType!
        }
        if self.feePackage != nil {
            map["FeePackage"] = self.feePackage!
        }
        if self.grafanaWorkspaceId != nil {
            map["GrafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.managedType != nil {
            map["ManagedType"] = self.managedType!
        }
        if self.prometheusInstanceId != nil {
            map["PrometheusInstanceId"] = self.prometheusInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("BindResourceId") {
            self.bindResourceId = dict["BindResourceId"] as! String
        }
        if dict.keys.contains("EnvironmentName") {
            self.environmentName = dict["EnvironmentName"] as! String
        }
        if dict.keys.contains("EnvironmentSubType") {
            self.environmentSubType = dict["EnvironmentSubType"] as! String
        }
        if dict.keys.contains("EnvironmentType") {
            self.environmentType = dict["EnvironmentType"] as! String
        }
        if dict.keys.contains("FeePackage") {
            self.feePackage = dict["FeePackage"] as! String
        }
        if dict.keys.contains("GrafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["GrafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("ManagedType") {
            self.managedType = dict["ManagedType"] as! String
        }
        if dict.keys.contains("PrometheusInstanceId") {
            self.prometheusInstanceId = dict["PrometheusInstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateEnvironmentRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateEnvironmentRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateEnvironmentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGrafanaWorkspaceRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aliyunLang: String?

    public var description_: String?

    public var grafanaVersion: String?

    public var grafanaWorkspaceEdition: String?

    public var grafanaWorkspaceName: String?

    public var password: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [CreateGrafanaWorkspaceRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.grafanaVersion != nil {
            map["GrafanaVersion"] = self.grafanaVersion!
        }
        if self.grafanaWorkspaceEdition != nil {
            map["GrafanaWorkspaceEdition"] = self.grafanaWorkspaceEdition!
        }
        if self.grafanaWorkspaceName != nil {
            map["GrafanaWorkspaceName"] = self.grafanaWorkspaceName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GrafanaVersion") {
            self.grafanaVersion = dict["GrafanaVersion"] as! String
        }
        if dict.keys.contains("GrafanaWorkspaceEdition") {
            self.grafanaWorkspaceEdition = dict["GrafanaWorkspaceEdition"] as! String
        }
        if dict.keys.contains("GrafanaWorkspaceName") {
            self.grafanaWorkspaceName = dict["GrafanaWorkspaceName"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateGrafanaWorkspaceRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateGrafanaWorkspaceRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateGrafanaWorkspaceShrinkRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var description_: String?

    public var grafanaVersion: String?

    public var grafanaWorkspaceEdition: String?

    public var grafanaWorkspaceName: String?

    public var password: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.grafanaVersion != nil {
            map["GrafanaVersion"] = self.grafanaVersion!
        }
        if self.grafanaWorkspaceEdition != nil {
            map["GrafanaWorkspaceEdition"] = self.grafanaWorkspaceEdition!
        }
        if self.grafanaWorkspaceName != nil {
            map["GrafanaWorkspaceName"] = self.grafanaWorkspaceName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GrafanaVersion") {
            self.grafanaVersion = dict["GrafanaVersion"] as! String
        }
        if dict.keys.contains("GrafanaWorkspaceEdition") {
            self.grafanaWorkspaceEdition = dict["GrafanaWorkspaceEdition"] as! String
        }
        if dict.keys.contains("GrafanaWorkspaceName") {
            self.grafanaWorkspaceName = dict["GrafanaWorkspaceName"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class CreateGrafanaWorkspaceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GrafanaWorkspace?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GrafanaWorkspace()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class CreateGrafanaWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGrafanaWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateGrafanaWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIntegrationRequest : Tea.TeaModel {
    public var autoRecover: Bool?

    public var description_: String?

    public var integrationName: String?

    public var integrationProductType: String?

    public var recoverTime: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRecover != nil {
            map["AutoRecover"] = self.autoRecover!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.integrationName != nil {
            map["IntegrationName"] = self.integrationName!
        }
        if self.integrationProductType != nil {
            map["IntegrationProductType"] = self.integrationProductType!
        }
        if self.recoverTime != nil {
            map["RecoverTime"] = self.recoverTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRecover") {
            self.autoRecover = dict["AutoRecover"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IntegrationName") {
            self.integrationName = dict["IntegrationName"] as! String
        }
        if dict.keys.contains("IntegrationProductType") {
            self.integrationProductType = dict["IntegrationProductType"] as! String
        }
        if dict.keys.contains("RecoverTime") {
            self.recoverTime = dict["RecoverTime"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateIntegrationResponseBody : Tea.TeaModel {
    public class Integration : Tea.TeaModel {
        public var autoRecover: Bool?

        public var description_: String?

        public var integrationId: Int64?

        public var integrationName: String?

        public var integrationProductType: String?

        public var recoverTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRecover != nil {
                map["AutoRecover"] = self.autoRecover!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.integrationId != nil {
                map["IntegrationId"] = self.integrationId!
            }
            if self.integrationName != nil {
                map["IntegrationName"] = self.integrationName!
            }
            if self.integrationProductType != nil {
                map["IntegrationProductType"] = self.integrationProductType!
            }
            if self.recoverTime != nil {
                map["RecoverTime"] = self.recoverTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoRecover") {
                self.autoRecover = dict["AutoRecover"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IntegrationId") {
                self.integrationId = dict["IntegrationId"] as! Int64
            }
            if dict.keys.contains("IntegrationName") {
                self.integrationName = dict["IntegrationName"] as! String
            }
            if dict.keys.contains("IntegrationProductType") {
                self.integrationProductType = dict["IntegrationProductType"] as! String
            }
            if dict.keys.contains("RecoverTime") {
                self.recoverTime = dict["RecoverTime"] as! Int64
            }
        }
    }
    public var integration: CreateIntegrationResponseBody.Integration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.integration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.integration != nil {
            map["Integration"] = self.integration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Integration") {
            var model = CreateIntegrationResponseBody.Integration()
            model.fromMap(dict["Integration"] as! [String: Any])
            self.integration = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateAlertRuleRequest : Tea.TeaModel {
    public class MarkTags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertCheckType: String?

    public var alertGroup: Int64?

    public var alertId: Int64?

    public var alertName: String?

    public var alertPiplines: String?

    public var alertRuleContent: String?

    public var alertStatus: String?

    public var alertType: String?

    public var annotations: String?

    public var autoAddNewApplication: Bool?

    public var autoAddTargetConfig: String?

    public var clusterId: String?

    public var dataConfig: String?

    public var duration: Int64?

    public var filters: String?

    public var labels: String?

    public var level: String?

    public var markTags: [CreateOrUpdateAlertRuleRequest.MarkTags]?

    public var message: String?

    public var metricsKey: String?

    public var metricsType: String?

    public var notice: String?

    public var notifyMode: String?

    public var notifyStrategy: String?

    public var pids: String?

    public var product: String?

    public var promQL: String?

    public var regionId: String?

    public var tags: [CreateOrUpdateAlertRuleRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertCheckType != nil {
            map["AlertCheckType"] = self.alertCheckType!
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.alertPiplines != nil {
            map["AlertPiplines"] = self.alertPiplines!
        }
        if self.alertRuleContent != nil {
            map["AlertRuleContent"] = self.alertRuleContent!
        }
        if self.alertStatus != nil {
            map["AlertStatus"] = self.alertStatus!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.autoAddNewApplication != nil {
            map["AutoAddNewApplication"] = self.autoAddNewApplication!
        }
        if self.autoAddTargetConfig != nil {
            map["AutoAddTargetConfig"] = self.autoAddTargetConfig!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataConfig != nil {
            map["DataConfig"] = self.dataConfig!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.filters != nil {
            map["Filters"] = self.filters!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.markTags != nil {
            var tmp : [Any] = []
            for k in self.markTags! {
                tmp.append(k.toMap())
            }
            map["MarkTags"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.metricsKey != nil {
            map["MetricsKey"] = self.metricsKey!
        }
        if self.metricsType != nil {
            map["MetricsType"] = self.metricsType!
        }
        if self.notice != nil {
            map["Notice"] = self.notice!
        }
        if self.notifyMode != nil {
            map["NotifyMode"] = self.notifyMode!
        }
        if self.notifyStrategy != nil {
            map["NotifyStrategy"] = self.notifyStrategy!
        }
        if self.pids != nil {
            map["Pids"] = self.pids!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.promQL != nil {
            map["PromQL"] = self.promQL!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertCheckType") {
            self.alertCheckType = dict["AlertCheckType"] as! String
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! Int64
        }
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("AlertName") {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("AlertPiplines") {
            self.alertPiplines = dict["AlertPiplines"] as! String
        }
        if dict.keys.contains("AlertRuleContent") {
            self.alertRuleContent = dict["AlertRuleContent"] as! String
        }
        if dict.keys.contains("AlertStatus") {
            self.alertStatus = dict["AlertStatus"] as! String
        }
        if dict.keys.contains("AlertType") {
            self.alertType = dict["AlertType"] as! String
        }
        if dict.keys.contains("Annotations") {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("AutoAddNewApplication") {
            self.autoAddNewApplication = dict["AutoAddNewApplication"] as! Bool
        }
        if dict.keys.contains("AutoAddTargetConfig") {
            self.autoAddTargetConfig = dict["AutoAddTargetConfig"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataConfig") {
            self.dataConfig = dict["DataConfig"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int64
        }
        if dict.keys.contains("Filters") {
            self.filters = dict["Filters"] as! String
        }
        if dict.keys.contains("Labels") {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MarkTags") {
            var tmp : [CreateOrUpdateAlertRuleRequest.MarkTags] = []
            for v in dict["MarkTags"] as! [Any] {
                var model = CreateOrUpdateAlertRuleRequest.MarkTags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.markTags = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("MetricsKey") {
            self.metricsKey = dict["MetricsKey"] as! String
        }
        if dict.keys.contains("MetricsType") {
            self.metricsType = dict["MetricsType"] as! String
        }
        if dict.keys.contains("Notice") {
            self.notice = dict["Notice"] as! String
        }
        if dict.keys.contains("NotifyMode") {
            self.notifyMode = dict["NotifyMode"] as! String
        }
        if dict.keys.contains("NotifyStrategy") {
            self.notifyStrategy = dict["NotifyStrategy"] as! String
        }
        if dict.keys.contains("Pids") {
            self.pids = dict["Pids"] as! String
        }
        if dict.keys.contains("Product") {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("PromQL") {
            self.promQL = dict["PromQL"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateOrUpdateAlertRuleRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateOrUpdateAlertRuleRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateOrUpdateAlertRuleResponseBody : Tea.TeaModel {
    public class AlertRule : Tea.TeaModel {
        public class AlertRuleContent : Tea.TeaModel {
            public class AlertRuleItems : Tea.TeaModel {
                public var aggregate: String?

                public var metricKey: String?

                public var n: Double?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aggregate != nil {
                        map["Aggregate"] = self.aggregate!
                    }
                    if self.metricKey != nil {
                        map["MetricKey"] = self.metricKey!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Aggregate") {
                        self.aggregate = dict["Aggregate"] as! String
                    }
                    if dict.keys.contains("MetricKey") {
                        self.metricKey = dict["MetricKey"] as! String
                    }
                    if dict.keys.contains("N") {
                        self.n = dict["N"] as! Double
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var alertRuleItems: [CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent.AlertRuleItems]?

            public var condition: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertRuleItems != nil {
                    var tmp : [Any] = []
                    for k in self.alertRuleItems! {
                        tmp.append(k.toMap())
                    }
                    map["AlertRuleItems"] = tmp
                }
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertRuleItems") {
                    var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent.AlertRuleItems] = []
                    for v in dict["AlertRuleItems"] as! [Any] {
                        var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent.AlertRuleItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alertRuleItems = tmp
                }
                if dict.keys.contains("Condition") {
                    self.condition = dict["Condition"] as! String
                }
            }
        }
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Filters : Tea.TeaModel {
            public class CustomSLSFilters : Tea.TeaModel {
                public var key: String?

                public var opt: String?

                public var show: Bool?

                public var t: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.opt != nil {
                        map["Opt"] = self.opt!
                    }
                    if self.show != nil {
                        map["Show"] = self.show!
                    }
                    if self.t != nil {
                        map["T"] = self.t!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Opt") {
                        self.opt = dict["Opt"] as! String
                    }
                    if dict.keys.contains("Show") {
                        self.show = dict["Show"] as! Bool
                    }
                    if dict.keys.contains("T") {
                        self.t = dict["T"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class DimFilters : Tea.TeaModel {
                public var filterKey: String?

                public var filterOpt: String?

                public var filterValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.filterKey != nil {
                        map["FilterKey"] = self.filterKey!
                    }
                    if self.filterOpt != nil {
                        map["FilterOpt"] = self.filterOpt!
                    }
                    if self.filterValues != nil {
                        map["FilterValues"] = self.filterValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FilterKey") {
                        self.filterKey = dict["FilterKey"] as! String
                    }
                    if dict.keys.contains("FilterOpt") {
                        self.filterOpt = dict["FilterOpt"] as! String
                    }
                    if dict.keys.contains("FilterValues") {
                        self.filterValues = dict["FilterValues"] as! [String]
                    }
                }
            }
            public var customSLSFilters: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.CustomSLSFilters]?

            public var customSLSGroupByDimensions: [String]?

            public var customSLSWheres: [String]?

            public var dimFilters: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.DimFilters]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customSLSFilters != nil {
                    var tmp : [Any] = []
                    for k in self.customSLSFilters! {
                        tmp.append(k.toMap())
                    }
                    map["CustomSLSFilters"] = tmp
                }
                if self.customSLSGroupByDimensions != nil {
                    map["CustomSLSGroupByDimensions"] = self.customSLSGroupByDimensions!
                }
                if self.customSLSWheres != nil {
                    map["CustomSLSWheres"] = self.customSLSWheres!
                }
                if self.dimFilters != nil {
                    var tmp : [Any] = []
                    for k in self.dimFilters! {
                        tmp.append(k.toMap())
                    }
                    map["DimFilters"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomSLSFilters") {
                    var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.CustomSLSFilters] = []
                    for v in dict["CustomSLSFilters"] as! [Any] {
                        var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.CustomSLSFilters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.customSLSFilters = tmp
                }
                if dict.keys.contains("CustomSLSGroupByDimensions") {
                    self.customSLSGroupByDimensions = dict["CustomSLSGroupByDimensions"] as! [String]
                }
                if dict.keys.contains("CustomSLSWheres") {
                    self.customSLSWheres = dict["CustomSLSWheres"] as! [String]
                }
                if dict.keys.contains("DimFilters") {
                    var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.DimFilters] = []
                    for v in dict["DimFilters"] as! [Any] {
                        var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.DimFilters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dimFilters = tmp
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertCheckType: String?

        public var alertGroup: Int64?

        public var alertId: Double?

        public var alertName: String?

        public var alertRuleContent: CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent?

        public var alertStatus: String?

        public var alertType: String?

        public var annotations: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Annotations]?

        public var autoAddNewApplication: Bool?

        public var clusterId: String?

        public var createdTime: Int64?

        public var duration: String?

        public var extend: String?

        public var filters: CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters?

        public var labels: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Labels]?

        public var level: String?

        public var message: String?

        public var metricsType: String?

        public var notifyMode: String?

        public var notifyStrategy: String?

        public var pids: [String]?

        public var promQL: String?

        public var regionId: String?

        public var tags: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Tags]?

        public var updatedTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alertRuleContent?.validate()
            try self.filters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertCheckType != nil {
                map["AlertCheckType"] = self.alertCheckType!
            }
            if self.alertGroup != nil {
                map["AlertGroup"] = self.alertGroup!
            }
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.alertRuleContent != nil {
                map["AlertRuleContent"] = self.alertRuleContent?.toMap()
            }
            if self.alertStatus != nil {
                map["AlertStatus"] = self.alertStatus!
            }
            if self.alertType != nil {
                map["AlertType"] = self.alertType!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.autoAddNewApplication != nil {
                map["AutoAddNewApplication"] = self.autoAddNewApplication!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.filters != nil {
                map["Filters"] = self.filters?.toMap()
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.metricsType != nil {
                map["MetricsType"] = self.metricsType!
            }
            if self.notifyMode != nil {
                map["NotifyMode"] = self.notifyMode!
            }
            if self.notifyStrategy != nil {
                map["NotifyStrategy"] = self.notifyStrategy!
            }
            if self.pids != nil {
                map["Pids"] = self.pids!
            }
            if self.promQL != nil {
                map["PromQL"] = self.promQL!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertCheckType") {
                self.alertCheckType = dict["AlertCheckType"] as! String
            }
            if dict.keys.contains("AlertGroup") {
                self.alertGroup = dict["AlertGroup"] as! Int64
            }
            if dict.keys.contains("AlertId") {
                self.alertId = dict["AlertId"] as! Double
            }
            if dict.keys.contains("AlertName") {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("AlertRuleContent") {
                var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent()
                model.fromMap(dict["AlertRuleContent"] as! [String: Any])
                self.alertRuleContent = model
            }
            if dict.keys.contains("AlertStatus") {
                self.alertStatus = dict["AlertStatus"] as! String
            }
            if dict.keys.contains("AlertType") {
                self.alertType = dict["AlertType"] as! String
            }
            if dict.keys.contains("Annotations") {
                var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("AutoAddNewApplication") {
                self.autoAddNewApplication = dict["AutoAddNewApplication"] as! Bool
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Extend") {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("Filters") {
                var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters()
                model.fromMap(dict["Filters"] as! [String: Any])
                self.filters = model
            }
            if dict.keys.contains("Labels") {
                var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MetricsType") {
                self.metricsType = dict["MetricsType"] as! String
            }
            if dict.keys.contains("NotifyMode") {
                self.notifyMode = dict["NotifyMode"] as! String
            }
            if dict.keys.contains("NotifyStrategy") {
                self.notifyStrategy = dict["NotifyStrategy"] as! String
            }
            if dict.keys.contains("Pids") {
                self.pids = dict["Pids"] as! [String]
            }
            if dict.keys.contains("PromQL") {
                self.promQL = dict["PromQL"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var alertRule: CreateOrUpdateAlertRuleResponseBody.AlertRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertRule != nil {
            map["AlertRule"] = self.alertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertRule") {
            var model = CreateOrUpdateAlertRuleResponseBody.AlertRule()
            model.fromMap(dict["AlertRule"] as! [String: Any])
            self.alertRule = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateContactRequest : Tea.TeaModel {
    public var contactId: Int64?

    public var contactName: String?

    public var corpUserId: String?

    public var dingRobotUrl: String?

    public var email: String?

    public var isEmailVerify: Bool?

    public var phone: String?

    public var reissueSendNotice: Int64?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.corpUserId != nil {
            map["CorpUserId"] = self.corpUserId!
        }
        if self.dingRobotUrl != nil {
            map["DingRobotUrl"] = self.dingRobotUrl!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.isEmailVerify != nil {
            map["IsEmailVerify"] = self.isEmailVerify!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        if self.reissueSendNotice != nil {
            map["ReissueSendNotice"] = self.reissueSendNotice!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("CorpUserId") {
            self.corpUserId = dict["CorpUserId"] as! String
        }
        if dict.keys.contains("DingRobotUrl") {
            self.dingRobotUrl = dict["DingRobotUrl"] as! String
        }
        if dict.keys.contains("Email") {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("IsEmailVerify") {
            self.isEmailVerify = dict["IsEmailVerify"] as! Bool
        }
        if dict.keys.contains("Phone") {
            self.phone = dict["Phone"] as! String
        }
        if dict.keys.contains("ReissueSendNotice") {
            self.reissueSendNotice = dict["ReissueSendNotice"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateOrUpdateContactResponseBody : Tea.TeaModel {
    public class AlertContact : Tea.TeaModel {
        public var contactId: Double?

        public var contactName: String?

        public var dingRobotUrl: String?

        public var email: String?

        public var isVerify: Bool?

        public var phone: String?

        public var reissueSendNotice: Int64?

        public var isEmailVerify: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.contactName != nil {
                map["ContactName"] = self.contactName!
            }
            if self.dingRobotUrl != nil {
                map["DingRobotUrl"] = self.dingRobotUrl!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.isVerify != nil {
                map["IsVerify"] = self.isVerify!
            }
            if self.phone != nil {
                map["Phone"] = self.phone!
            }
            if self.reissueSendNotice != nil {
                map["ReissueSendNotice"] = self.reissueSendNotice!
            }
            if self.isEmailVerify != nil {
                map["isEmailVerify"] = self.isEmailVerify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactId") {
                self.contactId = dict["ContactId"] as! Double
            }
            if dict.keys.contains("ContactName") {
                self.contactName = dict["ContactName"] as! String
            }
            if dict.keys.contains("DingRobotUrl") {
                self.dingRobotUrl = dict["DingRobotUrl"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("IsVerify") {
                self.isVerify = dict["IsVerify"] as! Bool
            }
            if dict.keys.contains("Phone") {
                self.phone = dict["Phone"] as! String
            }
            if dict.keys.contains("ReissueSendNotice") {
                self.reissueSendNotice = dict["ReissueSendNotice"] as! Int64
            }
            if dict.keys.contains("isEmailVerify") {
                self.isEmailVerify = dict["isEmailVerify"] as! Bool
            }
        }
    }
    public var alertContact: CreateOrUpdateContactResponseBody.AlertContact?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertContact?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertContact != nil {
            map["AlertContact"] = self.alertContact?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertContact") {
            var model = CreateOrUpdateContactResponseBody.AlertContact()
            model.fromMap(dict["AlertContact"] as! [String: Any])
            self.alertContact = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateContactGroupRequest : Tea.TeaModel {
    public var contactGroupId: Int64?

    public var contactGroupName: String?

    public var contactIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") {
            self.contactGroupId = dict["ContactGroupId"] as! Int64
        }
        if dict.keys.contains("ContactGroupName") {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactIds") {
            self.contactIds = dict["ContactIds"] as! String
        }
    }
}

public class CreateOrUpdateContactGroupResponseBody : Tea.TeaModel {
    public class AlertContactGroup : Tea.TeaModel {
        public var contactGroupId: Double?

        public var contactGroupName: String?

        public var contactIds: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactGroupId != nil {
                map["ContactGroupId"] = self.contactGroupId!
            }
            if self.contactGroupName != nil {
                map["ContactGroupName"] = self.contactGroupName!
            }
            if self.contactIds != nil {
                map["ContactIds"] = self.contactIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactGroupId") {
                self.contactGroupId = dict["ContactGroupId"] as! Double
            }
            if dict.keys.contains("ContactGroupName") {
                self.contactGroupName = dict["ContactGroupName"] as! String
            }
            if dict.keys.contains("ContactIds") {
                self.contactIds = dict["ContactIds"] as! String
            }
        }
    }
    public var alertContactGroup: CreateOrUpdateContactGroupResponseBody.AlertContactGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertContactGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertContactGroup != nil {
            map["AlertContactGroup"] = self.alertContactGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertContactGroup") {
            var model = CreateOrUpdateContactGroupResponseBody.AlertContactGroup()
            model.fromMap(dict["AlertContactGroup"] as! [String: Any])
            self.alertContactGroup = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateEventBridgeIntegrationRequest : Tea.TeaModel {
    public var accessKey: String?

    public var accessSecret: String?

    public var description_: String?

    public var endpoint: String?

    public var eventBusName: String?

    public var eventBusRegionId: String?

    public var id: Int64?

    public var name: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessKey != nil {
            map["AccessKey"] = self.accessKey!
        }
        if self.accessSecret != nil {
            map["AccessSecret"] = self.accessSecret!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventBusRegionId != nil {
            map["EventBusRegionId"] = self.eventBusRegionId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessKey") {
            self.accessKey = dict["AccessKey"] as! String
        }
        if dict.keys.contains("AccessSecret") {
            self.accessSecret = dict["AccessSecret"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Endpoint") {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EventBusName") {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventBusRegionId") {
            self.eventBusRegionId = dict["EventBusRegionId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class CreateOrUpdateEventBridgeIntegrationResponseBody : Tea.TeaModel {
    public class EventBridgeIntegration : Tea.TeaModel {
        public var accessKey: String?

        public var accessSecret: String?

        public var description_: String?

        public var endpoint: String?

        public var eventBusName: String?

        public var eventBusRegionId: String?

        public var id: Int64?

        public var name: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKey != nil {
                map["AccessKey"] = self.accessKey!
            }
            if self.accessSecret != nil {
                map["AccessSecret"] = self.accessSecret!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.eventBusName != nil {
                map["EventBusName"] = self.eventBusName!
            }
            if self.eventBusRegionId != nil {
                map["EventBusRegionId"] = self.eventBusRegionId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKey") {
                self.accessKey = dict["AccessKey"] as! String
            }
            if dict.keys.contains("AccessSecret") {
                self.accessSecret = dict["AccessSecret"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("EventBusName") {
                self.eventBusName = dict["EventBusName"] as! String
            }
            if dict.keys.contains("EventBusRegionId") {
                self.eventBusRegionId = dict["EventBusRegionId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var eventBridgeIntegration: CreateOrUpdateEventBridgeIntegrationResponseBody.EventBridgeIntegration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventBridgeIntegration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBridgeIntegration != nil {
            map["EventBridgeIntegration"] = self.eventBridgeIntegration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBridgeIntegration") {
            var model = CreateOrUpdateEventBridgeIntegrationResponseBody.EventBridgeIntegration()
            model.fromMap(dict["EventBridgeIntegration"] as! [String: Any])
            self.eventBridgeIntegration = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateEventBridgeIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateEventBridgeIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateEventBridgeIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateIMRobotRequest : Tea.TeaModel {
    public var cardTemplate: String?

    public var dailyNoc: Bool?

    public var dailyNocTime: String?

    public var dingSignKey: String?

    public var enableOutgoing: Bool?

    public var robotAddress: String?

    public var robotId: Int64?

    public var robotName: String?

    public var token: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cardTemplate != nil {
            map["CardTemplate"] = self.cardTemplate!
        }
        if self.dailyNoc != nil {
            map["DailyNoc"] = self.dailyNoc!
        }
        if self.dailyNocTime != nil {
            map["DailyNocTime"] = self.dailyNocTime!
        }
        if self.dingSignKey != nil {
            map["DingSignKey"] = self.dingSignKey!
        }
        if self.enableOutgoing != nil {
            map["EnableOutgoing"] = self.enableOutgoing!
        }
        if self.robotAddress != nil {
            map["RobotAddress"] = self.robotAddress!
        }
        if self.robotId != nil {
            map["RobotId"] = self.robotId!
        }
        if self.robotName != nil {
            map["RobotName"] = self.robotName!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CardTemplate") {
            self.cardTemplate = dict["CardTemplate"] as! String
        }
        if dict.keys.contains("DailyNoc") {
            self.dailyNoc = dict["DailyNoc"] as! Bool
        }
        if dict.keys.contains("DailyNocTime") {
            self.dailyNocTime = dict["DailyNocTime"] as! String
        }
        if dict.keys.contains("DingSignKey") {
            self.dingSignKey = dict["DingSignKey"] as! String
        }
        if dict.keys.contains("EnableOutgoing") {
            self.enableOutgoing = dict["EnableOutgoing"] as! Bool
        }
        if dict.keys.contains("RobotAddress") {
            self.robotAddress = dict["RobotAddress"] as! String
        }
        if dict.keys.contains("RobotId") {
            self.robotId = dict["RobotId"] as! Int64
        }
        if dict.keys.contains("RobotName") {
            self.robotName = dict["RobotName"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateOrUpdateIMRobotResponseBody : Tea.TeaModel {
    public class AlertRobot : Tea.TeaModel {
        public var cardTemplate: String?

        public var dailyNoc: Bool?

        public var dailyNocTime: String?

        public var enableOutgoing: Bool?

        public var robotAddress: String?

        public var robotId: Double?

        public var robotName: String?

        public var token: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cardTemplate != nil {
                map["CardTemplate"] = self.cardTemplate!
            }
            if self.dailyNoc != nil {
                map["DailyNoc"] = self.dailyNoc!
            }
            if self.dailyNocTime != nil {
                map["DailyNocTime"] = self.dailyNocTime!
            }
            if self.enableOutgoing != nil {
                map["EnableOutgoing"] = self.enableOutgoing!
            }
            if self.robotAddress != nil {
                map["RobotAddress"] = self.robotAddress!
            }
            if self.robotId != nil {
                map["RobotId"] = self.robotId!
            }
            if self.robotName != nil {
                map["RobotName"] = self.robotName!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CardTemplate") {
                self.cardTemplate = dict["CardTemplate"] as! String
            }
            if dict.keys.contains("DailyNoc") {
                self.dailyNoc = dict["DailyNoc"] as! Bool
            }
            if dict.keys.contains("DailyNocTime") {
                self.dailyNocTime = dict["DailyNocTime"] as! String
            }
            if dict.keys.contains("EnableOutgoing") {
                self.enableOutgoing = dict["EnableOutgoing"] as! Bool
            }
            if dict.keys.contains("RobotAddress") {
                self.robotAddress = dict["RobotAddress"] as! String
            }
            if dict.keys.contains("RobotId") {
                self.robotId = dict["RobotId"] as! Double
            }
            if dict.keys.contains("RobotName") {
                self.robotName = dict["RobotName"] as! String
            }
            if dict.keys.contains("Token") {
                self.token = dict["Token"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var alertRobot: CreateOrUpdateIMRobotResponseBody.AlertRobot?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertRobot?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertRobot != nil {
            map["AlertRobot"] = self.alertRobot?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertRobot") {
            var model = CreateOrUpdateIMRobotResponseBody.AlertRobot()
            model.fromMap(dict["AlertRobot"] as! [String: Any])
            self.alertRobot = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateIMRobotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateIMRobotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateIMRobotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateNotificationPolicyRequest : Tea.TeaModel {
    public var directedMode: Bool?

    public var escalationPolicyId: Int64?

    public var groupRule: String?

    public var id: Int64?

    public var integrationId: Int64?

    public var matchingRules: String?

    public var name: String?

    public var notifyRule: String?

    public var notifyTemplate: String?

    public var regionId: String?

    public var repeat_: Bool?

    public var repeatInterval: Int64?

    public var sendRecoverMessage: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directedMode != nil {
            map["DirectedMode"] = self.directedMode!
        }
        if self.escalationPolicyId != nil {
            map["EscalationPolicyId"] = self.escalationPolicyId!
        }
        if self.groupRule != nil {
            map["GroupRule"] = self.groupRule!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.integrationId != nil {
            map["IntegrationId"] = self.integrationId!
        }
        if self.matchingRules != nil {
            map["MatchingRules"] = self.matchingRules!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyRule != nil {
            map["NotifyRule"] = self.notifyRule!
        }
        if self.notifyTemplate != nil {
            map["NotifyTemplate"] = self.notifyTemplate!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeat_ != nil {
            map["Repeat"] = self.repeat_!
        }
        if self.repeatInterval != nil {
            map["RepeatInterval"] = self.repeatInterval!
        }
        if self.sendRecoverMessage != nil {
            map["SendRecoverMessage"] = self.sendRecoverMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectedMode") {
            self.directedMode = dict["DirectedMode"] as! Bool
        }
        if dict.keys.contains("EscalationPolicyId") {
            self.escalationPolicyId = dict["EscalationPolicyId"] as! Int64
        }
        if dict.keys.contains("GroupRule") {
            self.groupRule = dict["GroupRule"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IntegrationId") {
            self.integrationId = dict["IntegrationId"] as! Int64
        }
        if dict.keys.contains("MatchingRules") {
            self.matchingRules = dict["MatchingRules"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyRule") {
            self.notifyRule = dict["NotifyRule"] as! String
        }
        if dict.keys.contains("NotifyTemplate") {
            self.notifyTemplate = dict["NotifyTemplate"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Repeat") {
            self.repeat_ = dict["Repeat"] as! Bool
        }
        if dict.keys.contains("RepeatInterval") {
            self.repeatInterval = dict["RepeatInterval"] as! Int64
        }
        if dict.keys.contains("SendRecoverMessage") {
            self.sendRecoverMessage = dict["SendRecoverMessage"] as! Bool
        }
    }
}

public class CreateOrUpdateNotificationPolicyResponseBody : Tea.TeaModel {
    public class NotificationPolicy : Tea.TeaModel {
        public class GroupRule : Tea.TeaModel {
            public var groupInterval: Int64?

            public var groupWait: Int64?

            public var groupingFields: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupInterval != nil {
                    map["GroupInterval"] = self.groupInterval!
                }
                if self.groupWait != nil {
                    map["GroupWait"] = self.groupWait!
                }
                if self.groupingFields != nil {
                    map["GroupingFields"] = self.groupingFields!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupInterval") {
                    self.groupInterval = dict["GroupInterval"] as! Int64
                }
                if dict.keys.contains("GroupWait") {
                    self.groupWait = dict["GroupWait"] as! Int64
                }
                if dict.keys.contains("GroupingFields") {
                    self.groupingFields = dict["GroupingFields"] as! [String]
                }
            }
        }
        public class MatchingRules : Tea.TeaModel {
            public class MatchingConditions : Tea.TeaModel {
                public var key: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var matchingConditions: [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules.MatchingConditions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.matchingConditions != nil {
                    var tmp : [Any] = []
                    for k in self.matchingConditions! {
                        tmp.append(k.toMap())
                    }
                    map["MatchingConditions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MatchingConditions") {
                    var tmp : [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules.MatchingConditions] = []
                    for v in dict["MatchingConditions"] as! [Any] {
                        var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules.MatchingConditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.matchingConditions = tmp
                }
            }
        }
        public class NotifyRule : Tea.TeaModel {
            public class NotifyObjects : Tea.TeaModel {
                public var notifyChannels: [String]?

                public var notifyObjectId: Int64?

                public var notifyObjectName: String?

                public var notifyObjectType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.notifyChannels != nil {
                        map["NotifyChannels"] = self.notifyChannels!
                    }
                    if self.notifyObjectId != nil {
                        map["NotifyObjectId"] = self.notifyObjectId!
                    }
                    if self.notifyObjectName != nil {
                        map["NotifyObjectName"] = self.notifyObjectName!
                    }
                    if self.notifyObjectType != nil {
                        map["NotifyObjectType"] = self.notifyObjectType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NotifyChannels") {
                        self.notifyChannels = dict["NotifyChannels"] as! [String]
                    }
                    if dict.keys.contains("NotifyObjectId") {
                        self.notifyObjectId = dict["NotifyObjectId"] as! Int64
                    }
                    if dict.keys.contains("NotifyObjectName") {
                        self.notifyObjectName = dict["NotifyObjectName"] as! String
                    }
                    if dict.keys.contains("NotifyObjectType") {
                        self.notifyObjectType = dict["NotifyObjectType"] as! String
                    }
                }
            }
            public var notifyChannels: [String]?

            public var notifyEndTime: String?

            public var notifyObjects: [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule.NotifyObjects]?

            public var notifyStartTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notifyChannels != nil {
                    map["NotifyChannels"] = self.notifyChannels!
                }
                if self.notifyEndTime != nil {
                    map["NotifyEndTime"] = self.notifyEndTime!
                }
                if self.notifyObjects != nil {
                    var tmp : [Any] = []
                    for k in self.notifyObjects! {
                        tmp.append(k.toMap())
                    }
                    map["NotifyObjects"] = tmp
                }
                if self.notifyStartTime != nil {
                    map["NotifyStartTime"] = self.notifyStartTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NotifyChannels") {
                    self.notifyChannels = dict["NotifyChannels"] as! [String]
                }
                if dict.keys.contains("NotifyEndTime") {
                    self.notifyEndTime = dict["NotifyEndTime"] as! String
                }
                if dict.keys.contains("NotifyObjects") {
                    var tmp : [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule.NotifyObjects] = []
                    for v in dict["NotifyObjects"] as! [Any] {
                        var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule.NotifyObjects()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notifyObjects = tmp
                }
                if dict.keys.contains("NotifyStartTime") {
                    self.notifyStartTime = dict["NotifyStartTime"] as! String
                }
            }
        }
        public class NotifyTemplate : Tea.TeaModel {
            public var emailContent: String?

            public var emailRecoverContent: String?

            public var emailRecoverTitle: String?

            public var emailTitle: String?

            public var robotContent: String?

            public var smsContent: String?

            public var smsRecoverContent: String?

            public var ttsContent: String?

            public var ttsRecoverContent: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.emailContent != nil {
                    map["EmailContent"] = self.emailContent!
                }
                if self.emailRecoverContent != nil {
                    map["EmailRecoverContent"] = self.emailRecoverContent!
                }
                if self.emailRecoverTitle != nil {
                    map["EmailRecoverTitle"] = self.emailRecoverTitle!
                }
                if self.emailTitle != nil {
                    map["EmailTitle"] = self.emailTitle!
                }
                if self.robotContent != nil {
                    map["RobotContent"] = self.robotContent!
                }
                if self.smsContent != nil {
                    map["SmsContent"] = self.smsContent!
                }
                if self.smsRecoverContent != nil {
                    map["SmsRecoverContent"] = self.smsRecoverContent!
                }
                if self.ttsContent != nil {
                    map["TtsContent"] = self.ttsContent!
                }
                if self.ttsRecoverContent != nil {
                    map["TtsRecoverContent"] = self.ttsRecoverContent!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EmailContent") {
                    self.emailContent = dict["EmailContent"] as! String
                }
                if dict.keys.contains("EmailRecoverContent") {
                    self.emailRecoverContent = dict["EmailRecoverContent"] as! String
                }
                if dict.keys.contains("EmailRecoverTitle") {
                    self.emailRecoverTitle = dict["EmailRecoverTitle"] as! String
                }
                if dict.keys.contains("EmailTitle") {
                    self.emailTitle = dict["EmailTitle"] as! String
                }
                if dict.keys.contains("RobotContent") {
                    self.robotContent = dict["RobotContent"] as! String
                }
                if dict.keys.contains("SmsContent") {
                    self.smsContent = dict["SmsContent"] as! String
                }
                if dict.keys.contains("SmsRecoverContent") {
                    self.smsRecoverContent = dict["SmsRecoverContent"] as! String
                }
                if dict.keys.contains("TtsContent") {
                    self.ttsContent = dict["TtsContent"] as! String
                }
                if dict.keys.contains("TtsRecoverContent") {
                    self.ttsRecoverContent = dict["TtsRecoverContent"] as! String
                }
            }
        }
        public var directedMode: Bool?

        public var escalationPolicyId: Int64?

        public var groupRule: CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.GroupRule?

        public var id: Int64?

        public var integrationId: Int64?

        public var matchingRules: [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules]?

        public var name: String?

        public var notifyRule: CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule?

        public var notifyTemplate: CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyTemplate?

        public var repeat_: Bool?

        public var repeatInterval: Int64?

        public var sendRecoverMessage: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.groupRule?.validate()
            try self.notifyRule?.validate()
            try self.notifyTemplate?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.directedMode != nil {
                map["DirectedMode"] = self.directedMode!
            }
            if self.escalationPolicyId != nil {
                map["EscalationPolicyId"] = self.escalationPolicyId!
            }
            if self.groupRule != nil {
                map["GroupRule"] = self.groupRule?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.integrationId != nil {
                map["IntegrationId"] = self.integrationId!
            }
            if self.matchingRules != nil {
                var tmp : [Any] = []
                for k in self.matchingRules! {
                    tmp.append(k.toMap())
                }
                map["MatchingRules"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyRule != nil {
                map["NotifyRule"] = self.notifyRule?.toMap()
            }
            if self.notifyTemplate != nil {
                map["NotifyTemplate"] = self.notifyTemplate?.toMap()
            }
            if self.repeat_ != nil {
                map["Repeat"] = self.repeat_!
            }
            if self.repeatInterval != nil {
                map["RepeatInterval"] = self.repeatInterval!
            }
            if self.sendRecoverMessage != nil {
                map["SendRecoverMessage"] = self.sendRecoverMessage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DirectedMode") {
                self.directedMode = dict["DirectedMode"] as! Bool
            }
            if dict.keys.contains("EscalationPolicyId") {
                self.escalationPolicyId = dict["EscalationPolicyId"] as! Int64
            }
            if dict.keys.contains("GroupRule") {
                var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.GroupRule()
                model.fromMap(dict["GroupRule"] as! [String: Any])
                self.groupRule = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IntegrationId") {
                self.integrationId = dict["IntegrationId"] as! Int64
            }
            if dict.keys.contains("MatchingRules") {
                var tmp : [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules] = []
                for v in dict["MatchingRules"] as! [Any] {
                    var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.matchingRules = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyRule") {
                var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule()
                model.fromMap(dict["NotifyRule"] as! [String: Any])
                self.notifyRule = model
            }
            if dict.keys.contains("NotifyTemplate") {
                var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyTemplate()
                model.fromMap(dict["NotifyTemplate"] as! [String: Any])
                self.notifyTemplate = model
            }
            if dict.keys.contains("Repeat") {
                self.repeat_ = dict["Repeat"] as! Bool
            }
            if dict.keys.contains("RepeatInterval") {
                self.repeatInterval = dict["RepeatInterval"] as! Int64
            }
            if dict.keys.contains("SendRecoverMessage") {
                self.sendRecoverMessage = dict["SendRecoverMessage"] as! Bool
            }
        }
    }
    public var notificationPolicy: CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationPolicy != nil {
            map["NotificationPolicy"] = self.notificationPolicy?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationPolicy") {
            var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy()
            model.fromMap(dict["NotificationPolicy"] as! [String: Any])
            self.notificationPolicy = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateNotificationPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateNotificationPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateNotificationPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateSilencePolicyRequest : Tea.TeaModel {
    public var id: Int64?

    public var matchingRules: String?

    public var name: String?

    public var regionId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.matchingRules != nil {
            map["MatchingRules"] = self.matchingRules!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MatchingRules") {
            self.matchingRules = dict["MatchingRules"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class CreateOrUpdateSilencePolicyResponseBody : Tea.TeaModel {
    public class SilencePolicy : Tea.TeaModel {
        public class MatchingRules : Tea.TeaModel {
            public class MatchingConditions : Tea.TeaModel {
                public var key: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var matchingConditions: [CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules.MatchingConditions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.matchingConditions != nil {
                    var tmp : [Any] = []
                    for k in self.matchingConditions! {
                        tmp.append(k.toMap())
                    }
                    map["MatchingConditions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MatchingConditions") {
                    var tmp : [CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules.MatchingConditions] = []
                    for v in dict["MatchingConditions"] as! [Any] {
                        var model = CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules.MatchingConditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.matchingConditions = tmp
                }
            }
        }
        public var id: Int64?

        public var matchingRules: [CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules]?

        public var name: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchingRules != nil {
                var tmp : [Any] = []
                for k in self.matchingRules! {
                    tmp.append(k.toMap())
                }
                map["MatchingRules"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MatchingRules") {
                var tmp : [CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules] = []
                for v in dict["MatchingRules"] as! [Any] {
                    var model = CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.matchingRules = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var requestId: String?

    public var silencePolicy: CreateOrUpdateSilencePolicyResponseBody.SilencePolicy?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.silencePolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.silencePolicy != nil {
            map["SilencePolicy"] = self.silencePolicy?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SilencePolicy") {
            var model = CreateOrUpdateSilencePolicyResponseBody.SilencePolicy()
            model.fromMap(dict["SilencePolicy"] as! [String: Any])
            self.silencePolicy = model
        }
    }
}

public class CreateOrUpdateSilencePolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSilencePolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateSilencePolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateWebhookContactRequest : Tea.TeaModel {
    public var bizHeaders: String?

    public var bizParams: String?

    public var body: String?

    public var method: String?

    public var recoverBody: String?

    public var url: String?

    public var webhookId: Int64?

    public var webhookName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizHeaders != nil {
            map["BizHeaders"] = self.bizHeaders!
        }
        if self.bizParams != nil {
            map["BizParams"] = self.bizParams!
        }
        if self.body != nil {
            map["Body"] = self.body!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.recoverBody != nil {
            map["RecoverBody"] = self.recoverBody!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        if self.webhookId != nil {
            map["WebhookId"] = self.webhookId!
        }
        if self.webhookName != nil {
            map["WebhookName"] = self.webhookName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizHeaders") {
            self.bizHeaders = dict["BizHeaders"] as! String
        }
        if dict.keys.contains("BizParams") {
            self.bizParams = dict["BizParams"] as! String
        }
        if dict.keys.contains("Body") {
            self.body = dict["Body"] as! String
        }
        if dict.keys.contains("Method") {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("RecoverBody") {
            self.recoverBody = dict["RecoverBody"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
        if dict.keys.contains("WebhookId") {
            self.webhookId = dict["WebhookId"] as! Int64
        }
        if dict.keys.contains("WebhookName") {
            self.webhookName = dict["WebhookName"] as! String
        }
    }
}

public class CreateOrUpdateWebhookContactResponseBody : Tea.TeaModel {
    public class WebhookContact : Tea.TeaModel {
        public class Webhook : Tea.TeaModel {
            public var bizHeaders: String?

            public var bizParams: String?

            public var body: String?

            public var method: String?

            public var recoverBody: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizHeaders != nil {
                    map["BizHeaders"] = self.bizHeaders!
                }
                if self.bizParams != nil {
                    map["BizParams"] = self.bizParams!
                }
                if self.body != nil {
                    map["Body"] = self.body!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.recoverBody != nil {
                    map["RecoverBody"] = self.recoverBody!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizHeaders") {
                    self.bizHeaders = dict["BizHeaders"] as! String
                }
                if dict.keys.contains("BizParams") {
                    self.bizParams = dict["BizParams"] as! String
                }
                if dict.keys.contains("Body") {
                    self.body = dict["Body"] as! String
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("RecoverBody") {
                    self.recoverBody = dict["RecoverBody"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var webhook: CreateOrUpdateWebhookContactResponseBody.WebhookContact.Webhook?

        public var webhookId: Double?

        public var webhookName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.webhook?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.webhook != nil {
                map["Webhook"] = self.webhook?.toMap()
            }
            if self.webhookId != nil {
                map["WebhookId"] = self.webhookId!
            }
            if self.webhookName != nil {
                map["WebhookName"] = self.webhookName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Webhook") {
                var model = CreateOrUpdateWebhookContactResponseBody.WebhookContact.Webhook()
                model.fromMap(dict["Webhook"] as! [String: Any])
                self.webhook = model
            }
            if dict.keys.contains("WebhookId") {
                self.webhookId = dict["WebhookId"] as! Double
            }
            if dict.keys.contains("WebhookName") {
                self.webhookName = dict["WebhookName"] as! String
            }
        }
    }
    public var requestId: String?

    public var webhookContact: CreateOrUpdateWebhookContactResponseBody.WebhookContact?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webhookContact?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.webhookContact != nil {
            map["WebhookContact"] = self.webhookContact?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WebhookContact") {
            var model = CreateOrUpdateWebhookContactResponseBody.WebhookContact()
            model.fromMap(dict["WebhookContact"] as! [String: Any])
            self.webhookContact = model
        }
    }
}

public class CreateOrUpdateWebhookContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateWebhookContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateWebhookContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePrometheusAlertRuleRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertName: String?

    public var annotations: String?

    public var clusterId: String?

    public var dispatchRuleId: Int64?

    public var duration: String?

    public var expression: String?

    public var labels: String?

    public var message: String?

    public var notifyType: String?

    public var regionId: String?

    public var tags: [CreatePrometheusAlertRuleRequest.Tags]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dispatchRuleId != nil {
            map["DispatchRuleId"] = self.dispatchRuleId!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.expression != nil {
            map["Expression"] = self.expression!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertName") {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("Annotations") {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DispatchRuleId") {
            self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("Expression") {
            self.expression = dict["Expression"] as! String
        }
        if dict.keys.contains("Labels") {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NotifyType") {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreatePrometheusAlertRuleRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreatePrometheusAlertRuleRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreatePrometheusAlertRuleResponseBody : Tea.TeaModel {
    public class PrometheusAlertRule : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertId: Int64?

        public var alertName: String?

        public var annotations: [CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations]?

        public var clusterId: String?

        public var dispatchRuleId: Int64?

        public var duration: String?

        public var expression: String?

        public var labels: [CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels]?

        public var message: String?

        public var notifyType: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dispatchRuleId != nil {
                map["DispatchRuleId"] = self.dispatchRuleId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertId") {
                self.alertId = dict["AlertId"] as! Int64
            }
            if dict.keys.contains("AlertName") {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") {
                var tmp : [CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("DispatchRuleId") {
                self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") {
                var tmp : [CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NotifyType") {
                self.notifyType = dict["NotifyType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int64?

    public var message: String?

    public var prometheusAlertRule: CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prometheusAlertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.prometheusAlertRule != nil {
            map["PrometheusAlertRule"] = self.prometheusAlertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PrometheusAlertRule") {
            var model = CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule()
            model.fromMap(dict["PrometheusAlertRule"] as! [String: Any])
            self.prometheusAlertRule = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreatePrometheusAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePrometheusAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePrometheusAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePrometheusInstanceRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var allSubClustersSuccess: Bool?

    public var archiveDuration: Int32?

    public var clusterId: String?

    public var clusterName: String?

    public var clusterType: String?

    public var duration: Int32?

    public var grafanaInstanceId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var securityGroupId: String?

    public var subClustersJson: String?

    public var tags: [CreatePrometheusInstanceRequest.Tags]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allSubClustersSuccess != nil {
            map["AllSubClustersSuccess"] = self.allSubClustersSuccess!
        }
        if self.archiveDuration != nil {
            map["ArchiveDuration"] = self.archiveDuration!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.grafanaInstanceId != nil {
            map["GrafanaInstanceId"] = self.grafanaInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.subClustersJson != nil {
            map["SubClustersJson"] = self.subClustersJson!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllSubClustersSuccess") {
            self.allSubClustersSuccess = dict["AllSubClustersSuccess"] as! Bool
        }
        if dict.keys.contains("ArchiveDuration") {
            self.archiveDuration = dict["ArchiveDuration"] as! Int32
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("GrafanaInstanceId") {
            self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SubClustersJson") {
            self.subClustersJson = dict["SubClustersJson"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreatePrometheusInstanceRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreatePrometheusInstanceRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreatePrometheusInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePrometheusInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePrometheusInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePrometheusInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var configYaml: String?

    public var regionId: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigYaml") {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreatePrometheusMonitoringResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRetcodeAppRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceGroupId: String?

    public var retcodeAppName: String?

    public var retcodeAppType: String?

    public var tags: [CreateRetcodeAppRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.retcodeAppName != nil {
            map["RetcodeAppName"] = self.retcodeAppName!
        }
        if self.retcodeAppType != nil {
            map["RetcodeAppType"] = self.retcodeAppType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RetcodeAppName") {
            self.retcodeAppName = dict["RetcodeAppName"] as! String
        }
        if dict.keys.contains("RetcodeAppType") {
            self.retcodeAppType = dict["RetcodeAppType"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateRetcodeAppRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateRetcodeAppRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateRetcodeAppResponseBody : Tea.TeaModel {
    public class RetcodeAppDataBean : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var tags: [CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tags") {
                    var tmp : [CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
            }
        }
        public var appId: Int64?

        public var pid: String?

        public var resourceGroupId: String?

        public var tags: CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                var model = CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
        }
    }
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var retcodeAppDataBean: CreateRetcodeAppResponseBody.RetcodeAppDataBean?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.retcodeAppDataBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retcodeAppDataBean != nil {
            map["RetcodeAppDataBean"] = self.retcodeAppDataBean?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetcodeAppDataBean") {
            var model = CreateRetcodeAppResponseBody.RetcodeAppDataBean()
            model.fromMap(dict["RetcodeAppDataBean"] as! [String: Any])
            self.retcodeAppDataBean = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateRetcodeAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRetcodeAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRetcodeAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRumAppRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appGroup: String?

    public var appName: String?

    public var description_: String?

    public var packageName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var siteType: String?

    public var source: String?

    public var tag: [CreateRumAppRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGroup != nil {
            map["AppGroup"] = self.appGroup!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.packageName != nil {
            map["PackageName"] = self.packageName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.siteType != nil {
            map["SiteType"] = self.siteType!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGroup") {
            self.appGroup = dict["AppGroup"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("PackageName") {
            self.packageName = dict["PackageName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SiteType") {
            self.siteType = dict["SiteType"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateRumAppRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateRumAppRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateRumAppResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateRumAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRumAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRumAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRumUploadFileUrlRequest : Tea.TeaModel {
    public var appName: String?

    public var contentType: String?

    public var fileName: String?

    public var pid: String?

    public var regionId: String?

    public var sourcemapType: String?

    public var uuid: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sourcemapType != nil {
            map["SourcemapType"] = self.sourcemapType!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SourcemapType") {
            self.sourcemapType = dict["SourcemapType"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("VersionId") {
            self.versionId = dict["VersionId"] as! String
        }
    }
}

public class CreateRumUploadFileUrlResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateRumUploadFileUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRumUploadFileUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRumUploadFileUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSyntheticTaskRequest : Tea.TeaModel {
    public class CommonParam : Tea.TeaModel {
        public class AlertList : Tea.TeaModel {
            public var isCritical: Int64?

            public var name: String?

            public var symbols: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isCritical != nil {
                    map["IsCritical"] = self.isCritical!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.symbols != nil {
                    map["Symbols"] = self.symbols!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IsCritical") {
                    self.isCritical = dict["IsCritical"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Symbols") {
                    self.symbols = dict["Symbols"] as! Int64
                }
            }
        }
        public var alarmFlag: String?

        public var alertList: [CreateSyntheticTaskRequest.CommonParam.AlertList]?

        public var alertNotifierId: String?

        public var alertPolicyId: String?

        public var monitorSamples: Int64?

        public var startExecutionTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmFlag != nil {
                map["AlarmFlag"] = self.alarmFlag!
            }
            if self.alertList != nil {
                var tmp : [Any] = []
                for k in self.alertList! {
                    tmp.append(k.toMap())
                }
                map["AlertList"] = tmp
            }
            if self.alertNotifierId != nil {
                map["AlertNotifierId"] = self.alertNotifierId!
            }
            if self.alertPolicyId != nil {
                map["AlertPolicyId"] = self.alertPolicyId!
            }
            if self.monitorSamples != nil {
                map["MonitorSamples"] = self.monitorSamples!
            }
            if self.startExecutionTime != nil {
                map["StartExecutionTime"] = self.startExecutionTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmFlag") {
                self.alarmFlag = dict["AlarmFlag"] as! String
            }
            if dict.keys.contains("AlertList") {
                var tmp : [CreateSyntheticTaskRequest.CommonParam.AlertList] = []
                for v in dict["AlertList"] as! [Any] {
                    var model = CreateSyntheticTaskRequest.CommonParam.AlertList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertList = tmp
            }
            if dict.keys.contains("AlertNotifierId") {
                self.alertNotifierId = dict["AlertNotifierId"] as! String
            }
            if dict.keys.contains("AlertPolicyId") {
                self.alertPolicyId = dict["AlertPolicyId"] as! String
            }
            if dict.keys.contains("MonitorSamples") {
                self.monitorSamples = dict["MonitorSamples"] as! Int64
            }
            if dict.keys.contains("StartExecutionTime") {
                self.startExecutionTime = dict["StartExecutionTime"] as! Int64
            }
        }
    }
    public class Download : Tea.TeaModel {
        public var connectionTimeout: Double?

        public var downloadCustomHeaderContent: String?

        public var downloadCustomHost: Int64?

        public var downloadCustomHostIp: String?

        public var downloadIgnoreCertificateError: String?

        public var downloadKernel: Int64?

        public var downloadRedirection: Int64?

        public var downloadTransmissionSize: Int64?

        public var monitorTimeout: Int64?

        public var quickProtocol: String?

        public var validateKeywords: String?

        public var verifyWay: Int64?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionTimeout != nil {
                map["ConnectionTimeout"] = self.connectionTimeout!
            }
            if self.downloadCustomHeaderContent != nil {
                map["DownloadCustomHeaderContent"] = self.downloadCustomHeaderContent!
            }
            if self.downloadCustomHost != nil {
                map["DownloadCustomHost"] = self.downloadCustomHost!
            }
            if self.downloadCustomHostIp != nil {
                map["DownloadCustomHostIp"] = self.downloadCustomHostIp!
            }
            if self.downloadIgnoreCertificateError != nil {
                map["DownloadIgnoreCertificateError"] = self.downloadIgnoreCertificateError!
            }
            if self.downloadKernel != nil {
                map["DownloadKernel"] = self.downloadKernel!
            }
            if self.downloadRedirection != nil {
                map["DownloadRedirection"] = self.downloadRedirection!
            }
            if self.downloadTransmissionSize != nil {
                map["DownloadTransmissionSize"] = self.downloadTransmissionSize!
            }
            if self.monitorTimeout != nil {
                map["MonitorTimeout"] = self.monitorTimeout!
            }
            if self.quickProtocol != nil {
                map["QuickProtocol"] = self.quickProtocol!
            }
            if self.validateKeywords != nil {
                map["ValidateKeywords"] = self.validateKeywords!
            }
            if self.verifyWay != nil {
                map["VerifyWay"] = self.verifyWay!
            }
            if self.whiteList != nil {
                map["WhiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectionTimeout") {
                self.connectionTimeout = dict["ConnectionTimeout"] as! Double
            }
            if dict.keys.contains("DownloadCustomHeaderContent") {
                self.downloadCustomHeaderContent = dict["DownloadCustomHeaderContent"] as! String
            }
            if dict.keys.contains("DownloadCustomHost") {
                self.downloadCustomHost = dict["DownloadCustomHost"] as! Int64
            }
            if dict.keys.contains("DownloadCustomHostIp") {
                self.downloadCustomHostIp = dict["DownloadCustomHostIp"] as! String
            }
            if dict.keys.contains("DownloadIgnoreCertificateError") {
                self.downloadIgnoreCertificateError = dict["DownloadIgnoreCertificateError"] as! String
            }
            if dict.keys.contains("DownloadKernel") {
                self.downloadKernel = dict["DownloadKernel"] as! Int64
            }
            if dict.keys.contains("DownloadRedirection") {
                self.downloadRedirection = dict["DownloadRedirection"] as! Int64
            }
            if dict.keys.contains("DownloadTransmissionSize") {
                self.downloadTransmissionSize = dict["DownloadTransmissionSize"] as! Int64
            }
            if dict.keys.contains("MonitorTimeout") {
                self.monitorTimeout = dict["MonitorTimeout"] as! Int64
            }
            if dict.keys.contains("QuickProtocol") {
                self.quickProtocol = dict["QuickProtocol"] as! String
            }
            if dict.keys.contains("ValidateKeywords") {
                self.validateKeywords = dict["ValidateKeywords"] as! String
            }
            if dict.keys.contains("VerifyWay") {
                self.verifyWay = dict["VerifyWay"] as! Int64
            }
            if dict.keys.contains("WhiteList") {
                self.whiteList = dict["WhiteList"] as! String
            }
        }
    }
    public class ExtendInterval : Tea.TeaModel {
        public var days: [Int64]?

        public var endHour: Int64?

        public var endMinute: Int64?

        public var endTime: String?

        public var startHour: Int64?

        public var startMinute: Int64?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.days != nil {
                map["Days"] = self.days!
            }
            if self.endHour != nil {
                map["EndHour"] = self.endHour!
            }
            if self.endMinute != nil {
                map["EndMinute"] = self.endMinute!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startHour != nil {
                map["StartHour"] = self.startHour!
            }
            if self.startMinute != nil {
                map["StartMinute"] = self.startMinute!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Days") {
                self.days = dict["Days"] as! [Int64]
            }
            if dict.keys.contains("EndHour") {
                self.endHour = dict["EndHour"] as! Int64
            }
            if dict.keys.contains("EndMinute") {
                self.endMinute = dict["EndMinute"] as! Int64
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartHour") {
                self.startHour = dict["StartHour"] as! Int64
            }
            if dict.keys.contains("StartMinute") {
                self.startMinute = dict["StartMinute"] as! Int64
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class MonitorList : Tea.TeaModel {
        public var cityCode: Int64?

        public var monitorType: Int64?

        public var netServiceId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.monitorType != nil {
                map["MonitorType"] = self.monitorType!
            }
            if self.netServiceId != nil {
                map["NetServiceId"] = self.netServiceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! Int64
            }
            if dict.keys.contains("MonitorType") {
                self.monitorType = dict["MonitorType"] as! Int64
            }
            if dict.keys.contains("NetServiceId") {
                self.netServiceId = dict["NetServiceId"] as! Int64
            }
        }
    }
    public class Navigation : Tea.TeaModel {
        public var DNSHijackWhiteList: String?

        public var elementBlacklist: String?

        public var executeActiveX: Int64?

        public var executeApplication: Int64?

        public var executeScript: Int64?

        public var filterInvalidIP: Int64?

        public var flowHijackJumpTimes: Int64?

        public var flowHijackLogo: String?

        public var monitorTimeout: String?

        public var navAutomaticScrolling: String?

        public var navCustomHeader: String?

        public var navCustomHeaderContent: String?

        public var navCustomHost: Int64?

        public var navCustomHostIp: String?

        public var navDisableCache: Int64?

        public var navDisableCompression: String?

        public var navIgnoreCertificateError: Int64?

        public var navRedirection: Int64?

        public var navReturnElement: Int64?

        public var pageTamper: String?

        public var processName: String?

        public var QUICDomain: String?

        public var QUICVersion: Int64?

        public var requestHeader: Int64?

        public var responseHeader: Int64?

        public var slowElementThreshold: Double?

        public var verifyStringBlacklist: String?

        public var verifyStringWhiteList: String?

        public var waitCompletionTime: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DNSHijackWhiteList != nil {
                map["DNSHijackWhiteList"] = self.DNSHijackWhiteList!
            }
            if self.elementBlacklist != nil {
                map["ElementBlacklist"] = self.elementBlacklist!
            }
            if self.executeActiveX != nil {
                map["ExecuteActiveX"] = self.executeActiveX!
            }
            if self.executeApplication != nil {
                map["ExecuteApplication"] = self.executeApplication!
            }
            if self.executeScript != nil {
                map["ExecuteScript"] = self.executeScript!
            }
            if self.filterInvalidIP != nil {
                map["FilterInvalidIP"] = self.filterInvalidIP!
            }
            if self.flowHijackJumpTimes != nil {
                map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
            }
            if self.flowHijackLogo != nil {
                map["FlowHijackLogo"] = self.flowHijackLogo!
            }
            if self.monitorTimeout != nil {
                map["MonitorTimeout"] = self.monitorTimeout!
            }
            if self.navAutomaticScrolling != nil {
                map["NavAutomaticScrolling"] = self.navAutomaticScrolling!
            }
            if self.navCustomHeader != nil {
                map["NavCustomHeader"] = self.navCustomHeader!
            }
            if self.navCustomHeaderContent != nil {
                map["NavCustomHeaderContent"] = self.navCustomHeaderContent!
            }
            if self.navCustomHost != nil {
                map["NavCustomHost"] = self.navCustomHost!
            }
            if self.navCustomHostIp != nil {
                map["NavCustomHostIp"] = self.navCustomHostIp!
            }
            if self.navDisableCache != nil {
                map["NavDisableCache"] = self.navDisableCache!
            }
            if self.navDisableCompression != nil {
                map["NavDisableCompression"] = self.navDisableCompression!
            }
            if self.navIgnoreCertificateError != nil {
                map["NavIgnoreCertificateError"] = self.navIgnoreCertificateError!
            }
            if self.navRedirection != nil {
                map["NavRedirection"] = self.navRedirection!
            }
            if self.navReturnElement != nil {
                map["NavReturnElement"] = self.navReturnElement!
            }
            if self.pageTamper != nil {
                map["PageTamper"] = self.pageTamper!
            }
            if self.processName != nil {
                map["ProcessName"] = self.processName!
            }
            if self.QUICDomain != nil {
                map["QUICDomain"] = self.QUICDomain!
            }
            if self.QUICVersion != nil {
                map["QUICVersion"] = self.QUICVersion!
            }
            if self.requestHeader != nil {
                map["RequestHeader"] = self.requestHeader!
            }
            if self.responseHeader != nil {
                map["ResponseHeader"] = self.responseHeader!
            }
            if self.slowElementThreshold != nil {
                map["SlowElementThreshold"] = self.slowElementThreshold!
            }
            if self.verifyStringBlacklist != nil {
                map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
            }
            if self.verifyStringWhiteList != nil {
                map["VerifyStringWhiteList"] = self.verifyStringWhiteList!
            }
            if self.waitCompletionTime != nil {
                map["WaitCompletionTime"] = self.waitCompletionTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DNSHijackWhiteList") {
                self.DNSHijackWhiteList = dict["DNSHijackWhiteList"] as! String
            }
            if dict.keys.contains("ElementBlacklist") {
                self.elementBlacklist = dict["ElementBlacklist"] as! String
            }
            if dict.keys.contains("ExecuteActiveX") {
                self.executeActiveX = dict["ExecuteActiveX"] as! Int64
            }
            if dict.keys.contains("ExecuteApplication") {
                self.executeApplication = dict["ExecuteApplication"] as! Int64
            }
            if dict.keys.contains("ExecuteScript") {
                self.executeScript = dict["ExecuteScript"] as! Int64
            }
            if dict.keys.contains("FilterInvalidIP") {
                self.filterInvalidIP = dict["FilterInvalidIP"] as! Int64
            }
            if dict.keys.contains("FlowHijackJumpTimes") {
                self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int64
            }
            if dict.keys.contains("FlowHijackLogo") {
                self.flowHijackLogo = dict["FlowHijackLogo"] as! String
            }
            if dict.keys.contains("MonitorTimeout") {
                self.monitorTimeout = dict["MonitorTimeout"] as! String
            }
            if dict.keys.contains("NavAutomaticScrolling") {
                self.navAutomaticScrolling = dict["NavAutomaticScrolling"] as! String
            }
            if dict.keys.contains("NavCustomHeader") {
                self.navCustomHeader = dict["NavCustomHeader"] as! String
            }
            if dict.keys.contains("NavCustomHeaderContent") {
                self.navCustomHeaderContent = dict["NavCustomHeaderContent"] as! String
            }
            if dict.keys.contains("NavCustomHost") {
                self.navCustomHost = dict["NavCustomHost"] as! Int64
            }
            if dict.keys.contains("NavCustomHostIp") {
                self.navCustomHostIp = dict["NavCustomHostIp"] as! String
            }
            if dict.keys.contains("NavDisableCache") {
                self.navDisableCache = dict["NavDisableCache"] as! Int64
            }
            if dict.keys.contains("NavDisableCompression") {
                self.navDisableCompression = dict["NavDisableCompression"] as! String
            }
            if dict.keys.contains("NavIgnoreCertificateError") {
                self.navIgnoreCertificateError = dict["NavIgnoreCertificateError"] as! Int64
            }
            if dict.keys.contains("NavRedirection") {
                self.navRedirection = dict["NavRedirection"] as! Int64
            }
            if dict.keys.contains("NavReturnElement") {
                self.navReturnElement = dict["NavReturnElement"] as! Int64
            }
            if dict.keys.contains("PageTamper") {
                self.pageTamper = dict["PageTamper"] as! String
            }
            if dict.keys.contains("ProcessName") {
                self.processName = dict["ProcessName"] as! String
            }
            if dict.keys.contains("QUICDomain") {
                self.QUICDomain = dict["QUICDomain"] as! String
            }
            if dict.keys.contains("QUICVersion") {
                self.QUICVersion = dict["QUICVersion"] as! Int64
            }
            if dict.keys.contains("RequestHeader") {
                self.requestHeader = dict["RequestHeader"] as! Int64
            }
            if dict.keys.contains("ResponseHeader") {
                self.responseHeader = dict["ResponseHeader"] as! Int64
            }
            if dict.keys.contains("SlowElementThreshold") {
                self.slowElementThreshold = dict["SlowElementThreshold"] as! Double
            }
            if dict.keys.contains("VerifyStringBlacklist") {
                self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
            }
            if dict.keys.contains("VerifyStringWhiteList") {
                self.verifyStringWhiteList = dict["VerifyStringWhiteList"] as! String
            }
            if dict.keys.contains("WaitCompletionTime") {
                self.waitCompletionTime = dict["WaitCompletionTime"] as! Double
            }
        }
    }
    public class Net : Tea.TeaModel {
        public var netDNSNs: String?

        public var netDNSQueryMethod: Int64?

        public var netDNSServer: Int64?

        public var netDNSSwitch: Int64?

        public var netDNSTimeout: Int64?

        public var netDigSwitch: Int64?

        public var netICMPActive: Int64?

        public var netICMPDataCut: Int64?

        public var netICMPInterval: Int64?

        public var netICMPNum: Int64?

        public var netICMPSize: Int64?

        public var netICMPSwitch: Int64?

        public var netICMPTimeout: Int64?

        public var netTraceRouteNum: Int64?

        public var netTraceRouteSwitch: Int64?

        public var netTraceRouteTimeout: Int64?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.netDNSNs != nil {
                map["NetDNSNs"] = self.netDNSNs!
            }
            if self.netDNSQueryMethod != nil {
                map["NetDNSQueryMethod"] = self.netDNSQueryMethod!
            }
            if self.netDNSServer != nil {
                map["NetDNSServer"] = self.netDNSServer!
            }
            if self.netDNSSwitch != nil {
                map["NetDNSSwitch"] = self.netDNSSwitch!
            }
            if self.netDNSTimeout != nil {
                map["NetDNSTimeout"] = self.netDNSTimeout!
            }
            if self.netDigSwitch != nil {
                map["NetDigSwitch"] = self.netDigSwitch!
            }
            if self.netICMPActive != nil {
                map["NetICMPActive"] = self.netICMPActive!
            }
            if self.netICMPDataCut != nil {
                map["NetICMPDataCut"] = self.netICMPDataCut!
            }
            if self.netICMPInterval != nil {
                map["NetICMPInterval"] = self.netICMPInterval!
            }
            if self.netICMPNum != nil {
                map["NetICMPNum"] = self.netICMPNum!
            }
            if self.netICMPSize != nil {
                map["NetICMPSize"] = self.netICMPSize!
            }
            if self.netICMPSwitch != nil {
                map["NetICMPSwitch"] = self.netICMPSwitch!
            }
            if self.netICMPTimeout != nil {
                map["NetICMPTimeout"] = self.netICMPTimeout!
            }
            if self.netTraceRouteNum != nil {
                map["NetTraceRouteNum"] = self.netTraceRouteNum!
            }
            if self.netTraceRouteSwitch != nil {
                map["NetTraceRouteSwitch"] = self.netTraceRouteSwitch!
            }
            if self.netTraceRouteTimeout != nil {
                map["NetTraceRouteTimeout"] = self.netTraceRouteTimeout!
            }
            if self.whiteList != nil {
                map["WhiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetDNSNs") {
                self.netDNSNs = dict["NetDNSNs"] as! String
            }
            if dict.keys.contains("NetDNSQueryMethod") {
                self.netDNSQueryMethod = dict["NetDNSQueryMethod"] as! Int64
            }
            if dict.keys.contains("NetDNSServer") {
                self.netDNSServer = dict["NetDNSServer"] as! Int64
            }
            if dict.keys.contains("NetDNSSwitch") {
                self.netDNSSwitch = dict["NetDNSSwitch"] as! Int64
            }
            if dict.keys.contains("NetDNSTimeout") {
                self.netDNSTimeout = dict["NetDNSTimeout"] as! Int64
            }
            if dict.keys.contains("NetDigSwitch") {
                self.netDigSwitch = dict["NetDigSwitch"] as! Int64
            }
            if dict.keys.contains("NetICMPActive") {
                self.netICMPActive = dict["NetICMPActive"] as! Int64
            }
            if dict.keys.contains("NetICMPDataCut") {
                self.netICMPDataCut = dict["NetICMPDataCut"] as! Int64
            }
            if dict.keys.contains("NetICMPInterval") {
                self.netICMPInterval = dict["NetICMPInterval"] as! Int64
            }
            if dict.keys.contains("NetICMPNum") {
                self.netICMPNum = dict["NetICMPNum"] as! Int64
            }
            if dict.keys.contains("NetICMPSize") {
                self.netICMPSize = dict["NetICMPSize"] as! Int64
            }
            if dict.keys.contains("NetICMPSwitch") {
                self.netICMPSwitch = dict["NetICMPSwitch"] as! Int64
            }
            if dict.keys.contains("NetICMPTimeout") {
                self.netICMPTimeout = dict["NetICMPTimeout"] as! Int64
            }
            if dict.keys.contains("NetTraceRouteNum") {
                self.netTraceRouteNum = dict["NetTraceRouteNum"] as! Int64
            }
            if dict.keys.contains("NetTraceRouteSwitch") {
                self.netTraceRouteSwitch = dict["NetTraceRouteSwitch"] as! Int64
            }
            if dict.keys.contains("NetTraceRouteTimeout") {
                self.netTraceRouteTimeout = dict["NetTraceRouteTimeout"] as! Int64
            }
            if dict.keys.contains("WhiteList") {
                self.whiteList = dict["WhiteList"] as! String
            }
        }
    }
    public class Protocol_ : Tea.TeaModel {
        public class RequestContent : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public class FormData : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class UrlEncoding : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var formData: [CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.FormData]?

                public var language: String?

                public var mode: String?

                public var raw: String?

                public var urlEncoding: [CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.UrlEncoding]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.formData != nil {
                        var tmp : [Any] = []
                        for k in self.formData! {
                            tmp.append(k.toMap())
                        }
                        map["FormData"] = tmp
                    }
                    if self.language != nil {
                        map["Language"] = self.language!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.raw != nil {
                        map["Raw"] = self.raw!
                    }
                    if self.urlEncoding != nil {
                        var tmp : [Any] = []
                        for k in self.urlEncoding! {
                            tmp.append(k.toMap())
                        }
                        map["UrlEncoding"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FormData") {
                        var tmp : [CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.FormData] = []
                        for v in dict["FormData"] as! [Any] {
                            var model = CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.FormData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.formData = tmp
                    }
                    if dict.keys.contains("Language") {
                        self.language = dict["Language"] as! String
                    }
                    if dict.keys.contains("Mode") {
                        self.mode = dict["Mode"] as! String
                    }
                    if dict.keys.contains("Raw") {
                        self.raw = dict["Raw"] as! String
                    }
                    if dict.keys.contains("UrlEncoding") {
                        var tmp : [CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.UrlEncoding] = []
                        for v in dict["UrlEncoding"] as! [Any] {
                            var model = CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.UrlEncoding()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.urlEncoding = tmp
                    }
                }
            }
            public class Header : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: CreateSyntheticTaskRequest.Protocol_.RequestContent.Body?

            public var header: [CreateSyntheticTaskRequest.Protocol_.RequestContent.Header]?

            public var method: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.header != nil {
                    var tmp : [Any] = []
                    for k in self.header! {
                        tmp.append(k.toMap())
                    }
                    map["Header"] = tmp
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    var model = CreateSyntheticTaskRequest.Protocol_.RequestContent.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("Header") {
                    var tmp : [CreateSyntheticTaskRequest.Protocol_.RequestContent.Header] = []
                    for v in dict["Header"] as! [Any] {
                        var model = CreateSyntheticTaskRequest.Protocol_.RequestContent.Header()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.header = tmp
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
            }
        }
        public var characterEncoding: Int64?

        public var customHost: Int64?

        public var customHostIp: String?

        public var protocolConnectionTime: Int64?

        public var protocolMonitorTimeout: String?

        public var receivedDataSize: Int64?

        public var requestContent: CreateSyntheticTaskRequest.Protocol_.RequestContent?

        public var verifyContent: String?

        public var verifyWay: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.requestContent?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.characterEncoding != nil {
                map["CharacterEncoding"] = self.characterEncoding!
            }
            if self.customHost != nil {
                map["CustomHost"] = self.customHost!
            }
            if self.customHostIp != nil {
                map["CustomHostIp"] = self.customHostIp!
            }
            if self.protocolConnectionTime != nil {
                map["ProtocolConnectionTime"] = self.protocolConnectionTime!
            }
            if self.protocolMonitorTimeout != nil {
                map["ProtocolMonitorTimeout"] = self.protocolMonitorTimeout!
            }
            if self.receivedDataSize != nil {
                map["ReceivedDataSize"] = self.receivedDataSize!
            }
            if self.requestContent != nil {
                map["RequestContent"] = self.requestContent?.toMap()
            }
            if self.verifyContent != nil {
                map["VerifyContent"] = self.verifyContent!
            }
            if self.verifyWay != nil {
                map["VerifyWay"] = self.verifyWay!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CharacterEncoding") {
                self.characterEncoding = dict["CharacterEncoding"] as! Int64
            }
            if dict.keys.contains("CustomHost") {
                self.customHost = dict["CustomHost"] as! Int64
            }
            if dict.keys.contains("CustomHostIp") {
                self.customHostIp = dict["CustomHostIp"] as! String
            }
            if dict.keys.contains("ProtocolConnectionTime") {
                self.protocolConnectionTime = dict["ProtocolConnectionTime"] as! Int64
            }
            if dict.keys.contains("ProtocolMonitorTimeout") {
                self.protocolMonitorTimeout = dict["ProtocolMonitorTimeout"] as! String
            }
            if dict.keys.contains("ReceivedDataSize") {
                self.receivedDataSize = dict["ReceivedDataSize"] as! Int64
            }
            if dict.keys.contains("RequestContent") {
                var model = CreateSyntheticTaskRequest.Protocol_.RequestContent()
                model.fromMap(dict["RequestContent"] as! [String: Any])
                self.requestContent = model
            }
            if dict.keys.contains("VerifyContent") {
                self.verifyContent = dict["VerifyContent"] as! String
            }
            if dict.keys.contains("VerifyWay") {
                self.verifyWay = dict["VerifyWay"] as! Int64
            }
        }
    }
    public var commonParam: CreateSyntheticTaskRequest.CommonParam?

    public var download: CreateSyntheticTaskRequest.Download?

    public var extendInterval: CreateSyntheticTaskRequest.ExtendInterval?

    public var intervalTime: String?

    public var intervalType: String?

    public var ipType: Int64?

    public var monitorList: [CreateSyntheticTaskRequest.MonitorList]?

    public var navigation: CreateSyntheticTaskRequest.Navigation?

    public var net: CreateSyntheticTaskRequest.Net?

    public var protocol_: CreateSyntheticTaskRequest.Protocol_?

    public var regionId: String?

    public var taskName: String?

    public var taskType: Int64?

    public var updateTask: Bool?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonParam?.validate()
        try self.download?.validate()
        try self.extendInterval?.validate()
        try self.navigation?.validate()
        try self.net?.validate()
        try self.protocol_?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonParam != nil {
            map["CommonParam"] = self.commonParam?.toMap()
        }
        if self.download != nil {
            map["Download"] = self.download?.toMap()
        }
        if self.extendInterval != nil {
            map["ExtendInterval"] = self.extendInterval?.toMap()
        }
        if self.intervalTime != nil {
            map["IntervalTime"] = self.intervalTime!
        }
        if self.intervalType != nil {
            map["IntervalType"] = self.intervalType!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.monitorList != nil {
            var tmp : [Any] = []
            for k in self.monitorList! {
                tmp.append(k.toMap())
            }
            map["MonitorList"] = tmp
        }
        if self.navigation != nil {
            map["Navigation"] = self.navigation?.toMap()
        }
        if self.net != nil {
            map["Net"] = self.net?.toMap()
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.updateTask != nil {
            map["UpdateTask"] = self.updateTask!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommonParam") {
            var model = CreateSyntheticTaskRequest.CommonParam()
            model.fromMap(dict["CommonParam"] as! [String: Any])
            self.commonParam = model
        }
        if dict.keys.contains("Download") {
            var model = CreateSyntheticTaskRequest.Download()
            model.fromMap(dict["Download"] as! [String: Any])
            self.download = model
        }
        if dict.keys.contains("ExtendInterval") {
            var model = CreateSyntheticTaskRequest.ExtendInterval()
            model.fromMap(dict["ExtendInterval"] as! [String: Any])
            self.extendInterval = model
        }
        if dict.keys.contains("IntervalTime") {
            self.intervalTime = dict["IntervalTime"] as! String
        }
        if dict.keys.contains("IntervalType") {
            self.intervalType = dict["IntervalType"] as! String
        }
        if dict.keys.contains("IpType") {
            self.ipType = dict["IpType"] as! Int64
        }
        if dict.keys.contains("MonitorList") {
            var tmp : [CreateSyntheticTaskRequest.MonitorList] = []
            for v in dict["MonitorList"] as! [Any] {
                var model = CreateSyntheticTaskRequest.MonitorList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.monitorList = tmp
        }
        if dict.keys.contains("Navigation") {
            var model = CreateSyntheticTaskRequest.Navigation()
            model.fromMap(dict["Navigation"] as! [String: Any])
            self.navigation = model
        }
        if dict.keys.contains("Net") {
            var model = CreateSyntheticTaskRequest.Net()
            model.fromMap(dict["Net"] as! [String: Any])
            self.net = model
        }
        if dict.keys.contains("Protocol") {
            var model = CreateSyntheticTaskRequest.Protocol_()
            model.fromMap(dict["Protocol"] as! [String: Any])
            self.protocol_ = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! Int64
        }
        if dict.keys.contains("UpdateTask") {
            self.updateTask = dict["UpdateTask"] as! Bool
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class CreateSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var commonParamShrink: String?

    public var downloadShrink: String?

    public var extendIntervalShrink: String?

    public var intervalTime: String?

    public var intervalType: String?

    public var ipType: Int64?

    public var monitorListShrink: String?

    public var navigationShrink: String?

    public var netShrink: String?

    public var protocolShrink: String?

    public var regionId: String?

    public var taskName: String?

    public var taskType: Int64?

    public var updateTask: Bool?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonParamShrink != nil {
            map["CommonParam"] = self.commonParamShrink!
        }
        if self.downloadShrink != nil {
            map["Download"] = self.downloadShrink!
        }
        if self.extendIntervalShrink != nil {
            map["ExtendInterval"] = self.extendIntervalShrink!
        }
        if self.intervalTime != nil {
            map["IntervalTime"] = self.intervalTime!
        }
        if self.intervalType != nil {
            map["IntervalType"] = self.intervalType!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.monitorListShrink != nil {
            map["MonitorList"] = self.monitorListShrink!
        }
        if self.navigationShrink != nil {
            map["Navigation"] = self.navigationShrink!
        }
        if self.netShrink != nil {
            map["Net"] = self.netShrink!
        }
        if self.protocolShrink != nil {
            map["Protocol"] = self.protocolShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.updateTask != nil {
            map["UpdateTask"] = self.updateTask!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommonParam") {
            self.commonParamShrink = dict["CommonParam"] as! String
        }
        if dict.keys.contains("Download") {
            self.downloadShrink = dict["Download"] as! String
        }
        if dict.keys.contains("ExtendInterval") {
            self.extendIntervalShrink = dict["ExtendInterval"] as! String
        }
        if dict.keys.contains("IntervalTime") {
            self.intervalTime = dict["IntervalTime"] as! String
        }
        if dict.keys.contains("IntervalType") {
            self.intervalType = dict["IntervalType"] as! String
        }
        if dict.keys.contains("IpType") {
            self.ipType = dict["IpType"] as! Int64
        }
        if dict.keys.contains("MonitorList") {
            self.monitorListShrink = dict["MonitorList"] as! String
        }
        if dict.keys.contains("Navigation") {
            self.navigationShrink = dict["Navigation"] as! String
        }
        if dict.keys.contains("Net") {
            self.netShrink = dict["Net"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocolShrink = dict["Protocol"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! Int64
        }
        if dict.keys.contains("UpdateTask") {
            self.updateTask = dict["UpdateTask"] as! Bool
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class CreateSyntheticTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: CreateSyntheticTaskResponseBody.Data?

    public var msg: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateSyntheticTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Msg") {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTimingSyntheticTaskRequest : Tea.TeaModel {
    public class AvailableAssertions : Tea.TeaModel {
        public var expect: String?

        public var operator_: String?

        public var target: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expect != nil {
                map["Expect"] = self.expect!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Expect") {
                self.expect = dict["Expect"] as! String
            }
            if dict.keys.contains("Operator") {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Target") {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class CommonSetting : Tea.TeaModel {
        public class CustomHost : Tea.TeaModel {
            public class Hosts : Tea.TeaModel {
                public var domain: String?

                public var ipType: Int32?

                public var ips: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.domain != nil {
                        map["Domain"] = self.domain!
                    }
                    if self.ipType != nil {
                        map["IpType"] = self.ipType!
                    }
                    if self.ips != nil {
                        map["Ips"] = self.ips!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Domain") {
                        self.domain = dict["Domain"] as! String
                    }
                    if dict.keys.contains("IpType") {
                        self.ipType = dict["IpType"] as! Int32
                    }
                    if dict.keys.contains("Ips") {
                        self.ips = dict["Ips"] as! [String]
                    }
                }
            }
            public var hosts: [CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts]?

            public var selectType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hosts != nil {
                    var tmp : [Any] = []
                    for k in self.hosts! {
                        tmp.append(k.toMap())
                    }
                    map["Hosts"] = tmp
                }
                if self.selectType != nil {
                    map["SelectType"] = self.selectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Hosts") {
                    var tmp : [CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts] = []
                    for v in dict["Hosts"] as! [Any] {
                        var model = CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.hosts = tmp
                }
                if dict.keys.contains("SelectType") {
                    self.selectType = dict["SelectType"] as! Int32
                }
            }
        }
        public class CustomPrometheusSetting : Tea.TeaModel {
            public var prometheusClusterId: String?

            public var prometheusClusterRegion: String?

            public var prometheusLabels: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.prometheusClusterId != nil {
                    map["PrometheusClusterId"] = self.prometheusClusterId!
                }
                if self.prometheusClusterRegion != nil {
                    map["PrometheusClusterRegion"] = self.prometheusClusterRegion!
                }
                if self.prometheusLabels != nil {
                    map["PrometheusLabels"] = self.prometheusLabels!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PrometheusClusterId") {
                    self.prometheusClusterId = dict["PrometheusClusterId"] as! String
                }
                if dict.keys.contains("PrometheusClusterRegion") {
                    self.prometheusClusterRegion = dict["PrometheusClusterRegion"] as! String
                }
                if dict.keys.contains("PrometheusLabels") {
                    self.prometheusLabels = dict["PrometheusLabels"] as! [String: String]
                }
            }
        }
        public class CustomVPCSetting : Tea.TeaModel {
            public var regionId: String?

            public var secureGroupId: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.secureGroupId != nil {
                    map["SecureGroupId"] = self.secureGroupId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SecureGroupId") {
                    self.secureGroupId = dict["SecureGroupId"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var customHost: CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost?

        public var customPrometheusSetting: CreateTimingSyntheticTaskRequest.CommonSetting.CustomPrometheusSetting?

        public var customVPCSetting: CreateTimingSyntheticTaskRequest.CommonSetting.CustomVPCSetting?

        public var ipType: Int32?

        public var isOpenTrace: Bool?

        public var monitorSamples: Int32?

        public var traceClientType: Int32?

        public var xtraceRegion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customHost?.validate()
            try self.customPrometheusSetting?.validate()
            try self.customVPCSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customHost != nil {
                map["CustomHost"] = self.customHost?.toMap()
            }
            if self.customPrometheusSetting != nil {
                map["CustomPrometheusSetting"] = self.customPrometheusSetting?.toMap()
            }
            if self.customVPCSetting != nil {
                map["CustomVPCSetting"] = self.customVPCSetting?.toMap()
            }
            if self.ipType != nil {
                map["IpType"] = self.ipType!
            }
            if self.isOpenTrace != nil {
                map["IsOpenTrace"] = self.isOpenTrace!
            }
            if self.monitorSamples != nil {
                map["MonitorSamples"] = self.monitorSamples!
            }
            if self.traceClientType != nil {
                map["TraceClientType"] = self.traceClientType!
            }
            if self.xtraceRegion != nil {
                map["XtraceRegion"] = self.xtraceRegion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomHost") {
                var model = CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost()
                model.fromMap(dict["CustomHost"] as! [String: Any])
                self.customHost = model
            }
            if dict.keys.contains("CustomPrometheusSetting") {
                var model = CreateTimingSyntheticTaskRequest.CommonSetting.CustomPrometheusSetting()
                model.fromMap(dict["CustomPrometheusSetting"] as! [String: Any])
                self.customPrometheusSetting = model
            }
            if dict.keys.contains("CustomVPCSetting") {
                var model = CreateTimingSyntheticTaskRequest.CommonSetting.CustomVPCSetting()
                model.fromMap(dict["CustomVPCSetting"] as! [String: Any])
                self.customVPCSetting = model
            }
            if dict.keys.contains("IpType") {
                self.ipType = dict["IpType"] as! Int32
            }
            if dict.keys.contains("IsOpenTrace") {
                self.isOpenTrace = dict["IsOpenTrace"] as! Bool
            }
            if dict.keys.contains("MonitorSamples") {
                self.monitorSamples = dict["MonitorSamples"] as! Int32
            }
            if dict.keys.contains("TraceClientType") {
                self.traceClientType = dict["TraceClientType"] as! Int32
            }
            if dict.keys.contains("XtraceRegion") {
                self.xtraceRegion = dict["XtraceRegion"] as! String
            }
        }
    }
    public class CustomPeriod : Tea.TeaModel {
        public var endHour: Int32?

        public var startHour: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endHour != nil {
                map["EndHour"] = self.endHour!
            }
            if self.startHour != nil {
                map["StartHour"] = self.startHour!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndHour") {
                self.endHour = dict["EndHour"] as! Int32
            }
            if dict.keys.contains("StartHour") {
                self.startHour = dict["StartHour"] as! Int32
            }
        }
    }
    public class MonitorConf : Tea.TeaModel {
        public class ApiHTTP : Tea.TeaModel {
            public class RequestBody : Tea.TeaModel {
                public var content: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var checkCert: Bool?

            public var connectTimeout: Int64?

            public var method: String?

            public var protocolAlpnProtocol: Int32?

            public var requestBody: CreateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP.RequestBody?

            public var requestHeaders: [String: String]?

            public var targetUrl: String?

            public var timeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.requestBody?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkCert != nil {
                    map["CheckCert"] = self.checkCert!
                }
                if self.connectTimeout != nil {
                    map["ConnectTimeout"] = self.connectTimeout!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.protocolAlpnProtocol != nil {
                    map["ProtocolAlpnProtocol"] = self.protocolAlpnProtocol!
                }
                if self.requestBody != nil {
                    map["RequestBody"] = self.requestBody?.toMap()
                }
                if self.requestHeaders != nil {
                    map["RequestHeaders"] = self.requestHeaders!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckCert") {
                    self.checkCert = dict["CheckCert"] as! Bool
                }
                if dict.keys.contains("ConnectTimeout") {
                    self.connectTimeout = dict["ConnectTimeout"] as! Int64
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("ProtocolAlpnProtocol") {
                    self.protocolAlpnProtocol = dict["ProtocolAlpnProtocol"] as! Int32
                }
                if dict.keys.contains("RequestBody") {
                    var model = CreateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP.RequestBody()
                    model.fromMap(dict["RequestBody"] as! [String: Any])
                    self.requestBody = model
                }
                if dict.keys.contains("RequestHeaders") {
                    self.requestHeaders = dict["RequestHeaders"] as! [String: String]
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
            }
        }
        public class FileDownload : Tea.TeaModel {
            public var connectionTimeout: Int64?

            public var customHeaderContent: [String: String]?

            public var downloadKernel: Int32?

            public var ignoreCertificateAuthError: Int32?

            public var ignoreCertificateCanceledError: Int32?

            public var ignoreCertificateOutOfDateError: Int32?

            public var ignoreCertificateStatusError: Int32?

            public var ignoreCertificateUntrustworthyError: Int32?

            public var ignoreCertificateUsingError: Int32?

            public var ignoreInvalidHostError: Int32?

            public var monitorTimeout: Int64?

            public var quickProtocol: Int32?

            public var redirection: Int32?

            public var targetUrl: String?

            public var transmissionSize: Int64?

            public var validateKeywords: String?

            public var verifyWay: Int32?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectionTimeout != nil {
                    map["ConnectionTimeout"] = self.connectionTimeout!
                }
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.downloadKernel != nil {
                    map["DownloadKernel"] = self.downloadKernel!
                }
                if self.ignoreCertificateAuthError != nil {
                    map["IgnoreCertificateAuthError"] = self.ignoreCertificateAuthError!
                }
                if self.ignoreCertificateCanceledError != nil {
                    map["IgnoreCertificateCanceledError"] = self.ignoreCertificateCanceledError!
                }
                if self.ignoreCertificateOutOfDateError != nil {
                    map["IgnoreCertificateOutOfDateError"] = self.ignoreCertificateOutOfDateError!
                }
                if self.ignoreCertificateStatusError != nil {
                    map["IgnoreCertificateStatusError"] = self.ignoreCertificateStatusError!
                }
                if self.ignoreCertificateUntrustworthyError != nil {
                    map["IgnoreCertificateUntrustworthyError"] = self.ignoreCertificateUntrustworthyError!
                }
                if self.ignoreCertificateUsingError != nil {
                    map["IgnoreCertificateUsingError"] = self.ignoreCertificateUsingError!
                }
                if self.ignoreInvalidHostError != nil {
                    map["IgnoreInvalidHostError"] = self.ignoreInvalidHostError!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.quickProtocol != nil {
                    map["QuickProtocol"] = self.quickProtocol!
                }
                if self.redirection != nil {
                    map["Redirection"] = self.redirection!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.transmissionSize != nil {
                    map["TransmissionSize"] = self.transmissionSize!
                }
                if self.validateKeywords != nil {
                    map["ValidateKeywords"] = self.validateKeywords!
                }
                if self.verifyWay != nil {
                    map["VerifyWay"] = self.verifyWay!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectionTimeout") {
                    self.connectionTimeout = dict["ConnectionTimeout"] as! Int64
                }
                if dict.keys.contains("CustomHeaderContent") {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("DownloadKernel") {
                    self.downloadKernel = dict["DownloadKernel"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateAuthError") {
                    self.ignoreCertificateAuthError = dict["IgnoreCertificateAuthError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateCanceledError") {
                    self.ignoreCertificateCanceledError = dict["IgnoreCertificateCanceledError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateOutOfDateError") {
                    self.ignoreCertificateOutOfDateError = dict["IgnoreCertificateOutOfDateError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateStatusError") {
                    self.ignoreCertificateStatusError = dict["IgnoreCertificateStatusError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateUntrustworthyError") {
                    self.ignoreCertificateUntrustworthyError = dict["IgnoreCertificateUntrustworthyError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateUsingError") {
                    self.ignoreCertificateUsingError = dict["IgnoreCertificateUsingError"] as! Int32
                }
                if dict.keys.contains("IgnoreInvalidHostError") {
                    self.ignoreInvalidHostError = dict["IgnoreInvalidHostError"] as! Int32
                }
                if dict.keys.contains("MonitorTimeout") {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("QuickProtocol") {
                    self.quickProtocol = dict["QuickProtocol"] as! Int32
                }
                if dict.keys.contains("Redirection") {
                    self.redirection = dict["Redirection"] as! Int32
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("TransmissionSize") {
                    self.transmissionSize = dict["TransmissionSize"] as! Int64
                }
                if dict.keys.contains("ValidateKeywords") {
                    self.validateKeywords = dict["ValidateKeywords"] as! String
                }
                if dict.keys.contains("VerifyWay") {
                    self.verifyWay = dict["VerifyWay"] as! Int32
                }
                if dict.keys.contains("WhiteList") {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class NetDNS : Tea.TeaModel {
            public var dnsServerIpType: Int32?

            public var nsServer: String?

            public var queryMethod: Int32?

            public var targetUrl: String?

            public var timeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dnsServerIpType != nil {
                    map["DnsServerIpType"] = self.dnsServerIpType!
                }
                if self.nsServer != nil {
                    map["NsServer"] = self.nsServer!
                }
                if self.queryMethod != nil {
                    map["QueryMethod"] = self.queryMethod!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DnsServerIpType") {
                    self.dnsServerIpType = dict["DnsServerIpType"] as! Int32
                }
                if dict.keys.contains("NsServer") {
                    self.nsServer = dict["NsServer"] as! String
                }
                if dict.keys.contains("QueryMethod") {
                    self.queryMethod = dict["QueryMethod"] as! Int32
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
            }
        }
        public class NetICMP : Tea.TeaModel {
            public var interval: Int64?

            public var packageNum: Int32?

            public var packageSize: Int32?

            public var splitPackage: Bool?

            public var targetUrl: String?

            public var timeout: Int64?

            public var tracertEnable: Bool?

            public var tracertNumMax: Int32?

            public var tracertTimeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.packageNum != nil {
                    map["PackageNum"] = self.packageNum!
                }
                if self.packageSize != nil {
                    map["PackageSize"] = self.packageSize!
                }
                if self.splitPackage != nil {
                    map["SplitPackage"] = self.splitPackage!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.tracertEnable != nil {
                    map["TracertEnable"] = self.tracertEnable!
                }
                if self.tracertNumMax != nil {
                    map["TracertNumMax"] = self.tracertNumMax!
                }
                if self.tracertTimeout != nil {
                    map["TracertTimeout"] = self.tracertTimeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("PackageNum") {
                    self.packageNum = dict["PackageNum"] as! Int32
                }
                if dict.keys.contains("PackageSize") {
                    self.packageSize = dict["PackageSize"] as! Int32
                }
                if dict.keys.contains("SplitPackage") {
                    self.splitPackage = dict["SplitPackage"] as! Bool
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("TracertEnable") {
                    self.tracertEnable = dict["TracertEnable"] as! Bool
                }
                if dict.keys.contains("TracertNumMax") {
                    self.tracertNumMax = dict["TracertNumMax"] as! Int32
                }
                if dict.keys.contains("TracertTimeout") {
                    self.tracertTimeout = dict["TracertTimeout"] as! Int64
                }
            }
        }
        public class NetTCP : Tea.TeaModel {
            public var connectTimes: Int32?

            public var interval: Int64?

            public var targetUrl: String?

            public var timeout: Int64?

            public var tracertEnable: Bool?

            public var tracertNumMax: Int32?

            public var tracertTimeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectTimes != nil {
                    map["ConnectTimes"] = self.connectTimes!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.tracertEnable != nil {
                    map["TracertEnable"] = self.tracertEnable!
                }
                if self.tracertNumMax != nil {
                    map["TracertNumMax"] = self.tracertNumMax!
                }
                if self.tracertTimeout != nil {
                    map["TracertTimeout"] = self.tracertTimeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectTimes") {
                    self.connectTimes = dict["ConnectTimes"] as! Int32
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("TracertEnable") {
                    self.tracertEnable = dict["TracertEnable"] as! Bool
                }
                if dict.keys.contains("TracertNumMax") {
                    self.tracertNumMax = dict["TracertNumMax"] as! Int32
                }
                if dict.keys.contains("TracertTimeout") {
                    self.tracertTimeout = dict["TracertTimeout"] as! Int64
                }
            }
        }
        public class Stream : Tea.TeaModel {
            public var customHeaderContent: [String: String]?

            public var playerType: Int32?

            public var streamAddressType: Int32?

            public var streamMonitorTimeout: Int32?

            public var streamType: Int32?

            public var targetUrl: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.playerType != nil {
                    map["PlayerType"] = self.playerType!
                }
                if self.streamAddressType != nil {
                    map["StreamAddressType"] = self.streamAddressType!
                }
                if self.streamMonitorTimeout != nil {
                    map["StreamMonitorTimeout"] = self.streamMonitorTimeout!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomHeaderContent") {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("PlayerType") {
                    self.playerType = dict["PlayerType"] as! Int32
                }
                if dict.keys.contains("StreamAddressType") {
                    self.streamAddressType = dict["StreamAddressType"] as! Int32
                }
                if dict.keys.contains("StreamMonitorTimeout") {
                    self.streamMonitorTimeout = dict["StreamMonitorTimeout"] as! Int32
                }
                if dict.keys.contains("StreamType") {
                    self.streamType = dict["StreamType"] as! Int32
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("WhiteList") {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class Website : Tea.TeaModel {
            public var automaticScrolling: Int32?

            public var customHeader: Int32?

            public var customHeaderContent: [String: String]?

            public var DNSHijackWhitelist: String?

            public var disableCache: Int32?

            public var disableCompression: Int32?

            public var elementBlacklist: String?

            public var filterInvalidIP: Int32?

            public var flowHijackJumpTimes: Int32?

            public var flowHijackLogo: String?

            public var ignoreCertificateError: Int32?

            public var monitorTimeout: Int64?

            public var pageTamper: String?

            public var redirection: Int32?

            public var slowElementThreshold: Int64?

            public var targetUrl: String?

            public var verifyStringBlacklist: String?

            public var verifyStringWhitelist: String?

            public var waitCompletionTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.automaticScrolling != nil {
                    map["AutomaticScrolling"] = self.automaticScrolling!
                }
                if self.customHeader != nil {
                    map["CustomHeader"] = self.customHeader!
                }
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.DNSHijackWhitelist != nil {
                    map["DNSHijackWhitelist"] = self.DNSHijackWhitelist!
                }
                if self.disableCache != nil {
                    map["DisableCache"] = self.disableCache!
                }
                if self.disableCompression != nil {
                    map["DisableCompression"] = self.disableCompression!
                }
                if self.elementBlacklist != nil {
                    map["ElementBlacklist"] = self.elementBlacklist!
                }
                if self.filterInvalidIP != nil {
                    map["FilterInvalidIP"] = self.filterInvalidIP!
                }
                if self.flowHijackJumpTimes != nil {
                    map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
                }
                if self.flowHijackLogo != nil {
                    map["FlowHijackLogo"] = self.flowHijackLogo!
                }
                if self.ignoreCertificateError != nil {
                    map["IgnoreCertificateError"] = self.ignoreCertificateError!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.pageTamper != nil {
                    map["PageTamper"] = self.pageTamper!
                }
                if self.redirection != nil {
                    map["Redirection"] = self.redirection!
                }
                if self.slowElementThreshold != nil {
                    map["SlowElementThreshold"] = self.slowElementThreshold!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.verifyStringBlacklist != nil {
                    map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
                }
                if self.verifyStringWhitelist != nil {
                    map["VerifyStringWhitelist"] = self.verifyStringWhitelist!
                }
                if self.waitCompletionTime != nil {
                    map["WaitCompletionTime"] = self.waitCompletionTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutomaticScrolling") {
                    self.automaticScrolling = dict["AutomaticScrolling"] as! Int32
                }
                if dict.keys.contains("CustomHeader") {
                    self.customHeader = dict["CustomHeader"] as! Int32
                }
                if dict.keys.contains("CustomHeaderContent") {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("DNSHijackWhitelist") {
                    self.DNSHijackWhitelist = dict["DNSHijackWhitelist"] as! String
                }
                if dict.keys.contains("DisableCache") {
                    self.disableCache = dict["DisableCache"] as! Int32
                }
                if dict.keys.contains("DisableCompression") {
                    self.disableCompression = dict["DisableCompression"] as! Int32
                }
                if dict.keys.contains("ElementBlacklist") {
                    self.elementBlacklist = dict["ElementBlacklist"] as! String
                }
                if dict.keys.contains("FilterInvalidIP") {
                    self.filterInvalidIP = dict["FilterInvalidIP"] as! Int32
                }
                if dict.keys.contains("FlowHijackJumpTimes") {
                    self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int32
                }
                if dict.keys.contains("FlowHijackLogo") {
                    self.flowHijackLogo = dict["FlowHijackLogo"] as! String
                }
                if dict.keys.contains("IgnoreCertificateError") {
                    self.ignoreCertificateError = dict["IgnoreCertificateError"] as! Int32
                }
                if dict.keys.contains("MonitorTimeout") {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("PageTamper") {
                    self.pageTamper = dict["PageTamper"] as! String
                }
                if dict.keys.contains("Redirection") {
                    self.redirection = dict["Redirection"] as! Int32
                }
                if dict.keys.contains("SlowElementThreshold") {
                    self.slowElementThreshold = dict["SlowElementThreshold"] as! Int64
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("VerifyStringBlacklist") {
                    self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
                }
                if dict.keys.contains("VerifyStringWhitelist") {
                    self.verifyStringWhitelist = dict["VerifyStringWhitelist"] as! String
                }
                if dict.keys.contains("WaitCompletionTime") {
                    self.waitCompletionTime = dict["WaitCompletionTime"] as! Int64
                }
            }
        }
        public var apiHTTP: CreateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP?

        public var fileDownload: CreateTimingSyntheticTaskRequest.MonitorConf.FileDownload?

        public var netDNS: CreateTimingSyntheticTaskRequest.MonitorConf.NetDNS?

        public var netICMP: CreateTimingSyntheticTaskRequest.MonitorConf.NetICMP?

        public var netTCP: CreateTimingSyntheticTaskRequest.MonitorConf.NetTCP?

        public var stream: CreateTimingSyntheticTaskRequest.MonitorConf.Stream?

        public var website: CreateTimingSyntheticTaskRequest.MonitorConf.Website?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.apiHTTP?.validate()
            try self.fileDownload?.validate()
            try self.netDNS?.validate()
            try self.netICMP?.validate()
            try self.netTCP?.validate()
            try self.stream?.validate()
            try self.website?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiHTTP != nil {
                map["ApiHTTP"] = self.apiHTTP?.toMap()
            }
            if self.fileDownload != nil {
                map["FileDownload"] = self.fileDownload?.toMap()
            }
            if self.netDNS != nil {
                map["NetDNS"] = self.netDNS?.toMap()
            }
            if self.netICMP != nil {
                map["NetICMP"] = self.netICMP?.toMap()
            }
            if self.netTCP != nil {
                map["NetTCP"] = self.netTCP?.toMap()
            }
            if self.stream != nil {
                map["Stream"] = self.stream?.toMap()
            }
            if self.website != nil {
                map["Website"] = self.website?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiHTTP") {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP()
                model.fromMap(dict["ApiHTTP"] as! [String: Any])
                self.apiHTTP = model
            }
            if dict.keys.contains("FileDownload") {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.FileDownload()
                model.fromMap(dict["FileDownload"] as! [String: Any])
                self.fileDownload = model
            }
            if dict.keys.contains("NetDNS") {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.NetDNS()
                model.fromMap(dict["NetDNS"] as! [String: Any])
                self.netDNS = model
            }
            if dict.keys.contains("NetICMP") {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.NetICMP()
                model.fromMap(dict["NetICMP"] as! [String: Any])
                self.netICMP = model
            }
            if dict.keys.contains("NetTCP") {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.NetTCP()
                model.fromMap(dict["NetTCP"] as! [String: Any])
                self.netTCP = model
            }
            if dict.keys.contains("Stream") {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.Stream()
                model.fromMap(dict["Stream"] as! [String: Any])
                self.stream = model
            }
            if dict.keys.contains("Website") {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.Website()
                model.fromMap(dict["Website"] as! [String: Any])
                self.website = model
            }
        }
    }
    public class Monitors : Tea.TeaModel {
        public var cityCode: String?

        public var clientType: Int32?

        public var operatorCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.operatorCode != nil {
                map["OperatorCode"] = self.operatorCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("ClientType") {
                self.clientType = dict["ClientType"] as! Int32
            }
            if dict.keys.contains("OperatorCode") {
                self.operatorCode = dict["OperatorCode"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var availableAssertions: [CreateTimingSyntheticTaskRequest.AvailableAssertions]?

    public var commonSetting: CreateTimingSyntheticTaskRequest.CommonSetting?

    public var customPeriod: CreateTimingSyntheticTaskRequest.CustomPeriod?

    public var frequency: String?

    public var monitorCategory: Int32?

    public var monitorConf: CreateTimingSyntheticTaskRequest.MonitorConf?

    public var monitors: [CreateTimingSyntheticTaskRequest.Monitors]?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [CreateTimingSyntheticTaskRequest.Tags]?

    public var taskType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonSetting?.validate()
        try self.customPeriod?.validate()
        try self.monitorConf?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAssertions != nil {
            var tmp : [Any] = []
            for k in self.availableAssertions! {
                tmp.append(k.toMap())
            }
            map["AvailableAssertions"] = tmp
        }
        if self.commonSetting != nil {
            map["CommonSetting"] = self.commonSetting?.toMap()
        }
        if self.customPeriod != nil {
            map["CustomPeriod"] = self.customPeriod?.toMap()
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.monitorCategory != nil {
            map["MonitorCategory"] = self.monitorCategory!
        }
        if self.monitorConf != nil {
            map["MonitorConf"] = self.monitorConf?.toMap()
        }
        if self.monitors != nil {
            var tmp : [Any] = []
            for k in self.monitors! {
                tmp.append(k.toMap())
            }
            map["Monitors"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAssertions") {
            var tmp : [CreateTimingSyntheticTaskRequest.AvailableAssertions] = []
            for v in dict["AvailableAssertions"] as! [Any] {
                var model = CreateTimingSyntheticTaskRequest.AvailableAssertions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.availableAssertions = tmp
        }
        if dict.keys.contains("CommonSetting") {
            var model = CreateTimingSyntheticTaskRequest.CommonSetting()
            model.fromMap(dict["CommonSetting"] as! [String: Any])
            self.commonSetting = model
        }
        if dict.keys.contains("CustomPeriod") {
            var model = CreateTimingSyntheticTaskRequest.CustomPeriod()
            model.fromMap(dict["CustomPeriod"] as! [String: Any])
            self.customPeriod = model
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("MonitorCategory") {
            self.monitorCategory = dict["MonitorCategory"] as! Int32
        }
        if dict.keys.contains("MonitorConf") {
            var model = CreateTimingSyntheticTaskRequest.MonitorConf()
            model.fromMap(dict["MonitorConf"] as! [String: Any])
            self.monitorConf = model
        }
        if dict.keys.contains("Monitors") {
            var tmp : [CreateTimingSyntheticTaskRequest.Monitors] = []
            for v in dict["Monitors"] as! [Any] {
                var model = CreateTimingSyntheticTaskRequest.Monitors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.monitors = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateTimingSyntheticTaskRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateTimingSyntheticTaskRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! Int32
        }
    }
}

public class CreateTimingSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var availableAssertionsShrink: String?

    public var commonSettingShrink: String?

    public var customPeriodShrink: String?

    public var frequency: String?

    public var monitorCategory: Int32?

    public var monitorConfShrink: String?

    public var monitorsShrink: String?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tagsShrink: String?

    public var taskType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAssertionsShrink != nil {
            map["AvailableAssertions"] = self.availableAssertionsShrink!
        }
        if self.commonSettingShrink != nil {
            map["CommonSetting"] = self.commonSettingShrink!
        }
        if self.customPeriodShrink != nil {
            map["CustomPeriod"] = self.customPeriodShrink!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.monitorCategory != nil {
            map["MonitorCategory"] = self.monitorCategory!
        }
        if self.monitorConfShrink != nil {
            map["MonitorConf"] = self.monitorConfShrink!
        }
        if self.monitorsShrink != nil {
            map["Monitors"] = self.monitorsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAssertions") {
            self.availableAssertionsShrink = dict["AvailableAssertions"] as! String
        }
        if dict.keys.contains("CommonSetting") {
            self.commonSettingShrink = dict["CommonSetting"] as! String
        }
        if dict.keys.contains("CustomPeriod") {
            self.customPeriodShrink = dict["CustomPeriod"] as! String
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("MonitorCategory") {
            self.monitorCategory = dict["MonitorCategory"] as! Int32
        }
        if dict.keys.contains("MonitorConf") {
            self.monitorConfShrink = dict["MonitorConf"] as! String
        }
        if dict.keys.contains("Monitors") {
            self.monitorsShrink = dict["Monitors"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! Int32
        }
    }
}

public class CreateTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: CreateTimingSyntheticTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = CreateTimingSyntheticTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWebhookRequest : Tea.TeaModel {
    public var body: String?

    public var contactName: String?

    public var httpHeaders: String?

    public var httpParams: String?

    public var method: String?

    public var recoverBody: String?

    public var regionId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["Body"] = self.body!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.httpHeaders != nil {
            map["HttpHeaders"] = self.httpHeaders!
        }
        if self.httpParams != nil {
            map["HttpParams"] = self.httpParams!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.recoverBody != nil {
            map["RecoverBody"] = self.recoverBody!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Body") {
            self.body = dict["Body"] as! String
        }
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("HttpHeaders") {
            self.httpHeaders = dict["HttpHeaders"] as! String
        }
        if dict.keys.contains("HttpParams") {
            self.httpParams = dict["HttpParams"] as! String
        }
        if dict.keys.contains("Method") {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("RecoverBody") {
            self.recoverBody = dict["RecoverBody"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class CreateWebhookResponseBody : Tea.TeaModel {
    public var contactId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DelAuthTokenRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DelAuthTokenResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DelAuthTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DelAuthTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DelAuthTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAddonReleaseRequest : Tea.TeaModel {
    public var environmentId: String?

    public var force: Bool?

    public var regionId: String?

    public var releaseName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseName != nil {
            map["ReleaseName"] = self.releaseName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseName") {
            self.releaseName = dict["ReleaseName"] as! String
        }
    }
}

public class DeleteAddonReleaseResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAddonReleaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAddonReleaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAddonReleaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlertContactRequest : Tea.TeaModel {
    public var contactId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAlertContactResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlertContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAlertContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlertContactGroupRequest : Tea.TeaModel {
    public var contactGroupId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") {
            self.contactGroupId = dict["ContactGroupId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAlertContactGroupResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlertContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAlertContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlertRuleRequest : Tea.TeaModel {
    public var alertId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! Int64
        }
    }
}

public class DeleteAlertRuleResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlertRulesRequest : Tea.TeaModel {
    public var alertIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertIds != nil {
            map["AlertIds"] = self.alertIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertIds") {
            self.alertIds = dict["AlertIds"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAlertRulesResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAppListRequest : Tea.TeaModel {
    public var pids: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pids != nil {
            map["Pids"] = self.pids!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pids") {
            self.pids = dict["Pids"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAppListResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAppListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAppListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAppListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCmsExporterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteCmsExporterResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCmsExporterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCmsExporterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCmsExporterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactRequest : Tea.TeaModel {
    public var contactId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! Int64
        }
    }
}

public class DeleteContactResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactGroupRequest : Tea.TeaModel {
    public var contactGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") {
            self.contactGroupId = dict["ContactGroupId"] as! Int64
        }
    }
}

public class DeleteContactGroupResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDispatchRuleRequest : Tea.TeaModel {
    public var id: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteDispatchRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvCustomJobRequest : Tea.TeaModel {
    public var customJobName: String?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customJobName != nil {
            map["CustomJobName"] = self.customJobName!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomJobName") {
            self.customJobName = dict["CustomJobName"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEnvCustomJobResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnvCustomJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvCustomJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEnvCustomJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvPodMonitorRequest : Tea.TeaModel {
    public var environmentId: String?

    public var namespace: String?

    public var podMonitorName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.podMonitorName != nil {
            map["PodMonitorName"] = self.podMonitorName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PodMonitorName") {
            self.podMonitorName = dict["PodMonitorName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEnvPodMonitorResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnvPodMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvPodMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEnvPodMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvServiceMonitorRequest : Tea.TeaModel {
    public var environmentId: String?

    public var namespace: String?

    public var regionId: String?

    public var serviceMonitorName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serviceMonitorName != nil {
            map["ServiceMonitorName"] = self.serviceMonitorName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ServiceMonitorName") {
            self.serviceMonitorName = dict["ServiceMonitorName"] as! String
        }
    }
}

public class DeleteEnvServiceMonitorResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnvServiceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvServiceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEnvServiceMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvironmentRequest : Tea.TeaModel {
    public var deletePromInstance: Bool?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletePromInstance != nil {
            map["DeletePromInstance"] = self.deletePromInstance!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeletePromInstance") {
            self.deletePromInstance = dict["DeletePromInstance"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEnvironmentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvironmentFeatureRequest : Tea.TeaModel {
    public var environmentId: String?

    public var featureName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEnvironmentFeatureResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventBridgeIntegrationRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteEventBridgeIntegrationResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEventBridgeIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventBridgeIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEventBridgeIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGrafanaResourceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteGrafanaResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGrafanaResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGrafanaResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGrafanaResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGrafanaWorkspaceRequest : Tea.TeaModel {
    public var grafanaWorkspaceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grafanaWorkspaceId != nil {
            map["GrafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GrafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["GrafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteGrafanaWorkspaceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteGrafanaWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGrafanaWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGrafanaWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIMRobotRequest : Tea.TeaModel {
    public var robotId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.robotId != nil {
            map["RobotId"] = self.robotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RobotId") {
            self.robotId = dict["RobotId"] as! Int64
        }
    }
}

public class DeleteIMRobotResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIMRobotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIMRobotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIMRobotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integration: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integration != nil {
            map["Integration"] = self.integration!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Integration") {
            self.integration = dict["Integration"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteIntegrationResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIntegrationsRequest : Tea.TeaModel {
    public var integrationId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.integrationId != nil {
            map["IntegrationId"] = self.integrationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IntegrationId") {
            self.integrationId = dict["IntegrationId"] as! Int64
        }
    }
}

public class DeleteIntegrationsResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIntegrationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIntegrationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIntegrationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNotificationPolicyRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteNotificationPolicyResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNotificationPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNotificationPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNotificationPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusAlertRuleRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class DeletePrometheusAlertRuleResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeletePrometheusAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePrometheusAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusGlobalViewRequest : Tea.TeaModel {
    public var globalViewClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalViewClusterId") {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeletePrometheusGlobalViewResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceId: Int64?

    public var integrationType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("IntegrationType") {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeletePrometheusIntegrationResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var monitoringName: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.monitoringName != nil {
            map["MonitoringName"] = self.monitoringName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MonitoringName") {
            self.monitoringName = dict["MonitoringName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DeletePrometheusMonitoringResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusRemoteWriteRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var remoteWriteNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteWriteNames != nil {
            map["RemoteWriteNames"] = self.remoteWriteNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteWriteNames") {
            self.remoteWriteNames = dict["RemoteWriteNames"] as! String
        }
    }
}

public class DeletePrometheusRemoteWriteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeletePrometheusRemoteWriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusRemoteWriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePrometheusRemoteWriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRetcodeAppRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteRetcodeAppResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteRetcodeAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRetcodeAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRetcodeAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRumAppRequest : Tea.TeaModel {
    public var appGroup: String?

    public var appId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGroup != nil {
            map["AppGroup"] = self.appGroup!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGroup") {
            self.appGroup = dict["AppGroup"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteRumAppResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteRumAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRumAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRumAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRumUploadFileRequest : Tea.TeaModel {
    public var fileName: String?

    public var pid: String?

    public var regionId: String?

    public var uuid: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("VersionId") {
            self.versionId = dict["VersionId"] as! String
        }
    }
}

public class DeleteRumUploadFileResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteRumUploadFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRumUploadFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRumUploadFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScenarioRequest : Tea.TeaModel {
    public var regionId: String?

    public var scenarioId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
    }
}

public class DeleteScenarioResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSilencePolicyRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteSilencePolicyResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSilencePolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSilencePolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSilencePolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSourceMapRequest : Tea.TeaModel {
    public var fidList: [String]?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fidList != nil {
            map["FidList"] = self.fidList!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FidList") {
            self.fidList = dict["FidList"] as! [String]
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteSourceMapShrinkRequest : Tea.TeaModel {
    public var fidListShrink: String?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fidListShrink != nil {
            map["FidList"] = self.fidListShrink!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FidList") {
            self.fidListShrink = dict["FidList"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteSourceMapResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSourceMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSourceMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSourceMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") {
            self.taskIds = dict["TaskIds"] as! [String]
        }
    }
}

public class DeleteSyntheticTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DeleteSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTimingSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceGroupId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DeleteTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTraceAppRequest : Tea.TeaModel {
    public class DeleteReason : Tea.TeaModel {
        public class ReasonIds : Tea.TeaModel {
            public var id: Int32?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var reasonIds: [DeleteTraceAppRequest.DeleteReason.ReasonIds]?

        public var remark: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reasonIds != nil {
                var tmp : [Any] = []
                for k in self.reasonIds! {
                    tmp.append(k.toMap())
                }
                map["ReasonIds"] = tmp
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReasonIds") {
                var tmp : [DeleteTraceAppRequest.DeleteReason.ReasonIds] = []
                for v in dict["ReasonIds"] as! [Any] {
                    var model = DeleteTraceAppRequest.DeleteReason.ReasonIds()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reasonIds = tmp
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
        }
    }
    public var appId: String?

    public var deleteReason: DeleteTraceAppRequest.DeleteReason?

    public var pid: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deleteReason?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deleteReason != nil {
            map["DeleteReason"] = self.deleteReason?.toMap()
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeleteReason") {
            var model = DeleteTraceAppRequest.DeleteReason()
            model.fromMap(dict["DeleteReason"] as! [String: Any])
            self.deleteReason = model
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DeleteTraceAppShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var deleteReasonShrink: String?

    public var pid: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deleteReasonShrink != nil {
            map["DeleteReason"] = self.deleteReasonShrink!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeleteReason") {
            self.deleteReasonShrink = dict["DeleteReason"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DeleteTraceAppResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTraceAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTraceAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTraceAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWebhookContactRequest : Tea.TeaModel {
    public var webhookId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.webhookId != nil {
            map["WebhookId"] = self.webhookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WebhookId") {
            self.webhookId = dict["WebhookId"] as! Int64
        }
    }
}

public class DeleteWebhookContactResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteWebhookContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWebhookContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWebhookContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAddonReleaseRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public var releaseName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseName != nil {
            map["ReleaseName"] = self.releaseName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseName") {
            self.releaseName = dict["ReleaseName"] as! String
        }
    }
}

public class DescribeAddonReleaseResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Release : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var firstTransitionTime: String?

                public var lastTransitionTime: String?

                public var message: String?

                public var reason: String?

                public var status: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.firstTransitionTime != nil {
                        map["FirstTransitionTime"] = self.firstTransitionTime!
                    }
                    if self.lastTransitionTime != nil {
                        map["LastTransitionTime"] = self.lastTransitionTime!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FirstTransitionTime") {
                        self.firstTransitionTime = dict["FirstTransitionTime"] as! String
                    }
                    if dict.keys.contains("LastTransitionTime") {
                        self.lastTransitionTime = dict["LastTransitionTime"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var addonName: String?

            public var alertRuleCount: Int64?

            public var conditions: [DescribeAddonReleaseResponseBody.Data.Release.Conditions]?

            public var createTime: String?

            public var dashboardCount: Int64?

            public var environmentId: String?

            public var exporterCount: Int64?

            public var haveConfig: Bool?

            public var installUserId: String?

            public var language: String?

            public var managed: Bool?

            public var regionId: String?

            public var releaseId: String?

            public var releaseName: String?

            public var scene: String?

            public var status: String?

            public var updateTime: String?

            public var userID: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addonName != nil {
                    map["AddonName"] = self.addonName!
                }
                if self.alertRuleCount != nil {
                    map["AlertRuleCount"] = self.alertRuleCount!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["Conditions"] = tmp
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dashboardCount != nil {
                    map["DashboardCount"] = self.dashboardCount!
                }
                if self.environmentId != nil {
                    map["EnvironmentId"] = self.environmentId!
                }
                if self.exporterCount != nil {
                    map["ExporterCount"] = self.exporterCount!
                }
                if self.haveConfig != nil {
                    map["HaveConfig"] = self.haveConfig!
                }
                if self.installUserId != nil {
                    map["InstallUserId"] = self.installUserId!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.managed != nil {
                    map["Managed"] = self.managed!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.releaseId != nil {
                    map["ReleaseId"] = self.releaseId!
                }
                if self.releaseName != nil {
                    map["ReleaseName"] = self.releaseName!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userID != nil {
                    map["UserID"] = self.userID!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddonName") {
                    self.addonName = dict["AddonName"] as! String
                }
                if dict.keys.contains("AlertRuleCount") {
                    self.alertRuleCount = dict["AlertRuleCount"] as! Int64
                }
                if dict.keys.contains("Conditions") {
                    var tmp : [DescribeAddonReleaseResponseBody.Data.Release.Conditions] = []
                    for v in dict["Conditions"] as! [Any] {
                        var model = DescribeAddonReleaseResponseBody.Data.Release.Conditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.conditions = tmp
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DashboardCount") {
                    self.dashboardCount = dict["DashboardCount"] as! Int64
                }
                if dict.keys.contains("EnvironmentId") {
                    self.environmentId = dict["EnvironmentId"] as! String
                }
                if dict.keys.contains("ExporterCount") {
                    self.exporterCount = dict["ExporterCount"] as! Int64
                }
                if dict.keys.contains("HaveConfig") {
                    self.haveConfig = dict["HaveConfig"] as! Bool
                }
                if dict.keys.contains("InstallUserId") {
                    self.installUserId = dict["InstallUserId"] as! String
                }
                if dict.keys.contains("Language") {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("Managed") {
                    self.managed = dict["Managed"] as! Bool
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReleaseId") {
                    self.releaseId = dict["ReleaseId"] as! String
                }
                if dict.keys.contains("ReleaseName") {
                    self.releaseName = dict["ReleaseName"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UserID") {
                    self.userID = dict["UserID"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var config: String?

        public var release: DescribeAddonReleaseResponseBody.Data.Release?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.release?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.release != nil {
                map["Release"] = self.release?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("Release") {
                var model = DescribeAddonReleaseResponseBody.Data.Release()
                model.fromMap(dict["Release"] as! [String: Any])
                self.release = model
            }
        }
    }
    public var code: String?

    public var data: DescribeAddonReleaseResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeAddonReleaseResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeAddonReleaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAddonReleaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAddonReleaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContactGroupsRequest : Tea.TeaModel {
    public var contactGroupName: String?

    public var groupIds: String?

    public var isDetail: Bool?

    public var page: Int64?

    public var regionId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupName") {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("GroupIds") {
            self.groupIds = dict["GroupIds"] as! String
        }
        if dict.keys.contains("IsDetail") {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class DescribeContactGroupsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertContactGroups : Tea.TeaModel {
            public class Contacts : Tea.TeaModel {
                public var armsContactId: Int64?

                public var contactId: Double?

                public var contactName: String?

                public var email: String?

                public var phone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.armsContactId != nil {
                        map["ArmsContactId"] = self.armsContactId!
                    }
                    if self.contactId != nil {
                        map["ContactId"] = self.contactId!
                    }
                    if self.contactName != nil {
                        map["ContactName"] = self.contactName!
                    }
                    if self.email != nil {
                        map["Email"] = self.email!
                    }
                    if self.phone != nil {
                        map["Phone"] = self.phone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ArmsContactId") {
                        self.armsContactId = dict["ArmsContactId"] as! Int64
                    }
                    if dict.keys.contains("ContactId") {
                        self.contactId = dict["ContactId"] as! Double
                    }
                    if dict.keys.contains("ContactName") {
                        self.contactName = dict["ContactName"] as! String
                    }
                    if dict.keys.contains("Email") {
                        self.email = dict["Email"] as! String
                    }
                    if dict.keys.contains("Phone") {
                        self.phone = dict["Phone"] as! String
                    }
                }
            }
            public var armsContactGroupId: Int64?

            public var contactGroupId: Double?

            public var contactGroupName: String?

            public var contacts: [DescribeContactGroupsResponseBody.PageBean.AlertContactGroups.Contacts]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.armsContactGroupId != nil {
                    map["ArmsContactGroupId"] = self.armsContactGroupId!
                }
                if self.contactGroupId != nil {
                    map["ContactGroupId"] = self.contactGroupId!
                }
                if self.contactGroupName != nil {
                    map["ContactGroupName"] = self.contactGroupName!
                }
                if self.contacts != nil {
                    var tmp : [Any] = []
                    for k in self.contacts! {
                        tmp.append(k.toMap())
                    }
                    map["Contacts"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ArmsContactGroupId") {
                    self.armsContactGroupId = dict["ArmsContactGroupId"] as! Int64
                }
                if dict.keys.contains("ContactGroupId") {
                    self.contactGroupId = dict["ContactGroupId"] as! Double
                }
                if dict.keys.contains("ContactGroupName") {
                    self.contactGroupName = dict["ContactGroupName"] as! String
                }
                if dict.keys.contains("Contacts") {
                    var tmp : [DescribeContactGroupsResponseBody.PageBean.AlertContactGroups.Contacts] = []
                    for v in dict["Contacts"] as! [Any] {
                        var model = DescribeContactGroupsResponseBody.PageBean.AlertContactGroups.Contacts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.contacts = tmp
                }
            }
        }
        public var alertContactGroups: [DescribeContactGroupsResponseBody.PageBean.AlertContactGroups]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertContactGroups != nil {
                var tmp : [Any] = []
                for k in self.alertContactGroups! {
                    tmp.append(k.toMap())
                }
                map["AlertContactGroups"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertContactGroups") {
                var tmp : [DescribeContactGroupsResponseBody.PageBean.AlertContactGroups] = []
                for v in dict["AlertContactGroups"] as! [Any] {
                    var model = DescribeContactGroupsResponseBody.PageBean.AlertContactGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertContactGroups = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: DescribeContactGroupsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = DescribeContactGroupsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeContactGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContactGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeContactGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContactsRequest : Tea.TeaModel {
    public var contactIds: String?

    public var contactName: String?

    public var email: String?

    public var page: Int64?

    public var phone: String?

    public var regionId: String?

    public var size: Int64?

    public var verbose: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.verbose != nil {
            map["Verbose"] = self.verbose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIds") {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("Email") {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Phone") {
            self.phone = dict["Phone"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("Verbose") {
            self.verbose = dict["Verbose"] as! String
        }
    }
}

public class DescribeContactsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertContacts : Tea.TeaModel {
            public var armsContactId: Int64?

            public var contactId: Double?

            public var contactName: String?

            public var email: String?

            public var isEmailVerify: Bool?

            public var isVerify: Bool?

            public var phone: String?

            public var reissueSendNotice: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.armsContactId != nil {
                    map["ArmsContactId"] = self.armsContactId!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.isEmailVerify != nil {
                    map["IsEmailVerify"] = self.isEmailVerify!
                }
                if self.isVerify != nil {
                    map["IsVerify"] = self.isVerify!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.reissueSendNotice != nil {
                    map["ReissueSendNotice"] = self.reissueSendNotice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ArmsContactId") {
                    self.armsContactId = dict["ArmsContactId"] as! Int64
                }
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! Double
                }
                if dict.keys.contains("ContactName") {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("IsEmailVerify") {
                    self.isEmailVerify = dict["IsEmailVerify"] as! Bool
                }
                if dict.keys.contains("IsVerify") {
                    self.isVerify = dict["IsVerify"] as! Bool
                }
                if dict.keys.contains("Phone") {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("ReissueSendNotice") {
                    self.reissueSendNotice = dict["ReissueSendNotice"] as! Int64
                }
            }
        }
        public var alertContacts: [DescribeContactsResponseBody.PageBean.AlertContacts]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertContacts != nil {
                var tmp : [Any] = []
                for k in self.alertContacts! {
                    tmp.append(k.toMap())
                }
                map["AlertContacts"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertContacts") {
                var tmp : [DescribeContactsResponseBody.PageBean.AlertContacts] = []
                for v in dict["AlertContacts"] as! [Any] {
                    var model = DescribeContactsResponseBody.PageBean.AlertContacts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertContacts = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: DescribeContactsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = DescribeContactsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeContactsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContactsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeContactsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDispatchRuleRequest : Tea.TeaModel {
    public var id: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeDispatchRuleResponseBody : Tea.TeaModel {
    public class DispatchRule : Tea.TeaModel {
        public class GroupRules : Tea.TeaModel {
            public var groupId: Int64?

            public var groupInterval: Int64?

            public var groupWaitTime: Int64?

            public var groupingFields: [String]?

            public var repeatInterval: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupInterval != nil {
                    map["GroupInterval"] = self.groupInterval!
                }
                if self.groupWaitTime != nil {
                    map["GroupWaitTime"] = self.groupWaitTime!
                }
                if self.groupingFields != nil {
                    map["GroupingFields"] = self.groupingFields!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupInterval") {
                    self.groupInterval = dict["GroupInterval"] as! Int64
                }
                if dict.keys.contains("GroupWaitTime") {
                    self.groupWaitTime = dict["GroupWaitTime"] as! Int64
                }
                if dict.keys.contains("GroupingFields") {
                    self.groupingFields = dict["GroupingFields"] as! [String]
                }
                if dict.keys.contains("RepeatInterval") {
                    self.repeatInterval = dict["RepeatInterval"] as! Int64
                }
            }
        }
        public class LabelMatchExpressionGrid : Tea.TeaModel {
            public class LabelMatchExpressionGroups : Tea.TeaModel {
                public class LabelMatchExpressions : Tea.TeaModel {
                    public var key: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var labelMatchExpressions: [DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups.LabelMatchExpressions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.labelMatchExpressions != nil {
                        var tmp : [Any] = []
                        for k in self.labelMatchExpressions! {
                            tmp.append(k.toMap())
                        }
                        map["LabelMatchExpressions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LabelMatchExpressions") {
                        var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups.LabelMatchExpressions] = []
                        for v in dict["LabelMatchExpressions"] as! [Any] {
                            var model = DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups.LabelMatchExpressions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.labelMatchExpressions = tmp
                    }
                }
            }
            public var labelMatchExpressionGroups: [DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.labelMatchExpressionGroups != nil {
                    var tmp : [Any] = []
                    for k in self.labelMatchExpressionGroups! {
                        tmp.append(k.toMap())
                    }
                    map["LabelMatchExpressionGroups"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LabelMatchExpressionGroups") {
                    var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups] = []
                    for v in dict["LabelMatchExpressionGroups"] as! [Any] {
                        var model = DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.labelMatchExpressionGroups = tmp
                }
            }
        }
        public class NotifyRules : Tea.TeaModel {
            public class NotifyObjects : Tea.TeaModel {
                public var name: String?

                public var notifyObjectId: String?

                public var notifyType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.notifyObjectId != nil {
                        map["NotifyObjectId"] = self.notifyObjectId!
                    }
                    if self.notifyType != nil {
                        map["NotifyType"] = self.notifyType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("NotifyObjectId") {
                        self.notifyObjectId = dict["NotifyObjectId"] as! String
                    }
                    if dict.keys.contains("NotifyType") {
                        self.notifyType = dict["NotifyType"] as! String
                    }
                }
            }
            public var notifyChannels: [String]?

            public var notifyObjects: [DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules.NotifyObjects]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notifyChannels != nil {
                    map["NotifyChannels"] = self.notifyChannels!
                }
                if self.notifyObjects != nil {
                    var tmp : [Any] = []
                    for k in self.notifyObjects! {
                        tmp.append(k.toMap())
                    }
                    map["NotifyObjects"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NotifyChannels") {
                    self.notifyChannels = dict["NotifyChannels"] as! [String]
                }
                if dict.keys.contains("NotifyObjects") {
                    var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules.NotifyObjects] = []
                    for v in dict["NotifyObjects"] as! [Any] {
                        var model = DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules.NotifyObjects()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notifyObjects = tmp
                }
            }
        }
        public var dispatchType: String?

        public var groupRules: [DescribeDispatchRuleResponseBody.DispatchRule.GroupRules]?

        public var isRecover: Bool?

        public var labelMatchExpressionGrid: DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid?

        public var name: String?

        public var notifyRules: [DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules]?

        public var ruleId: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.labelMatchExpressionGrid?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dispatchType != nil {
                map["DispatchType"] = self.dispatchType!
            }
            if self.groupRules != nil {
                var tmp : [Any] = []
                for k in self.groupRules! {
                    tmp.append(k.toMap())
                }
                map["GroupRules"] = tmp
            }
            if self.isRecover != nil {
                map["IsRecover"] = self.isRecover!
            }
            if self.labelMatchExpressionGrid != nil {
                map["LabelMatchExpressionGrid"] = self.labelMatchExpressionGrid?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyRules != nil {
                var tmp : [Any] = []
                for k in self.notifyRules! {
                    tmp.append(k.toMap())
                }
                map["NotifyRules"] = tmp
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DispatchType") {
                self.dispatchType = dict["DispatchType"] as! String
            }
            if dict.keys.contains("GroupRules") {
                var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.GroupRules] = []
                for v in dict["GroupRules"] as! [Any] {
                    var model = DescribeDispatchRuleResponseBody.DispatchRule.GroupRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groupRules = tmp
            }
            if dict.keys.contains("IsRecover") {
                self.isRecover = dict["IsRecover"] as! Bool
            }
            if dict.keys.contains("LabelMatchExpressionGrid") {
                var model = DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid()
                model.fromMap(dict["LabelMatchExpressionGrid"] as! [String: Any])
                self.labelMatchExpressionGrid = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyRules") {
                var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules] = []
                for v in dict["NotifyRules"] as! [Any] {
                    var model = DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifyRules = tmp
            }
            if dict.keys.contains("RuleId") {
                self.ruleId = dict["RuleId"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var dispatchRule: DescribeDispatchRuleResponseBody.DispatchRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dispatchRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRule != nil {
            map["DispatchRule"] = self.dispatchRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRule") {
            var model = DescribeDispatchRuleResponseBody.DispatchRule()
            model.fromMap(dict["DispatchRule"] as! [String: Any])
            self.dispatchRule = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvCustomJobRequest : Tea.TeaModel {
    public var customJobName: String?

    public var encryptYaml: Bool?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customJobName != nil {
            map["CustomJobName"] = self.customJobName!
        }
        if self.encryptYaml != nil {
            map["EncryptYaml"] = self.encryptYaml!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomJobName") {
            self.customJobName = dict["CustomJobName"] as! String
        }
        if dict.keys.contains("EncryptYaml") {
            self.encryptYaml = dict["EncryptYaml"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEnvCustomJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configYaml: String?

        public var customJobName: String?

        public var environmentId: String?

        public var regionId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.customJobName != nil {
                map["CustomJobName"] = self.customJobName!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigYaml") {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("CustomJobName") {
                self.customJobName = dict["CustomJobName"] as! String
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvCustomJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DescribeEnvCustomJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnvCustomJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvCustomJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnvCustomJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvPodMonitorRequest : Tea.TeaModel {
    public var environmentId: String?

    public var namespace: String?

    public var podMonitorName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.podMonitorName != nil {
            map["PodMonitorName"] = self.podMonitorName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PodMonitorName") {
            self.podMonitorName = dict["PodMonitorName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEnvPodMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configYaml: String?

        public var environmentId: String?

        public var namespace: String?

        public var podMonitorName: String?

        public var regionId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.podMonitorName != nil {
                map["PodMonitorName"] = self.podMonitorName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigYaml") {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PodMonitorName") {
                self.podMonitorName = dict["PodMonitorName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvPodMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DescribeEnvPodMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnvPodMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvPodMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnvPodMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvServiceMonitorRequest : Tea.TeaModel {
    public var environmentId: String?

    public var namespace: String?

    public var regionId: String?

    public var serviceMonitorName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serviceMonitorName != nil {
            map["ServiceMonitorName"] = self.serviceMonitorName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ServiceMonitorName") {
            self.serviceMonitorName = dict["ServiceMonitorName"] as! String
        }
    }
}

public class DescribeEnvServiceMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configYaml: String?

        public var environmentId: String?

        public var namespace: String?

        public var regionId: String?

        public var serviceMonitorName: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.serviceMonitorName != nil {
                map["ServiceMonitorName"] = self.serviceMonitorName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigYaml") {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ServiceMonitorName") {
                self.serviceMonitorName = dict["ServiceMonitorName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvServiceMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DescribeEnvServiceMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnvServiceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvServiceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnvServiceMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvironmentRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEnvironmentResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var bindResourceId: String?

        public var bindResourceProfile: String?

        public var bindResourceStatus: String?

        public var bindResourceStoreDuration: String?

        public var bindResourceType: String?

        public var bindVpcCidr: String?

        public var dbInstanceStatus: String?

        public var environmentId: String?

        public var environmentName: String?

        public var environmentSubType: String?

        public var environmentType: String?

        public var feePackage: String?

        public var grafaDataSourceName: String?

        public var grafanaDatasourceUid: String?

        public var grafanaFolderTitle: String?

        public var grafanaFolderUid: String?

        public var grafanaFolderUrl: String?

        public var grafanaWorkspaceId: String?

        public var managedType: String?

        public var prometheusInstanceId: String?

        public var prometheusInstanceName: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var tags: [DescribeEnvironmentResponseBody.Data.Tags]?

        public var userId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindResourceId != nil {
                map["BindResourceId"] = self.bindResourceId!
            }
            if self.bindResourceProfile != nil {
                map["BindResourceProfile"] = self.bindResourceProfile!
            }
            if self.bindResourceStatus != nil {
                map["BindResourceStatus"] = self.bindResourceStatus!
            }
            if self.bindResourceStoreDuration != nil {
                map["BindResourceStoreDuration"] = self.bindResourceStoreDuration!
            }
            if self.bindResourceType != nil {
                map["BindResourceType"] = self.bindResourceType!
            }
            if self.bindVpcCidr != nil {
                map["BindVpcCidr"] = self.bindVpcCidr!
            }
            if self.dbInstanceStatus != nil {
                map["DbInstanceStatus"] = self.dbInstanceStatus!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.environmentName != nil {
                map["EnvironmentName"] = self.environmentName!
            }
            if self.environmentSubType != nil {
                map["EnvironmentSubType"] = self.environmentSubType!
            }
            if self.environmentType != nil {
                map["EnvironmentType"] = self.environmentType!
            }
            if self.feePackage != nil {
                map["FeePackage"] = self.feePackage!
            }
            if self.grafaDataSourceName != nil {
                map["GrafaDataSourceName"] = self.grafaDataSourceName!
            }
            if self.grafanaDatasourceUid != nil {
                map["GrafanaDatasourceUid"] = self.grafanaDatasourceUid!
            }
            if self.grafanaFolderTitle != nil {
                map["GrafanaFolderTitle"] = self.grafanaFolderTitle!
            }
            if self.grafanaFolderUid != nil {
                map["GrafanaFolderUid"] = self.grafanaFolderUid!
            }
            if self.grafanaFolderUrl != nil {
                map["GrafanaFolderUrl"] = self.grafanaFolderUrl!
            }
            if self.grafanaWorkspaceId != nil {
                map["GrafanaWorkspaceId"] = self.grafanaWorkspaceId!
            }
            if self.managedType != nil {
                map["ManagedType"] = self.managedType!
            }
            if self.prometheusInstanceId != nil {
                map["PrometheusInstanceId"] = self.prometheusInstanceId!
            }
            if self.prometheusInstanceName != nil {
                map["PrometheusInstanceName"] = self.prometheusInstanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindResourceId") {
                self.bindResourceId = dict["BindResourceId"] as! String
            }
            if dict.keys.contains("BindResourceProfile") {
                self.bindResourceProfile = dict["BindResourceProfile"] as! String
            }
            if dict.keys.contains("BindResourceStatus") {
                self.bindResourceStatus = dict["BindResourceStatus"] as! String
            }
            if dict.keys.contains("BindResourceStoreDuration") {
                self.bindResourceStoreDuration = dict["BindResourceStoreDuration"] as! String
            }
            if dict.keys.contains("BindResourceType") {
                self.bindResourceType = dict["BindResourceType"] as! String
            }
            if dict.keys.contains("BindVpcCidr") {
                self.bindVpcCidr = dict["BindVpcCidr"] as! String
            }
            if dict.keys.contains("DbInstanceStatus") {
                self.dbInstanceStatus = dict["DbInstanceStatus"] as! String
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("EnvironmentName") {
                self.environmentName = dict["EnvironmentName"] as! String
            }
            if dict.keys.contains("EnvironmentSubType") {
                self.environmentSubType = dict["EnvironmentSubType"] as! String
            }
            if dict.keys.contains("EnvironmentType") {
                self.environmentType = dict["EnvironmentType"] as! String
            }
            if dict.keys.contains("FeePackage") {
                self.feePackage = dict["FeePackage"] as! String
            }
            if dict.keys.contains("GrafaDataSourceName") {
                self.grafaDataSourceName = dict["GrafaDataSourceName"] as! String
            }
            if dict.keys.contains("GrafanaDatasourceUid") {
                self.grafanaDatasourceUid = dict["GrafanaDatasourceUid"] as! String
            }
            if dict.keys.contains("GrafanaFolderTitle") {
                self.grafanaFolderTitle = dict["GrafanaFolderTitle"] as! String
            }
            if dict.keys.contains("GrafanaFolderUid") {
                self.grafanaFolderUid = dict["GrafanaFolderUid"] as! String
            }
            if dict.keys.contains("GrafanaFolderUrl") {
                self.grafanaFolderUrl = dict["GrafanaFolderUrl"] as! String
            }
            if dict.keys.contains("GrafanaWorkspaceId") {
                self.grafanaWorkspaceId = dict["GrafanaWorkspaceId"] as! String
            }
            if dict.keys.contains("ManagedType") {
                self.managedType = dict["ManagedType"] as! String
            }
            if dict.keys.contains("PrometheusInstanceId") {
                self.prometheusInstanceId = dict["PrometheusInstanceId"] as! String
            }
            if dict.keys.contains("PrometheusInstanceName") {
                self.prometheusInstanceName = dict["PrometheusInstanceName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeEnvironmentResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeEnvironmentResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvironmentResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DescribeEnvironmentResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvironmentFeatureRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var environmentId: String?

    public var featureName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEnvironmentFeatureResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Feature : Tea.TeaModel {
            public var alias: String?

            public var config: [String: String]?

            public var description_: String?

            public var environmentId: String?

            public var icon: String?

            public var language: String?

            public var latestVersion: String?

            public var managed: Bool?

            public var name: String?

            public var status: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.config != nil {
                    map["Config"] = self.config!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.environmentId != nil {
                    map["EnvironmentId"] = self.environmentId!
                }
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.latestVersion != nil {
                    map["LatestVersion"] = self.latestVersion!
                }
                if self.managed != nil {
                    map["Managed"] = self.managed!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("Config") {
                    self.config = dict["Config"] as! [String: String]
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnvironmentId") {
                    self.environmentId = dict["EnvironmentId"] as! String
                }
                if dict.keys.contains("Icon") {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Language") {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("LatestVersion") {
                    self.latestVersion = dict["LatestVersion"] as! String
                }
                if dict.keys.contains("Managed") {
                    self.managed = dict["Managed"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class FeatureStatus : Tea.TeaModel {
            public class FeatureContainers : Tea.TeaModel {
                public var args: [String]?

                public var image: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.args != nil {
                        map["Args"] = self.args!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Args") {
                        self.args = dict["Args"] as! [String]
                    }
                    if dict.keys.contains("Image") {
                        self.image = dict["Image"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var bindResourceId: String?

            public var featureContainers: [DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus.FeatureContainers]?

            public var ips: [String]?

            public var name: String?

            public var namespace: String?

            public var securityGroupId: String?

            public var status: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindResourceId != nil {
                    map["BindResourceId"] = self.bindResourceId!
                }
                if self.featureContainers != nil {
                    var tmp : [Any] = []
                    for k in self.featureContainers! {
                        tmp.append(k.toMap())
                    }
                    map["FeatureContainers"] = tmp
                }
                if self.ips != nil {
                    map["Ips"] = self.ips!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindResourceId") {
                    self.bindResourceId = dict["BindResourceId"] as! String
                }
                if dict.keys.contains("FeatureContainers") {
                    var tmp : [DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus.FeatureContainers] = []
                    for v in dict["FeatureContainers"] as! [Any] {
                        var model = DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus.FeatureContainers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.featureContainers = tmp
                }
                if dict.keys.contains("Ips") {
                    self.ips = dict["Ips"] as! [String]
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
            }
        }
        public var feature: DescribeEnvironmentFeatureResponseBody.Data.Feature?

        public var featureStatus: DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.feature?.validate()
            try self.featureStatus?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feature != nil {
                map["Feature"] = self.feature?.toMap()
            }
            if self.featureStatus != nil {
                map["FeatureStatus"] = self.featureStatus?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Feature") {
                var model = DescribeEnvironmentFeatureResponseBody.Data.Feature()
                model.fromMap(dict["Feature"] as! [String: Any])
                self.feature = model
            }
            if dict.keys.contains("FeatureStatus") {
                var model = DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus()
                model.fromMap(dict["FeatureStatus"] as! [String: Any])
                self.featureStatus = model
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvironmentFeatureResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DescribeEnvironmentFeatureResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIMRobotsRequest : Tea.TeaModel {
    public var page: Int64?

    public var robotIds: String?

    public var robotName: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.robotIds != nil {
            map["RobotIds"] = self.robotIds!
        }
        if self.robotName != nil {
            map["RobotName"] = self.robotName!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RobotIds") {
            self.robotIds = dict["RobotIds"] as! String
        }
        if dict.keys.contains("RobotName") {
            self.robotName = dict["RobotName"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class DescribeIMRobotsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertIMRobots : Tea.TeaModel {
            public class DispatchRules : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("id") {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public var createTime: String?

            public var dailyNoc: Bool?

            public var dailyNocTime: String?

            public var dingSignKey: String?

            public var dispatchRules: [DescribeIMRobotsResponseBody.PageBean.AlertIMRobots.DispatchRules]?

            public var robotAddr: String?

            public var robotId: Double?

            public var robotName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dailyNoc != nil {
                    map["DailyNoc"] = self.dailyNoc!
                }
                if self.dailyNocTime != nil {
                    map["DailyNocTime"] = self.dailyNocTime!
                }
                if self.dingSignKey != nil {
                    map["DingSignKey"] = self.dingSignKey!
                }
                if self.dispatchRules != nil {
                    var tmp : [Any] = []
                    for k in self.dispatchRules! {
                        tmp.append(k.toMap())
                    }
                    map["DispatchRules"] = tmp
                }
                if self.robotAddr != nil {
                    map["RobotAddr"] = self.robotAddr!
                }
                if self.robotId != nil {
                    map["RobotId"] = self.robotId!
                }
                if self.robotName != nil {
                    map["RobotName"] = self.robotName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DailyNoc") {
                    self.dailyNoc = dict["DailyNoc"] as! Bool
                }
                if dict.keys.contains("DailyNocTime") {
                    self.dailyNocTime = dict["DailyNocTime"] as! String
                }
                if dict.keys.contains("DingSignKey") {
                    self.dingSignKey = dict["DingSignKey"] as! String
                }
                if dict.keys.contains("DispatchRules") {
                    var tmp : [DescribeIMRobotsResponseBody.PageBean.AlertIMRobots.DispatchRules] = []
                    for v in dict["DispatchRules"] as! [Any] {
                        var model = DescribeIMRobotsResponseBody.PageBean.AlertIMRobots.DispatchRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dispatchRules = tmp
                }
                if dict.keys.contains("RobotAddr") {
                    self.robotAddr = dict["RobotAddr"] as! String
                }
                if dict.keys.contains("RobotId") {
                    self.robotId = dict["RobotId"] as! Double
                }
                if dict.keys.contains("RobotName") {
                    self.robotName = dict["RobotName"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var alertIMRobots: [DescribeIMRobotsResponseBody.PageBean.AlertIMRobots]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertIMRobots != nil {
                var tmp : [Any] = []
                for k in self.alertIMRobots! {
                    tmp.append(k.toMap())
                }
                map["AlertIMRobots"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertIMRobots") {
                var tmp : [DescribeIMRobotsResponseBody.PageBean.AlertIMRobots] = []
                for v in dict["AlertIMRobots"] as! [Any] {
                    var model = DescribeIMRobotsResponseBody.PageBean.AlertIMRobots()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertIMRobots = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: DescribeIMRobotsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = DescribeIMRobotsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeIMRobotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIMRobotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIMRobotsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrometheusAlertRuleRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class DescribePrometheusAlertRuleResponseBody : Tea.TeaModel {
    public class PrometheusAlertRule : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertId: Int64?

        public var alertName: String?

        public var annotations: [DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations]?

        public var clusterId: String?

        public var dispatchRuleId: Int64?

        public var duration: String?

        public var expression: String?

        public var labels: [DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels]?

        public var message: String?

        public var notifyType: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dispatchRuleId != nil {
                map["DispatchRuleId"] = self.dispatchRuleId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertId") {
                self.alertId = dict["AlertId"] as! Int64
            }
            if dict.keys.contains("AlertName") {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") {
                var tmp : [DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("DispatchRuleId") {
                self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") {
                var tmp : [DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NotifyType") {
                self.notifyType = dict["NotifyType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int64?

    public var message: String?

    public var prometheusAlertRule: DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prometheusAlertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.prometheusAlertRule != nil {
            map["PrometheusAlertRule"] = self.prometheusAlertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PrometheusAlertRule") {
            var model = DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule()
            model.fromMap(dict["PrometheusAlertRule"] as! [String: Any])
            self.prometheusAlertRule = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribePrometheusAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrometheusAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePrometheusAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTraceLicenseKeyRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeTraceLicenseKeyResponseBody : Tea.TeaModel {
    public var licenseKey: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.licenseKey != nil {
            map["LicenseKey"] = self.licenseKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LicenseKey") {
            self.licenseKey = dict["LicenseKey"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeTraceLicenseKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTraceLicenseKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTraceLicenseKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebhookContactsRequest : Tea.TeaModel {
    public var contactIds: String?

    public var page: Int64?

    public var size: Int64?

    public var webhookName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.webhookName != nil {
            map["WebhookName"] = self.webhookName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIds") {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("WebhookName") {
            self.webhookName = dict["WebhookName"] as! String
        }
    }
}

public class DescribeWebhookContactsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class WebhookContacts : Tea.TeaModel {
            public class Webhook : Tea.TeaModel {
                public var bizHeaders: [String: Any]?

                public var bizParams: [String: Any]?

                public var body: String?

                public var method: String?

                public var recoverBody: String?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizHeaders != nil {
                        map["BizHeaders"] = self.bizHeaders!
                    }
                    if self.bizParams != nil {
                        map["BizParams"] = self.bizParams!
                    }
                    if self.body != nil {
                        map["Body"] = self.body!
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    if self.recoverBody != nil {
                        map["RecoverBody"] = self.recoverBody!
                    }
                    if self.url != nil {
                        map["Url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizHeaders") {
                        self.bizHeaders = dict["BizHeaders"] as! [String: Any]
                    }
                    if dict.keys.contains("BizParams") {
                        self.bizParams = dict["BizParams"] as! [String: Any]
                    }
                    if dict.keys.contains("Body") {
                        self.body = dict["Body"] as! String
                    }
                    if dict.keys.contains("Method") {
                        self.method = dict["Method"] as! String
                    }
                    if dict.keys.contains("RecoverBody") {
                        self.recoverBody = dict["RecoverBody"] as! String
                    }
                    if dict.keys.contains("Url") {
                        self.url = dict["Url"] as! String
                    }
                }
            }
            public var webhook: DescribeWebhookContactsResponseBody.PageBean.WebhookContacts.Webhook?

            public var webhookId: Double?

            public var webhookName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.webhook?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.webhook != nil {
                    map["Webhook"] = self.webhook?.toMap()
                }
                if self.webhookId != nil {
                    map["WebhookId"] = self.webhookId!
                }
                if self.webhookName != nil {
                    map["WebhookName"] = self.webhookName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Webhook") {
                    var model = DescribeWebhookContactsResponseBody.PageBean.WebhookContacts.Webhook()
                    model.fromMap(dict["Webhook"] as! [String: Any])
                    self.webhook = model
                }
                if dict.keys.contains("WebhookId") {
                    self.webhookId = dict["WebhookId"] as! Double
                }
                if dict.keys.contains("WebhookName") {
                    self.webhookName = dict["WebhookName"] as! String
                }
            }
        }
        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public var webhookContacts: [DescribeWebhookContactsResponseBody.PageBean.WebhookContacts]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            if self.webhookContacts != nil {
                var tmp : [Any] = []
                for k in self.webhookContacts! {
                    tmp.append(k.toMap())
                }
                map["WebhookContacts"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
            if dict.keys.contains("WebhookContacts") {
                var tmp : [DescribeWebhookContactsResponseBody.PageBean.WebhookContacts] = []
                for v in dict["WebhookContacts"] as! [Any] {
                    var model = DescribeWebhookContactsResponseBody.PageBean.WebhookContacts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.webhookContacts = tmp
            }
        }
    }
    public var pageBean: DescribeWebhookContactsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = DescribeWebhookContactsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeWebhookContactsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebhookContactsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeWebhookContactsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableMetricRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dropMetric: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dropMetric != nil {
            map["DropMetric"] = self.dropMetric!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DropMetric") {
            self.dropMetric = dict["DropMetric"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class EnableMetricResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAgentDownloadUrlRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetAgentDownloadUrlResponseBody : Tea.TeaModel {
    public var armsAgentDownloadUrl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.armsAgentDownloadUrl != nil {
            map["ArmsAgentDownloadUrl"] = self.armsAgentDownloadUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ArmsAgentDownloadUrl") {
            self.armsAgentDownloadUrl = dict["ArmsAgentDownloadUrl"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAgentDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAgentDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAgentDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAlertRulesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertIds: String?

    public var alertNames: String?

    public var alertStatus: String?

    public var alertType: String?

    public var clusterId: String?

    public var page: Int64?

    public var productCode: String?

    public var regionId: String?

    public var size: Int64?

    public var tags: [GetAlertRulesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertIds != nil {
            map["AlertIds"] = self.alertIds!
        }
        if self.alertNames != nil {
            map["AlertNames"] = self.alertNames!
        }
        if self.alertStatus != nil {
            map["AlertStatus"] = self.alertStatus!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertIds") {
            self.alertIds = dict["AlertIds"] as! String
        }
        if dict.keys.contains("AlertNames") {
            self.alertNames = dict["AlertNames"] as! String
        }
        if dict.keys.contains("AlertStatus") {
            self.alertStatus = dict["AlertStatus"] as! String
        }
        if dict.keys.contains("AlertType") {
            self.alertType = dict["AlertType"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("ProductCode") {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [GetAlertRulesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetAlertRulesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetAlertRulesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertRules : Tea.TeaModel {
            public class AlertRuleContent : Tea.TeaModel {
                public class AlertRuleItems : Tea.TeaModel {
                    public var aggregate: String?

                    public var metricKey: String?

                    public var n: Int64?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.aggregate != nil {
                            map["Aggregate"] = self.aggregate!
                        }
                        if self.metricKey != nil {
                            map["MetricKey"] = self.metricKey!
                        }
                        if self.n != nil {
                            map["N"] = self.n!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Aggregate") {
                            self.aggregate = dict["Aggregate"] as! String
                        }
                        if dict.keys.contains("MetricKey") {
                            self.metricKey = dict["MetricKey"] as! String
                        }
                        if dict.keys.contains("N") {
                            self.n = dict["N"] as! Int64
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var alertRuleItems: [GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent.AlertRuleItems]?

                public var condition: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alertRuleItems != nil {
                        var tmp : [Any] = []
                        for k in self.alertRuleItems! {
                            tmp.append(k.toMap())
                        }
                        map["AlertRuleItems"] = tmp
                    }
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlertRuleItems") {
                        var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent.AlertRuleItems] = []
                        for v in dict["AlertRuleItems"] as! [Any] {
                            var model = GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent.AlertRuleItems()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.alertRuleItems = tmp
                    }
                    if dict.keys.contains("Condition") {
                        self.condition = dict["Condition"] as! String
                    }
                }
            }
            public class Annotations : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Filters : Tea.TeaModel {
                public class CustomSLSFilters : Tea.TeaModel {
                    public var key: String?

                    public var opt: String?

                    public var show: Bool?

                    public var t: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.opt != nil {
                            map["Opt"] = self.opt!
                        }
                        if self.show != nil {
                            map["Show"] = self.show!
                        }
                        if self.t != nil {
                            map["T"] = self.t!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Opt") {
                            self.opt = dict["Opt"] as! String
                        }
                        if dict.keys.contains("Show") {
                            self.show = dict["Show"] as! Bool
                        }
                        if dict.keys.contains("T") {
                            self.t = dict["T"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class DimFilters : Tea.TeaModel {
                    public var filterKey: String?

                    public var filterOpt: String?

                    public var filterValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.filterKey != nil {
                            map["FilterKey"] = self.filterKey!
                        }
                        if self.filterOpt != nil {
                            map["FilterOpt"] = self.filterOpt!
                        }
                        if self.filterValues != nil {
                            map["FilterValues"] = self.filterValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FilterKey") {
                            self.filterKey = dict["FilterKey"] as! String
                        }
                        if dict.keys.contains("FilterOpt") {
                            self.filterOpt = dict["FilterOpt"] as! String
                        }
                        if dict.keys.contains("FilterValues") {
                            self.filterValues = dict["FilterValues"] as! [String]
                        }
                    }
                }
                public var customSLSFilters: [GetAlertRulesResponseBody.PageBean.AlertRules.Filters.CustomSLSFilters]?

                public var customSLSGroupByDimensions: [String]?

                public var customSLSWheres: [String]?

                public var dimFilters: [GetAlertRulesResponseBody.PageBean.AlertRules.Filters.DimFilters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.customSLSFilters != nil {
                        var tmp : [Any] = []
                        for k in self.customSLSFilters! {
                            tmp.append(k.toMap())
                        }
                        map["CustomSLSFilters"] = tmp
                    }
                    if self.customSLSGroupByDimensions != nil {
                        map["CustomSLSGroupByDimensions"] = self.customSLSGroupByDimensions!
                    }
                    if self.customSLSWheres != nil {
                        map["CustomSLSWheres"] = self.customSLSWheres!
                    }
                    if self.dimFilters != nil {
                        var tmp : [Any] = []
                        for k in self.dimFilters! {
                            tmp.append(k.toMap())
                        }
                        map["DimFilters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CustomSLSFilters") {
                        var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Filters.CustomSLSFilters] = []
                        for v in dict["CustomSLSFilters"] as! [Any] {
                            var model = GetAlertRulesResponseBody.PageBean.AlertRules.Filters.CustomSLSFilters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.customSLSFilters = tmp
                    }
                    if dict.keys.contains("CustomSLSGroupByDimensions") {
                        self.customSLSGroupByDimensions = dict["CustomSLSGroupByDimensions"] as! [String]
                    }
                    if dict.keys.contains("CustomSLSWheres") {
                        self.customSLSWheres = dict["CustomSLSWheres"] as! [String]
                    }
                    if dict.keys.contains("DimFilters") {
                        var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Filters.DimFilters] = []
                        for v in dict["DimFilters"] as! [Any] {
                            var model = GetAlertRulesResponseBody.PageBean.AlertRules.Filters.DimFilters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dimFilters = tmp
                    }
                }
            }
            public class Labels : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var alertCheckType: String?

            public var alertGroup: Int64?

            public var alertId: Int64?

            public var alertName: String?

            public var alertRuleContent: GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent?

            public var alertStatus: String?

            public var alertType: String?

            public var annotations: [GetAlertRulesResponseBody.PageBean.AlertRules.Annotations]?

            public var autoAddNewApplication: Bool?

            public var clusterId: String?

            public var createdTime: Int64?

            public var duration: String?

            public var extend: String?

            public var filters: GetAlertRulesResponseBody.PageBean.AlertRules.Filters?

            public var labels: [GetAlertRulesResponseBody.PageBean.AlertRules.Labels]?

            public var level: String?

            public var message: String?

            public var metricsType: String?

            public var notifyStrategy: String?

            public var pids: [String]?

            public var promQL: String?

            public var regionId: String?

            public var tags: [GetAlertRulesResponseBody.PageBean.AlertRules.Tags]?

            public var updatedTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.alertRuleContent?.validate()
                try self.filters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertCheckType != nil {
                    map["AlertCheckType"] = self.alertCheckType!
                }
                if self.alertGroup != nil {
                    map["AlertGroup"] = self.alertGroup!
                }
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.alertRuleContent != nil {
                    map["AlertRuleContent"] = self.alertRuleContent?.toMap()
                }
                if self.alertStatus != nil {
                    map["AlertStatus"] = self.alertStatus!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.annotations != nil {
                    var tmp : [Any] = []
                    for k in self.annotations! {
                        tmp.append(k.toMap())
                    }
                    map["Annotations"] = tmp
                }
                if self.autoAddNewApplication != nil {
                    map["AutoAddNewApplication"] = self.autoAddNewApplication!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.extend != nil {
                    map["Extend"] = self.extend!
                }
                if self.filters != nil {
                    map["Filters"] = self.filters?.toMap()
                }
                if self.labels != nil {
                    var tmp : [Any] = []
                    for k in self.labels! {
                        tmp.append(k.toMap())
                    }
                    map["Labels"] = tmp
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.metricsType != nil {
                    map["MetricsType"] = self.metricsType!
                }
                if self.notifyStrategy != nil {
                    map["NotifyStrategy"] = self.notifyStrategy!
                }
                if self.pids != nil {
                    map["Pids"] = self.pids!
                }
                if self.promQL != nil {
                    map["PromQL"] = self.promQL!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertCheckType") {
                    self.alertCheckType = dict["AlertCheckType"] as! String
                }
                if dict.keys.contains("AlertGroup") {
                    self.alertGroup = dict["AlertGroup"] as! Int64
                }
                if dict.keys.contains("AlertId") {
                    self.alertId = dict["AlertId"] as! Int64
                }
                if dict.keys.contains("AlertName") {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("AlertRuleContent") {
                    var model = GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent()
                    model.fromMap(dict["AlertRuleContent"] as! [String: Any])
                    self.alertRuleContent = model
                }
                if dict.keys.contains("AlertStatus") {
                    self.alertStatus = dict["AlertStatus"] as! String
                }
                if dict.keys.contains("AlertType") {
                    self.alertType = dict["AlertType"] as! String
                }
                if dict.keys.contains("Annotations") {
                    var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Annotations] = []
                    for v in dict["Annotations"] as! [Any] {
                        var model = GetAlertRulesResponseBody.PageBean.AlertRules.Annotations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.annotations = tmp
                }
                if dict.keys.contains("AutoAddNewApplication") {
                    self.autoAddNewApplication = dict["AutoAddNewApplication"] as! Bool
                }
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! Int64
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Extend") {
                    self.extend = dict["Extend"] as! String
                }
                if dict.keys.contains("Filters") {
                    var model = GetAlertRulesResponseBody.PageBean.AlertRules.Filters()
                    model.fromMap(dict["Filters"] as! [String: Any])
                    self.filters = model
                }
                if dict.keys.contains("Labels") {
                    var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Labels] = []
                    for v in dict["Labels"] as! [Any] {
                        var model = GetAlertRulesResponseBody.PageBean.AlertRules.Labels()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.labels = tmp
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("MetricsType") {
                    self.metricsType = dict["MetricsType"] as! String
                }
                if dict.keys.contains("NotifyStrategy") {
                    self.notifyStrategy = dict["NotifyStrategy"] as! String
                }
                if dict.keys.contains("Pids") {
                    self.pids = dict["Pids"] as! [String]
                }
                if dict.keys.contains("PromQL") {
                    self.promQL = dict["PromQL"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = GetAlertRulesResponseBody.PageBean.AlertRules.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("UpdatedTime") {
                    self.updatedTime = dict["UpdatedTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var alertRules: [GetAlertRulesResponseBody.PageBean.AlertRules]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertRules != nil {
                var tmp : [Any] = []
                for k in self.alertRules! {
                    tmp.append(k.toMap())
                }
                map["AlertRules"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertRules") {
                var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules] = []
                for v in dict["AlertRules"] as! [Any] {
                    var model = GetAlertRulesResponseBody.PageBean.AlertRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertRules = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: GetAlertRulesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = GetAlertRulesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppApiByPageRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var endTime: Int64?

    public var intervalMills: Int32?

    public var PId: String?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.intervalMills != nil {
            map["IntervalMills"] = self.intervalMills!
        }
        if self.PId != nil {
            map["PId"] = self.PId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("IntervalMills") {
            self.intervalMills = dict["IntervalMills"] as! Int32
        }
        if dict.keys.contains("PId") {
            self.PId = dict["PId"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetAppApiByPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var completed: Bool?

        public var items: [[String: Any]]?

        public var page: Int32?

        public var pageSize: Int32?

        public var total: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completed != nil {
                map["Completed"] = self.completed!
            }
            if self.items != nil {
                map["Items"] = self.items!
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Completed") {
                self.completed = dict["Completed"] as! Bool
            }
            if dict.keys.contains("Items") {
                self.items = dict["Items"] as! [[String: Any]]
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetAppApiByPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetAppApiByPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAppApiByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppApiByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAppApiByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppJVMConfigRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var pid: String?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetAppJVMConfigResponseBody : Tea.TeaModel {
    public class JvmInfoList : Tea.TeaModel {
        public var agentVersion: String?

        public var hostName: String?

        public var ip: String?

        public var pid: String?

        public var procId: String?

        public var vmArgs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentVersion != nil {
                map["AgentVersion"] = self.agentVersion!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.procId != nil {
                map["ProcId"] = self.procId!
            }
            if self.vmArgs != nil {
                map["VmArgs"] = self.vmArgs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentVersion") {
                self.agentVersion = dict["AgentVersion"] as! String
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("ProcId") {
                self.procId = dict["ProcId"] as! String
            }
            if dict.keys.contains("VmArgs") {
                self.vmArgs = dict["VmArgs"] as! String
            }
        }
    }
    public var code: Int32?

    public var jvmInfoList: [GetAppJVMConfigResponseBody.JvmInfoList]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.jvmInfoList != nil {
            var tmp : [Any] = []
            for k in self.jvmInfoList! {
                tmp.append(k.toMap())
            }
            map["JvmInfoList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("JvmInfoList") {
            var tmp : [GetAppJVMConfigResponseBody.JvmInfoList] = []
            for v in dict["JvmInfoList"] as! [Any] {
                var model = GetAppJVMConfigResponseBody.JvmInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jvmInfoList = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAppJVMConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppJVMConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAppJVMConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuthTokenRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetAuthTokenResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAuthTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuthTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAuthTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCloudClusterAllUrlRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetCloudClusterAllUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RemoteUrl : Tea.TeaModel {
            public var authToken: Bool?

            public var grafanaUrl: String?

            public var internetGrafanaUrl: String?

            public var internetPushGatewayUrl: String?

            public var internetRemoteReadUrl: String?

            public var internetRemoteWriteUrl: String?

            public var pushGatewayUrl: String?

            public var remoteReadUrl: String?

            public var remoteWriteUrl: String?

            public var token: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authToken != nil {
                    map["AuthToken"] = self.authToken!
                }
                if self.grafanaUrl != nil {
                    map["GrafanaUrl"] = self.grafanaUrl!
                }
                if self.internetGrafanaUrl != nil {
                    map["InternetGrafanaUrl"] = self.internetGrafanaUrl!
                }
                if self.internetPushGatewayUrl != nil {
                    map["InternetPushGatewayUrl"] = self.internetPushGatewayUrl!
                }
                if self.internetRemoteReadUrl != nil {
                    map["InternetRemoteReadUrl"] = self.internetRemoteReadUrl!
                }
                if self.internetRemoteWriteUrl != nil {
                    map["InternetRemoteWriteUrl"] = self.internetRemoteWriteUrl!
                }
                if self.pushGatewayUrl != nil {
                    map["PushGatewayUrl"] = self.pushGatewayUrl!
                }
                if self.remoteReadUrl != nil {
                    map["RemoteReadUrl"] = self.remoteReadUrl!
                }
                if self.remoteWriteUrl != nil {
                    map["RemoteWriteUrl"] = self.remoteWriteUrl!
                }
                if self.token != nil {
                    map["Token"] = self.token!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthToken") {
                    self.authToken = dict["AuthToken"] as! Bool
                }
                if dict.keys.contains("GrafanaUrl") {
                    self.grafanaUrl = dict["GrafanaUrl"] as! String
                }
                if dict.keys.contains("InternetGrafanaUrl") {
                    self.internetGrafanaUrl = dict["InternetGrafanaUrl"] as! String
                }
                if dict.keys.contains("InternetPushGatewayUrl") {
                    self.internetPushGatewayUrl = dict["InternetPushGatewayUrl"] as! String
                }
                if dict.keys.contains("InternetRemoteReadUrl") {
                    self.internetRemoteReadUrl = dict["InternetRemoteReadUrl"] as! String
                }
                if dict.keys.contains("InternetRemoteWriteUrl") {
                    self.internetRemoteWriteUrl = dict["InternetRemoteWriteUrl"] as! String
                }
                if dict.keys.contains("PushGatewayUrl") {
                    self.pushGatewayUrl = dict["PushGatewayUrl"] as! String
                }
                if dict.keys.contains("RemoteReadUrl") {
                    self.remoteReadUrl = dict["RemoteReadUrl"] as! String
                }
                if dict.keys.contains("RemoteWriteUrl") {
                    self.remoteWriteUrl = dict["RemoteWriteUrl"] as! String
                }
                if dict.keys.contains("Token") {
                    self.token = dict["Token"] as! String
                }
            }
        }
        public var productCode: String?

        public var region: String?

        public var remoteUrl: GetCloudClusterAllUrlResponseBody.Data.RemoteUrl?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.remoteUrl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.productCode != nil {
                map["ProductCode"] = self.productCode!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.remoteUrl != nil {
                map["RemoteUrl"] = self.remoteUrl?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProductCode") {
                self.productCode = dict["ProductCode"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("RemoteUrl") {
                var model = GetCloudClusterAllUrlResponseBody.Data.RemoteUrl()
                model.fromMap(dict["RemoteUrl"] as! [String: Any])
                self.remoteUrl = model
            }
        }
    }
    public var code: Int32?

    public var data: [GetCloudClusterAllUrlResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [GetCloudClusterAllUrlResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetCloudClusterAllUrlResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetCloudClusterAllUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCloudClusterAllUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCloudClusterAllUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClusterAllUrlRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetClusterAllUrlResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetClusterAllUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterAllUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetClusterAllUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCommercialStatusRequest : Tea.TeaModel {
    public var commodityCode: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetCommercialStatusResponseBody : Tea.TeaModel {
    public class UserAndCommodityStatus : Tea.TeaModel {
        public var basic: Bool?

        public var chargeType: String?

        public var enable: Bool?

        public var extraInfo: [String: Any]?

        public var freeDays: Int64?

        public var lable: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.basic != nil {
                map["Basic"] = self.basic!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.freeDays != nil {
                map["FreeDays"] = self.freeDays!
            }
            if self.lable != nil {
                map["Lable"] = self.lable!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Basic") {
                self.basic = dict["Basic"] as! Bool
            }
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("ExtraInfo") {
                self.extraInfo = dict["ExtraInfo"] as! [String: Any]
            }
            if dict.keys.contains("FreeDays") {
                self.freeDays = dict["FreeDays"] as! Int64
            }
            if dict.keys.contains("Lable") {
                self.lable = dict["Lable"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var requestId: String?

    public var userAndCommodityStatus: GetCommercialStatusResponseBody.UserAndCommodityStatus?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userAndCommodityStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userAndCommodityStatus != nil {
            map["UserAndCommodityStatus"] = self.userAndCommodityStatus?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserAndCommodityStatus") {
            var model = GetCommercialStatusResponseBody.UserAndCommodityStatus()
            model.fromMap(dict["UserAndCommodityStatus"] as! [String: Any])
            self.userAndCommodityStatus = model
        }
    }
}

public class GetCommercialStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCommercialStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCommercialStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetExploreUrlRequest : Tea.TeaModel {
    public var clusterId: String?

    public var expression: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.expression != nil {
            map["Expression"] = self.expression!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Expression") {
            self.expression = dict["Expression"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetExploreUrlResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetExploreUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetExploreUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetExploreUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGrafanaWorkspaceRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var grafanaWorkspaceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.grafanaWorkspaceId != nil {
            map["GrafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("GrafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["GrafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetGrafanaWorkspaceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GrafanaWorkspace?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GrafanaWorkspace()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class GetGrafanaWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGrafanaWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGrafanaWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIntegrationStateRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integration: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integration != nil {
            map["Integration"] = self.integration!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Integration") {
            self.integration = dict["Integration"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetIntegrationStateResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var state: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Bool
        }
    }
}

public class GetIntegrationStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIntegrationStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetIntegrationStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetManagedPrometheusStatusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class GetManagedPrometheusStatusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetManagedPrometheusStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetManagedPrometheusStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetManagedPrometheusStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultipleTraceRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var regionId: String?

    public var startTime: Int64?

    public var traceIDs: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.traceIDs != nil {
            map["TraceIDs"] = self.traceIDs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TraceIDs") {
            self.traceIDs = dict["TraceIDs"] as! [String]
        }
    }
}

public class GetMultipleTraceResponseBody : Tea.TeaModel {
    public class MultiCallChainInfos : Tea.TeaModel {
        public class Spans : Tea.TeaModel {
            public class LogEventList : Tea.TeaModel {
                public class TagEntryList : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagEntryList: [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList.TagEntryList]?

                public var timestamp: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagEntryList != nil {
                        var tmp : [Any] = []
                        for k in self.tagEntryList! {
                            tmp.append(k.toMap())
                        }
                        map["TagEntryList"] = tmp
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagEntryList") {
                        var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList.TagEntryList] = []
                        for v in dict["TagEntryList"] as! [Any] {
                            var model = GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList.TagEntryList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tagEntryList = tmp
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                }
            }
            public class TagEntryList : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var duration: Int64?

            public var haveStack: Bool?

            public var logEventList: [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList]?

            public var operationName: String?

            public var parentSpanId: String?

            public var resultCode: String?

            public var rpcId: String?

            public var rpcType: Int32?

            public var serviceIp: String?

            public var serviceName: String?

            public var spanId: String?

            public var tagEntryList: [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.TagEntryList]?

            public var timestamp: Int64?

            public var traceID: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.haveStack != nil {
                    map["HaveStack"] = self.haveStack!
                }
                if self.logEventList != nil {
                    var tmp : [Any] = []
                    for k in self.logEventList! {
                        tmp.append(k.toMap())
                    }
                    map["LogEventList"] = tmp
                }
                if self.operationName != nil {
                    map["OperationName"] = self.operationName!
                }
                if self.parentSpanId != nil {
                    map["ParentSpanId"] = self.parentSpanId!
                }
                if self.resultCode != nil {
                    map["ResultCode"] = self.resultCode!
                }
                if self.rpcId != nil {
                    map["RpcId"] = self.rpcId!
                }
                if self.rpcType != nil {
                    map["RpcType"] = self.rpcType!
                }
                if self.serviceIp != nil {
                    map["ServiceIp"] = self.serviceIp!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.spanId != nil {
                    map["SpanId"] = self.spanId!
                }
                if self.tagEntryList != nil {
                    var tmp : [Any] = []
                    for k in self.tagEntryList! {
                        tmp.append(k.toMap())
                    }
                    map["TagEntryList"] = tmp
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.traceID != nil {
                    map["TraceID"] = self.traceID!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("HaveStack") {
                    self.haveStack = dict["HaveStack"] as! Bool
                }
                if dict.keys.contains("LogEventList") {
                    var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList] = []
                    for v in dict["LogEventList"] as! [Any] {
                        var model = GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.logEventList = tmp
                }
                if dict.keys.contains("OperationName") {
                    self.operationName = dict["OperationName"] as! String
                }
                if dict.keys.contains("ParentSpanId") {
                    self.parentSpanId = dict["ParentSpanId"] as! String
                }
                if dict.keys.contains("ResultCode") {
                    self.resultCode = dict["ResultCode"] as! String
                }
                if dict.keys.contains("RpcId") {
                    self.rpcId = dict["RpcId"] as! String
                }
                if dict.keys.contains("RpcType") {
                    self.rpcType = dict["RpcType"] as! Int32
                }
                if dict.keys.contains("ServiceIp") {
                    self.serviceIp = dict["ServiceIp"] as! String
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("SpanId") {
                    self.spanId = dict["SpanId"] as! String
                }
                if dict.keys.contains("TagEntryList") {
                    var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.TagEntryList] = []
                    for v in dict["TagEntryList"] as! [Any] {
                        var model = GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.TagEntryList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tagEntryList = tmp
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("TraceID") {
                    self.traceID = dict["TraceID"] as! String
                }
            }
        }
        public var spans: [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans]?

        public var traceID: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.spans != nil {
                var tmp : [Any] = []
                for k in self.spans! {
                    tmp.append(k.toMap())
                }
                map["Spans"] = tmp
            }
            if self.traceID != nil {
                map["TraceID"] = self.traceID!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Spans") {
                var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans] = []
                for v in dict["Spans"] as! [Any] {
                    var model = GetMultipleTraceResponseBody.MultiCallChainInfos.Spans()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.spans = tmp
            }
            if dict.keys.contains("TraceID") {
                self.traceID = dict["TraceID"] as! String
            }
        }
    }
    public var multiCallChainInfos: [GetMultipleTraceResponseBody.MultiCallChainInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.multiCallChainInfos != nil {
            var tmp : [Any] = []
            for k in self.multiCallChainInfos! {
                tmp.append(k.toMap())
            }
            map["MultiCallChainInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MultiCallChainInfos") {
            var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos] = []
            for v in dict["MultiCallChainInfos"] as! [Any] {
                var model = GetMultipleTraceResponseBody.MultiCallChainInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.multiCallChainInfos = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMultipleTraceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultipleTraceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMultipleTraceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOnCallSchedulesDetailRequest : Tea.TeaModel {
    public var endTime: String?

    public var id: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetOnCallSchedulesDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RenderedFinnalEntries : Tea.TeaModel {
            public class SimpleContact : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var end: String?

            public var simpleContact: GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries.SimpleContact?

            public var start: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.simpleContact?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.simpleContact != nil {
                    map["SimpleContact"] = self.simpleContact?.toMap()
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") {
                    self.end = dict["End"] as! String
                }
                if dict.keys.contains("SimpleContact") {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries.SimpleContact()
                    model.fromMap(dict["SimpleContact"] as! [String: Any])
                    self.simpleContact = model
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! String
                }
            }
        }
        public class RenderedLayerEntries : Tea.TeaModel {
            public class SimpleContact : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var start: String?

            public var end: String?

            public var simpleContact: GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries.SimpleContact?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.simpleContact?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.start != nil {
                    map["Start"] = self.start!
                }
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.simpleContact != nil {
                    map["SimpleContact"] = self.simpleContact?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! String
                }
                if dict.keys.contains("End") {
                    self.end = dict["End"] as! String
                }
                if dict.keys.contains("SimpleContact") {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries.SimpleContact()
                    model.fromMap(dict["SimpleContact"] as! [String: Any])
                    self.simpleContact = model
                }
            }
        }
        public class RenderedSubstitudeEntries : Tea.TeaModel {
            public class SimpleContact : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var end: String?

            public var simpleContact: GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries.SimpleContact?

            public var start: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.simpleContact?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.simpleContact != nil {
                    map["SimpleContact"] = self.simpleContact?.toMap()
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") {
                    self.end = dict["End"] as! String
                }
                if dict.keys.contains("SimpleContact") {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries.SimpleContact()
                    model.fromMap(dict["SimpleContact"] as! [String: Any])
                    self.simpleContact = model
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! String
                }
            }
        }
        public class ScheduleLayers : Tea.TeaModel {
            public class Restrictions : Tea.TeaModel {
                public var endTimeOfDay: String?

                public var restrictionType: String?

                public var startTimeOfDay: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTimeOfDay != nil {
                        map["EndTimeOfDay"] = self.endTimeOfDay!
                    }
                    if self.restrictionType != nil {
                        map["RestrictionType"] = self.restrictionType!
                    }
                    if self.startTimeOfDay != nil {
                        map["StartTimeOfDay"] = self.startTimeOfDay!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTimeOfDay") {
                        self.endTimeOfDay = dict["EndTimeOfDay"] as! String
                    }
                    if dict.keys.contains("RestrictionType") {
                        self.restrictionType = dict["RestrictionType"] as! String
                    }
                    if dict.keys.contains("StartTimeOfDay") {
                        self.startTimeOfDay = dict["StartTimeOfDay"] as! String
                    }
                }
            }
            public var contactIds: [Int64]?

            public var restrictions: [GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers.Restrictions]?

            public var rotationType: String?

            public var shiftLength: Int64?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactIds != nil {
                    map["ContactIds"] = self.contactIds!
                }
                if self.restrictions != nil {
                    var tmp : [Any] = []
                    for k in self.restrictions! {
                        tmp.append(k.toMap())
                    }
                    map["Restrictions"] = tmp
                }
                if self.rotationType != nil {
                    map["RotationType"] = self.rotationType!
                }
                if self.shiftLength != nil {
                    map["ShiftLength"] = self.shiftLength!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactIds") {
                    self.contactIds = dict["ContactIds"] as! [Int64]
                }
                if dict.keys.contains("Restrictions") {
                    var tmp : [GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers.Restrictions] = []
                    for v in dict["Restrictions"] as! [Any] {
                        var model = GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers.Restrictions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restrictions = tmp
                }
                if dict.keys.contains("RotationType") {
                    self.rotationType = dict["RotationType"] as! String
                }
                if dict.keys.contains("ShiftLength") {
                    self.shiftLength = dict["ShiftLength"] as! Int64
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var alertRobotId: Int64?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var renderedFinnalEntries: [GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries]?

        public var renderedLayerEntries: [[GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries]]?

        public var renderedSubstitudeEntries: [GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries]?

        public var scheduleLayers: [GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertRobotId != nil {
                map["AlertRobotId"] = self.alertRobotId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.renderedFinnalEntries != nil {
                var tmp : [Any] = []
                for k in self.renderedFinnalEntries! {
                    tmp.append(k.toMap())
                }
                map["RenderedFinnalEntries"] = tmp
            }
            if self.renderedLayerEntries != nil {
                var tmp : [Any] = []
                for k in self.renderedLayerEntries! {
                    var l1 : [Any] = []
                    for k1 in k {
                        l1.append(k1.toMap())
                    }
                    tmp.append(l1)
                }
                map["RenderedLayerEntries"] = tmp
            }
            if self.renderedSubstitudeEntries != nil {
                var tmp : [Any] = []
                for k in self.renderedSubstitudeEntries! {
                    tmp.append(k.toMap())
                }
                map["RenderedSubstitudeEntries"] = tmp
            }
            if self.scheduleLayers != nil {
                var tmp : [Any] = []
                for k in self.scheduleLayers! {
                    tmp.append(k.toMap())
                }
                map["ScheduleLayers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertRobotId") {
                self.alertRobotId = dict["AlertRobotId"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RenderedFinnalEntries") {
                var tmp : [GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries] = []
                for v in dict["RenderedFinnalEntries"] as! [Any] {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.renderedFinnalEntries = tmp
            }
            if dict.keys.contains("RenderedLayerEntries") {
                var tmp : [[GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries]] = []
                for v in dict["RenderedLayerEntries"] as! [Any] {
                    var l1 : [GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries] = []
                    for v1 in v as! [Any] {
                        var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries()
                        if v1 != nil {
                            model.fromMap(v1 as! [String: Any])
                        }
                        l1.append(model)
                    }
                    tmp.append(l1)
                }
                self.renderedLayerEntries = tmp
            }
            if dict.keys.contains("RenderedSubstitudeEntries") {
                var tmp : [GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries] = []
                for v in dict["RenderedSubstitudeEntries"] as! [Any] {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.renderedSubstitudeEntries = tmp
            }
            if dict.keys.contains("ScheduleLayers") {
                var tmp : [GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers] = []
                for v in dict["ScheduleLayers"] as! [Any] {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scheduleLayers = tmp
            }
        }
    }
    public var data: GetOnCallSchedulesDetailResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetOnCallSchedulesDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetOnCallSchedulesDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOnCallSchedulesDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOnCallSchedulesDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusApiTokenRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetPrometheusApiTokenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetPrometheusApiTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusApiTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPrometheusApiTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusGlobalViewRequest : Tea.TeaModel {
    public var globalViewClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalViewClusterId") {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusInstanceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetPrometheusInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var accessType: String?

        public var archiveDuration: Int32?

        public var authToken: String?

        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: String?

        public var grafanaInstanceId: String?

        public var httpApiInterUrl: String?

        public var httpApiIntraUrl: String?

        public var paymentType: String?

        public var pushGatewayInterUrl: String?

        public var pushGatewayIntraUrl: String?

        public var regionId: String?

        public var remoteReadInterUrl: String?

        public var remoteReadIntraUrl: String?

        public var remoteWriteInterUrl: String?

        public var remoteWriteIntraUrl: String?

        public var resourceGroupId: String?

        public var resourceType: String?

        public var securityGroupId: String?

        public var storageDuration: Int32?

        public var subClustersJson: String?

        public var tags: [GetPrometheusInstanceResponseBody.Data.Tags]?

        public var userId: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessType != nil {
                map["AccessType"] = self.accessType!
            }
            if self.archiveDuration != nil {
                map["ArchiveDuration"] = self.archiveDuration!
            }
            if self.authToken != nil {
                map["AuthToken"] = self.authToken!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.grafanaInstanceId != nil {
                map["GrafanaInstanceId"] = self.grafanaInstanceId!
            }
            if self.httpApiInterUrl != nil {
                map["HttpApiInterUrl"] = self.httpApiInterUrl!
            }
            if self.httpApiIntraUrl != nil {
                map["HttpApiIntraUrl"] = self.httpApiIntraUrl!
            }
            if self.paymentType != nil {
                map["PaymentType"] = self.paymentType!
            }
            if self.pushGatewayInterUrl != nil {
                map["PushGatewayInterUrl"] = self.pushGatewayInterUrl!
            }
            if self.pushGatewayIntraUrl != nil {
                map["PushGatewayIntraUrl"] = self.pushGatewayIntraUrl!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.remoteReadInterUrl != nil {
                map["RemoteReadInterUrl"] = self.remoteReadInterUrl!
            }
            if self.remoteReadIntraUrl != nil {
                map["RemoteReadIntraUrl"] = self.remoteReadIntraUrl!
            }
            if self.remoteWriteInterUrl != nil {
                map["RemoteWriteInterUrl"] = self.remoteWriteInterUrl!
            }
            if self.remoteWriteIntraUrl != nil {
                map["RemoteWriteIntraUrl"] = self.remoteWriteIntraUrl!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.storageDuration != nil {
                map["StorageDuration"] = self.storageDuration!
            }
            if self.subClustersJson != nil {
                map["SubClustersJson"] = self.subClustersJson!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessType") {
                self.accessType = dict["AccessType"] as! String
            }
            if dict.keys.contains("ArchiveDuration") {
                self.archiveDuration = dict["ArchiveDuration"] as! Int32
            }
            if dict.keys.contains("AuthToken") {
                self.authToken = dict["AuthToken"] as! String
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("GrafanaInstanceId") {
                self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
            }
            if dict.keys.contains("HttpApiInterUrl") {
                self.httpApiInterUrl = dict["HttpApiInterUrl"] as! String
            }
            if dict.keys.contains("HttpApiIntraUrl") {
                self.httpApiIntraUrl = dict["HttpApiIntraUrl"] as! String
            }
            if dict.keys.contains("PaymentType") {
                self.paymentType = dict["PaymentType"] as! String
            }
            if dict.keys.contains("PushGatewayInterUrl") {
                self.pushGatewayInterUrl = dict["PushGatewayInterUrl"] as! String
            }
            if dict.keys.contains("PushGatewayIntraUrl") {
                self.pushGatewayIntraUrl = dict["PushGatewayIntraUrl"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RemoteReadInterUrl") {
                self.remoteReadInterUrl = dict["RemoteReadInterUrl"] as! String
            }
            if dict.keys.contains("RemoteReadIntraUrl") {
                self.remoteReadIntraUrl = dict["RemoteReadIntraUrl"] as! String
            }
            if dict.keys.contains("RemoteWriteInterUrl") {
                self.remoteWriteInterUrl = dict["RemoteWriteInterUrl"] as! String
            }
            if dict.keys.contains("RemoteWriteIntraUrl") {
                self.remoteWriteIntraUrl = dict["RemoteWriteIntraUrl"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("StorageDuration") {
                self.storageDuration = dict["StorageDuration"] as! Int32
            }
            if dict.keys.contains("SubClustersJson") {
                self.subClustersJson = dict["SubClustersJson"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetPrometheusInstanceResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetPrometheusInstanceResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetPrometheusInstanceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetPrometheusInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPrometheusInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPrometheusInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceId: Int64?

    public var integrationType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("IntegrationType") {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetPrometheusIntegrationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var canDelete: Bool?

        public var canEditor: Bool?

        public var clusterId: String?

        public var containerName: String?

        public var describe: String?

        public var exporterType: String?

        public var instanceId: Int64?

        public var instanceName: String?

        public var integrationType: String?

        public var namespace: String?

        public var needUpgrade: Bool?

        public var param: String?

        public var showDescribe: Bool?

        public var showLog: String?

        public var status: String?

        public var target: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canDelete != nil {
                map["CanDelete"] = self.canDelete!
            }
            if self.canEditor != nil {
                map["CanEditor"] = self.canEditor!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.containerName != nil {
                map["ContainerName"] = self.containerName!
            }
            if self.describe != nil {
                map["Describe"] = self.describe!
            }
            if self.exporterType != nil {
                map["ExporterType"] = self.exporterType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.integrationType != nil {
                map["IntegrationType"] = self.integrationType!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.needUpgrade != nil {
                map["NeedUpgrade"] = self.needUpgrade!
            }
            if self.param != nil {
                map["Param"] = self.param!
            }
            if self.showDescribe != nil {
                map["ShowDescribe"] = self.showDescribe!
            }
            if self.showLog != nil {
                map["ShowLog"] = self.showLog!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanDelete") {
                self.canDelete = dict["CanDelete"] as! Bool
            }
            if dict.keys.contains("CanEditor") {
                self.canEditor = dict["CanEditor"] as! Bool
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ContainerName") {
                self.containerName = dict["ContainerName"] as! String
            }
            if dict.keys.contains("Describe") {
                self.describe = dict["Describe"] as! String
            }
            if dict.keys.contains("ExporterType") {
                self.exporterType = dict["ExporterType"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("IntegrationType") {
                self.integrationType = dict["IntegrationType"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NeedUpgrade") {
                self.needUpgrade = dict["NeedUpgrade"] as! Bool
            }
            if dict.keys.contains("Param") {
                self.param = dict["Param"] as! String
            }
            if dict.keys.contains("ShowDescribe") {
                self.showDescribe = dict["ShowDescribe"] as! Bool
            }
            if dict.keys.contains("ShowLog") {
                self.showLog = dict["ShowLog"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Target") {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetPrometheusIntegrationResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetPrometheusIntegrationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var monitoringName: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.monitoringName != nil {
            map["MonitoringName"] = self.monitoringName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MonitoringName") {
            self.monitoringName = dict["MonitoringName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetPrometheusMonitoringResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var configYaml: String?

        public var monitoringName: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.monitoringName != nil {
                map["MonitoringName"] = self.monitoringName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ConfigYaml") {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("MonitoringName") {
                self.monitoringName = dict["MonitoringName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetPrometheusMonitoringResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetPrometheusMonitoringResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusRemoteWriteRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var remoteWriteName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteWriteName != nil {
            map["RemoteWriteName"] = self.remoteWriteName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteWriteName") {
            self.remoteWriteName = dict["RemoteWriteName"] as! String
        }
    }
}

public class GetPrometheusRemoteWriteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var remoteWriteName: String?

        public var remoteWriteYaml: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.remoteWriteName != nil {
                map["RemoteWriteName"] = self.remoteWriteName!
            }
            if self.remoteWriteYaml != nil {
                map["RemoteWriteYaml"] = self.remoteWriteYaml!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("RemoteWriteName") {
                self.remoteWriteName = dict["RemoteWriteName"] as! String
            }
            if dict.keys.contains("RemoteWriteYaml") {
                self.remoteWriteYaml = dict["RemoteWriteYaml"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetPrometheusRemoteWriteResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetPrometheusRemoteWriteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPrometheusRemoteWriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusRemoteWriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPrometheusRemoteWriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRecordingRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetRecordingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetRecordingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRecordingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRecordingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRetcodeAppByPidRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pid: String?

    public var regionId: String?

    public var tags: [GetRetcodeAppByPidRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [GetRetcodeAppByPidRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetRetcodeAppByPidRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetRetcodeAppByPidResponseBody : Tea.TeaModel {
    public class RetcodeApp : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: String?

        public var appName: String?

        public var pid: String?

        public var resourceGroupId: String?

        public var retcodeAppType: String?

        public var tags: [GetRetcodeAppByPidResponseBody.RetcodeApp.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.retcodeAppType != nil {
                map["RetcodeAppType"] = self.retcodeAppType!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RetcodeAppType") {
                self.retcodeAppType = dict["RetcodeAppType"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetRetcodeAppByPidResponseBody.RetcodeApp.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetRetcodeAppByPidResponseBody.RetcodeApp.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var requestId: String?

    public var retcodeApp: GetRetcodeAppByPidResponseBody.RetcodeApp?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.retcodeApp?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retcodeApp != nil {
            map["RetcodeApp"] = self.retcodeApp?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetcodeApp") {
            var model = GetRetcodeAppByPidResponseBody.RetcodeApp()
            model.fromMap(dict["RetcodeApp"] as! [String: Any])
            self.retcodeApp = model
        }
    }
}

public class GetRetcodeAppByPidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRetcodeAppByPidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRetcodeAppByPidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRetcodeDataByQueryRequest : Tea.TeaModel {
    public var from: Int64?

    public var pid: String?

    public var query: String?

    public var regionId: String?

    public var to: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") {
            self.from = dict["From"] as! Int64
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("Query") {
            self.query = dict["Query"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("To") {
            self.to = dict["To"] as! Int64
        }
    }
}

public class GetRetcodeDataByQueryResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRetcodeDataByQueryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRetcodeDataByQueryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRetcodeDataByQueryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRetcodeLogstoreRequest : Tea.TeaModel {
    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetRetcodeLogstoreResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RetcodeSLSConfig : Tea.TeaModel {
            public var logstore: String?

            public var project: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logstore != nil {
                    map["Logstore"] = self.logstore!
                }
                if self.project != nil {
                    map["Project"] = self.project!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Logstore") {
                    self.logstore = dict["Logstore"] as! String
                }
                if dict.keys.contains("Project") {
                    self.project = dict["Project"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var message: String?

        public var retcodeSLSConfig: GetRetcodeLogstoreResponseBody.Data.RetcodeSLSConfig?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.retcodeSLSConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.retcodeSLSConfig != nil {
                map["RetcodeSLSConfig"] = self.retcodeSLSConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RetcodeSLSConfig") {
                var model = GetRetcodeLogstoreResponseBody.Data.RetcodeSLSConfig()
                model.fromMap(dict["RetcodeSLSConfig"] as! [String: Any])
                self.retcodeSLSConfig = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GetRetcodeLogstoreResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetRetcodeLogstoreResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetRetcodeLogstoreResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRetcodeLogstoreResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRetcodeLogstoreResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRetcodeShareUrlRequest : Tea.TeaModel {
    public var pid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
    }
}

public class GetRetcodeShareUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetRetcodeShareUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRetcodeShareUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRetcodeShareUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRumAppInfoRequest : Tea.TeaModel {
    public var appGroup: String?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGroup != nil {
            map["AppGroup"] = self.appGroup!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGroup") {
            self.appGroup = dict["AppGroup"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetRumAppInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ServiceDomainConfigs : Tea.TeaModel {
            public var description_: String?

            public var domain: String?

            public var propagatorTypes: [String]?

            public var tracing: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.propagatorTypes != nil {
                    map["PropagatorTypes"] = self.propagatorTypes!
                }
                if self.tracing != nil {
                    map["Tracing"] = self.tracing!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("PropagatorTypes") {
                    self.propagatorTypes = dict["PropagatorTypes"] as! [String]
                }
                if dict.keys.contains("Tracing") {
                    self.tracing = dict["Tracing"] as! Bool
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appType: String?

        public var createTime: String?

        public var description_: String?

        public var endpoint: String?

        public var isSubscription: String?

        public var name: String?

        public var nickName: String?

        public var packageName: String?

        public var pid: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var serviceDomainConfigs: [GetRumAppInfoResponseBody.Data.ServiceDomainConfigs]?

        public var slsLogstore: String?

        public var slsProject: String?

        public var status: String?

        public var tags: [GetRumAppInfoResponseBody.Data.Tags]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.isSubscription != nil {
                map["IsSubscription"] = self.isSubscription!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.packageName != nil {
                map["PackageName"] = self.packageName!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.serviceDomainConfigs != nil {
                var tmp : [Any] = []
                for k in self.serviceDomainConfigs! {
                    tmp.append(k.toMap())
                }
                map["ServiceDomainConfigs"] = tmp
            }
            if self.slsLogstore != nil {
                map["SlsLogstore"] = self.slsLogstore!
            }
            if self.slsProject != nil {
                map["SlsProject"] = self.slsProject!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppType") {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("IsSubscription") {
                self.isSubscription = dict["IsSubscription"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NickName") {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("PackageName") {
                self.packageName = dict["PackageName"] as! String
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ServiceDomainConfigs") {
                var tmp : [GetRumAppInfoResponseBody.Data.ServiceDomainConfigs] = []
                for v in dict["ServiceDomainConfigs"] as! [Any] {
                    var model = GetRumAppInfoResponseBody.Data.ServiceDomainConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceDomainConfigs = tmp
            }
            if dict.keys.contains("SlsLogstore") {
                self.slsLogstore = dict["SlsLogstore"] as! String
            }
            if dict.keys.contains("SlsProject") {
                self.slsProject = dict["SlsProject"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetRumAppInfoResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetRumAppInfoResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetRumAppInfoResponseBody.Data?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetRumAppInfoResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRumAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRumAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRumAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRumAppsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appGroup: String?

    public var appId: String?

    public var appName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [GetRumAppsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGroup != nil {
            map["AppGroup"] = self.appGroup!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGroup") {
            self.appGroup = dict["AppGroup"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [GetRumAppsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetRumAppsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetRumAppsResponseBody : Tea.TeaModel {
    public class AppList : Tea.TeaModel {
        public class ServiceDomainConfigs : Tea.TeaModel {
            public var description_: String?

            public var domain: String?

            public var propagatorTypes: [String]?

            public var tracing: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.propagatorTypes != nil {
                    map["PropagatorTypes"] = self.propagatorTypes!
                }
                if self.tracing != nil {
                    map["Tracing"] = self.tracing!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("PropagatorTypes") {
                    self.propagatorTypes = dict["PropagatorTypes"] as! [String]
                }
                if dict.keys.contains("Tracing") {
                    self.tracing = dict["Tracing"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appType: String?

        public var createTime: Any?

        public var description_: String?

        public var endpoint: String?

        public var isSubscription: Bool?

        public var name: String?

        public var nickName: String?

        public var packageName: String?

        public var pid: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var serviceDomainConfigs: [GetRumAppsResponseBody.AppList.ServiceDomainConfigs]?

        public var slsLogstore: String?

        public var slsProject: String?

        public var status: String?

        public var tags: [GetRumAppsResponseBody.AppList.Tags]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.isSubscription != nil {
                map["IsSubscription"] = self.isSubscription!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.packageName != nil {
                map["PackageName"] = self.packageName!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.serviceDomainConfigs != nil {
                var tmp : [Any] = []
                for k in self.serviceDomainConfigs! {
                    tmp.append(k.toMap())
                }
                map["ServiceDomainConfigs"] = tmp
            }
            if self.slsLogstore != nil {
                map["SlsLogstore"] = self.slsLogstore!
            }
            if self.slsProject != nil {
                map["SlsProject"] = self.slsProject!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppType") {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Any
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("IsSubscription") {
                self.isSubscription = dict["IsSubscription"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NickName") {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("PackageName") {
                self.packageName = dict["PackageName"] as! String
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ServiceDomainConfigs") {
                var tmp : [GetRumAppsResponseBody.AppList.ServiceDomainConfigs] = []
                for v in dict["ServiceDomainConfigs"] as! [Any] {
                    var model = GetRumAppsResponseBody.AppList.ServiceDomainConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceDomainConfigs = tmp
            }
            if dict.keys.contains("SlsLogstore") {
                self.slsLogstore = dict["SlsLogstore"] as! String
            }
            if dict.keys.contains("SlsProject") {
                self.slsProject = dict["SlsProject"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetRumAppsResponseBody.AppList.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetRumAppsResponseBody.AppList.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var appList: [GetRumAppsResponseBody.AppList]?

    public var code: Int32?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appList != nil {
            var tmp : [Any] = []
            for k in self.appList! {
                tmp.append(k.toMap())
            }
            map["AppList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppList") {
            var tmp : [GetRumAppsResponseBody.AppList] = []
            for v in dict["AppList"] as! [Any] {
                var model = GetRumAppsResponseBody.AppList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.appList = tmp
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRumAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRumAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRumAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRumDataForPageRequest : Tea.TeaModel {
    public var appGroup: String?

    public var currentPage: Int32?

    public var endTime: Int32?

    public var pageSize: Int32?

    public var pid: String?

    public var query: String?

    public var regionId: String?

    public var startTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appGroup != nil {
            map["AppGroup"] = self.appGroup!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppGroup") {
            self.appGroup = dict["AppGroup"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("Query") {
            self.query = dict["Query"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int32
        }
    }
}

public class GetRumDataForPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var authentication: String?

        public var completion: String?

        public var items: [[String: Any]]?

        public var page: String?

        public var pageSize: String?

        public var preference: String?

        public var total: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authentication != nil {
                map["Authentication"] = self.authentication!
            }
            if self.completion != nil {
                map["Completion"] = self.completion!
            }
            if self.items != nil {
                map["Items"] = self.items!
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.preference != nil {
                map["Preference"] = self.preference!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Authentication") {
                self.authentication = dict["Authentication"] as! String
            }
            if dict.keys.contains("Completion") {
                self.completion = dict["Completion"] as! String
            }
            if dict.keys.contains("Items") {
                self.items = dict["Items"] as! [[String: Any]]
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("Preference") {
                self.preference = dict["Preference"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetRumDataForPageResponseBody.Data?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetRumDataForPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetRumDataForPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRumDataForPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRumDataForPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRumExceptionStackRequest : Tea.TeaModel {
    public var exceptionBinaryImages: String?

    public var exceptionStack: String?

    public var exceptionThreadId: String?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exceptionBinaryImages != nil {
            map["ExceptionBinaryImages"] = self.exceptionBinaryImages!
        }
        if self.exceptionStack != nil {
            map["ExceptionStack"] = self.exceptionStack!
        }
        if self.exceptionThreadId != nil {
            map["ExceptionThreadId"] = self.exceptionThreadId!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExceptionBinaryImages") {
            self.exceptionBinaryImages = dict["ExceptionBinaryImages"] as! String
        }
        if dict.keys.contains("ExceptionStack") {
            self.exceptionStack = dict["ExceptionStack"] as! String
        }
        if dict.keys.contains("ExceptionThreadId") {
            self.exceptionThreadId = dict["ExceptionThreadId"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetRumExceptionStackResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var lines: [String]?

        public var threadId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lines != nil {
                map["Lines"] = self.lines!
            }
            if self.threadId != nil {
                map["ThreadId"] = self.threadId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Lines") {
                self.lines = dict["Lines"] as! [String]
            }
            if dict.keys.contains("ThreadId") {
                self.threadId = dict["ThreadId"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetRumExceptionStackResponseBody.Data?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetRumExceptionStackResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetRumExceptionStackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRumExceptionStackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRumExceptionStackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRumUploadFilesRequest : Tea.TeaModel {
    public var appType: String?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetRumUploadFilesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileName: String?

        public var lastModifiedTime: Any?

        public var size: String?

        public var uuid: String?

        public var versionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.lastModifiedTime != nil {
                map["LastModifiedTime"] = self.lastModifiedTime!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.versionId != nil {
                map["VersionId"] = self.versionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("LastModifiedTime") {
                self.lastModifiedTime = dict["LastModifiedTime"] as! Any
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("Uuid") {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VersionId") {
                self.versionId = dict["VersionId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetRumUploadFilesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [GetRumUploadFilesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetRumUploadFilesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRumUploadFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRumUploadFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRumUploadFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSourceMapInfoRequest : Tea.TeaModel {
    public var ascendingSequence: Bool?

    public var edition: String?

    public var ID: String?

    public var keyword: String?

    public var orderField: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ascendingSequence != nil {
            map["AscendingSequence"] = self.ascendingSequence!
        }
        if self.edition != nil {
            map["Edition"] = self.edition!
        }
        if self.ID != nil {
            map["ID"] = self.ID!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.orderField != nil {
            map["OrderField"] = self.orderField!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AscendingSequence") {
            self.ascendingSequence = dict["AscendingSequence"] as! Bool
        }
        if dict.keys.contains("Edition") {
            self.edition = dict["Edition"] as! String
        }
        if dict.keys.contains("ID") {
            self.ID = dict["ID"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("OrderField") {
            self.orderField = dict["OrderField"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetSourceMapInfoResponseBody : Tea.TeaModel {
    public class SourceMapList : Tea.TeaModel {
        public var fid: String?

        public var fileName: String?

        public var size: String?

        public var uploadTime: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fid != nil {
                map["Fid"] = self.fid!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.uploadTime != nil {
                map["UploadTime"] = self.uploadTime!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Fid") {
                self.fid = dict["Fid"] as! String
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("UploadTime") {
                self.uploadTime = dict["UploadTime"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var sourceMapList: [GetSourceMapInfoResponseBody.SourceMapList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceMapList != nil {
            var tmp : [Any] = []
            for k in self.sourceMapList! {
                tmp.append(k.toMap())
            }
            map["SourceMapList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceMapList") {
            var tmp : [GetSourceMapInfoResponseBody.SourceMapList] = []
            for v in dict["SourceMapList"] as! [Any] {
                var model = GetSourceMapInfoResponseBody.SourceMapList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sourceMapList = tmp
        }
    }
}

public class GetSourceMapInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSourceMapInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSourceMapInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStackRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var pid: String?

    public var regionId: String?

    public var rpcID: String?

    public var startTime: Int64?

    public var traceID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rpcID != nil {
            map["RpcID"] = self.rpcID!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.traceID != nil {
            map["TraceID"] = self.traceID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RpcID") {
            self.rpcID = dict["RpcID"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TraceID") {
            self.traceID = dict["TraceID"] as! String
        }
    }
}

public class GetStackResponseBody : Tea.TeaModel {
    public class StackInfo : Tea.TeaModel {
        public class ExtInfo : Tea.TeaModel {
            public var info: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.info != nil {
                    map["Info"] = self.info!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Info") {
                    self.info = dict["Info"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var api: String?

        public var duration: Int64?

        public var exception: String?

        public var extInfo: GetStackResponseBody.StackInfo.ExtInfo?

        public var line: String?

        public var rpcId: String?

        public var serviceName: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.api != nil {
                map["Api"] = self.api!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.exception != nil {
                map["Exception"] = self.exception!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo?.toMap()
            }
            if self.line != nil {
                map["Line"] = self.line!
            }
            if self.rpcId != nil {
                map["RpcId"] = self.rpcId!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Api") {
                self.api = dict["Api"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Exception") {
                self.exception = dict["Exception"] as! String
            }
            if dict.keys.contains("ExtInfo") {
                var model = GetStackResponseBody.StackInfo.ExtInfo()
                model.fromMap(dict["ExtInfo"] as! [String: Any])
                self.extInfo = model
            }
            if dict.keys.contains("Line") {
                self.line = dict["Line"] as! String
            }
            if dict.keys.contains("RpcId") {
                self.rpcId = dict["RpcId"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var stackInfo: [GetStackResponseBody.StackInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.stackInfo != nil {
            var tmp : [Any] = []
            for k in self.stackInfo! {
                tmp.append(k.toMap())
            }
            map["StackInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StackInfo") {
            var tmp : [GetStackResponseBody.StackInfo] = []
            for v in dict["StackInfo"] as! [Any] {
                var model = GetStackResponseBody.StackInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.stackInfo = tmp
        }
    }
}

public class GetStackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetStackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSyntheticMonitorsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var monitorCategory: Int32?

        public var network: Int32?

        public var taskType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorCategory != nil {
                map["MonitorCategory"] = self.monitorCategory!
            }
            if self.network != nil {
                map["Network"] = self.network!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorCategory") {
                self.monitorCategory = dict["MonitorCategory"] as! Int32
            }
            if dict.keys.contains("Network") {
                self.network = dict["Network"] as! Int32
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! Int32
            }
        }
    }
    public var filter: GetSyntheticMonitorsRequest.Filter?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filter?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            map["Filter"] = self.filter?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var model = GetSyntheticMonitorsRequest.Filter()
            model.fromMap(dict["Filter"] as! [String: Any])
            self.filter = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetSyntheticMonitorsShrinkRequest : Tea.TeaModel {
    public var filterShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterShrink != nil {
            map["Filter"] = self.filterShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            self.filterShrink = dict["Filter"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetSyntheticMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var available: String?

        public var canBeSelected: Bool?

        public var city: String?

        public var cityCode: String?

        public var clientType: Int32?

        public var country: String?

        public var ipv6: Int32?

        public var operator_: String?

        public var operatorCode: String?

        public var region: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.available != nil {
                map["Available"] = self.available!
            }
            if self.canBeSelected != nil {
                map["CanBeSelected"] = self.canBeSelected!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.country != nil {
                map["Country"] = self.country!
            }
            if self.ipv6 != nil {
                map["Ipv6"] = self.ipv6!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.operatorCode != nil {
                map["OperatorCode"] = self.operatorCode!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Available") {
                self.available = dict["Available"] as! String
            }
            if dict.keys.contains("CanBeSelected") {
                self.canBeSelected = dict["CanBeSelected"] as! Bool
            }
            if dict.keys.contains("City") {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("ClientType") {
                self.clientType = dict["ClientType"] as! Int32
            }
            if dict.keys.contains("Country") {
                self.country = dict["Country"] as! String
            }
            if dict.keys.contains("Ipv6") {
                self.ipv6 = dict["Ipv6"] as! Int32
            }
            if dict.keys.contains("Operator") {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("OperatorCode") {
                self.operatorCode = dict["OperatorCode"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: [GetSyntheticMonitorsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var tmp : [GetSyntheticMonitorsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetSyntheticMonitorsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSyntheticMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSyntheticMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSyntheticMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSyntheticTaskDetailRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetSyntheticTaskDetailResponseBody : Tea.TeaModel {
    public class TaskDetail : Tea.TeaModel {
        public class CommonParam : Tea.TeaModel {
            public class AlertList : Tea.TeaModel {
                public var generalAlert: String?

                public var isCritical: String?

                public var name: String?

                public var seriousAlert: String?

                public var symbols: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.generalAlert != nil {
                        map["GeneralAlert"] = self.generalAlert!
                    }
                    if self.isCritical != nil {
                        map["IsCritical"] = self.isCritical!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.seriousAlert != nil {
                        map["SeriousAlert"] = self.seriousAlert!
                    }
                    if self.symbols != nil {
                        map["Symbols"] = self.symbols!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GeneralAlert") {
                        self.generalAlert = dict["GeneralAlert"] as! String
                    }
                    if dict.keys.contains("IsCritical") {
                        self.isCritical = dict["IsCritical"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("SeriousAlert") {
                        self.seriousAlert = dict["SeriousAlert"] as! String
                    }
                    if dict.keys.contains("Symbols") {
                        self.symbols = dict["Symbols"] as! String
                    }
                }
            }
            public var alarmFlag: Int64?

            public var alertList: [GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam.AlertList]?

            public var alertNotifierId: String?

            public var alertPolicyId: String?

            public var monitorSamples: String?

            public var startExecutionTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmFlag != nil {
                    map["AlarmFlag"] = self.alarmFlag!
                }
                if self.alertList != nil {
                    var tmp : [Any] = []
                    for k in self.alertList! {
                        tmp.append(k.toMap())
                    }
                    map["AlertList"] = tmp
                }
                if self.alertNotifierId != nil {
                    map["AlertNotifierId"] = self.alertNotifierId!
                }
                if self.alertPolicyId != nil {
                    map["AlertPolicyId"] = self.alertPolicyId!
                }
                if self.monitorSamples != nil {
                    map["MonitorSamples"] = self.monitorSamples!
                }
                if self.startExecutionTime != nil {
                    map["StartExecutionTime"] = self.startExecutionTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmFlag") {
                    self.alarmFlag = dict["AlarmFlag"] as! Int64
                }
                if dict.keys.contains("AlertList") {
                    var tmp : [GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam.AlertList] = []
                    for v in dict["AlertList"] as! [Any] {
                        var model = GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam.AlertList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alertList = tmp
                }
                if dict.keys.contains("AlertNotifierId") {
                    self.alertNotifierId = dict["AlertNotifierId"] as! String
                }
                if dict.keys.contains("AlertPolicyId") {
                    self.alertPolicyId = dict["AlertPolicyId"] as! String
                }
                if dict.keys.contains("MonitorSamples") {
                    self.monitorSamples = dict["MonitorSamples"] as! String
                }
                if dict.keys.contains("StartExecutionTime") {
                    self.startExecutionTime = dict["StartExecutionTime"] as! String
                }
            }
        }
        public class Download : Tea.TeaModel {
            public var connectionTimeout: Int64?

            public var downloadCustomHeaderContent: String?

            public var downloadCustomHost: Int64?

            public var downloadCustomHostIp: String?

            public var downloadKernel: Int64?

            public var downloadRedirect: Int64?

            public var downloadTransmissionSize: Int64?

            public var monitorTimeout: Int64?

            public var quickProtocol: String?

            public var validateKeywords: String?

            public var verifyWay: Int64?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectionTimeout != nil {
                    map["ConnectionTimeout"] = self.connectionTimeout!
                }
                if self.downloadCustomHeaderContent != nil {
                    map["DownloadCustomHeaderContent"] = self.downloadCustomHeaderContent!
                }
                if self.downloadCustomHost != nil {
                    map["DownloadCustomHost"] = self.downloadCustomHost!
                }
                if self.downloadCustomHostIp != nil {
                    map["DownloadCustomHostIp"] = self.downloadCustomHostIp!
                }
                if self.downloadKernel != nil {
                    map["DownloadKernel"] = self.downloadKernel!
                }
                if self.downloadRedirect != nil {
                    map["DownloadRedirect"] = self.downloadRedirect!
                }
                if self.downloadTransmissionSize != nil {
                    map["DownloadTransmissionSize"] = self.downloadTransmissionSize!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.quickProtocol != nil {
                    map["QuickProtocol"] = self.quickProtocol!
                }
                if self.validateKeywords != nil {
                    map["ValidateKeywords"] = self.validateKeywords!
                }
                if self.verifyWay != nil {
                    map["VerifyWay"] = self.verifyWay!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectionTimeout") {
                    self.connectionTimeout = dict["ConnectionTimeout"] as! Int64
                }
                if dict.keys.contains("DownloadCustomHeaderContent") {
                    self.downloadCustomHeaderContent = dict["DownloadCustomHeaderContent"] as! String
                }
                if dict.keys.contains("DownloadCustomHost") {
                    self.downloadCustomHost = dict["DownloadCustomHost"] as! Int64
                }
                if dict.keys.contains("DownloadCustomHostIp") {
                    self.downloadCustomHostIp = dict["DownloadCustomHostIp"] as! String
                }
                if dict.keys.contains("DownloadKernel") {
                    self.downloadKernel = dict["DownloadKernel"] as! Int64
                }
                if dict.keys.contains("DownloadRedirect") {
                    self.downloadRedirect = dict["DownloadRedirect"] as! Int64
                }
                if dict.keys.contains("DownloadTransmissionSize") {
                    self.downloadTransmissionSize = dict["DownloadTransmissionSize"] as! Int64
                }
                if dict.keys.contains("MonitorTimeout") {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("QuickProtocol") {
                    self.quickProtocol = dict["QuickProtocol"] as! String
                }
                if dict.keys.contains("ValidateKeywords") {
                    self.validateKeywords = dict["ValidateKeywords"] as! String
                }
                if dict.keys.contains("VerifyWay") {
                    self.verifyWay = dict["VerifyWay"] as! Int64
                }
                if dict.keys.contains("WhiteList") {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class ExtendInterval : Tea.TeaModel {
            public var days: [Int64]?

            public var endMinute: Int64?

            public var endTime: String?

            public var endhour: Int64?

            public var startHour: Int64?

            public var startMinute: Int64?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.days != nil {
                    map["Days"] = self.days!
                }
                if self.endMinute != nil {
                    map["EndMinute"] = self.endMinute!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.endhour != nil {
                    map["Endhour"] = self.endhour!
                }
                if self.startHour != nil {
                    map["StartHour"] = self.startHour!
                }
                if self.startMinute != nil {
                    map["StartMinute"] = self.startMinute!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Days") {
                    self.days = dict["Days"] as! [Int64]
                }
                if dict.keys.contains("EndMinute") {
                    self.endMinute = dict["EndMinute"] as! Int64
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("Endhour") {
                    self.endhour = dict["Endhour"] as! Int64
                }
                if dict.keys.contains("StartHour") {
                    self.startHour = dict["StartHour"] as! Int64
                }
                if dict.keys.contains("StartMinute") {
                    self.startMinute = dict["StartMinute"] as! Int64
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public class MonitorList : Tea.TeaModel {
            public var cityCode: Int64?

            public var monitorType: Int64?

            public var netServiceId: Int64?

            public var sendCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.monitorType != nil {
                    map["MonitorType"] = self.monitorType!
                }
                if self.netServiceId != nil {
                    map["NetServiceId"] = self.netServiceId!
                }
                if self.sendCount != nil {
                    map["SendCount"] = self.sendCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! Int64
                }
                if dict.keys.contains("MonitorType") {
                    self.monitorType = dict["MonitorType"] as! Int64
                }
                if dict.keys.contains("NetServiceId") {
                    self.netServiceId = dict["NetServiceId"] as! Int64
                }
                if dict.keys.contains("SendCount") {
                    self.sendCount = dict["SendCount"] as! Int64
                }
            }
        }
        public class Nav : Tea.TeaModel {
            public var dnsHijackWhitelist: String?

            public var elementBlacklist: String?

            public var executeActiveX: Int64?

            public var executeApplet: Int64?

            public var executeScript: Int64?

            public var filterInvalidIP: Int64?

            public var flowHijackJumpTimes: Int64?

            public var flowHijackLogo: String?

            public var monitorTimeout: Int64?

            public var navAutomaticScrolling: Int64?

            public var navCustomHeader: String?

            public var navCustomHeaderContent: String?

            public var navCustomHost: Int64?

            public var navCustomHostIp: String?

            public var navDisableCache: Int64?

            public var navDisableCompression: Int64?

            public var navIgnoreCertificateError: Int64?

            public var navRedirect: Int64?

            public var navReturnElement: Int64?

            public var pageTampering: String?

            public var processName: String?

            public var quicDomain: String?

            public var quicVersion: Int64?

            public var requestHeader: Int64?

            public var slowElementThreshold: Int64?

            public var verifyStringBlacklist: String?

            public var verifyStringWhitelist: String?

            public var waitCompletionTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dnsHijackWhitelist != nil {
                    map["DnsHijackWhitelist"] = self.dnsHijackWhitelist!
                }
                if self.elementBlacklist != nil {
                    map["ElementBlacklist"] = self.elementBlacklist!
                }
                if self.executeActiveX != nil {
                    map["ExecuteActiveX"] = self.executeActiveX!
                }
                if self.executeApplet != nil {
                    map["ExecuteApplet"] = self.executeApplet!
                }
                if self.executeScript != nil {
                    map["ExecuteScript"] = self.executeScript!
                }
                if self.filterInvalidIP != nil {
                    map["FilterInvalidIP"] = self.filterInvalidIP!
                }
                if self.flowHijackJumpTimes != nil {
                    map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
                }
                if self.flowHijackLogo != nil {
                    map["FlowHijackLogo"] = self.flowHijackLogo!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.navAutomaticScrolling != nil {
                    map["NavAutomaticScrolling"] = self.navAutomaticScrolling!
                }
                if self.navCustomHeader != nil {
                    map["NavCustomHeader"] = self.navCustomHeader!
                }
                if self.navCustomHeaderContent != nil {
                    map["NavCustomHeaderContent"] = self.navCustomHeaderContent!
                }
                if self.navCustomHost != nil {
                    map["NavCustomHost"] = self.navCustomHost!
                }
                if self.navCustomHostIp != nil {
                    map["NavCustomHostIp"] = self.navCustomHostIp!
                }
                if self.navDisableCache != nil {
                    map["NavDisableCache"] = self.navDisableCache!
                }
                if self.navDisableCompression != nil {
                    map["NavDisableCompression"] = self.navDisableCompression!
                }
                if self.navIgnoreCertificateError != nil {
                    map["NavIgnoreCertificateError"] = self.navIgnoreCertificateError!
                }
                if self.navRedirect != nil {
                    map["NavRedirect"] = self.navRedirect!
                }
                if self.navReturnElement != nil {
                    map["NavReturnElement"] = self.navReturnElement!
                }
                if self.pageTampering != nil {
                    map["PageTampering"] = self.pageTampering!
                }
                if self.processName != nil {
                    map["ProcessName"] = self.processName!
                }
                if self.quicDomain != nil {
                    map["QuicDomain"] = self.quicDomain!
                }
                if self.quicVersion != nil {
                    map["QuicVersion"] = self.quicVersion!
                }
                if self.requestHeader != nil {
                    map["RequestHeader"] = self.requestHeader!
                }
                if self.slowElementThreshold != nil {
                    map["SlowElementThreshold"] = self.slowElementThreshold!
                }
                if self.verifyStringBlacklist != nil {
                    map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
                }
                if self.verifyStringWhitelist != nil {
                    map["VerifyStringWhitelist"] = self.verifyStringWhitelist!
                }
                if self.waitCompletionTime != nil {
                    map["WaitCompletionTime"] = self.waitCompletionTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DnsHijackWhitelist") {
                    self.dnsHijackWhitelist = dict["DnsHijackWhitelist"] as! String
                }
                if dict.keys.contains("ElementBlacklist") {
                    self.elementBlacklist = dict["ElementBlacklist"] as! String
                }
                if dict.keys.contains("ExecuteActiveX") {
                    self.executeActiveX = dict["ExecuteActiveX"] as! Int64
                }
                if dict.keys.contains("ExecuteApplet") {
                    self.executeApplet = dict["ExecuteApplet"] as! Int64
                }
                if dict.keys.contains("ExecuteScript") {
                    self.executeScript = dict["ExecuteScript"] as! Int64
                }
                if dict.keys.contains("FilterInvalidIP") {
                    self.filterInvalidIP = dict["FilterInvalidIP"] as! Int64
                }
                if dict.keys.contains("FlowHijackJumpTimes") {
                    self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int64
                }
                if dict.keys.contains("FlowHijackLogo") {
                    self.flowHijackLogo = dict["FlowHijackLogo"] as! String
                }
                if dict.keys.contains("MonitorTimeout") {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("NavAutomaticScrolling") {
                    self.navAutomaticScrolling = dict["NavAutomaticScrolling"] as! Int64
                }
                if dict.keys.contains("NavCustomHeader") {
                    self.navCustomHeader = dict["NavCustomHeader"] as! String
                }
                if dict.keys.contains("NavCustomHeaderContent") {
                    self.navCustomHeaderContent = dict["NavCustomHeaderContent"] as! String
                }
                if dict.keys.contains("NavCustomHost") {
                    self.navCustomHost = dict["NavCustomHost"] as! Int64
                }
                if dict.keys.contains("NavCustomHostIp") {
                    self.navCustomHostIp = dict["NavCustomHostIp"] as! String
                }
                if dict.keys.contains("NavDisableCache") {
                    self.navDisableCache = dict["NavDisableCache"] as! Int64
                }
                if dict.keys.contains("NavDisableCompression") {
                    self.navDisableCompression = dict["NavDisableCompression"] as! Int64
                }
                if dict.keys.contains("NavIgnoreCertificateError") {
                    self.navIgnoreCertificateError = dict["NavIgnoreCertificateError"] as! Int64
                }
                if dict.keys.contains("NavRedirect") {
                    self.navRedirect = dict["NavRedirect"] as! Int64
                }
                if dict.keys.contains("NavReturnElement") {
                    self.navReturnElement = dict["NavReturnElement"] as! Int64
                }
                if dict.keys.contains("PageTampering") {
                    self.pageTampering = dict["PageTampering"] as! String
                }
                if dict.keys.contains("ProcessName") {
                    self.processName = dict["ProcessName"] as! String
                }
                if dict.keys.contains("QuicDomain") {
                    self.quicDomain = dict["QuicDomain"] as! String
                }
                if dict.keys.contains("QuicVersion") {
                    self.quicVersion = dict["QuicVersion"] as! Int64
                }
                if dict.keys.contains("RequestHeader") {
                    self.requestHeader = dict["RequestHeader"] as! Int64
                }
                if dict.keys.contains("SlowElementThreshold") {
                    self.slowElementThreshold = dict["SlowElementThreshold"] as! Int64
                }
                if dict.keys.contains("VerifyStringBlacklist") {
                    self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
                }
                if dict.keys.contains("VerifyStringWhitelist") {
                    self.verifyStringWhitelist = dict["VerifyStringWhitelist"] as! String
                }
                if dict.keys.contains("WaitCompletionTime") {
                    self.waitCompletionTime = dict["WaitCompletionTime"] as! Int64
                }
            }
        }
        public class Net : Tea.TeaModel {
            public var netDigSwitch: Int64?

            public var netDnsNs: String?

            public var netDnsQueryMethod: String?

            public var netDnsServer: Int64?

            public var netDnsSwitch: Int64?

            public var netDnsTimeout: String?

            public var netIcmpActive: Int64?

            public var netIcmpDataCut: Int64?

            public var netIcmpInterval: Int64?

            public var netIcmpNum: Int64?

            public var netIcmpSize: Int64?

            public var netIcmpSwitch: Int64?

            public var netIcmpTimeout: Int64?

            public var netTraceRouteNum: Int64?

            public var netTraceRouteSwitch: Int64?

            public var netTraceRouteTimeout: Int64?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.netDigSwitch != nil {
                    map["NetDigSwitch"] = self.netDigSwitch!
                }
                if self.netDnsNs != nil {
                    map["NetDnsNs"] = self.netDnsNs!
                }
                if self.netDnsQueryMethod != nil {
                    map["NetDnsQueryMethod"] = self.netDnsQueryMethod!
                }
                if self.netDnsServer != nil {
                    map["NetDnsServer"] = self.netDnsServer!
                }
                if self.netDnsSwitch != nil {
                    map["NetDnsSwitch"] = self.netDnsSwitch!
                }
                if self.netDnsTimeout != nil {
                    map["NetDnsTimeout"] = self.netDnsTimeout!
                }
                if self.netIcmpActive != nil {
                    map["NetIcmpActive"] = self.netIcmpActive!
                }
                if self.netIcmpDataCut != nil {
                    map["NetIcmpDataCut"] = self.netIcmpDataCut!
                }
                if self.netIcmpInterval != nil {
                    map["NetIcmpInterval"] = self.netIcmpInterval!
                }
                if self.netIcmpNum != nil {
                    map["NetIcmpNum"] = self.netIcmpNum!
                }
                if self.netIcmpSize != nil {
                    map["NetIcmpSize"] = self.netIcmpSize!
                }
                if self.netIcmpSwitch != nil {
                    map["NetIcmpSwitch"] = self.netIcmpSwitch!
                }
                if self.netIcmpTimeout != nil {
                    map["NetIcmpTimeout"] = self.netIcmpTimeout!
                }
                if self.netTraceRouteNum != nil {
                    map["NetTraceRouteNum"] = self.netTraceRouteNum!
                }
                if self.netTraceRouteSwitch != nil {
                    map["NetTraceRouteSwitch"] = self.netTraceRouteSwitch!
                }
                if self.netTraceRouteTimeout != nil {
                    map["NetTraceRouteTimeout"] = self.netTraceRouteTimeout!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NetDigSwitch") {
                    self.netDigSwitch = dict["NetDigSwitch"] as! Int64
                }
                if dict.keys.contains("NetDnsNs") {
                    self.netDnsNs = dict["NetDnsNs"] as! String
                }
                if dict.keys.contains("NetDnsQueryMethod") {
                    self.netDnsQueryMethod = dict["NetDnsQueryMethod"] as! String
                }
                if dict.keys.contains("NetDnsServer") {
                    self.netDnsServer = dict["NetDnsServer"] as! Int64
                }
                if dict.keys.contains("NetDnsSwitch") {
                    self.netDnsSwitch = dict["NetDnsSwitch"] as! Int64
                }
                if dict.keys.contains("NetDnsTimeout") {
                    self.netDnsTimeout = dict["NetDnsTimeout"] as! String
                }
                if dict.keys.contains("NetIcmpActive") {
                    self.netIcmpActive = dict["NetIcmpActive"] as! Int64
                }
                if dict.keys.contains("NetIcmpDataCut") {
                    self.netIcmpDataCut = dict["NetIcmpDataCut"] as! Int64
                }
                if dict.keys.contains("NetIcmpInterval") {
                    self.netIcmpInterval = dict["NetIcmpInterval"] as! Int64
                }
                if dict.keys.contains("NetIcmpNum") {
                    self.netIcmpNum = dict["NetIcmpNum"] as! Int64
                }
                if dict.keys.contains("NetIcmpSize") {
                    self.netIcmpSize = dict["NetIcmpSize"] as! Int64
                }
                if dict.keys.contains("NetIcmpSwitch") {
                    self.netIcmpSwitch = dict["NetIcmpSwitch"] as! Int64
                }
                if dict.keys.contains("NetIcmpTimeout") {
                    self.netIcmpTimeout = dict["NetIcmpTimeout"] as! Int64
                }
                if dict.keys.contains("NetTraceRouteNum") {
                    self.netTraceRouteNum = dict["NetTraceRouteNum"] as! Int64
                }
                if dict.keys.contains("NetTraceRouteSwitch") {
                    self.netTraceRouteSwitch = dict["NetTraceRouteSwitch"] as! Int64
                }
                if dict.keys.contains("NetTraceRouteTimeout") {
                    self.netTraceRouteTimeout = dict["NetTraceRouteTimeout"] as! Int64
                }
                if dict.keys.contains("WhiteList") {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class Protocol_ : Tea.TeaModel {
            public class RequestContent : Tea.TeaModel {
                public class Body : Tea.TeaModel {
                    public class Formdata : Tea.TeaModel {
                        public var key: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Key") {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Urlencoded : Tea.TeaModel {
                        public var key: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Key") {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var formdata: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body.Formdata?

                    public var language: String?

                    public var mode: String?

                    public var raw: String?

                    public var urlencoded: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body.Urlencoded?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.formdata?.validate()
                        try self.urlencoded?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.formdata != nil {
                            map["Formdata"] = self.formdata?.toMap()
                        }
                        if self.language != nil {
                            map["Language"] = self.language!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.raw != nil {
                            map["Raw"] = self.raw!
                        }
                        if self.urlencoded != nil {
                            map["Urlencoded"] = self.urlencoded?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Formdata") {
                            var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body.Formdata()
                            model.fromMap(dict["Formdata"] as! [String: Any])
                            self.formdata = model
                        }
                        if dict.keys.contains("Language") {
                            self.language = dict["Language"] as! String
                        }
                        if dict.keys.contains("Mode") {
                            self.mode = dict["Mode"] as! String
                        }
                        if dict.keys.contains("Raw") {
                            self.raw = dict["Raw"] as! String
                        }
                        if dict.keys.contains("Urlencoded") {
                            var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body.Urlencoded()
                            model.fromMap(dict["Urlencoded"] as! [String: Any])
                            self.urlencoded = model
                        }
                    }
                }
                public class Header : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var body: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body?

                public var header: [GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Header]?

                public var method: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.body?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body?.toMap()
                    }
                    if self.header != nil {
                        var tmp : [Any] = []
                        for k in self.header! {
                            tmp.append(k.toMap())
                        }
                        map["Header"] = tmp
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") {
                        var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body()
                        model.fromMap(dict["Body"] as! [String: Any])
                        self.body = model
                    }
                    if dict.keys.contains("Header") {
                        var tmp : [GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Header] = []
                        for v in dict["Header"] as! [Any] {
                            var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Header()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.header = tmp
                    }
                    if dict.keys.contains("Method") {
                        self.method = dict["Method"] as! String
                    }
                }
            }
            public var characterEncoding: Int64?

            public var customHost: Int64?

            public var customHostIp: String?

            public var protocolConnectionTimeout: Int64?

            public var protocolMonitorTimeout: Int64?

            public var receivedDataSize: Int64?

            public var requestContent: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent?

            public var verifyContent: String?

            public var verifyWay: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.requestContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.characterEncoding != nil {
                    map["CharacterEncoding"] = self.characterEncoding!
                }
                if self.customHost != nil {
                    map["CustomHost"] = self.customHost!
                }
                if self.customHostIp != nil {
                    map["CustomHostIp"] = self.customHostIp!
                }
                if self.protocolConnectionTimeout != nil {
                    map["ProtocolConnectionTimeout"] = self.protocolConnectionTimeout!
                }
                if self.protocolMonitorTimeout != nil {
                    map["ProtocolMonitorTimeout"] = self.protocolMonitorTimeout!
                }
                if self.receivedDataSize != nil {
                    map["ReceivedDataSize"] = self.receivedDataSize!
                }
                if self.requestContent != nil {
                    map["RequestContent"] = self.requestContent?.toMap()
                }
                if self.verifyContent != nil {
                    map["VerifyContent"] = self.verifyContent!
                }
                if self.verifyWay != nil {
                    map["VerifyWay"] = self.verifyWay!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CharacterEncoding") {
                    self.characterEncoding = dict["CharacterEncoding"] as! Int64
                }
                if dict.keys.contains("CustomHost") {
                    self.customHost = dict["CustomHost"] as! Int64
                }
                if dict.keys.contains("CustomHostIp") {
                    self.customHostIp = dict["CustomHostIp"] as! String
                }
                if dict.keys.contains("ProtocolConnectionTimeout") {
                    self.protocolConnectionTimeout = dict["ProtocolConnectionTimeout"] as! Int64
                }
                if dict.keys.contains("ProtocolMonitorTimeout") {
                    self.protocolMonitorTimeout = dict["ProtocolMonitorTimeout"] as! Int64
                }
                if dict.keys.contains("ReceivedDataSize") {
                    self.receivedDataSize = dict["ReceivedDataSize"] as! Int64
                }
                if dict.keys.contains("RequestContent") {
                    var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent()
                    model.fromMap(dict["RequestContent"] as! [String: Any])
                    self.requestContent = model
                }
                if dict.keys.contains("VerifyContent") {
                    self.verifyContent = dict["VerifyContent"] as! String
                }
                if dict.keys.contains("VerifyWay") {
                    self.verifyWay = dict["VerifyWay"] as! Int64
                }
            }
        }
        public var commonParam: GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam?

        public var download: GetSyntheticTaskDetailResponseBody.TaskDetail.Download?

        public var extendInterval: GetSyntheticTaskDetailResponseBody.TaskDetail.ExtendInterval?

        public var intervalTime: Int64?

        public var intervalType: Int64?

        public var ipType: Int64?

        public var monitorList: [GetSyntheticTaskDetailResponseBody.TaskDetail.MonitorList]?

        public var monitorListString: String?

        public var nav: GetSyntheticTaskDetailResponseBody.TaskDetail.Nav?

        public var net: GetSyntheticTaskDetailResponseBody.TaskDetail.Net?

        public var protocol_: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_?

        public var taskId: Int64?

        public var taskName: String?

        public var taskType: Int64?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commonParam?.validate()
            try self.download?.validate()
            try self.extendInterval?.validate()
            try self.nav?.validate()
            try self.net?.validate()
            try self.protocol_?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commonParam != nil {
                map["CommonParam"] = self.commonParam?.toMap()
            }
            if self.download != nil {
                map["Download"] = self.download?.toMap()
            }
            if self.extendInterval != nil {
                map["ExtendInterval"] = self.extendInterval?.toMap()
            }
            if self.intervalTime != nil {
                map["IntervalTime"] = self.intervalTime!
            }
            if self.intervalType != nil {
                map["IntervalType"] = self.intervalType!
            }
            if self.ipType != nil {
                map["IpType"] = self.ipType!
            }
            if self.monitorList != nil {
                var tmp : [Any] = []
                for k in self.monitorList! {
                    tmp.append(k.toMap())
                }
                map["MonitorList"] = tmp
            }
            if self.monitorListString != nil {
                map["MonitorListString"] = self.monitorListString!
            }
            if self.nav != nil {
                map["Nav"] = self.nav?.toMap()
            }
            if self.net != nil {
                map["Net"] = self.net?.toMap()
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_?.toMap()
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommonParam") {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam()
                model.fromMap(dict["CommonParam"] as! [String: Any])
                self.commonParam = model
            }
            if dict.keys.contains("Download") {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Download()
                model.fromMap(dict["Download"] as! [String: Any])
                self.download = model
            }
            if dict.keys.contains("ExtendInterval") {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.ExtendInterval()
                model.fromMap(dict["ExtendInterval"] as! [String: Any])
                self.extendInterval = model
            }
            if dict.keys.contains("IntervalTime") {
                self.intervalTime = dict["IntervalTime"] as! Int64
            }
            if dict.keys.contains("IntervalType") {
                self.intervalType = dict["IntervalType"] as! Int64
            }
            if dict.keys.contains("IpType") {
                self.ipType = dict["IpType"] as! Int64
            }
            if dict.keys.contains("MonitorList") {
                var tmp : [GetSyntheticTaskDetailResponseBody.TaskDetail.MonitorList] = []
                for v in dict["MonitorList"] as! [Any] {
                    var model = GetSyntheticTaskDetailResponseBody.TaskDetail.MonitorList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorList = tmp
            }
            if dict.keys.contains("MonitorListString") {
                self.monitorListString = dict["MonitorListString"] as! String
            }
            if dict.keys.contains("Nav") {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Nav()
                model.fromMap(dict["Nav"] as! [String: Any])
                self.nav = model
            }
            if dict.keys.contains("Net") {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Net()
                model.fromMap(dict["Net"] as! [String: Any])
                self.net = model
            }
            if dict.keys.contains("Protocol") {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_()
                model.fromMap(dict["Protocol"] as! [String: Any])
                self.protocol_ = model
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! Int64
            }
            if dict.keys.contains("TaskName") {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! Int64
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var requestId: String?

    public var taskDetail: GetSyntheticTaskDetailResponseBody.TaskDetail?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskDetail != nil {
            map["TaskDetail"] = self.taskDetail?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskDetail") {
            var model = GetSyntheticTaskDetailResponseBody.TaskDetail()
            model.fromMap(dict["TaskDetail"] as! [String: Any])
            self.taskDetail = model
        }
    }
}

public class GetSyntheticTaskDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSyntheticTaskDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSyntheticTaskDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSyntheticTaskListRequest : Tea.TeaModel {
    public var direction: String?

    public var order: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var taskName: String?

    public var taskStatus: String?

    public var taskType: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskStatus") {
            self.taskStatus = dict["TaskStatus"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetSyntheticTaskListResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var createTime: String?

            public var monitorNumber: Int64?

            public var taskId: String?

            public var taskName: String?

            public var taskStatus: String?

            public var taskType: Int64?

            public var taskTypeName: String?

            public var url: String?

            public var usable: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.monitorNumber != nil {
                    map["MonitorNumber"] = self.monitorNumber!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.taskTypeName != nil {
                    map["TaskTypeName"] = self.taskTypeName!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.usable != nil {
                    map["Usable"] = self.usable!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("MonitorNumber") {
                    self.monitorNumber = dict["MonitorNumber"] as! Int64
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskName") {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TaskStatus") {
                    self.taskStatus = dict["TaskStatus"] as! String
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! Int64
                }
                if dict.keys.contains("TaskTypeName") {
                    self.taskTypeName = dict["TaskTypeName"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Usable") {
                    self.usable = dict["Usable"] as! Double
                }
            }
        }
        public var hasNextPage: String?

        public var hasPreviousPage: Bool?

        public var isFirstPage: Bool?

        public var isLastPage: Bool?

        public var list: [GetSyntheticTaskListResponseBody.PageInfo.List]?

        public var navigateFirstPage: String?

        public var navigateLastPage: String?

        public var navigatePageNums: String?

        public var nextPage: String?

        public var pages: String?

        public var prepage: String?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasNextPage != nil {
                map["HasNextPage"] = self.hasNextPage!
            }
            if self.hasPreviousPage != nil {
                map["HasPreviousPage"] = self.hasPreviousPage!
            }
            if self.isFirstPage != nil {
                map["IsFirstPage"] = self.isFirstPage!
            }
            if self.isLastPage != nil {
                map["IsLastPage"] = self.isLastPage!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.navigateFirstPage != nil {
                map["NavigateFirstPage"] = self.navigateFirstPage!
            }
            if self.navigateLastPage != nil {
                map["NavigateLastPage"] = self.navigateLastPage!
            }
            if self.navigatePageNums != nil {
                map["NavigatePageNums"] = self.navigatePageNums!
            }
            if self.nextPage != nil {
                map["NextPage"] = self.nextPage!
            }
            if self.pages != nil {
                map["Pages"] = self.pages!
            }
            if self.prepage != nil {
                map["Prepage"] = self.prepage!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HasNextPage") {
                self.hasNextPage = dict["HasNextPage"] as! String
            }
            if dict.keys.contains("HasPreviousPage") {
                self.hasPreviousPage = dict["HasPreviousPage"] as! Bool
            }
            if dict.keys.contains("IsFirstPage") {
                self.isFirstPage = dict["IsFirstPage"] as! Bool
            }
            if dict.keys.contains("IsLastPage") {
                self.isLastPage = dict["IsLastPage"] as! Bool
            }
            if dict.keys.contains("List") {
                var tmp : [GetSyntheticTaskListResponseBody.PageInfo.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetSyntheticTaskListResponseBody.PageInfo.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("NavigateFirstPage") {
                self.navigateFirstPage = dict["NavigateFirstPage"] as! String
            }
            if dict.keys.contains("NavigateLastPage") {
                self.navigateLastPage = dict["NavigateLastPage"] as! String
            }
            if dict.keys.contains("NavigatePageNums") {
                self.navigatePageNums = dict["NavigatePageNums"] as! String
            }
            if dict.keys.contains("NextPage") {
                self.nextPage = dict["NextPage"] as! String
            }
            if dict.keys.contains("Pages") {
                self.pages = dict["Pages"] as! String
            }
            if dict.keys.contains("Prepage") {
                self.prepage = dict["Prepage"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageInfo: GetSyntheticTaskListResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") {
            var model = GetSyntheticTaskListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSyntheticTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSyntheticTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSyntheticTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSyntheticTaskMonitorsRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetSyntheticTaskMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var busy: Int64?

        public var city: String?

        public var cityCode: Int64?

        public var clientType: Int64?

        public var district: String?

        public var netServiceId: Int64?

        public var netServiceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.busy != nil {
                map["Busy"] = self.busy!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.district != nil {
                map["District"] = self.district!
            }
            if self.netServiceId != nil {
                map["NetServiceId"] = self.netServiceId!
            }
            if self.netServiceName != nil {
                map["NetServiceName"] = self.netServiceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Busy") {
                self.busy = dict["Busy"] as! Int64
            }
            if dict.keys.contains("City") {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! Int64
            }
            if dict.keys.contains("ClientType") {
                self.clientType = dict["ClientType"] as! Int64
            }
            if dict.keys.contains("District") {
                self.district = dict["District"] as! String
            }
            if dict.keys.contains("NetServiceId") {
                self.netServiceId = dict["NetServiceId"] as! Int64
            }
            if dict.keys.contains("NetServiceName") {
                self.netServiceName = dict["NetServiceName"] as! String
            }
        }
    }
    public var code: String?

    public var data: [GetSyntheticTaskMonitorsResponseBody.Data]?

    public var msg: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [GetSyntheticTaskMonitorsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetSyntheticTaskMonitorsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Msg") {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSyntheticTaskMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSyntheticTaskMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSyntheticTaskMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTimingSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvailableAssertions : Tea.TeaModel {
            public var expect: String?

            public var operator_: String?

            public var target: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expect != nil {
                    map["Expect"] = self.expect!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.target != nil {
                    map["Target"] = self.target!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Expect") {
                    self.expect = dict["Expect"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Target") {
                    self.target = dict["Target"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class CommonSetting : Tea.TeaModel {
            public class CustomHost : Tea.TeaModel {
                public class Hosts : Tea.TeaModel {
                    public var domain: String?

                    public var ipType: Int32?

                    public var ips: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.domain != nil {
                            map["Domain"] = self.domain!
                        }
                        if self.ipType != nil {
                            map["IpType"] = self.ipType!
                        }
                        if self.ips != nil {
                            map["Ips"] = self.ips!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Domain") {
                            self.domain = dict["Domain"] as! String
                        }
                        if dict.keys.contains("IpType") {
                            self.ipType = dict["IpType"] as! Int32
                        }
                        if dict.keys.contains("Ips") {
                            self.ips = dict["Ips"] as! [String]
                        }
                    }
                }
                public var hosts: [GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost.Hosts]?

                public var selectType: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.hosts != nil {
                        var tmp : [Any] = []
                        for k in self.hosts! {
                            tmp.append(k.toMap())
                        }
                        map["Hosts"] = tmp
                    }
                    if self.selectType != nil {
                        map["SelectType"] = self.selectType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Hosts") {
                        var tmp : [GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost.Hosts] = []
                        for v in dict["Hosts"] as! [Any] {
                            var model = GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost.Hosts()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.hosts = tmp
                    }
                    if dict.keys.contains("SelectType") {
                        self.selectType = dict["SelectType"] as! Int32
                    }
                }
            }
            public class CustomPrometheusSetting : Tea.TeaModel {
                public var prometheusClusterId: String?

                public var prometheusClusterRegion: String?

                public var prometheusLabels: [String: String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.prometheusClusterId != nil {
                        map["PrometheusClusterId"] = self.prometheusClusterId!
                    }
                    if self.prometheusClusterRegion != nil {
                        map["PrometheusClusterRegion"] = self.prometheusClusterRegion!
                    }
                    if self.prometheusLabels != nil {
                        map["PrometheusLabels"] = self.prometheusLabels!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrometheusClusterId") {
                        self.prometheusClusterId = dict["PrometheusClusterId"] as! String
                    }
                    if dict.keys.contains("PrometheusClusterRegion") {
                        self.prometheusClusterRegion = dict["PrometheusClusterRegion"] as! String
                    }
                    if dict.keys.contains("PrometheusLabels") {
                        self.prometheusLabels = dict["PrometheusLabels"] as! [String: String]
                    }
                }
            }
            public class CustomVPCSetting : Tea.TeaModel {
                public var regionId: String?

                public var secureGroupId: String?

                public var vSwitchId: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.secureGroupId != nil {
                        map["SecureGroupId"] = self.secureGroupId!
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("SecureGroupId") {
                        self.secureGroupId = dict["SecureGroupId"] as! String
                    }
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public var customHost: GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost?

            public var customPrometheusSetting: GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomPrometheusSetting?

            public var customVPCSetting: GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomVPCSetting?

            public var ipType: Int32?

            public var isOpenTrace: Bool?

            public var monitorSamples: Int32?

            public var traceClientType: Int32?

            public var xtraceRegion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.customHost?.validate()
                try self.customPrometheusSetting?.validate()
                try self.customVPCSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customHost != nil {
                    map["CustomHost"] = self.customHost?.toMap()
                }
                if self.customPrometheusSetting != nil {
                    map["CustomPrometheusSetting"] = self.customPrometheusSetting?.toMap()
                }
                if self.customVPCSetting != nil {
                    map["CustomVPCSetting"] = self.customVPCSetting?.toMap()
                }
                if self.ipType != nil {
                    map["IpType"] = self.ipType!
                }
                if self.isOpenTrace != nil {
                    map["IsOpenTrace"] = self.isOpenTrace!
                }
                if self.monitorSamples != nil {
                    map["MonitorSamples"] = self.monitorSamples!
                }
                if self.traceClientType != nil {
                    map["TraceClientType"] = self.traceClientType!
                }
                if self.xtraceRegion != nil {
                    map["XtraceRegion"] = self.xtraceRegion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomHost") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost()
                    model.fromMap(dict["CustomHost"] as! [String: Any])
                    self.customHost = model
                }
                if dict.keys.contains("CustomPrometheusSetting") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomPrometheusSetting()
                    model.fromMap(dict["CustomPrometheusSetting"] as! [String: Any])
                    self.customPrometheusSetting = model
                }
                if dict.keys.contains("CustomVPCSetting") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomVPCSetting()
                    model.fromMap(dict["CustomVPCSetting"] as! [String: Any])
                    self.customVPCSetting = model
                }
                if dict.keys.contains("IpType") {
                    self.ipType = dict["IpType"] as! Int32
                }
                if dict.keys.contains("IsOpenTrace") {
                    self.isOpenTrace = dict["IsOpenTrace"] as! Bool
                }
                if dict.keys.contains("MonitorSamples") {
                    self.monitorSamples = dict["MonitorSamples"] as! Int32
                }
                if dict.keys.contains("TraceClientType") {
                    self.traceClientType = dict["TraceClientType"] as! Int32
                }
                if dict.keys.contains("XtraceRegion") {
                    self.xtraceRegion = dict["XtraceRegion"] as! String
                }
            }
        }
        public class CustomPeriod : Tea.TeaModel {
            public var endHour: Int64?

            public var startHour: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endHour != nil {
                    map["EndHour"] = self.endHour!
                }
                if self.startHour != nil {
                    map["StartHour"] = self.startHour!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndHour") {
                    self.endHour = dict["EndHour"] as! Int64
                }
                if dict.keys.contains("StartHour") {
                    self.startHour = dict["StartHour"] as! Int64
                }
            }
        }
        public class MonitorConf : Tea.TeaModel {
            public class ApiHTTP : Tea.TeaModel {
                public class RequestBody : Tea.TeaModel {
                    public var content: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var checkCert: Bool?

                public var connectTimeout: Int64?

                public var method: String?

                public var protocolAlpnProtocol: Int32?

                public var requestBody: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.ApiHTTP.RequestBody?

                public var requestHeaders: [String: String]?

                public var targetUrl: String?

                public var timeout: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.requestBody?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkCert != nil {
                        map["CheckCert"] = self.checkCert!
                    }
                    if self.connectTimeout != nil {
                        map["ConnectTimeout"] = self.connectTimeout!
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    if self.protocolAlpnProtocol != nil {
                        map["ProtocolAlpnProtocol"] = self.protocolAlpnProtocol!
                    }
                    if self.requestBody != nil {
                        map["RequestBody"] = self.requestBody?.toMap()
                    }
                    if self.requestHeaders != nil {
                        map["RequestHeaders"] = self.requestHeaders!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckCert") {
                        self.checkCert = dict["CheckCert"] as! Bool
                    }
                    if dict.keys.contains("ConnectTimeout") {
                        self.connectTimeout = dict["ConnectTimeout"] as! Int64
                    }
                    if dict.keys.contains("Method") {
                        self.method = dict["Method"] as! String
                    }
                    if dict.keys.contains("ProtocolAlpnProtocol") {
                        self.protocolAlpnProtocol = dict["ProtocolAlpnProtocol"] as! Int32
                    }
                    if dict.keys.contains("RequestBody") {
                        var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.ApiHTTP.RequestBody()
                        model.fromMap(dict["RequestBody"] as! [String: Any])
                        self.requestBody = model
                    }
                    if dict.keys.contains("RequestHeaders") {
                        self.requestHeaders = dict["RequestHeaders"] as! [String: String]
                    }
                    if dict.keys.contains("TargetUrl") {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("Timeout") {
                        self.timeout = dict["Timeout"] as! Int64
                    }
                }
            }
            public class FileDownload : Tea.TeaModel {
                public var connectionTimeout: Int64?

                public var customHeaderContent: [String: String]?

                public var downloadKernel: Int64?

                public var ignoreCertificateAuthError: Int32?

                public var ignoreCertificateCanceledError: Int32?

                public var ignoreCertificateOutOfDateError: Int32?

                public var ignoreCertificateStatusError: Int32?

                public var ignoreCertificateUntrustworthyError: Int32?

                public var ignoreCertificateUsingError: Int32?

                public var ignoreInvalidHostError: Int32?

                public var monitorTimeout: Int64?

                public var quickProtocol: Int64?

                public var redirection: Int32?

                public var targetUrl: String?

                public var transmissionSize: Int64?

                public var validateKeywords: String?

                public var verifyWay: Int32?

                public var whiteList: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionTimeout != nil {
                        map["ConnectionTimeout"] = self.connectionTimeout!
                    }
                    if self.customHeaderContent != nil {
                        map["CustomHeaderContent"] = self.customHeaderContent!
                    }
                    if self.downloadKernel != nil {
                        map["DownloadKernel"] = self.downloadKernel!
                    }
                    if self.ignoreCertificateAuthError != nil {
                        map["IgnoreCertificateAuthError"] = self.ignoreCertificateAuthError!
                    }
                    if self.ignoreCertificateCanceledError != nil {
                        map["IgnoreCertificateCanceledError"] = self.ignoreCertificateCanceledError!
                    }
                    if self.ignoreCertificateOutOfDateError != nil {
                        map["IgnoreCertificateOutOfDateError"] = self.ignoreCertificateOutOfDateError!
                    }
                    if self.ignoreCertificateStatusError != nil {
                        map["IgnoreCertificateStatusError"] = self.ignoreCertificateStatusError!
                    }
                    if self.ignoreCertificateUntrustworthyError != nil {
                        map["IgnoreCertificateUntrustworthyError"] = self.ignoreCertificateUntrustworthyError!
                    }
                    if self.ignoreCertificateUsingError != nil {
                        map["IgnoreCertificateUsingError"] = self.ignoreCertificateUsingError!
                    }
                    if self.ignoreInvalidHostError != nil {
                        map["IgnoreInvalidHostError"] = self.ignoreInvalidHostError!
                    }
                    if self.monitorTimeout != nil {
                        map["MonitorTimeout"] = self.monitorTimeout!
                    }
                    if self.quickProtocol != nil {
                        map["QuickProtocol"] = self.quickProtocol!
                    }
                    if self.redirection != nil {
                        map["Redirection"] = self.redirection!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.transmissionSize != nil {
                        map["TransmissionSize"] = self.transmissionSize!
                    }
                    if self.validateKeywords != nil {
                        map["ValidateKeywords"] = self.validateKeywords!
                    }
                    if self.verifyWay != nil {
                        map["VerifyWay"] = self.verifyWay!
                    }
                    if self.whiteList != nil {
                        map["WhiteList"] = self.whiteList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectionTimeout") {
                        self.connectionTimeout = dict["ConnectionTimeout"] as! Int64
                    }
                    if dict.keys.contains("CustomHeaderContent") {
                        self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                    }
                    if dict.keys.contains("DownloadKernel") {
                        self.downloadKernel = dict["DownloadKernel"] as! Int64
                    }
                    if dict.keys.contains("IgnoreCertificateAuthError") {
                        self.ignoreCertificateAuthError = dict["IgnoreCertificateAuthError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateCanceledError") {
                        self.ignoreCertificateCanceledError = dict["IgnoreCertificateCanceledError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateOutOfDateError") {
                        self.ignoreCertificateOutOfDateError = dict["IgnoreCertificateOutOfDateError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateStatusError") {
                        self.ignoreCertificateStatusError = dict["IgnoreCertificateStatusError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateUntrustworthyError") {
                        self.ignoreCertificateUntrustworthyError = dict["IgnoreCertificateUntrustworthyError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateUsingError") {
                        self.ignoreCertificateUsingError = dict["IgnoreCertificateUsingError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreInvalidHostError") {
                        self.ignoreInvalidHostError = dict["IgnoreInvalidHostError"] as! Int32
                    }
                    if dict.keys.contains("MonitorTimeout") {
                        self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                    }
                    if dict.keys.contains("QuickProtocol") {
                        self.quickProtocol = dict["QuickProtocol"] as! Int64
                    }
                    if dict.keys.contains("Redirection") {
                        self.redirection = dict["Redirection"] as! Int32
                    }
                    if dict.keys.contains("TargetUrl") {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("TransmissionSize") {
                        self.transmissionSize = dict["TransmissionSize"] as! Int64
                    }
                    if dict.keys.contains("ValidateKeywords") {
                        self.validateKeywords = dict["ValidateKeywords"] as! String
                    }
                    if dict.keys.contains("VerifyWay") {
                        self.verifyWay = dict["VerifyWay"] as! Int32
                    }
                    if dict.keys.contains("WhiteList") {
                        self.whiteList = dict["WhiteList"] as! String
                    }
                }
            }
            public class NetDNS : Tea.TeaModel {
                public var dnsServerIpType: Int32?

                public var nsServer: String?

                public var queryMethod: Int32?

                public var targetUrl: String?

                public var timeout: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dnsServerIpType != nil {
                        map["DnsServerIpType"] = self.dnsServerIpType!
                    }
                    if self.nsServer != nil {
                        map["NsServer"] = self.nsServer!
                    }
                    if self.queryMethod != nil {
                        map["QueryMethod"] = self.queryMethod!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DnsServerIpType") {
                        self.dnsServerIpType = dict["DnsServerIpType"] as! Int32
                    }
                    if dict.keys.contains("NsServer") {
                        self.nsServer = dict["NsServer"] as! String
                    }
                    if dict.keys.contains("QueryMethod") {
                        self.queryMethod = dict["QueryMethod"] as! Int32
                    }
                    if dict.keys.contains("TargetUrl") {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("Timeout") {
                        self.timeout = dict["Timeout"] as! Int64
                    }
                }
            }
            public class NetICMP : Tea.TeaModel {
                public var interval: Int32?

                public var packageNum: Int32?

                public var packageSize: Int32?

                public var splitPackage: Bool?

                public var targetUrl: String?

                public var timeout: Int64?

                public var tracertEnable: Bool?

                public var tracertNumMax: Int32?

                public var tracertTimeout: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.packageNum != nil {
                        map["PackageNum"] = self.packageNum!
                    }
                    if self.packageSize != nil {
                        map["PackageSize"] = self.packageSize!
                    }
                    if self.splitPackage != nil {
                        map["SplitPackage"] = self.splitPackage!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.tracertEnable != nil {
                        map["TracertEnable"] = self.tracertEnable!
                    }
                    if self.tracertNumMax != nil {
                        map["TracertNumMax"] = self.tracertNumMax!
                    }
                    if self.tracertTimeout != nil {
                        map["TracertTimeout"] = self.tracertTimeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("PackageNum") {
                        self.packageNum = dict["PackageNum"] as! Int32
                    }
                    if dict.keys.contains("PackageSize") {
                        self.packageSize = dict["PackageSize"] as! Int32
                    }
                    if dict.keys.contains("SplitPackage") {
                        self.splitPackage = dict["SplitPackage"] as! Bool
                    }
                    if dict.keys.contains("TargetUrl") {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("Timeout") {
                        self.timeout = dict["Timeout"] as! Int64
                    }
                    if dict.keys.contains("TracertEnable") {
                        self.tracertEnable = dict["TracertEnable"] as! Bool
                    }
                    if dict.keys.contains("TracertNumMax") {
                        self.tracertNumMax = dict["TracertNumMax"] as! Int32
                    }
                    if dict.keys.contains("TracertTimeout") {
                        self.tracertTimeout = dict["TracertTimeout"] as! Int64
                    }
                }
            }
            public class NetTCP : Tea.TeaModel {
                public var connectTimes: Int32?

                public var interval: Int64?

                public var targetUrl: String?

                public var timeout: Int64?

                public var tracertEnable: Bool?

                public var tracertNumMax: Int32?

                public var tracertTimeout: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectTimes != nil {
                        map["ConnectTimes"] = self.connectTimes!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.tracertEnable != nil {
                        map["TracertEnable"] = self.tracertEnable!
                    }
                    if self.tracertNumMax != nil {
                        map["TracertNumMax"] = self.tracertNumMax!
                    }
                    if self.tracertTimeout != nil {
                        map["TracertTimeout"] = self.tracertTimeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectTimes") {
                        self.connectTimes = dict["ConnectTimes"] as! Int32
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! Int64
                    }
                    if dict.keys.contains("TargetUrl") {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("Timeout") {
                        self.timeout = dict["Timeout"] as! Int64
                    }
                    if dict.keys.contains("TracertEnable") {
                        self.tracertEnable = dict["TracertEnable"] as! Bool
                    }
                    if dict.keys.contains("TracertNumMax") {
                        self.tracertNumMax = dict["TracertNumMax"] as! Int32
                    }
                    if dict.keys.contains("TracertTimeout") {
                        self.tracertTimeout = dict["TracertTimeout"] as! Int64
                    }
                }
            }
            public class Stream : Tea.TeaModel {
                public var customHeaderContent: [String: String]?

                public var playerType: Int32?

                public var streamAddressType: Int32?

                public var streamMonitorTimeout: Int32?

                public var streamType: Int32?

                public var targetUrl: String?

                public var whiteList: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.customHeaderContent != nil {
                        map["CustomHeaderContent"] = self.customHeaderContent!
                    }
                    if self.playerType != nil {
                        map["PlayerType"] = self.playerType!
                    }
                    if self.streamAddressType != nil {
                        map["StreamAddressType"] = self.streamAddressType!
                    }
                    if self.streamMonitorTimeout != nil {
                        map["StreamMonitorTimeout"] = self.streamMonitorTimeout!
                    }
                    if self.streamType != nil {
                        map["StreamType"] = self.streamType!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.whiteList != nil {
                        map["WhiteList"] = self.whiteList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CustomHeaderContent") {
                        self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                    }
                    if dict.keys.contains("PlayerType") {
                        self.playerType = dict["PlayerType"] as! Int32
                    }
                    if dict.keys.contains("StreamAddressType") {
                        self.streamAddressType = dict["StreamAddressType"] as! Int32
                    }
                    if dict.keys.contains("StreamMonitorTimeout") {
                        self.streamMonitorTimeout = dict["StreamMonitorTimeout"] as! Int32
                    }
                    if dict.keys.contains("StreamType") {
                        self.streamType = dict["StreamType"] as! Int32
                    }
                    if dict.keys.contains("TargetUrl") {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("WhiteList") {
                        self.whiteList = dict["WhiteList"] as! String
                    }
                }
            }
            public class Website : Tea.TeaModel {
                public var automaticScrolling: Int32?

                public var customHeader: Int32?

                public var customHeaderContent: [String: String]?

                public var DNSHijackWhitelist: String?

                public var disableCache: Int32?

                public var disableCompression: Int32?

                public var elementBlacklist: String?

                public var filterInvalidIP: Int32?

                public var flowHijackJumpTimes: Int32?

                public var flowHijackLogo: String?

                public var ignoreCertificateError: Int32?

                public var monitorTimeout: Int32?

                public var pageTamper: String?

                public var redirection: Int32?

                public var slowElementThreshold: Int64?

                public var targetUrl: String?

                public var verifyStringBlacklist: String?

                public var verifyStringWhitelist: String?

                public var waitCompletionTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.automaticScrolling != nil {
                        map["AutomaticScrolling"] = self.automaticScrolling!
                    }
                    if self.customHeader != nil {
                        map["CustomHeader"] = self.customHeader!
                    }
                    if self.customHeaderContent != nil {
                        map["CustomHeaderContent"] = self.customHeaderContent!
                    }
                    if self.DNSHijackWhitelist != nil {
                        map["DNSHijackWhitelist"] = self.DNSHijackWhitelist!
                    }
                    if self.disableCache != nil {
                        map["DisableCache"] = self.disableCache!
                    }
                    if self.disableCompression != nil {
                        map["DisableCompression"] = self.disableCompression!
                    }
                    if self.elementBlacklist != nil {
                        map["ElementBlacklist"] = self.elementBlacklist!
                    }
                    if self.filterInvalidIP != nil {
                        map["FilterInvalidIP"] = self.filterInvalidIP!
                    }
                    if self.flowHijackJumpTimes != nil {
                        map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
                    }
                    if self.flowHijackLogo != nil {
                        map["FlowHijackLogo"] = self.flowHijackLogo!
                    }
                    if self.ignoreCertificateError != nil {
                        map["IgnoreCertificateError"] = self.ignoreCertificateError!
                    }
                    if self.monitorTimeout != nil {
                        map["MonitorTimeout"] = self.monitorTimeout!
                    }
                    if self.pageTamper != nil {
                        map["PageTamper"] = self.pageTamper!
                    }
                    if self.redirection != nil {
                        map["Redirection"] = self.redirection!
                    }
                    if self.slowElementThreshold != nil {
                        map["SlowElementThreshold"] = self.slowElementThreshold!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.verifyStringBlacklist != nil {
                        map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
                    }
                    if self.verifyStringWhitelist != nil {
                        map["VerifyStringWhitelist"] = self.verifyStringWhitelist!
                    }
                    if self.waitCompletionTime != nil {
                        map["WaitCompletionTime"] = self.waitCompletionTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutomaticScrolling") {
                        self.automaticScrolling = dict["AutomaticScrolling"] as! Int32
                    }
                    if dict.keys.contains("CustomHeader") {
                        self.customHeader = dict["CustomHeader"] as! Int32
                    }
                    if dict.keys.contains("CustomHeaderContent") {
                        self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                    }
                    if dict.keys.contains("DNSHijackWhitelist") {
                        self.DNSHijackWhitelist = dict["DNSHijackWhitelist"] as! String
                    }
                    if dict.keys.contains("DisableCache") {
                        self.disableCache = dict["DisableCache"] as! Int32
                    }
                    if dict.keys.contains("DisableCompression") {
                        self.disableCompression = dict["DisableCompression"] as! Int32
                    }
                    if dict.keys.contains("ElementBlacklist") {
                        self.elementBlacklist = dict["ElementBlacklist"] as! String
                    }
                    if dict.keys.contains("FilterInvalidIP") {
                        self.filterInvalidIP = dict["FilterInvalidIP"] as! Int32
                    }
                    if dict.keys.contains("FlowHijackJumpTimes") {
                        self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int32
                    }
                    if dict.keys.contains("FlowHijackLogo") {
                        self.flowHijackLogo = dict["FlowHijackLogo"] as! String
                    }
                    if dict.keys.contains("IgnoreCertificateError") {
                        self.ignoreCertificateError = dict["IgnoreCertificateError"] as! Int32
                    }
                    if dict.keys.contains("MonitorTimeout") {
                        self.monitorTimeout = dict["MonitorTimeout"] as! Int32
                    }
                    if dict.keys.contains("PageTamper") {
                        self.pageTamper = dict["PageTamper"] as! String
                    }
                    if dict.keys.contains("Redirection") {
                        self.redirection = dict["Redirection"] as! Int32
                    }
                    if dict.keys.contains("SlowElementThreshold") {
                        self.slowElementThreshold = dict["SlowElementThreshold"] as! Int64
                    }
                    if dict.keys.contains("TargetUrl") {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("VerifyStringBlacklist") {
                        self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
                    }
                    if dict.keys.contains("VerifyStringWhitelist") {
                        self.verifyStringWhitelist = dict["VerifyStringWhitelist"] as! String
                    }
                    if dict.keys.contains("WaitCompletionTime") {
                        self.waitCompletionTime = dict["WaitCompletionTime"] as! Int64
                    }
                }
            }
            public var apiHTTP: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.ApiHTTP?

            public var fileDownload: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.FileDownload?

            public var netDNS: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetDNS?

            public var netICMP: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetICMP?

            public var netTCP: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetTCP?

            public var stream: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.Stream?

            public var website: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.Website?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.apiHTTP?.validate()
                try self.fileDownload?.validate()
                try self.netDNS?.validate()
                try self.netICMP?.validate()
                try self.netTCP?.validate()
                try self.stream?.validate()
                try self.website?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiHTTP != nil {
                    map["ApiHTTP"] = self.apiHTTP?.toMap()
                }
                if self.fileDownload != nil {
                    map["FileDownload"] = self.fileDownload?.toMap()
                }
                if self.netDNS != nil {
                    map["NetDNS"] = self.netDNS?.toMap()
                }
                if self.netICMP != nil {
                    map["NetICMP"] = self.netICMP?.toMap()
                }
                if self.netTCP != nil {
                    map["NetTCP"] = self.netTCP?.toMap()
                }
                if self.stream != nil {
                    map["Stream"] = self.stream?.toMap()
                }
                if self.website != nil {
                    map["Website"] = self.website?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiHTTP") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.ApiHTTP()
                    model.fromMap(dict["ApiHTTP"] as! [String: Any])
                    self.apiHTTP = model
                }
                if dict.keys.contains("FileDownload") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.FileDownload()
                    model.fromMap(dict["FileDownload"] as! [String: Any])
                    self.fileDownload = model
                }
                if dict.keys.contains("NetDNS") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetDNS()
                    model.fromMap(dict["NetDNS"] as! [String: Any])
                    self.netDNS = model
                }
                if dict.keys.contains("NetICMP") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetICMP()
                    model.fromMap(dict["NetICMP"] as! [String: Any])
                    self.netICMP = model
                }
                if dict.keys.contains("NetTCP") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetTCP()
                    model.fromMap(dict["NetTCP"] as! [String: Any])
                    self.netTCP = model
                }
                if dict.keys.contains("Stream") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.Stream()
                    model.fromMap(dict["Stream"] as! [String: Any])
                    self.stream = model
                }
                if dict.keys.contains("Website") {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.Website()
                    model.fromMap(dict["Website"] as! [String: Any])
                    self.website = model
                }
            }
        }
        public class Monitors : Tea.TeaModel {
            public var cityCode: String?

            public var clientType: Int32?

            public var operatorCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.clientType != nil {
                    map["ClientType"] = self.clientType!
                }
                if self.operatorCode != nil {
                    map["OperatorCode"] = self.operatorCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("ClientType") {
                    self.clientType = dict["ClientType"] as! Int32
                }
                if dict.keys.contains("OperatorCode") {
                    self.operatorCode = dict["OperatorCode"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var availableAssertions: [GetTimingSyntheticTaskResponseBody.Data.AvailableAssertions]?

        public var commonSetting: GetTimingSyntheticTaskResponseBody.Data.CommonSetting?

        public var customPeriod: GetTimingSyntheticTaskResponseBody.Data.CustomPeriod?

        public var frequency: String?

        public var monitorCategory: Int64?

        public var monitorConf: GetTimingSyntheticTaskResponseBody.Data.MonitorConf?

        public var monitors: [GetTimingSyntheticTaskResponseBody.Data.Monitors]?

        public var name: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var status: String?

        public var tags: [GetTimingSyntheticTaskResponseBody.Data.Tags]?

        public var taskId: String?

        public var taskType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commonSetting?.validate()
            try self.customPeriod?.validate()
            try self.monitorConf?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableAssertions != nil {
                var tmp : [Any] = []
                for k in self.availableAssertions! {
                    tmp.append(k.toMap())
                }
                map["AvailableAssertions"] = tmp
            }
            if self.commonSetting != nil {
                map["CommonSetting"] = self.commonSetting?.toMap()
            }
            if self.customPeriod != nil {
                map["CustomPeriod"] = self.customPeriod?.toMap()
            }
            if self.frequency != nil {
                map["Frequency"] = self.frequency!
            }
            if self.monitorCategory != nil {
                map["MonitorCategory"] = self.monitorCategory!
            }
            if self.monitorConf != nil {
                map["MonitorConf"] = self.monitorConf?.toMap()
            }
            if self.monitors != nil {
                var tmp : [Any] = []
                for k in self.monitors! {
                    tmp.append(k.toMap())
                }
                map["Monitors"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableAssertions") {
                var tmp : [GetTimingSyntheticTaskResponseBody.Data.AvailableAssertions] = []
                for v in dict["AvailableAssertions"] as! [Any] {
                    var model = GetTimingSyntheticTaskResponseBody.Data.AvailableAssertions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableAssertions = tmp
            }
            if dict.keys.contains("CommonSetting") {
                var model = GetTimingSyntheticTaskResponseBody.Data.CommonSetting()
                model.fromMap(dict["CommonSetting"] as! [String: Any])
                self.commonSetting = model
            }
            if dict.keys.contains("CustomPeriod") {
                var model = GetTimingSyntheticTaskResponseBody.Data.CustomPeriod()
                model.fromMap(dict["CustomPeriod"] as! [String: Any])
                self.customPeriod = model
            }
            if dict.keys.contains("Frequency") {
                self.frequency = dict["Frequency"] as! String
            }
            if dict.keys.contains("MonitorCategory") {
                self.monitorCategory = dict["MonitorCategory"] as! Int64
            }
            if dict.keys.contains("MonitorConf") {
                var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf()
                model.fromMap(dict["MonitorConf"] as! [String: Any])
                self.monitorConf = model
            }
            if dict.keys.contains("Monitors") {
                var tmp : [GetTimingSyntheticTaskResponseBody.Data.Monitors] = []
                for v in dict["Monitors"] as! [Any] {
                    var model = GetTimingSyntheticTaskResponseBody.Data.Monitors()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitors = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetTimingSyntheticTaskResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetTimingSyntheticTaskResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! Int32
            }
        }
    }
    public var code: Int64?

    public var data: GetTimingSyntheticTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetTimingSyntheticTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTraceRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var regionId: String?

    public var startTime: Int64?

    public var traceID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.traceID != nil {
            map["TraceID"] = self.traceID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TraceID") {
            self.traceID = dict["TraceID"] as! String
        }
    }
}

public class GetTraceResponseBody : Tea.TeaModel {
    public class Spans : Tea.TeaModel {
        public class LogEventList : Tea.TeaModel {
            public class TagEntryList : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var tagEntryList: [GetTraceResponseBody.Spans.LogEventList.TagEntryList]?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagEntryList != nil {
                    var tmp : [Any] = []
                    for k in self.tagEntryList! {
                        tmp.append(k.toMap())
                    }
                    map["TagEntryList"] = tmp
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagEntryList") {
                    var tmp : [GetTraceResponseBody.Spans.LogEventList.TagEntryList] = []
                    for v in dict["TagEntryList"] as! [Any] {
                        var model = GetTraceResponseBody.Spans.LogEventList.TagEntryList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tagEntryList = tmp
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
            }
        }
        public class TagEntryList : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var children: [[String: Any]]?

        public var duration: Int64?

        public var haveStack: Bool?

        public var logEventList: [GetTraceResponseBody.Spans.LogEventList]?

        public var operationName: String?

        public var parentSpanId: String?

        public var resultCode: String?

        public var rpcId: String?

        public var rpcType: Int32?

        public var serviceIp: String?

        public var serviceName: String?

        public var spanId: String?

        public var tagEntryList: [GetTraceResponseBody.Spans.TagEntryList]?

        public var timestamp: Int64?

        public var traceID: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.children != nil {
                map["Children"] = self.children!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.haveStack != nil {
                map["HaveStack"] = self.haveStack!
            }
            if self.logEventList != nil {
                var tmp : [Any] = []
                for k in self.logEventList! {
                    tmp.append(k.toMap())
                }
                map["LogEventList"] = tmp
            }
            if self.operationName != nil {
                map["OperationName"] = self.operationName!
            }
            if self.parentSpanId != nil {
                map["ParentSpanId"] = self.parentSpanId!
            }
            if self.resultCode != nil {
                map["ResultCode"] = self.resultCode!
            }
            if self.rpcId != nil {
                map["RpcId"] = self.rpcId!
            }
            if self.rpcType != nil {
                map["RpcType"] = self.rpcType!
            }
            if self.serviceIp != nil {
                map["ServiceIp"] = self.serviceIp!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.spanId != nil {
                map["SpanId"] = self.spanId!
            }
            if self.tagEntryList != nil {
                var tmp : [Any] = []
                for k in self.tagEntryList! {
                    tmp.append(k.toMap())
                }
                map["TagEntryList"] = tmp
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.traceID != nil {
                map["TraceID"] = self.traceID!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Children") {
                self.children = dict["Children"] as! [[String: Any]]
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("HaveStack") {
                self.haveStack = dict["HaveStack"] as! Bool
            }
            if dict.keys.contains("LogEventList") {
                var tmp : [GetTraceResponseBody.Spans.LogEventList] = []
                for v in dict["LogEventList"] as! [Any] {
                    var model = GetTraceResponseBody.Spans.LogEventList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logEventList = tmp
            }
            if dict.keys.contains("OperationName") {
                self.operationName = dict["OperationName"] as! String
            }
            if dict.keys.contains("ParentSpanId") {
                self.parentSpanId = dict["ParentSpanId"] as! String
            }
            if dict.keys.contains("ResultCode") {
                self.resultCode = dict["ResultCode"] as! String
            }
            if dict.keys.contains("RpcId") {
                self.rpcId = dict["RpcId"] as! String
            }
            if dict.keys.contains("RpcType") {
                self.rpcType = dict["RpcType"] as! Int32
            }
            if dict.keys.contains("ServiceIp") {
                self.serviceIp = dict["ServiceIp"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("SpanId") {
                self.spanId = dict["SpanId"] as! String
            }
            if dict.keys.contains("TagEntryList") {
                var tmp : [GetTraceResponseBody.Spans.TagEntryList] = []
                for v in dict["TagEntryList"] as! [Any] {
                    var model = GetTraceResponseBody.Spans.TagEntryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagEntryList = tmp
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TraceID") {
                self.traceID = dict["TraceID"] as! String
            }
        }
    }
    public var requestId: String?

    public var spans: [GetTraceResponseBody.Spans]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spans != nil {
            var tmp : [Any] = []
            for k in self.spans! {
                tmp.append(k.toMap())
            }
            map["Spans"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Spans") {
            var tmp : [GetTraceResponseBody.Spans] = []
            for v in dict["Spans"] as! [Any] {
                var model = GetTraceResponseBody.Spans()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spans = tmp
        }
    }
}

public class GetTraceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTraceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTraceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTraceAppRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pid: String?

    public var regionId: String?

    public var tags: [GetTraceAppRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [GetTraceAppRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetTraceAppRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetTraceAppResponseBody : Tea.TeaModel {
    public class TraceApp : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: Int64?

        public var appName: String?

        public var clusterId: String?

        public var createTime: Int64?

        public var labels: [String]?

        public var language: String?

        public var pid: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var show: Bool?

        public var source: String?

        public var tags: [GetTraceAppResponseBody.TraceApp.Tags]?

        public var type: String?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.labels != nil {
                map["Labels"] = self.labels!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.show != nil {
                map["Show"] = self.show!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Labels") {
                self.labels = dict["Labels"] as! [String]
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Show") {
                self.show = dict["Show"] as! Bool
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetTraceAppResponseBody.TraceApp.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetTraceAppResponseBody.TraceApp.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var requestId: String?

    public var traceApp: GetTraceAppResponseBody.TraceApp?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.traceApp?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceApp != nil {
            map["TraceApp"] = self.traceApp?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TraceApp") {
            var model = GetTraceAppResponseBody.TraceApp()
            model.fromMap(dict["TraceApp"] as! [String: Any])
            self.traceApp = model
        }
    }
}

public class GetTraceAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTraceAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTraceAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportAppAlertRulesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var contactGroupIds: String?

    public var isAutoStart: Bool?

    public var pids: String?

    public var regionId: String?

    public var tags: [ImportAppAlertRulesRequest.Tags]?

    public var templageAlertConfig: String?

    public var templateAlertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupIds != nil {
            map["ContactGroupIds"] = self.contactGroupIds!
        }
        if self.isAutoStart != nil {
            map["IsAutoStart"] = self.isAutoStart!
        }
        if self.pids != nil {
            map["Pids"] = self.pids!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.templageAlertConfig != nil {
            map["TemplageAlertConfig"] = self.templageAlertConfig!
        }
        if self.templateAlertId != nil {
            map["TemplateAlertId"] = self.templateAlertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupIds") {
            self.contactGroupIds = dict["ContactGroupIds"] as! String
        }
        if dict.keys.contains("IsAutoStart") {
            self.isAutoStart = dict["IsAutoStart"] as! Bool
        }
        if dict.keys.contains("Pids") {
            self.pids = dict["Pids"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ImportAppAlertRulesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ImportAppAlertRulesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TemplageAlertConfig") {
            self.templageAlertConfig = dict["TemplageAlertConfig"] as! String
        }
        if dict.keys.contains("TemplateAlertId") {
            self.templateAlertId = dict["TemplateAlertId"] as! String
        }
    }
}

public class ImportAppAlertRulesResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportAppAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportAppAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportAppAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitEnvironmentRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var createAuthToken: Bool?

    public var environmentId: String?

    public var managedType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.createAuthToken != nil {
            map["CreateAuthToken"] = self.createAuthToken!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.managedType != nil {
            map["ManagedType"] = self.managedType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("CreateAuthToken") {
            self.createAuthToken = dict["CreateAuthToken"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("ManagedType") {
            self.managedType = dict["ManagedType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class InitEnvironmentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InitEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InitEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallAddonRequest : Tea.TeaModel {
    public var addonVersion: String?

    public var aliyunLang: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var name: String?

    public var regionId: String?

    public var releaseName: String?

    public var values: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonVersion != nil {
            map["AddonVersion"] = self.addonVersion!
        }
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseName != nil {
            map["ReleaseName"] = self.releaseName!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonVersion") {
            self.addonVersion = dict["AddonVersion"] as! String
        }
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseName") {
            self.releaseName = dict["ReleaseName"] as! String
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! String
        }
    }
}

public class InstallAddonResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Conditions : Tea.TeaModel {
            public var firstTransitionTime: String?

            public var lastTransitionTime: String?

            public var message: String?

            public var reason: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.firstTransitionTime != nil {
                    map["FirstTransitionTime"] = self.firstTransitionTime!
                }
                if self.lastTransitionTime != nil {
                    map["LastTransitionTime"] = self.lastTransitionTime!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FirstTransitionTime") {
                    self.firstTransitionTime = dict["FirstTransitionTime"] as! String
                }
                if dict.keys.contains("LastTransitionTime") {
                    self.lastTransitionTime = dict["LastTransitionTime"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var addonName: String?

        public var alertRuleCount: Int64?

        public var conditions: [InstallAddonResponseBody.Data.Conditions]?

        public var createTime: String?

        public var dashboardCount: Int64?

        public var environmentId: String?

        public var exporterCount: Int64?

        public var haveConfig: Bool?

        public var installUserId: String?

        public var language: String?

        public var managed: Bool?

        public var regionId: String?

        public var releaseId: String?

        public var releaseName: String?

        public var scene: String?

        public var status: String?

        public var updateTime: String?

        public var userId: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addonName != nil {
                map["AddonName"] = self.addonName!
            }
            if self.alertRuleCount != nil {
                map["AlertRuleCount"] = self.alertRuleCount!
            }
            if self.conditions != nil {
                var tmp : [Any] = []
                for k in self.conditions! {
                    tmp.append(k.toMap())
                }
                map["Conditions"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dashboardCount != nil {
                map["DashboardCount"] = self.dashboardCount!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.exporterCount != nil {
                map["ExporterCount"] = self.exporterCount!
            }
            if self.haveConfig != nil {
                map["HaveConfig"] = self.haveConfig!
            }
            if self.installUserId != nil {
                map["InstallUserId"] = self.installUserId!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.managed != nil {
                map["Managed"] = self.managed!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.releaseId != nil {
                map["ReleaseId"] = self.releaseId!
            }
            if self.releaseName != nil {
                map["ReleaseName"] = self.releaseName!
            }
            if self.scene != nil {
                map["Scene"] = self.scene!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddonName") {
                self.addonName = dict["AddonName"] as! String
            }
            if dict.keys.contains("AlertRuleCount") {
                self.alertRuleCount = dict["AlertRuleCount"] as! Int64
            }
            if dict.keys.contains("Conditions") {
                var tmp : [InstallAddonResponseBody.Data.Conditions] = []
                for v in dict["Conditions"] as! [Any] {
                    var model = InstallAddonResponseBody.Data.Conditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditions = tmp
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DashboardCount") {
                self.dashboardCount = dict["DashboardCount"] as! Int64
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("ExporterCount") {
                self.exporterCount = dict["ExporterCount"] as! Int64
            }
            if dict.keys.contains("HaveConfig") {
                self.haveConfig = dict["HaveConfig"] as! Bool
            }
            if dict.keys.contains("InstallUserId") {
                self.installUserId = dict["InstallUserId"] as! String
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("Managed") {
                self.managed = dict["Managed"] as! Bool
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ReleaseId") {
                self.releaseId = dict["ReleaseId"] as! String
            }
            if dict.keys.contains("ReleaseName") {
                self.releaseName = dict["ReleaseName"] as! String
            }
            if dict.keys.contains("Scene") {
                self.scene = dict["Scene"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: InstallAddonResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = InstallAddonResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallAddonResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallAddonResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallAddonResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallCmsExporterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var cmsArgs: String?

    public var directArgs: String?

    public var enableTag: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cmsArgs != nil {
            map["CmsArgs"] = self.cmsArgs!
        }
        if self.directArgs != nil {
            map["DirectArgs"] = self.directArgs!
        }
        if self.enableTag != nil {
            map["EnableTag"] = self.enableTag!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CmsArgs") {
            self.cmsArgs = dict["CmsArgs"] as! String
        }
        if dict.keys.contains("DirectArgs") {
            self.directArgs = dict["DirectArgs"] as! String
        }
        if dict.keys.contains("EnableTag") {
            self.enableTag = dict["EnableTag"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class InstallCmsExporterResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InstallCmsExporterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallCmsExporterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallCmsExporterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallEnvironmentFeatureRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var config: String?

    public var environmentId: String?

    public var featureName: String?

    public var featureVersion: String?

    public var region: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.featureVersion != nil {
            map["FeatureVersion"] = self.featureVersion!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("FeatureVersion") {
            self.featureVersion = dict["FeatureVersion"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class InstallEnvironmentFeatureResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallManagedPrometheusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterName: String?

    public var clusterType: String?

    public var grafanaInstanceId: String?

    public var kubeConfig: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var securityGroupId: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.grafanaInstanceId != nil {
            map["GrafanaInstanceId"] = self.grafanaInstanceId!
        }
        if self.kubeConfig != nil {
            map["KubeConfig"] = self.kubeConfig!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("GrafanaInstanceId") {
            self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
        }
        if dict.keys.contains("KubeConfig") {
            self.kubeConfig = dict["KubeConfig"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class InstallManagedPrometheusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallManagedPrometheusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallManagedPrometheusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallManagedPrometheusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListActivatedAlertsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var filter: String?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Filter") {
            self.filter = dict["Filter"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListActivatedAlertsResponseBody : Tea.TeaModel {
    public class Page : Tea.TeaModel {
        public class Alerts : Tea.TeaModel {
            public class DispatchRules : Tea.TeaModel {
                public var ruleId: Int32?

                public var ruleName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! Int32
                    }
                    if dict.keys.contains("RuleName") {
                        self.ruleName = dict["RuleName"] as! String
                    }
                }
            }
            public var alertId: String?

            public var alertName: String?

            public var alertType: String?

            public var count: Int32?

            public var createTime: Int64?

            public var dispatchRules: [ListActivatedAlertsResponseBody.Page.Alerts.DispatchRules]?

            public var endsAt: Int64?

            public var expandFields: [String: Any]?

            public var integrationName: String?

            public var integrationType: String?

            public var involvedObjectKind: String?

            public var involvedObjectName: String?

            public var message: String?

            public var severity: String?

            public var startsAt: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dispatchRules != nil {
                    var tmp : [Any] = []
                    for k in self.dispatchRules! {
                        tmp.append(k.toMap())
                    }
                    map["DispatchRules"] = tmp
                }
                if self.endsAt != nil {
                    map["EndsAt"] = self.endsAt!
                }
                if self.expandFields != nil {
                    map["ExpandFields"] = self.expandFields!
                }
                if self.integrationName != nil {
                    map["IntegrationName"] = self.integrationName!
                }
                if self.integrationType != nil {
                    map["IntegrationType"] = self.integrationType!
                }
                if self.involvedObjectKind != nil {
                    map["InvolvedObjectKind"] = self.involvedObjectKind!
                }
                if self.involvedObjectName != nil {
                    map["InvolvedObjectName"] = self.involvedObjectName!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.startsAt != nil {
                    map["StartsAt"] = self.startsAt!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertId") {
                    self.alertId = dict["AlertId"] as! String
                }
                if dict.keys.contains("AlertName") {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("AlertType") {
                    self.alertType = dict["AlertType"] as! String
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DispatchRules") {
                    var tmp : [ListActivatedAlertsResponseBody.Page.Alerts.DispatchRules] = []
                    for v in dict["DispatchRules"] as! [Any] {
                        var model = ListActivatedAlertsResponseBody.Page.Alerts.DispatchRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dispatchRules = tmp
                }
                if dict.keys.contains("EndsAt") {
                    self.endsAt = dict["EndsAt"] as! Int64
                }
                if dict.keys.contains("ExpandFields") {
                    self.expandFields = dict["ExpandFields"] as! [String: Any]
                }
                if dict.keys.contains("IntegrationName") {
                    self.integrationName = dict["IntegrationName"] as! String
                }
                if dict.keys.contains("IntegrationType") {
                    self.integrationType = dict["IntegrationType"] as! String
                }
                if dict.keys.contains("InvolvedObjectKind") {
                    self.involvedObjectKind = dict["InvolvedObjectKind"] as! String
                }
                if dict.keys.contains("InvolvedObjectName") {
                    self.involvedObjectName = dict["InvolvedObjectName"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("StartsAt") {
                    self.startsAt = dict["StartsAt"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var alerts: [ListActivatedAlertsResponseBody.Page.Alerts]?

        public var page: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alerts != nil {
                var tmp : [Any] = []
                for k in self.alerts! {
                    tmp.append(k.toMap())
                }
                map["Alerts"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alerts") {
                var tmp : [ListActivatedAlertsResponseBody.Page.Alerts] = []
                for v in dict["Alerts"] as! [Any] {
                    var model = ListActivatedAlertsResponseBody.Page.Alerts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alerts = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var page: ListActivatedAlertsResponseBody.Page?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.page?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["Page"] = self.page?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Page") {
            var model = ListActivatedAlertsResponseBody.Page()
            model.fromMap(dict["Page"] as! [String: Any])
            self.page = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListActivatedAlertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListActivatedAlertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListActivatedAlertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAddonReleasesRequest : Tea.TeaModel {
    public var addonName: String?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonName != nil {
            map["AddonName"] = self.addonName!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonName") {
            self.addonName = dict["AddonName"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListAddonReleasesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Releases : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var firstTransitionTime: String?

                public var lastTransitionTime: String?

                public var message: String?

                public var reason: String?

                public var status: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.firstTransitionTime != nil {
                        map["FirstTransitionTime"] = self.firstTransitionTime!
                    }
                    if self.lastTransitionTime != nil {
                        map["LastTransitionTime"] = self.lastTransitionTime!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FirstTransitionTime") {
                        self.firstTransitionTime = dict["FirstTransitionTime"] as! String
                    }
                    if dict.keys.contains("LastTransitionTime") {
                        self.lastTransitionTime = dict["LastTransitionTime"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var addonName: String?

            public var alertRuleCount: Int64?

            public var conditions: [ListAddonReleasesResponseBody.Data.Releases.Conditions]?

            public var createTime: String?

            public var dashboardCount: Int64?

            public var environmentId: String?

            public var exporterCount: Int64?

            public var haveConfig: Bool?

            public var installUserId: String?

            public var language: String?

            public var managed: Bool?

            public var regionId: String?

            public var releaseId: String?

            public var releaseName: String?

            public var scene: String?

            public var status: String?

            public var updateTime: String?

            public var userId: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addonName != nil {
                    map["AddonName"] = self.addonName!
                }
                if self.alertRuleCount != nil {
                    map["AlertRuleCount"] = self.alertRuleCount!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["Conditions"] = tmp
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dashboardCount != nil {
                    map["DashboardCount"] = self.dashboardCount!
                }
                if self.environmentId != nil {
                    map["EnvironmentId"] = self.environmentId!
                }
                if self.exporterCount != nil {
                    map["ExporterCount"] = self.exporterCount!
                }
                if self.haveConfig != nil {
                    map["HaveConfig"] = self.haveConfig!
                }
                if self.installUserId != nil {
                    map["InstallUserId"] = self.installUserId!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.managed != nil {
                    map["Managed"] = self.managed!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.releaseId != nil {
                    map["ReleaseId"] = self.releaseId!
                }
                if self.releaseName != nil {
                    map["ReleaseName"] = self.releaseName!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddonName") {
                    self.addonName = dict["AddonName"] as! String
                }
                if dict.keys.contains("AlertRuleCount") {
                    self.alertRuleCount = dict["AlertRuleCount"] as! Int64
                }
                if dict.keys.contains("Conditions") {
                    var tmp : [ListAddonReleasesResponseBody.Data.Releases.Conditions] = []
                    for v in dict["Conditions"] as! [Any] {
                        var model = ListAddonReleasesResponseBody.Data.Releases.Conditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.conditions = tmp
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DashboardCount") {
                    self.dashboardCount = dict["DashboardCount"] as! Int64
                }
                if dict.keys.contains("EnvironmentId") {
                    self.environmentId = dict["EnvironmentId"] as! String
                }
                if dict.keys.contains("ExporterCount") {
                    self.exporterCount = dict["ExporterCount"] as! Int64
                }
                if dict.keys.contains("HaveConfig") {
                    self.haveConfig = dict["HaveConfig"] as! Bool
                }
                if dict.keys.contains("InstallUserId") {
                    self.installUserId = dict["InstallUserId"] as! String
                }
                if dict.keys.contains("Language") {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("Managed") {
                    self.managed = dict["Managed"] as! Bool
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReleaseId") {
                    self.releaseId = dict["ReleaseId"] as! String
                }
                if dict.keys.contains("ReleaseName") {
                    self.releaseName = dict["ReleaseName"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var releases: [ListAddonReleasesResponseBody.Data.Releases]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.releases != nil {
                var tmp : [Any] = []
                for k in self.releases! {
                    tmp.append(k.toMap())
                }
                map["Releases"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Releases") {
                var tmp : [ListAddonReleasesResponseBody.Data.Releases] = []
                for v in dict["Releases"] as! [Any] {
                    var model = ListAddonReleasesResponseBody.Data.Releases()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.releases = tmp
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListAddonReleasesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListAddonReleasesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAddonReleasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAddonReleasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAddonReleasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAddonsRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var category: String?

    public var regexp: Bool?

    public var regionId: String?

    public var search: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.regexp != nil {
            map["Regexp"] = self.regexp!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.search != nil {
            map["Search"] = self.search!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Regexp") {
            self.regexp = dict["Regexp"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Search") {
            self.search = dict["Search"] as! String
        }
    }
}

public class ListAddonsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Dashboards : Tea.TeaModel {
            public var description_: String?

            public var name: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class Environments : Tea.TeaModel {
            public class Dependencies : Tea.TeaModel {
                public var features: [String: Bool]?

                public var services: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.features != nil {
                        map["Features"] = self.features!
                    }
                    if self.services != nil {
                        map["Services"] = self.services!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Features") {
                        self.features = dict["Features"] as! [String: Bool]
                    }
                    if dict.keys.contains("Services") {
                        self.services = dict["Services"] as! [String]
                    }
                }
            }
            public class Policies : Tea.TeaModel {
                public class MetricCheckRule : Tea.TeaModel {
                    public var promQL: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.promQL != nil {
                            map["PromQL"] = self.promQL!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("PromQL") {
                            self.promQL = dict["PromQL"] as! [String]
                        }
                    }
                }
                public class Protocols : Tea.TeaModel {
                    public var description_: String?

                    public var icon: String?

                    public var label: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.icon != nil {
                            map["Icon"] = self.icon!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("Icon") {
                            self.icon = dict["Icon"] as! String
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var alertDefaultStatus: String?

                public var defaultInstall: Bool?

                public var enableServiceAccount: Bool?

                public var metricCheckRule: ListAddonsResponseBody.Data.Environments.Policies.MetricCheckRule?

                public var needRestartAfterIntegration: Bool?

                public var protocols: [ListAddonsResponseBody.Data.Environments.Policies.Protocols]?

                public var targetAddonName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.metricCheckRule?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alertDefaultStatus != nil {
                        map["AlertDefaultStatus"] = self.alertDefaultStatus!
                    }
                    if self.defaultInstall != nil {
                        map["DefaultInstall"] = self.defaultInstall!
                    }
                    if self.enableServiceAccount != nil {
                        map["EnableServiceAccount"] = self.enableServiceAccount!
                    }
                    if self.metricCheckRule != nil {
                        map["MetricCheckRule"] = self.metricCheckRule?.toMap()
                    }
                    if self.needRestartAfterIntegration != nil {
                        map["NeedRestartAfterIntegration"] = self.needRestartAfterIntegration!
                    }
                    if self.protocols != nil {
                        var tmp : [Any] = []
                        for k in self.protocols! {
                            tmp.append(k.toMap())
                        }
                        map["Protocols"] = tmp
                    }
                    if self.targetAddonName != nil {
                        map["TargetAddonName"] = self.targetAddonName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlertDefaultStatus") {
                        self.alertDefaultStatus = dict["AlertDefaultStatus"] as! String
                    }
                    if dict.keys.contains("DefaultInstall") {
                        self.defaultInstall = dict["DefaultInstall"] as! Bool
                    }
                    if dict.keys.contains("EnableServiceAccount") {
                        self.enableServiceAccount = dict["EnableServiceAccount"] as! Bool
                    }
                    if dict.keys.contains("MetricCheckRule") {
                        var model = ListAddonsResponseBody.Data.Environments.Policies.MetricCheckRule()
                        model.fromMap(dict["MetricCheckRule"] as! [String: Any])
                        self.metricCheckRule = model
                    }
                    if dict.keys.contains("NeedRestartAfterIntegration") {
                        self.needRestartAfterIntegration = dict["NeedRestartAfterIntegration"] as! Bool
                    }
                    if dict.keys.contains("Protocols") {
                        var tmp : [ListAddonsResponseBody.Data.Environments.Policies.Protocols] = []
                        for v in dict["Protocols"] as! [Any] {
                            var model = ListAddonsResponseBody.Data.Environments.Policies.Protocols()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.protocols = tmp
                    }
                    if dict.keys.contains("TargetAddonName") {
                        self.targetAddonName = dict["TargetAddonName"] as! String
                    }
                }
            }
            public var dependencies: ListAddonsResponseBody.Data.Environments.Dependencies?

            public var description_: String?

            public var enable: Bool?

            public var label: String?

            public var name: String?

            public var policies: ListAddonsResponseBody.Data.Environments.Policies?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dependencies?.validate()
                try self.policies?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dependencies != nil {
                    map["Dependencies"] = self.dependencies?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.policies != nil {
                    map["Policies"] = self.policies?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dependencies") {
                    var model = ListAddonsResponseBody.Data.Environments.Dependencies()
                    model.fromMap(dict["Dependencies"] as! [String: Any])
                    self.dependencies = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Policies") {
                    var model = ListAddonsResponseBody.Data.Environments.Policies()
                    model.fromMap(dict["Policies"] as! [String: Any])
                    self.policies = model
                }
            }
        }
        public var alias: String?

        public var categories: [String]?

        public var dashboards: [ListAddonsResponseBody.Data.Dashboards]?

        public var description_: String?

        public var environments: [ListAddonsResponseBody.Data.Environments]?

        public var icon: String?

        public var keywords: [String]?

        public var language: String?

        public var latestReleaseCreateTime: String?

        public var name: String?

        public var once: Bool?

        public var scene: String?

        public var version: String?

        public var weight: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.categories != nil {
                map["Categories"] = self.categories!
            }
            if self.dashboards != nil {
                var tmp : [Any] = []
                for k in self.dashboards! {
                    tmp.append(k.toMap())
                }
                map["Dashboards"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.environments != nil {
                var tmp : [Any] = []
                for k in self.environments! {
                    tmp.append(k.toMap())
                }
                map["Environments"] = tmp
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.keywords != nil {
                map["Keywords"] = self.keywords!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.latestReleaseCreateTime != nil {
                map["LatestReleaseCreateTime"] = self.latestReleaseCreateTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.once != nil {
                map["Once"] = self.once!
            }
            if self.scene != nil {
                map["Scene"] = self.scene!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("Categories") {
                self.categories = dict["Categories"] as! [String]
            }
            if dict.keys.contains("Dashboards") {
                var tmp : [ListAddonsResponseBody.Data.Dashboards] = []
                for v in dict["Dashboards"] as! [Any] {
                    var model = ListAddonsResponseBody.Data.Dashboards()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dashboards = tmp
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Environments") {
                var tmp : [ListAddonsResponseBody.Data.Environments] = []
                for v in dict["Environments"] as! [Any] {
                    var model = ListAddonsResponseBody.Data.Environments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.environments = tmp
            }
            if dict.keys.contains("Icon") {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("Keywords") {
                self.keywords = dict["Keywords"] as! [String]
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("LatestReleaseCreateTime") {
                self.latestReleaseCreateTime = dict["LatestReleaseCreateTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Once") {
                self.once = dict["Once"] as! Bool
            }
            if dict.keys.contains("Scene") {
                self.scene = dict["Scene"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListAddonsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListAddonsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAddonsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAddonsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAddonsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAddonsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlertEventsRequest : Tea.TeaModel {
    public var alertName: String?

    public var endTime: String?

    public var matchingConditions: String?

    public var page: Int64?

    public var showNotificationPolicies: Bool?

    public var size: Int64?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.matchingConditions != nil {
            map["MatchingConditions"] = self.matchingConditions!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.showNotificationPolicies != nil {
            map["ShowNotificationPolicies"] = self.showNotificationPolicies!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertName") {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("MatchingConditions") {
            self.matchingConditions = dict["MatchingConditions"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("ShowNotificationPolicies") {
            self.showNotificationPolicies = dict["ShowNotificationPolicies"] as! Bool
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListAlertEventsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class Events : Tea.TeaModel {
            public class Alarms : Tea.TeaModel {
                public var alarmId: Int64?

                public var alarmName: String?

                public var createTime: String?

                public var state: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alarmId != nil {
                        map["AlarmId"] = self.alarmId!
                    }
                    if self.alarmName != nil {
                        map["AlarmName"] = self.alarmName!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlarmId") {
                        self.alarmId = dict["AlarmId"] as! Int64
                    }
                    if dict.keys.contains("AlarmName") {
                        self.alarmName = dict["AlarmName"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! Int32
                    }
                }
            }
            public class NotificationPolicies : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var alarms: [ListAlertEventsResponseBody.PageBean.Events.Alarms]?

            public var alertName: String?

            public var annotations: String?

            public var description_: String?

            public var endTime: String?

            public var generatorURL: String?

            public var handlerName: String?

            public var integrationName: String?

            public var integrationType: String?

            public var labels: String?

            public var notificationPolicies: [ListAlertEventsResponseBody.PageBean.Events.NotificationPolicies]?

            public var receiveTime: String?

            public var severity: String?

            public var startTime: String?

            public var status: String?

            public var triggerCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarms != nil {
                    var tmp : [Any] = []
                    for k in self.alarms! {
                        tmp.append(k.toMap())
                    }
                    map["Alarms"] = tmp
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.annotations != nil {
                    map["Annotations"] = self.annotations!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.generatorURL != nil {
                    map["GeneratorURL"] = self.generatorURL!
                }
                if self.handlerName != nil {
                    map["HandlerName"] = self.handlerName!
                }
                if self.integrationName != nil {
                    map["IntegrationName"] = self.integrationName!
                }
                if self.integrationType != nil {
                    map["IntegrationType"] = self.integrationType!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.notificationPolicies != nil {
                    var tmp : [Any] = []
                    for k in self.notificationPolicies! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationPolicies"] = tmp
                }
                if self.receiveTime != nil {
                    map["ReceiveTime"] = self.receiveTime!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.triggerCount != nil {
                    map["TriggerCount"] = self.triggerCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alarms") {
                    var tmp : [ListAlertEventsResponseBody.PageBean.Events.Alarms] = []
                    for v in dict["Alarms"] as! [Any] {
                        var model = ListAlertEventsResponseBody.PageBean.Events.Alarms()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alarms = tmp
                }
                if dict.keys.contains("AlertName") {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("Annotations") {
                    self.annotations = dict["Annotations"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("GeneratorURL") {
                    self.generatorURL = dict["GeneratorURL"] as! String
                }
                if dict.keys.contains("HandlerName") {
                    self.handlerName = dict["HandlerName"] as! String
                }
                if dict.keys.contains("IntegrationName") {
                    self.integrationName = dict["IntegrationName"] as! String
                }
                if dict.keys.contains("IntegrationType") {
                    self.integrationType = dict["IntegrationType"] as! String
                }
                if dict.keys.contains("Labels") {
                    self.labels = dict["Labels"] as! String
                }
                if dict.keys.contains("NotificationPolicies") {
                    var tmp : [ListAlertEventsResponseBody.PageBean.Events.NotificationPolicies] = []
                    for v in dict["NotificationPolicies"] as! [Any] {
                        var model = ListAlertEventsResponseBody.PageBean.Events.NotificationPolicies()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notificationPolicies = tmp
                }
                if dict.keys.contains("ReceiveTime") {
                    self.receiveTime = dict["ReceiveTime"] as! String
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TriggerCount") {
                    self.triggerCount = dict["TriggerCount"] as! Int64
                }
            }
        }
        public var events: [ListAlertEventsResponseBody.PageBean.Events]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.events != nil {
                var tmp : [Any] = []
                for k in self.events! {
                    tmp.append(k.toMap())
                }
                map["Events"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Events") {
                var tmp : [ListAlertEventsResponseBody.PageBean.Events] = []
                for v in dict["Events"] as! [Any] {
                    var model = ListAlertEventsResponseBody.PageBean.Events()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.events = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListAlertEventsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = ListAlertEventsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAlertEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAlertEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlertsRequest : Tea.TeaModel {
    public var alertName: String?

    public var dispatchRuleId: Int64?

    public var endTime: String?

    public var integrationType: String?

    public var page: Int64?

    public var regionId: String?

    public var severity: String?

    public var showActivities: Bool?

    public var showEvents: Bool?

    public var size: Int64?

    public var startTime: String?

    public var state: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.dispatchRuleId != nil {
            map["DispatchRuleId"] = self.dispatchRuleId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.showActivities != nil {
            map["ShowActivities"] = self.showActivities!
        }
        if self.showEvents != nil {
            map["ShowEvents"] = self.showEvents!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertName") {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("DispatchRuleId") {
            self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IntegrationType") {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("ShowActivities") {
            self.showActivities = dict["ShowActivities"] as! Bool
        }
        if dict.keys.contains("ShowEvents") {
            self.showEvents = dict["ShowEvents"] as! Bool
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Int64
        }
    }
}

public class ListAlertsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class ListAlerts : Tea.TeaModel {
            public class Activities : Tea.TeaModel {
                public var content: String?

                public var description_: String?

                public var handlerName: String?

                public var time: String?

                public var type: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.handlerName != nil {
                        map["HandlerName"] = self.handlerName!
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("HandlerName") {
                        self.handlerName = dict["HandlerName"] as! String
                    }
                    if dict.keys.contains("Time") {
                        self.time = dict["Time"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! Int64
                    }
                }
            }
            public class AlertEvents : Tea.TeaModel {
                public var alertName: String?

                public var annotations: String?

                public var description_: String?

                public var endTime: String?

                public var generatorURL: String?

                public var integrationName: String?

                public var integrationType: String?

                public var labels: String?

                public var receiveTime: String?

                public var severity: String?

                public var startTime: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alertName != nil {
                        map["AlertName"] = self.alertName!
                    }
                    if self.annotations != nil {
                        map["Annotations"] = self.annotations!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.generatorURL != nil {
                        map["GeneratorURL"] = self.generatorURL!
                    }
                    if self.integrationName != nil {
                        map["IntegrationName"] = self.integrationName!
                    }
                    if self.integrationType != nil {
                        map["IntegrationType"] = self.integrationType!
                    }
                    if self.labels != nil {
                        map["Labels"] = self.labels!
                    }
                    if self.receiveTime != nil {
                        map["ReceiveTime"] = self.receiveTime!
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlertName") {
                        self.alertName = dict["AlertName"] as! String
                    }
                    if dict.keys.contains("Annotations") {
                        self.annotations = dict["Annotations"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("GeneratorURL") {
                        self.generatorURL = dict["GeneratorURL"] as! String
                    }
                    if dict.keys.contains("IntegrationName") {
                        self.integrationName = dict["IntegrationName"] as! String
                    }
                    if dict.keys.contains("IntegrationType") {
                        self.integrationType = dict["IntegrationType"] as! String
                    }
                    if dict.keys.contains("Labels") {
                        self.labels = dict["Labels"] as! String
                    }
                    if dict.keys.contains("ReceiveTime") {
                        self.receiveTime = dict["ReceiveTime"] as! String
                    }
                    if dict.keys.contains("Severity") {
                        self.severity = dict["Severity"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                }
            }
            public var acknowledgeTime: Int64?

            public var activities: [ListAlertsResponseBody.PageBean.ListAlerts.Activities]?

            public var alertEvents: [ListAlertsResponseBody.PageBean.ListAlerts.AlertEvents]?

            public var alertId: Int64?

            public var alertName: String?

            public var createTime: String?

            public var describe: String?

            public var dispatchRuleId: Double?

            public var dispatchRuleName: String?

            public var handler: String?

            public var notifyRobots: String?

            public var owner: String?

            public var recoverTime: Int64?

            public var severity: String?

            public var solution: String?

            public var state: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acknowledgeTime != nil {
                    map["AcknowledgeTime"] = self.acknowledgeTime!
                }
                if self.activities != nil {
                    var tmp : [Any] = []
                    for k in self.activities! {
                        tmp.append(k.toMap())
                    }
                    map["Activities"] = tmp
                }
                if self.alertEvents != nil {
                    var tmp : [Any] = []
                    for k in self.alertEvents! {
                        tmp.append(k.toMap())
                    }
                    map["AlertEvents"] = tmp
                }
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.describe != nil {
                    map["Describe"] = self.describe!
                }
                if self.dispatchRuleId != nil {
                    map["DispatchRuleId"] = self.dispatchRuleId!
                }
                if self.dispatchRuleName != nil {
                    map["DispatchRuleName"] = self.dispatchRuleName!
                }
                if self.handler != nil {
                    map["Handler"] = self.handler!
                }
                if self.notifyRobots != nil {
                    map["NotifyRobots"] = self.notifyRobots!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.recoverTime != nil {
                    map["RecoverTime"] = self.recoverTime!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.solution != nil {
                    map["Solution"] = self.solution!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AcknowledgeTime") {
                    self.acknowledgeTime = dict["AcknowledgeTime"] as! Int64
                }
                if dict.keys.contains("Activities") {
                    var tmp : [ListAlertsResponseBody.PageBean.ListAlerts.Activities] = []
                    for v in dict["Activities"] as! [Any] {
                        var model = ListAlertsResponseBody.PageBean.ListAlerts.Activities()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.activities = tmp
                }
                if dict.keys.contains("AlertEvents") {
                    var tmp : [ListAlertsResponseBody.PageBean.ListAlerts.AlertEvents] = []
                    for v in dict["AlertEvents"] as! [Any] {
                        var model = ListAlertsResponseBody.PageBean.ListAlerts.AlertEvents()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alertEvents = tmp
                }
                if dict.keys.contains("AlertId") {
                    self.alertId = dict["AlertId"] as! Int64
                }
                if dict.keys.contains("AlertName") {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Describe") {
                    self.describe = dict["Describe"] as! String
                }
                if dict.keys.contains("DispatchRuleId") {
                    self.dispatchRuleId = dict["DispatchRuleId"] as! Double
                }
                if dict.keys.contains("DispatchRuleName") {
                    self.dispatchRuleName = dict["DispatchRuleName"] as! String
                }
                if dict.keys.contains("Handler") {
                    self.handler = dict["Handler"] as! String
                }
                if dict.keys.contains("NotifyRobots") {
                    self.notifyRobots = dict["NotifyRobots"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("RecoverTime") {
                    self.recoverTime = dict["RecoverTime"] as! Int64
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("Solution") {
                    self.solution = dict["Solution"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! Int64
                }
            }
        }
        public var listAlerts: [ListAlertsResponseBody.PageBean.ListAlerts]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.listAlerts != nil {
                var tmp : [Any] = []
                for k in self.listAlerts! {
                    tmp.append(k.toMap())
                }
                map["ListAlerts"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ListAlerts") {
                var tmp : [ListAlertsResponseBody.PageBean.ListAlerts] = []
                for v in dict["ListAlerts"] as! [Any] {
                    var model = ListAlertsResponseBody.PageBean.ListAlerts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.listAlerts = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListAlertsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = ListAlertsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAlertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAlertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterFromGrafanaRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListClusterFromGrafanaResponseBody : Tea.TeaModel {
    public class PromClusterList : Tea.TeaModel {
        public var agentStatus: String?

        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: String?

        public var controllerId: String?

        public var createTime: Int64?

        public var extra: String?

        public var id: Int64?

        public var installTime: Int64?

        public var isControllerInstalled: Bool?

        public var lastHeartBeatTime: Int64?

        public var nodeNum: Int32?

        public var options: String?

        public var pluginsJsonArray: String?

        public var regionId: String?

        public var stateJson: String?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentStatus != nil {
                map["AgentStatus"] = self.agentStatus!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.controllerId != nil {
                map["ControllerId"] = self.controllerId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.installTime != nil {
                map["InstallTime"] = self.installTime!
            }
            if self.isControllerInstalled != nil {
                map["IsControllerInstalled"] = self.isControllerInstalled!
            }
            if self.lastHeartBeatTime != nil {
                map["LastHeartBeatTime"] = self.lastHeartBeatTime!
            }
            if self.nodeNum != nil {
                map["NodeNum"] = self.nodeNum!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            if self.pluginsJsonArray != nil {
                map["PluginsJsonArray"] = self.pluginsJsonArray!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.stateJson != nil {
                map["StateJson"] = self.stateJson!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentStatus") {
                self.agentStatus = dict["AgentStatus"] as! String
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("ControllerId") {
                self.controllerId = dict["ControllerId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstallTime") {
                self.installTime = dict["InstallTime"] as! Int64
            }
            if dict.keys.contains("IsControllerInstalled") {
                self.isControllerInstalled = dict["IsControllerInstalled"] as! Bool
            }
            if dict.keys.contains("LastHeartBeatTime") {
                self.lastHeartBeatTime = dict["LastHeartBeatTime"] as! Int64
            }
            if dict.keys.contains("NodeNum") {
                self.nodeNum = dict["NodeNum"] as! Int32
            }
            if dict.keys.contains("Options") {
                self.options = dict["Options"] as! String
            }
            if dict.keys.contains("PluginsJsonArray") {
                self.pluginsJsonArray = dict["PluginsJsonArray"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("StateJson") {
                self.stateJson = dict["StateJson"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var promClusterList: [ListClusterFromGrafanaResponseBody.PromClusterList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.promClusterList != nil {
            var tmp : [Any] = []
            for k in self.promClusterList! {
                tmp.append(k.toMap())
            }
            map["PromClusterList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PromClusterList") {
            var tmp : [ListClusterFromGrafanaResponseBody.PromClusterList] = []
            for v in dict["PromClusterList"] as! [Any] {
                var model = ListClusterFromGrafanaResponseBody.PromClusterList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.promClusterList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClusterFromGrafanaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterFromGrafanaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClusterFromGrafanaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCmsInstancesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var typeFilter: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.typeFilter != nil {
            map["TypeFilter"] = self.typeFilter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TypeFilter") {
            self.typeFilter = dict["TypeFilter"] as! String
        }
    }
}

public class ListCmsInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Products : Tea.TeaModel {
            public var descr: String?

            public var id: String?

            public var instance: String?

            public var name: String?

            public var prod: String?

            public var source: String?

            public var state: String?

            public var time: String?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.descr != nil {
                    map["Descr"] = self.descr!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instance != nil {
                    map["Instance"] = self.instance!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.prod != nil {
                    map["Prod"] = self.prod!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Descr") {
                    self.descr = dict["Descr"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Instance") {
                    self.instance = dict["Instance"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Prod") {
                    self.prod = dict["Prod"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var enableTag: Bool?

        public var products: [ListCmsInstancesResponseBody.Data.Products]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableTag != nil {
                map["EnableTag"] = self.enableTag!
            }
            if self.products != nil {
                var tmp : [Any] = []
                for k in self.products! {
                    tmp.append(k.toMap())
                }
                map["Products"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableTag") {
                self.enableTag = dict["EnableTag"] as! Bool
            }
            if dict.keys.contains("Products") {
                var tmp : [ListCmsInstancesResponseBody.Data.Products] = []
                for v in dict["Products"] as! [Any] {
                    var model = ListCmsInstancesResponseBody.Data.Products()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.products = tmp
            }
        }
    }
    public var data: ListCmsInstancesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListCmsInstancesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCmsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCmsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCmsInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDashboardsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var dashboardName: String?

    public var language: String?

    public var product: String?

    public var recreateSwitch: Bool?

    public var regionId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.dashboardName != nil {
            map["DashboardName"] = self.dashboardName!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.recreateSwitch != nil {
            map["RecreateSwitch"] = self.recreateSwitch!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("DashboardName") {
            self.dashboardName = dict["DashboardName"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Product") {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RecreateSwitch") {
            self.recreateSwitch = dict["RecreateSwitch"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class ListDashboardsResponseBody : Tea.TeaModel {
    public class DashboardVos : Tea.TeaModel {
        public class I18nChild : Tea.TeaModel {
            public var dashboardType: String?

            public var exporter: String?

            public var httpUrl: String?

            public var httpsUrl: String?

            public var id: String?

            public var isArmsExporter: Bool?

            public var kind: String?

            public var language: String?

            public var name: String?

            public var needUpdate: Bool?

            public var tags: [String]?

            public var time: String?

            public var title: String?

            public var type: String?

            public var uid: String?

            public var url: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dashboardType != nil {
                    map["DashboardType"] = self.dashboardType!
                }
                if self.exporter != nil {
                    map["Exporter"] = self.exporter!
                }
                if self.httpUrl != nil {
                    map["HttpUrl"] = self.httpUrl!
                }
                if self.httpsUrl != nil {
                    map["HttpsUrl"] = self.httpsUrl!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isArmsExporter != nil {
                    map["IsArmsExporter"] = self.isArmsExporter!
                }
                if self.kind != nil {
                    map["Kind"] = self.kind!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.needUpdate != nil {
                    map["NeedUpdate"] = self.needUpdate!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.uid != nil {
                    map["Uid"] = self.uid!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DashboardType") {
                    self.dashboardType = dict["DashboardType"] as! String
                }
                if dict.keys.contains("Exporter") {
                    self.exporter = dict["Exporter"] as! String
                }
                if dict.keys.contains("HttpUrl") {
                    self.httpUrl = dict["HttpUrl"] as! String
                }
                if dict.keys.contains("HttpsUrl") {
                    self.httpsUrl = dict["HttpsUrl"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("IsArmsExporter") {
                    self.isArmsExporter = dict["IsArmsExporter"] as! Bool
                }
                if dict.keys.contains("Kind") {
                    self.kind = dict["Kind"] as! String
                }
                if dict.keys.contains("Language") {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NeedUpdate") {
                    self.needUpdate = dict["NeedUpdate"] as! Bool
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! [String]
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Uid") {
                    self.uid = dict["Uid"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var dashboardType: String?

        public var exporter: String?

        public var httpUrl: String?

        public var httpsUrl: String?

        public var i18nChild: ListDashboardsResponseBody.DashboardVos.I18nChild?

        public var id: String?

        public var isArmsExporter: Bool?

        public var kind: String?

        public var language: String?

        public var name: String?

        public var needUpdate: Bool?

        public var tags: [String]?

        public var time: String?

        public var title: String?

        public var type: String?

        public var uid: String?

        public var url: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.i18nChild?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dashboardType != nil {
                map["DashboardType"] = self.dashboardType!
            }
            if self.exporter != nil {
                map["Exporter"] = self.exporter!
            }
            if self.httpUrl != nil {
                map["HttpUrl"] = self.httpUrl!
            }
            if self.httpsUrl != nil {
                map["HttpsUrl"] = self.httpsUrl!
            }
            if self.i18nChild != nil {
                map["I18nChild"] = self.i18nChild?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isArmsExporter != nil {
                map["IsArmsExporter"] = self.isArmsExporter!
            }
            if self.kind != nil {
                map["Kind"] = self.kind!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.needUpdate != nil {
                map["NeedUpdate"] = self.needUpdate!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DashboardType") {
                self.dashboardType = dict["DashboardType"] as! String
            }
            if dict.keys.contains("Exporter") {
                self.exporter = dict["Exporter"] as! String
            }
            if dict.keys.contains("HttpUrl") {
                self.httpUrl = dict["HttpUrl"] as! String
            }
            if dict.keys.contains("HttpsUrl") {
                self.httpsUrl = dict["HttpsUrl"] as! String
            }
            if dict.keys.contains("I18nChild") {
                var model = ListDashboardsResponseBody.DashboardVos.I18nChild()
                model.fromMap(dict["I18nChild"] as! [String: Any])
                self.i18nChild = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsArmsExporter") {
                self.isArmsExporter = dict["IsArmsExporter"] as! Bool
            }
            if dict.keys.contains("Kind") {
                self.kind = dict["Kind"] as! String
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NeedUpdate") {
                self.needUpdate = dict["NeedUpdate"] as! Bool
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! [String]
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uid") {
                self.uid = dict["Uid"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var dashboardVos: [ListDashboardsResponseBody.DashboardVos]?

    public var environmentId: String?

    public var grafanaServiceOpened: String?

    public var prometheusServiceOpened: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dashboardVos != nil {
            var tmp : [Any] = []
            for k in self.dashboardVos! {
                tmp.append(k.toMap())
            }
            map["DashboardVos"] = tmp
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.grafanaServiceOpened != nil {
            map["GrafanaServiceOpened"] = self.grafanaServiceOpened!
        }
        if self.prometheusServiceOpened != nil {
            map["PrometheusServiceOpened"] = self.prometheusServiceOpened!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DashboardVos") {
            var tmp : [ListDashboardsResponseBody.DashboardVos] = []
            for v in dict["DashboardVos"] as! [Any] {
                var model = ListDashboardsResponseBody.DashboardVos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dashboardVos = tmp
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("GrafanaServiceOpened") {
            self.grafanaServiceOpened = dict["GrafanaServiceOpened"] as! String
        }
        if dict.keys.contains("PrometheusServiceOpened") {
            self.prometheusServiceOpened = dict["PrometheusServiceOpened"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDashboardsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDashboardsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDashboardsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDashboardsByNameRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var dashBoardName: String?

    public var dashBoardVersion: String?

    public var dataSourceType: String?

    public var groupName: String?

    public var onlyQuery: Bool?

    public var productCode: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.dashBoardName != nil {
            map["DashBoardName"] = self.dashBoardName!
        }
        if self.dashBoardVersion != nil {
            map["DashBoardVersion"] = self.dashBoardVersion!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.onlyQuery != nil {
            map["OnlyQuery"] = self.onlyQuery!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("DashBoardName") {
            self.dashBoardName = dict["DashBoardName"] as! String
        }
        if dict.keys.contains("DashBoardVersion") {
            self.dashBoardVersion = dict["DashBoardVersion"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("OnlyQuery") {
            self.onlyQuery = dict["OnlyQuery"] as! Bool
        }
        if dict.keys.contains("ProductCode") {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListDashboardsByNameResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDashboardsByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDashboardsByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDashboardsByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDispatchRuleRequest : Tea.TeaModel {
    public var name: String?

    public var regionId: String?

    public var system: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.system != nil {
            map["System"] = self.system!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("System") {
            self.system = dict["System"] as! Bool
        }
    }
}

public class ListDispatchRuleResponseBody : Tea.TeaModel {
    public class DispatchRules : Tea.TeaModel {
        public var name: String?

        public var ruleId: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RuleId") {
                self.ruleId = dict["RuleId"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var dispatchRules: [ListDispatchRuleResponseBody.DispatchRules]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRules != nil {
            var tmp : [Any] = []
            for k in self.dispatchRules! {
                tmp.append(k.toMap())
            }
            map["DispatchRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRules") {
            var tmp : [ListDispatchRuleResponseBody.DispatchRules] = []
            for v in dict["DispatchRules"] as! [Any] {
                var model = ListDispatchRuleResponseBody.DispatchRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dispatchRules = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvCustomJobsRequest : Tea.TeaModel {
    public var encryptYaml: Bool?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encryptYaml != nil {
            map["EncryptYaml"] = self.encryptYaml!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EncryptYaml") {
            self.encryptYaml = dict["EncryptYaml"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListEnvCustomJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ScrapeConfigs : Tea.TeaModel {
            public var jobName: String?

            public var metricsPath: String?

            public var scrapeDiscoverys: [String]?

            public var scrapeInterval: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobName != nil {
                    map["JobName"] = self.jobName!
                }
                if self.metricsPath != nil {
                    map["MetricsPath"] = self.metricsPath!
                }
                if self.scrapeDiscoverys != nil {
                    map["ScrapeDiscoverys"] = self.scrapeDiscoverys!
                }
                if self.scrapeInterval != nil {
                    map["ScrapeInterval"] = self.scrapeInterval!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobName") {
                    self.jobName = dict["JobName"] as! String
                }
                if dict.keys.contains("MetricsPath") {
                    self.metricsPath = dict["MetricsPath"] as! String
                }
                if dict.keys.contains("ScrapeDiscoverys") {
                    self.scrapeDiscoverys = dict["ScrapeDiscoverys"] as! [String]
                }
                if dict.keys.contains("ScrapeInterval") {
                    self.scrapeInterval = dict["ScrapeInterval"] as! String
                }
            }
        }
        public var addonName: String?

        public var addonReleaseName: String?

        public var addonVersion: String?

        public var configYaml: String?

        public var creationTimestamp: String?

        public var customJobName: String?

        public var environmentId: String?

        public var regionId: String?

        public var scrapeConfigs: [ListEnvCustomJobsResponseBody.Data.ScrapeConfigs]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addonName != nil {
                map["AddonName"] = self.addonName!
            }
            if self.addonReleaseName != nil {
                map["AddonReleaseName"] = self.addonReleaseName!
            }
            if self.addonVersion != nil {
                map["AddonVersion"] = self.addonVersion!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.creationTimestamp != nil {
                map["CreationTimestamp"] = self.creationTimestamp!
            }
            if self.customJobName != nil {
                map["CustomJobName"] = self.customJobName!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.scrapeConfigs != nil {
                var tmp : [Any] = []
                for k in self.scrapeConfigs! {
                    tmp.append(k.toMap())
                }
                map["ScrapeConfigs"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddonName") {
                self.addonName = dict["AddonName"] as! String
            }
            if dict.keys.contains("AddonReleaseName") {
                self.addonReleaseName = dict["AddonReleaseName"] as! String
            }
            if dict.keys.contains("AddonVersion") {
                self.addonVersion = dict["AddonVersion"] as! String
            }
            if dict.keys.contains("ConfigYaml") {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("CreationTimestamp") {
                self.creationTimestamp = dict["CreationTimestamp"] as! String
            }
            if dict.keys.contains("CustomJobName") {
                self.customJobName = dict["CustomJobName"] as! String
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ScrapeConfigs") {
                var tmp : [ListEnvCustomJobsResponseBody.Data.ScrapeConfigs] = []
                for v in dict["ScrapeConfigs"] as! [Any] {
                    var model = ListEnvCustomJobsResponseBody.Data.ScrapeConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scrapeConfigs = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListEnvCustomJobsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListEnvCustomJobsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEnvCustomJobsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEnvCustomJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvCustomJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEnvCustomJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvPodMonitorsRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListEnvPodMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Endpoints : Tea.TeaModel {
            public var interval: String?

            public var matchedTargetCount: Int32?

            public var path: String?

            public var port: String?

            public var targetPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.matchedTargetCount != nil {
                    map["MatchedTargetCount"] = self.matchedTargetCount!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! String
                }
                if dict.keys.contains("MatchedTargetCount") {
                    self.matchedTargetCount = dict["MatchedTargetCount"] as! Int32
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("TargetPort") {
                    self.targetPort = dict["TargetPort"] as! Int32
                }
            }
        }
        public var addonName: String?

        public var addonReleaseName: String?

        public var addonVersion: String?

        public var configYaml: String?

        public var creationTimestamp: String?

        public var endpoints: [ListEnvPodMonitorsResponseBody.Data.Endpoints]?

        public var environmentId: String?

        public var namespace: String?

        public var podMonitorName: String?

        public var regionId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addonName != nil {
                map["AddonName"] = self.addonName!
            }
            if self.addonReleaseName != nil {
                map["AddonReleaseName"] = self.addonReleaseName!
            }
            if self.addonVersion != nil {
                map["AddonVersion"] = self.addonVersion!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.creationTimestamp != nil {
                map["CreationTimestamp"] = self.creationTimestamp!
            }
            if self.endpoints != nil {
                var tmp : [Any] = []
                for k in self.endpoints! {
                    tmp.append(k.toMap())
                }
                map["Endpoints"] = tmp
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.podMonitorName != nil {
                map["PodMonitorName"] = self.podMonitorName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddonName") {
                self.addonName = dict["AddonName"] as! String
            }
            if dict.keys.contains("AddonReleaseName") {
                self.addonReleaseName = dict["AddonReleaseName"] as! String
            }
            if dict.keys.contains("AddonVersion") {
                self.addonVersion = dict["AddonVersion"] as! String
            }
            if dict.keys.contains("ConfigYaml") {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("CreationTimestamp") {
                self.creationTimestamp = dict["CreationTimestamp"] as! String
            }
            if dict.keys.contains("Endpoints") {
                var tmp : [ListEnvPodMonitorsResponseBody.Data.Endpoints] = []
                for v in dict["Endpoints"] as! [Any] {
                    var model = ListEnvPodMonitorsResponseBody.Data.Endpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpoints = tmp
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PodMonitorName") {
                self.podMonitorName = dict["PodMonitorName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListEnvPodMonitorsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListEnvPodMonitorsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEnvPodMonitorsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEnvPodMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvPodMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEnvPodMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvServiceMonitorsRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListEnvServiceMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Endpoints : Tea.TeaModel {
            public var interval: String?

            public var matchedTargetCount: Int32?

            public var path: String?

            public var port: String?

            public var targetPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.matchedTargetCount != nil {
                    map["MatchedTargetCount"] = self.matchedTargetCount!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! String
                }
                if dict.keys.contains("MatchedTargetCount") {
                    self.matchedTargetCount = dict["MatchedTargetCount"] as! Int32
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("TargetPort") {
                    self.targetPort = dict["TargetPort"] as! Int32
                }
            }
        }
        public var addonName: String?

        public var addonReleaseName: String?

        public var addonVersion: String?

        public var configYaml: String?

        public var creationTimestamp: String?

        public var endpoints: [ListEnvServiceMonitorsResponseBody.Data.Endpoints]?

        public var environmentId: String?

        public var matchedServiceCount: Int32?

        public var namespace: String?

        public var regionId: String?

        public var serviceMonitorName: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addonName != nil {
                map["AddonName"] = self.addonName!
            }
            if self.addonReleaseName != nil {
                map["AddonReleaseName"] = self.addonReleaseName!
            }
            if self.addonVersion != nil {
                map["AddonVersion"] = self.addonVersion!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.creationTimestamp != nil {
                map["CreationTimestamp"] = self.creationTimestamp!
            }
            if self.endpoints != nil {
                var tmp : [Any] = []
                for k in self.endpoints! {
                    tmp.append(k.toMap())
                }
                map["Endpoints"] = tmp
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.matchedServiceCount != nil {
                map["MatchedServiceCount"] = self.matchedServiceCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.serviceMonitorName != nil {
                map["ServiceMonitorName"] = self.serviceMonitorName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddonName") {
                self.addonName = dict["AddonName"] as! String
            }
            if dict.keys.contains("AddonReleaseName") {
                self.addonReleaseName = dict["AddonReleaseName"] as! String
            }
            if dict.keys.contains("AddonVersion") {
                self.addonVersion = dict["AddonVersion"] as! String
            }
            if dict.keys.contains("ConfigYaml") {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("CreationTimestamp") {
                self.creationTimestamp = dict["CreationTimestamp"] as! String
            }
            if dict.keys.contains("Endpoints") {
                var tmp : [ListEnvServiceMonitorsResponseBody.Data.Endpoints] = []
                for v in dict["Endpoints"] as! [Any] {
                    var model = ListEnvServiceMonitorsResponseBody.Data.Endpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpoints = tmp
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("MatchedServiceCount") {
                self.matchedServiceCount = dict["MatchedServiceCount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ServiceMonitorName") {
                self.serviceMonitorName = dict["ServiceMonitorName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListEnvServiceMonitorsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListEnvServiceMonitorsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEnvServiceMonitorsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEnvServiceMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvServiceMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEnvServiceMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvironmentDashboardsRequest : Tea.TeaModel {
    public var addonName: String?

    public var environmentId: String?

    public var regionId: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonName != nil {
            map["AddonName"] = self.addonName!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonName") {
            self.addonName = dict["AddonName"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
    }
}

public class ListEnvironmentDashboardsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Dashboards : Tea.TeaModel {
            public var folderUid: String?

            public var region: String?

            public var tags: [String]?

            public var title: String?

            public var uid: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.folderUid != nil {
                    map["FolderUid"] = self.folderUid!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.uid != nil {
                    map["Uid"] = self.uid!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FolderUid") {
                    self.folderUid = dict["FolderUid"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! [String]
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("Uid") {
                    self.uid = dict["Uid"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var dashboards: [ListEnvironmentDashboardsResponseBody.Data.Dashboards]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dashboards != nil {
                var tmp : [Any] = []
                for k in self.dashboards! {
                    tmp.append(k.toMap())
                }
                map["Dashboards"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dashboards") {
                var tmp : [ListEnvironmentDashboardsResponseBody.Data.Dashboards] = []
                for v in dict["Dashboards"] as! [Any] {
                    var model = ListEnvironmentDashboardsResponseBody.Data.Dashboards()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dashboards = tmp
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListEnvironmentDashboardsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListEnvironmentDashboardsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEnvironmentDashboardsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvironmentDashboardsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEnvironmentDashboardsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvironmentFeaturesRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListEnvironmentFeaturesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var alias: String?

        public var config: [String: String]?

        public var description_: String?

        public var environmentId: String?

        public var icon: String?

        public var language: String?

        public var latestVersion: String?

        public var managed: Bool?

        public var name: String?

        public var status: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.latestVersion != nil {
                map["LatestVersion"] = self.latestVersion!
            }
            if self.managed != nil {
                map["Managed"] = self.managed!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! [String: String]
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("Icon") {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("LatestVersion") {
                self.latestVersion = dict["LatestVersion"] as! String
            }
            if dict.keys.contains("Managed") {
                self.managed = dict["Managed"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListEnvironmentFeaturesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListEnvironmentFeaturesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEnvironmentFeaturesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEnvironmentFeaturesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvironmentFeaturesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEnvironmentFeaturesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvironmentsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var addonName: String?

    public var bindResourceId: String?

    public var environmentType: String?

    public var feePackage: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [ListEnvironmentsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonName != nil {
            map["AddonName"] = self.addonName!
        }
        if self.bindResourceId != nil {
            map["BindResourceId"] = self.bindResourceId!
        }
        if self.environmentType != nil {
            map["EnvironmentType"] = self.environmentType!
        }
        if self.feePackage != nil {
            map["FeePackage"] = self.feePackage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonName") {
            self.addonName = dict["AddonName"] as! String
        }
        if dict.keys.contains("BindResourceId") {
            self.bindResourceId = dict["BindResourceId"] as! String
        }
        if dict.keys.contains("EnvironmentType") {
            self.environmentType = dict["EnvironmentType"] as! String
        }
        if dict.keys.contains("FeePackage") {
            self.feePackage = dict["FeePackage"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListEnvironmentsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListEnvironmentsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListEnvironmentsShrinkRequest : Tea.TeaModel {
    public var addonName: String?

    public var bindResourceId: String?

    public var environmentType: String?

    public var feePackage: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonName != nil {
            map["AddonName"] = self.addonName!
        }
        if self.bindResourceId != nil {
            map["BindResourceId"] = self.bindResourceId!
        }
        if self.environmentType != nil {
            map["EnvironmentType"] = self.environmentType!
        }
        if self.feePackage != nil {
            map["FeePackage"] = self.feePackage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonName") {
            self.addonName = dict["AddonName"] as! String
        }
        if dict.keys.contains("BindResourceId") {
            self.bindResourceId = dict["BindResourceId"] as! String
        }
        if dict.keys.contains("EnvironmentType") {
            self.environmentType = dict["EnvironmentType"] as! String
        }
        if dict.keys.contains("FeePackage") {
            self.feePackage = dict["FeePackage"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tagShrink = dict["Tag"] as! String
        }
    }
}

public class ListEnvironmentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Environments : Tea.TeaModel {
            public class Addons : Tea.TeaModel {
                public var alias: String?

                public var description_: String?

                public var icon: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Icon") {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class Features : Tea.TeaModel {
                public var alias: String?

                public var description_: String?

                public var icon: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Icon") {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var addons: [ListEnvironmentsResponseBody.Data.Environments.Addons]?

            public var bindResourceId: String?

            public var bindResourceProfile: String?

            public var bindResourceType: String?

            public var bindVpcCidr: String?

            public var createTime: String?

            public var createdUserId: String?

            public var environmentId: String?

            public var environmentName: String?

            public var environmentType: String?

            public var features: [ListEnvironmentsResponseBody.Data.Environments.Features]?

            public var feePackage: String?

            public var grafanaDatasourceUid: String?

            public var grafanaFolderTitle: String?

            public var grafanaFolderUid: String?

            public var latestReleaseCreateTime: String?

            public var managedType: String?

            public var prometheusId: Int64?

            public var prometheusInstanceId: String?

            public var regionId: String?

            public var releaseCount: Int32?

            public var resourceGroupId: String?

            public var tags: [ListEnvironmentsResponseBody.Data.Environments.Tags]?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addons != nil {
                    var tmp : [Any] = []
                    for k in self.addons! {
                        tmp.append(k.toMap())
                    }
                    map["Addons"] = tmp
                }
                if self.bindResourceId != nil {
                    map["BindResourceId"] = self.bindResourceId!
                }
                if self.bindResourceProfile != nil {
                    map["BindResourceProfile"] = self.bindResourceProfile!
                }
                if self.bindResourceType != nil {
                    map["BindResourceType"] = self.bindResourceType!
                }
                if self.bindVpcCidr != nil {
                    map["BindVpcCidr"] = self.bindVpcCidr!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createdUserId != nil {
                    map["CreatedUserId"] = self.createdUserId!
                }
                if self.environmentId != nil {
                    map["EnvironmentId"] = self.environmentId!
                }
                if self.environmentName != nil {
                    map["EnvironmentName"] = self.environmentName!
                }
                if self.environmentType != nil {
                    map["EnvironmentType"] = self.environmentType!
                }
                if self.features != nil {
                    var tmp : [Any] = []
                    for k in self.features! {
                        tmp.append(k.toMap())
                    }
                    map["Features"] = tmp
                }
                if self.feePackage != nil {
                    map["FeePackage"] = self.feePackage!
                }
                if self.grafanaDatasourceUid != nil {
                    map["GrafanaDatasourceUid"] = self.grafanaDatasourceUid!
                }
                if self.grafanaFolderTitle != nil {
                    map["GrafanaFolderTitle"] = self.grafanaFolderTitle!
                }
                if self.grafanaFolderUid != nil {
                    map["GrafanaFolderUid"] = self.grafanaFolderUid!
                }
                if self.latestReleaseCreateTime != nil {
                    map["LatestReleaseCreateTime"] = self.latestReleaseCreateTime!
                }
                if self.managedType != nil {
                    map["ManagedType"] = self.managedType!
                }
                if self.prometheusId != nil {
                    map["PrometheusId"] = self.prometheusId!
                }
                if self.prometheusInstanceId != nil {
                    map["PrometheusInstanceId"] = self.prometheusInstanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.releaseCount != nil {
                    map["ReleaseCount"] = self.releaseCount!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Addons") {
                    var tmp : [ListEnvironmentsResponseBody.Data.Environments.Addons] = []
                    for v in dict["Addons"] as! [Any] {
                        var model = ListEnvironmentsResponseBody.Data.Environments.Addons()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.addons = tmp
                }
                if dict.keys.contains("BindResourceId") {
                    self.bindResourceId = dict["BindResourceId"] as! String
                }
                if dict.keys.contains("BindResourceProfile") {
                    self.bindResourceProfile = dict["BindResourceProfile"] as! String
                }
                if dict.keys.contains("BindResourceType") {
                    self.bindResourceType = dict["BindResourceType"] as! String
                }
                if dict.keys.contains("BindVpcCidr") {
                    self.bindVpcCidr = dict["BindVpcCidr"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreatedUserId") {
                    self.createdUserId = dict["CreatedUserId"] as! String
                }
                if dict.keys.contains("EnvironmentId") {
                    self.environmentId = dict["EnvironmentId"] as! String
                }
                if dict.keys.contains("EnvironmentName") {
                    self.environmentName = dict["EnvironmentName"] as! String
                }
                if dict.keys.contains("EnvironmentType") {
                    self.environmentType = dict["EnvironmentType"] as! String
                }
                if dict.keys.contains("Features") {
                    var tmp : [ListEnvironmentsResponseBody.Data.Environments.Features] = []
                    for v in dict["Features"] as! [Any] {
                        var model = ListEnvironmentsResponseBody.Data.Environments.Features()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.features = tmp
                }
                if dict.keys.contains("FeePackage") {
                    self.feePackage = dict["FeePackage"] as! String
                }
                if dict.keys.contains("GrafanaDatasourceUid") {
                    self.grafanaDatasourceUid = dict["GrafanaDatasourceUid"] as! String
                }
                if dict.keys.contains("GrafanaFolderTitle") {
                    self.grafanaFolderTitle = dict["GrafanaFolderTitle"] as! String
                }
                if dict.keys.contains("GrafanaFolderUid") {
                    self.grafanaFolderUid = dict["GrafanaFolderUid"] as! String
                }
                if dict.keys.contains("LatestReleaseCreateTime") {
                    self.latestReleaseCreateTime = dict["LatestReleaseCreateTime"] as! String
                }
                if dict.keys.contains("ManagedType") {
                    self.managedType = dict["ManagedType"] as! String
                }
                if dict.keys.contains("PrometheusId") {
                    self.prometheusId = dict["PrometheusId"] as! Int64
                }
                if dict.keys.contains("PrometheusInstanceId") {
                    self.prometheusInstanceId = dict["PrometheusInstanceId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReleaseCount") {
                    self.releaseCount = dict["ReleaseCount"] as! Int32
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var tmp : [ListEnvironmentsResponseBody.Data.Environments.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListEnvironmentsResponseBody.Data.Environments.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var environments: [ListEnvironmentsResponseBody.Data.Environments]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.environments != nil {
                var tmp : [Any] = []
                for k in self.environments! {
                    tmp.append(k.toMap())
                }
                map["Environments"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Environments") {
                var tmp : [ListEnvironmentsResponseBody.Data.Environments] = []
                for v in dict["Environments"] as! [Any] {
                    var model = ListEnvironmentsResponseBody.Data.Environments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.environments = tmp
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListEnvironmentsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListEnvironmentsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEnvironmentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvironmentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEnvironmentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEscalationPoliciesRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListEscalationPoliciesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class EscalationPolicies : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var escalationPolicies: [ListEscalationPoliciesResponseBody.PageBean.EscalationPolicies]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPolicies != nil {
                var tmp : [Any] = []
                for k in self.escalationPolicies! {
                    tmp.append(k.toMap())
                }
                map["EscalationPolicies"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EscalationPolicies") {
                var tmp : [ListEscalationPoliciesResponseBody.PageBean.EscalationPolicies] = []
                for v in dict["EscalationPolicies"] as! [Any] {
                    var model = ListEscalationPoliciesResponseBody.PageBean.EscalationPolicies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPolicies = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListEscalationPoliciesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = ListEscalationPoliciesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEscalationPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEscalationPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEscalationPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventBridgeIntegrationsRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListEventBridgeIntegrationsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class EventBridgeIntegrations : Tea.TeaModel {
            public var description_: String?

            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var eventBridgeIntegrations: [ListEventBridgeIntegrationsResponseBody.PageBean.EventBridgeIntegrations]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventBridgeIntegrations != nil {
                var tmp : [Any] = []
                for k in self.eventBridgeIntegrations! {
                    tmp.append(k.toMap())
                }
                map["EventBridgeIntegrations"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventBridgeIntegrations") {
                var tmp : [ListEventBridgeIntegrationsResponseBody.PageBean.EventBridgeIntegrations] = []
                for v in dict["EventBridgeIntegrations"] as! [Any] {
                    var model = ListEventBridgeIntegrationsResponseBody.PageBean.EventBridgeIntegrations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventBridgeIntegrations = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListEventBridgeIntegrationsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = ListEventBridgeIntegrationsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEventBridgeIntegrationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventBridgeIntegrationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEventBridgeIntegrationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGrafanaWorkspaceRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aliyunLang: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [ListGrafanaWorkspaceRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListGrafanaWorkspaceRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListGrafanaWorkspaceRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListGrafanaWorkspaceShrinkRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class ListGrafanaWorkspaceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [GrafanaWorkspace]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [GrafanaWorkspace] = []
            for v in dict["Data"] as! [Any] {
                var model = GrafanaWorkspace()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListGrafanaWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGrafanaWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGrafanaWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInsightsEventsRequest : Tea.TeaModel {
    public var endTime: String?

    public var insightsTypes: String?

    public var pid: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.insightsTypes != nil {
            map["InsightsTypes"] = self.insightsTypes!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InsightsTypes") {
            self.insightsTypes = dict["InsightsTypes"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListInsightsEventsResponseBody : Tea.TeaModel {
    public class InsightsEvents : Tea.TeaModel {
        public var date: Int64?

        public var desc: String?

        public var level: String?

        public var pid: String?

        public var problemId: String?

        public var title: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.problemId != nil {
                map["ProblemId"] = self.problemId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! Int64
            }
            if dict.keys.contains("Desc") {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("ProblemId") {
                self.problemId = dict["ProblemId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var insightsEvents: [ListInsightsEventsResponseBody.InsightsEvents]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.insightsEvents != nil {
            var tmp : [Any] = []
            for k in self.insightsEvents! {
                tmp.append(k.toMap())
            }
            map["InsightsEvents"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InsightsEvents") {
            var tmp : [ListInsightsEventsResponseBody.InsightsEvents] = []
            for v in dict["InsightsEvents"] as! [Any] {
                var model = ListInsightsEventsResponseBody.InsightsEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.insightsEvents = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListInsightsEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInsightsEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInsightsEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntegrationRequest : Tea.TeaModel {
    public var integrationName: String?

    public var integrationProductType: String?

    public var isDetail: Bool?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.integrationName != nil {
            map["IntegrationName"] = self.integrationName!
        }
        if self.integrationProductType != nil {
            map["IntegrationProductType"] = self.integrationProductType!
        }
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IntegrationName") {
            self.integrationName = dict["IntegrationName"] as! String
        }
        if dict.keys.contains("IntegrationProductType") {
            self.integrationProductType = dict["IntegrationProductType"] as! String
        }
        if dict.keys.contains("IsDetail") {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListIntegrationResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public class Integrations : Tea.TeaModel {
            public class IntegrationDetail : Tea.TeaModel {
                public var autoRecover: Bool?

                public var description_: String?

                public var duplicateKey: String?

                public var extendedFieldRedefineRules: [[String: Any]]?

                public var fieldRedefineRules: [[String: Any]]?

                public var initiativeRecoverField: String?

                public var initiativeRecoverValue: String?

                public var recoverTime: Int64?

                public var stat: [Int64]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoRecover != nil {
                        map["AutoRecover"] = self.autoRecover!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.duplicateKey != nil {
                        map["DuplicateKey"] = self.duplicateKey!
                    }
                    if self.extendedFieldRedefineRules != nil {
                        map["ExtendedFieldRedefineRules"] = self.extendedFieldRedefineRules!
                    }
                    if self.fieldRedefineRules != nil {
                        map["FieldRedefineRules"] = self.fieldRedefineRules!
                    }
                    if self.initiativeRecoverField != nil {
                        map["InitiativeRecoverField"] = self.initiativeRecoverField!
                    }
                    if self.initiativeRecoverValue != nil {
                        map["InitiativeRecoverValue"] = self.initiativeRecoverValue!
                    }
                    if self.recoverTime != nil {
                        map["RecoverTime"] = self.recoverTime!
                    }
                    if self.stat != nil {
                        map["Stat"] = self.stat!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutoRecover") {
                        self.autoRecover = dict["AutoRecover"] as! Bool
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DuplicateKey") {
                        self.duplicateKey = dict["DuplicateKey"] as! String
                    }
                    if dict.keys.contains("ExtendedFieldRedefineRules") {
                        self.extendedFieldRedefineRules = dict["ExtendedFieldRedefineRules"] as! [[String: Any]]
                    }
                    if dict.keys.contains("FieldRedefineRules") {
                        self.fieldRedefineRules = dict["FieldRedefineRules"] as! [[String: Any]]
                    }
                    if dict.keys.contains("InitiativeRecoverField") {
                        self.initiativeRecoverField = dict["InitiativeRecoverField"] as! String
                    }
                    if dict.keys.contains("InitiativeRecoverValue") {
                        self.initiativeRecoverValue = dict["InitiativeRecoverValue"] as! String
                    }
                    if dict.keys.contains("RecoverTime") {
                        self.recoverTime = dict["RecoverTime"] as! Int64
                    }
                    if dict.keys.contains("Stat") {
                        self.stat = dict["Stat"] as! [Int64]
                    }
                }
            }
            public var apiEndpoint: String?

            public var createTime: String?

            public var integrationDetail: ListIntegrationResponseBody.PageInfo.Integrations.IntegrationDetail?

            public var integrationId: Int64?

            public var integrationName: String?

            public var integrationProductType: String?

            public var liveness: String?

            public var shortToken: String?

            public var state: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.integrationDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiEndpoint != nil {
                    map["ApiEndpoint"] = self.apiEndpoint!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.integrationDetail != nil {
                    map["IntegrationDetail"] = self.integrationDetail?.toMap()
                }
                if self.integrationId != nil {
                    map["IntegrationId"] = self.integrationId!
                }
                if self.integrationName != nil {
                    map["IntegrationName"] = self.integrationName!
                }
                if self.integrationProductType != nil {
                    map["IntegrationProductType"] = self.integrationProductType!
                }
                if self.liveness != nil {
                    map["Liveness"] = self.liveness!
                }
                if self.shortToken != nil {
                    map["ShortToken"] = self.shortToken!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiEndpoint") {
                    self.apiEndpoint = dict["ApiEndpoint"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("IntegrationDetail") {
                    var model = ListIntegrationResponseBody.PageInfo.Integrations.IntegrationDetail()
                    model.fromMap(dict["IntegrationDetail"] as! [String: Any])
                    self.integrationDetail = model
                }
                if dict.keys.contains("IntegrationId") {
                    self.integrationId = dict["IntegrationId"] as! Int64
                }
                if dict.keys.contains("IntegrationName") {
                    self.integrationName = dict["IntegrationName"] as! String
                }
                if dict.keys.contains("IntegrationProductType") {
                    self.integrationProductType = dict["IntegrationProductType"] as! String
                }
                if dict.keys.contains("Liveness") {
                    self.liveness = dict["Liveness"] as! String
                }
                if dict.keys.contains("ShortToken") {
                    self.shortToken = dict["ShortToken"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! Bool
                }
            }
        }
        public var integrations: [ListIntegrationResponseBody.PageInfo.Integrations]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.integrations != nil {
                var tmp : [Any] = []
                for k in self.integrations! {
                    tmp.append(k.toMap())
                }
                map["Integrations"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Integrations") {
                var tmp : [ListIntegrationResponseBody.PageInfo.Integrations] = []
                for v in dict["Integrations"] as! [Any] {
                    var model = ListIntegrationResponseBody.PageInfo.Integrations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.integrations = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageInfo: ListIntegrationResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") {
            var model = ListIntegrationResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNotificationPoliciesRequest : Tea.TeaModel {
    public var directedMode: Bool?

    public var ids: String?

    public var isDetail: Bool?

    public var name: String?

    public var page: Int64?

    public var regionId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directedMode != nil {
            map["DirectedMode"] = self.directedMode!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectedMode") {
            self.directedMode = dict["DirectedMode"] as! Bool
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("IsDetail") {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListNotificationPoliciesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class NotificationPolicies : Tea.TeaModel {
            public class GroupRule : Tea.TeaModel {
                public var groupInterval: Int64?

                public var groupWait: Int64?

                public var groupingFields: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupInterval != nil {
                        map["GroupInterval"] = self.groupInterval!
                    }
                    if self.groupWait != nil {
                        map["GroupWait"] = self.groupWait!
                    }
                    if self.groupingFields != nil {
                        map["GroupingFields"] = self.groupingFields!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GroupInterval") {
                        self.groupInterval = dict["GroupInterval"] as! Int64
                    }
                    if dict.keys.contains("GroupWait") {
                        self.groupWait = dict["GroupWait"] as! Int64
                    }
                    if dict.keys.contains("GroupingFields") {
                        self.groupingFields = dict["GroupingFields"] as! [String]
                    }
                }
            }
            public class MatchingRules : Tea.TeaModel {
                public class MatchingConditions : Tea.TeaModel {
                    public var key: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var matchingConditions: [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules.MatchingConditions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.matchingConditions != nil {
                        var tmp : [Any] = []
                        for k in self.matchingConditions! {
                            tmp.append(k.toMap())
                        }
                        map["MatchingConditions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MatchingConditions") {
                        var tmp : [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules.MatchingConditions] = []
                        for v in dict["MatchingConditions"] as! [Any] {
                            var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules.MatchingConditions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.matchingConditions = tmp
                    }
                }
            }
            public class NotifyRule : Tea.TeaModel {
                public class NotifyObjects : Tea.TeaModel {
                    public var notifyChannels: [String]?

                    public var notifyObjectId: Int64?

                    public var notifyObjectName: String?

                    public var notifyObjectType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.notifyChannels != nil {
                            map["NotifyChannels"] = self.notifyChannels!
                        }
                        if self.notifyObjectId != nil {
                            map["NotifyObjectId"] = self.notifyObjectId!
                        }
                        if self.notifyObjectName != nil {
                            map["NotifyObjectName"] = self.notifyObjectName!
                        }
                        if self.notifyObjectType != nil {
                            map["NotifyObjectType"] = self.notifyObjectType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NotifyChannels") {
                            self.notifyChannels = dict["NotifyChannels"] as! [String]
                        }
                        if dict.keys.contains("NotifyObjectId") {
                            self.notifyObjectId = dict["NotifyObjectId"] as! Int64
                        }
                        if dict.keys.contains("NotifyObjectName") {
                            self.notifyObjectName = dict["NotifyObjectName"] as! String
                        }
                        if dict.keys.contains("NotifyObjectType") {
                            self.notifyObjectType = dict["NotifyObjectType"] as! String
                        }
                    }
                }
                public var notifyChannels: [String]?

                public var notifyEndTime: String?

                public var notifyObjects: [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule.NotifyObjects]?

                public var notifyStartTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.notifyChannels != nil {
                        map["NotifyChannels"] = self.notifyChannels!
                    }
                    if self.notifyEndTime != nil {
                        map["NotifyEndTime"] = self.notifyEndTime!
                    }
                    if self.notifyObjects != nil {
                        var tmp : [Any] = []
                        for k in self.notifyObjects! {
                            tmp.append(k.toMap())
                        }
                        map["NotifyObjects"] = tmp
                    }
                    if self.notifyStartTime != nil {
                        map["NotifyStartTime"] = self.notifyStartTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NotifyChannels") {
                        self.notifyChannels = dict["NotifyChannels"] as! [String]
                    }
                    if dict.keys.contains("NotifyEndTime") {
                        self.notifyEndTime = dict["NotifyEndTime"] as! String
                    }
                    if dict.keys.contains("NotifyObjects") {
                        var tmp : [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule.NotifyObjects] = []
                        for v in dict["NotifyObjects"] as! [Any] {
                            var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule.NotifyObjects()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notifyObjects = tmp
                    }
                    if dict.keys.contains("NotifyStartTime") {
                        self.notifyStartTime = dict["NotifyStartTime"] as! String
                    }
                }
            }
            public class NotifyTemplate : Tea.TeaModel {
                public var emailContent: String?

                public var emailRecoverContent: String?

                public var emailRecoverTitle: String?

                public var emailTitle: String?

                public var robotContent: String?

                public var smsContent: String?

                public var smsRecoverContent: String?

                public var ttsContent: String?

                public var ttsRecoverContent: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.emailContent != nil {
                        map["EmailContent"] = self.emailContent!
                    }
                    if self.emailRecoverContent != nil {
                        map["EmailRecoverContent"] = self.emailRecoverContent!
                    }
                    if self.emailRecoverTitle != nil {
                        map["EmailRecoverTitle"] = self.emailRecoverTitle!
                    }
                    if self.emailTitle != nil {
                        map["EmailTitle"] = self.emailTitle!
                    }
                    if self.robotContent != nil {
                        map["RobotContent"] = self.robotContent!
                    }
                    if self.smsContent != nil {
                        map["SmsContent"] = self.smsContent!
                    }
                    if self.smsRecoverContent != nil {
                        map["SmsRecoverContent"] = self.smsRecoverContent!
                    }
                    if self.ttsContent != nil {
                        map["TtsContent"] = self.ttsContent!
                    }
                    if self.ttsRecoverContent != nil {
                        map["TtsRecoverContent"] = self.ttsRecoverContent!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EmailContent") {
                        self.emailContent = dict["EmailContent"] as! String
                    }
                    if dict.keys.contains("EmailRecoverContent") {
                        self.emailRecoverContent = dict["EmailRecoverContent"] as! String
                    }
                    if dict.keys.contains("EmailRecoverTitle") {
                        self.emailRecoverTitle = dict["EmailRecoverTitle"] as! String
                    }
                    if dict.keys.contains("EmailTitle") {
                        self.emailTitle = dict["EmailTitle"] as! String
                    }
                    if dict.keys.contains("RobotContent") {
                        self.robotContent = dict["RobotContent"] as! String
                    }
                    if dict.keys.contains("SmsContent") {
                        self.smsContent = dict["SmsContent"] as! String
                    }
                    if dict.keys.contains("SmsRecoverContent") {
                        self.smsRecoverContent = dict["SmsRecoverContent"] as! String
                    }
                    if dict.keys.contains("TtsContent") {
                        self.ttsContent = dict["TtsContent"] as! String
                    }
                    if dict.keys.contains("TtsRecoverContent") {
                        self.ttsRecoverContent = dict["TtsRecoverContent"] as! String
                    }
                }
            }
            public var directedMode: Bool?

            public var escalationPolicyId: Int64?

            public var groupRule: ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.GroupRule?

            public var id: Int64?

            public var integrationId: Int64?

            public var matchingRules: [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules]?

            public var name: String?

            public var notifyRule: ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule?

            public var notifyTemplate: ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyTemplate?

            public var repeat_: Bool?

            public var repeatInterval: Int64?

            public var sendRecoverMessage: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groupRule?.validate()
                try self.notifyRule?.validate()
                try self.notifyTemplate?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.directedMode != nil {
                    map["DirectedMode"] = self.directedMode!
                }
                if self.escalationPolicyId != nil {
                    map["EscalationPolicyId"] = self.escalationPolicyId!
                }
                if self.groupRule != nil {
                    map["GroupRule"] = self.groupRule?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.integrationId != nil {
                    map["IntegrationId"] = self.integrationId!
                }
                if self.matchingRules != nil {
                    var tmp : [Any] = []
                    for k in self.matchingRules! {
                        tmp.append(k.toMap())
                    }
                    map["MatchingRules"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifyRule != nil {
                    map["NotifyRule"] = self.notifyRule?.toMap()
                }
                if self.notifyTemplate != nil {
                    map["NotifyTemplate"] = self.notifyTemplate?.toMap()
                }
                if self.repeat_ != nil {
                    map["Repeat"] = self.repeat_!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.sendRecoverMessage != nil {
                    map["SendRecoverMessage"] = self.sendRecoverMessage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DirectedMode") {
                    self.directedMode = dict["DirectedMode"] as! Bool
                }
                if dict.keys.contains("EscalationPolicyId") {
                    self.escalationPolicyId = dict["EscalationPolicyId"] as! Int64
                }
                if dict.keys.contains("GroupRule") {
                    var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.GroupRule()
                    model.fromMap(dict["GroupRule"] as! [String: Any])
                    self.groupRule = model
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IntegrationId") {
                    self.integrationId = dict["IntegrationId"] as! Int64
                }
                if dict.keys.contains("MatchingRules") {
                    var tmp : [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules] = []
                    for v in dict["MatchingRules"] as! [Any] {
                        var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.matchingRules = tmp
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NotifyRule") {
                    var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule()
                    model.fromMap(dict["NotifyRule"] as! [String: Any])
                    self.notifyRule = model
                }
                if dict.keys.contains("NotifyTemplate") {
                    var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyTemplate()
                    model.fromMap(dict["NotifyTemplate"] as! [String: Any])
                    self.notifyTemplate = model
                }
                if dict.keys.contains("Repeat") {
                    self.repeat_ = dict["Repeat"] as! Bool
                }
                if dict.keys.contains("RepeatInterval") {
                    self.repeatInterval = dict["RepeatInterval"] as! Int64
                }
                if dict.keys.contains("SendRecoverMessage") {
                    self.sendRecoverMessage = dict["SendRecoverMessage"] as! Bool
                }
            }
        }
        public var notificationPolicies: [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notificationPolicies != nil {
                var tmp : [Any] = []
                for k in self.notificationPolicies! {
                    tmp.append(k.toMap())
                }
                map["NotificationPolicies"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NotificationPolicies") {
                var tmp : [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies] = []
                for v in dict["NotificationPolicies"] as! [Any] {
                    var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationPolicies = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListNotificationPoliciesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = ListNotificationPoliciesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListNotificationPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNotificationPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNotificationPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOnCallSchedulesRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListOnCallSchedulesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class OnCallSchedules : Tea.TeaModel {
            public var description_: String?

            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var onCallSchedules: [ListOnCallSchedulesResponseBody.PageBean.OnCallSchedules]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.onCallSchedules != nil {
                var tmp : [Any] = []
                for k in self.onCallSchedules! {
                    tmp.append(k.toMap())
                }
                map["OnCallSchedules"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OnCallSchedules") {
                var tmp : [ListOnCallSchedulesResponseBody.PageBean.OnCallSchedules] = []
                for v in dict["OnCallSchedules"] as! [Any] {
                    var model = ListOnCallSchedulesResponseBody.PageBean.OnCallSchedules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.onCallSchedules = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListOnCallSchedulesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = ListOnCallSchedulesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListOnCallSchedulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOnCallSchedulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListOnCallSchedulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusAlertRulesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clusterId: String?

    public var matchExpressions: String?

    public var name: String?

    public var regionId: String?

    public var status: Int32?

    public var tags: [ListPrometheusAlertRulesRequest.Tags]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.matchExpressions != nil {
            map["MatchExpressions"] = self.matchExpressions!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MatchExpressions") {
            self.matchExpressions = dict["MatchExpressions"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListPrometheusAlertRulesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListPrometheusAlertRulesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListPrometheusAlertRulesResponseBody : Tea.TeaModel {
    public class PrometheusAlertRules : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertId: Int64?

        public var alertName: String?

        public var annotations: [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Annotations]?

        public var clusterId: String?

        public var dispatchRuleId: Int64?

        public var duration: String?

        public var expression: String?

        public var labels: [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Labels]?

        public var message: String?

        public var notifyType: String?

        public var status: Int32?

        public var tags: [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Tags]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dispatchRuleId != nil {
                map["DispatchRuleId"] = self.dispatchRuleId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertId") {
                self.alertId = dict["AlertId"] as! Int64
            }
            if dict.keys.contains("AlertName") {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") {
                var tmp : [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("DispatchRuleId") {
                self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") {
                var tmp : [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NotifyType") {
                self.notifyType = dict["NotifyType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int64?

    public var message: String?

    public var prometheusAlertRules: [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.prometheusAlertRules != nil {
            var tmp : [Any] = []
            for k in self.prometheusAlertRules! {
                tmp.append(k.toMap())
            }
            map["PrometheusAlertRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PrometheusAlertRules") {
            var tmp : [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules] = []
            for v in dict["PrometheusAlertRules"] as! [Any] {
                var model = ListPrometheusAlertRulesResponseBody.PrometheusAlertRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.prometheusAlertRules = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListPrometheusAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrometheusAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusAlertTemplatesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListPrometheusAlertTemplatesResponseBody : Tea.TeaModel {
    public class PrometheusAlertTemplates : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertName: String?

        public var annotations: [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Annotations]?

        public var description_: String?

        public var duration: String?

        public var expression: String?

        public var labels: [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Labels]?

        public var type: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertName") {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") {
                var tmp : [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") {
                var tmp : [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var prometheusAlertTemplates: [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.prometheusAlertTemplates != nil {
            var tmp : [Any] = []
            for k in self.prometheusAlertTemplates! {
                tmp.append(k.toMap())
            }
            map["PrometheusAlertTemplates"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrometheusAlertTemplates") {
            var tmp : [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates] = []
            for v in dict["PrometheusAlertTemplates"] as! [Any] {
                var model = ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.prometheusAlertTemplates = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusAlertTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusAlertTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrometheusAlertTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusGlobalViewRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusInstanceByTagAndResourceGroupIdRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [ListPrometheusInstanceByTagAndResourceGroupIdRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListPrometheusInstanceByTagAndResourceGroupIdRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListPrometheusInstanceByTagAndResourceGroupIdRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListPrometheusInstanceByTagAndResourceGroupIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class PrometheusInstances : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagKey") {
                        self.tagKey = dict["TagKey"] as! String
                    }
                    if dict.keys.contains("TagValue") {
                        self.tagValue = dict["TagValue"] as! String
                    }
                }
            }
            public var authToken: String?

            public var clusterId: String?

            public var clusterName: String?

            public var clusterType: String?

            public var grafanaInstanceId: String?

            public var httpApiInterUrl: String?

            public var httpApiIntraUrl: String?

            public var paymentType: String?

            public var pushGatewayInterUrl: String?

            public var pushGatewayIntraUrl: String?

            public var regionId: String?

            public var remoteReadInterUrl: String?

            public var remoteReadIntraUrl: String?

            public var remoteWriteInterUrl: String?

            public var remoteWriteIntraUrl: String?

            public var resourceGroupId: String?

            public var resourceType: String?

            public var securityGroupId: String?

            public var subClustersJson: String?

            public var tags: [ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances.Tags]?

            public var userId: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authToken != nil {
                    map["AuthToken"] = self.authToken!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.grafanaInstanceId != nil {
                    map["GrafanaInstanceId"] = self.grafanaInstanceId!
                }
                if self.httpApiInterUrl != nil {
                    map["HttpApiInterUrl"] = self.httpApiInterUrl!
                }
                if self.httpApiIntraUrl != nil {
                    map["HttpApiIntraUrl"] = self.httpApiIntraUrl!
                }
                if self.paymentType != nil {
                    map["PaymentType"] = self.paymentType!
                }
                if self.pushGatewayInterUrl != nil {
                    map["PushGatewayInterUrl"] = self.pushGatewayInterUrl!
                }
                if self.pushGatewayIntraUrl != nil {
                    map["PushGatewayIntraUrl"] = self.pushGatewayIntraUrl!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.remoteReadInterUrl != nil {
                    map["RemoteReadInterUrl"] = self.remoteReadInterUrl!
                }
                if self.remoteReadIntraUrl != nil {
                    map["RemoteReadIntraUrl"] = self.remoteReadIntraUrl!
                }
                if self.remoteWriteInterUrl != nil {
                    map["RemoteWriteInterUrl"] = self.remoteWriteInterUrl!
                }
                if self.remoteWriteIntraUrl != nil {
                    map["RemoteWriteIntraUrl"] = self.remoteWriteIntraUrl!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.subClustersJson != nil {
                    map["SubClustersJson"] = self.subClustersJson!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthToken") {
                    self.authToken = dict["AuthToken"] as! String
                }
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("ClusterType") {
                    self.clusterType = dict["ClusterType"] as! String
                }
                if dict.keys.contains("GrafanaInstanceId") {
                    self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
                }
                if dict.keys.contains("HttpApiInterUrl") {
                    self.httpApiInterUrl = dict["HttpApiInterUrl"] as! String
                }
                if dict.keys.contains("HttpApiIntraUrl") {
                    self.httpApiIntraUrl = dict["HttpApiIntraUrl"] as! String
                }
                if dict.keys.contains("PaymentType") {
                    self.paymentType = dict["PaymentType"] as! String
                }
                if dict.keys.contains("PushGatewayInterUrl") {
                    self.pushGatewayInterUrl = dict["PushGatewayInterUrl"] as! String
                }
                if dict.keys.contains("PushGatewayIntraUrl") {
                    self.pushGatewayIntraUrl = dict["PushGatewayIntraUrl"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RemoteReadInterUrl") {
                    self.remoteReadInterUrl = dict["RemoteReadInterUrl"] as! String
                }
                if dict.keys.contains("RemoteReadIntraUrl") {
                    self.remoteReadIntraUrl = dict["RemoteReadIntraUrl"] as! String
                }
                if dict.keys.contains("RemoteWriteInterUrl") {
                    self.remoteWriteInterUrl = dict["RemoteWriteInterUrl"] as! String
                }
                if dict.keys.contains("RemoteWriteIntraUrl") {
                    self.remoteWriteIntraUrl = dict["RemoteWriteIntraUrl"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("SubClustersJson") {
                    self.subClustersJson = dict["SubClustersJson"] as! String
                }
                if dict.keys.contains("Tags") {
                    var tmp : [ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var prometheusInstances: [ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.prometheusInstances != nil {
                var tmp : [Any] = []
                for k in self.prometheusInstances! {
                    tmp.append(k.toMap())
                }
                map["PrometheusInstances"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrometheusInstances") {
                var tmp : [ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances] = []
                for v in dict["PrometheusInstances"] as! [Any] {
                    var model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.prometheusInstances = tmp
            }
        }
    }
    public var code: String?

    public var data: ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusInstanceByTagAndResourceGroupIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusInstanceByTagAndResourceGroupIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusInstancesRequest : Tea.TeaModel {
    public var clusterType: String?

    public var regionId: String?

    public var showGlobalView: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showGlobalView != nil {
            map["ShowGlobalView"] = self.showGlobalView!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ShowGlobalView") {
            self.showGlobalView = dict["ShowGlobalView"] as! Bool
        }
    }
}

public class ListPrometheusInstancesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrometheusInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integrationType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("IntegrationType") {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListPrometheusIntegrationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var canDelete: Bool?

        public var canEditor: Bool?

        public var clusterId: String?

        public var containerName: String?

        public var describe: String?

        public var exporterType: String?

        public var instanceId: Int64?

        public var instanceName: String?

        public var integrationType: String?

        public var namespace: String?

        public var needUpgrade: Bool?

        public var param: String?

        public var podName: String?

        public var showDescribe: Bool?

        public var showLog: Bool?

        public var status: String?

        public var target: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canDelete != nil {
                map["CanDelete"] = self.canDelete!
            }
            if self.canEditor != nil {
                map["CanEditor"] = self.canEditor!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.containerName != nil {
                map["ContainerName"] = self.containerName!
            }
            if self.describe != nil {
                map["Describe"] = self.describe!
            }
            if self.exporterType != nil {
                map["ExporterType"] = self.exporterType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.integrationType != nil {
                map["IntegrationType"] = self.integrationType!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.needUpgrade != nil {
                map["NeedUpgrade"] = self.needUpgrade!
            }
            if self.param != nil {
                map["Param"] = self.param!
            }
            if self.podName != nil {
                map["PodName"] = self.podName!
            }
            if self.showDescribe != nil {
                map["ShowDescribe"] = self.showDescribe!
            }
            if self.showLog != nil {
                map["ShowLog"] = self.showLog!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanDelete") {
                self.canDelete = dict["CanDelete"] as! Bool
            }
            if dict.keys.contains("CanEditor") {
                self.canEditor = dict["CanEditor"] as! Bool
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ContainerName") {
                self.containerName = dict["ContainerName"] as! String
            }
            if dict.keys.contains("Describe") {
                self.describe = dict["Describe"] as! String
            }
            if dict.keys.contains("ExporterType") {
                self.exporterType = dict["ExporterType"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("IntegrationType") {
                self.integrationType = dict["IntegrationType"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NeedUpgrade") {
                self.needUpgrade = dict["NeedUpgrade"] as! Bool
            }
            if dict.keys.contains("Param") {
                self.param = dict["Param"] as! String
            }
            if dict.keys.contains("PodName") {
                self.podName = dict["PodName"] as! String
            }
            if dict.keys.contains("ShowDescribe") {
                self.showDescribe = dict["ShowDescribe"] as! Bool
            }
            if dict.keys.contains("ShowLog") {
                self.showLog = dict["ShowLog"] as! Bool
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Target") {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListPrometheusIntegrationResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListPrometheusIntegrationResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListPrometheusIntegrationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListPrometheusMonitoringResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var configYaml: String?

        public var monitoringName: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.monitoringName != nil {
                map["MonitoringName"] = self.monitoringName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ConfigYaml") {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("MonitoringName") {
                self.monitoringName = dict["MonitoringName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListPrometheusMonitoringResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListPrometheusMonitoringResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListPrometheusMonitoringResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusRemoteWritesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListPrometheusRemoteWritesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var remoteWriteName: String?

        public var remoteWriteYaml: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.remoteWriteName != nil {
                map["RemoteWriteName"] = self.remoteWriteName!
            }
            if self.remoteWriteYaml != nil {
                map["RemoteWriteYaml"] = self.remoteWriteYaml!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("RemoteWriteName") {
                self.remoteWriteName = dict["RemoteWriteName"] as! String
            }
            if dict.keys.contains("RemoteWriteYaml") {
                self.remoteWriteYaml = dict["RemoteWriteYaml"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListPrometheusRemoteWritesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListPrometheusRemoteWritesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListPrometheusRemoteWritesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListPrometheusRemoteWritesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusRemoteWritesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrometheusRemoteWritesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRetcodeAppsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [ListRetcodeAppsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListRetcodeAppsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListRetcodeAppsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListRetcodeAppsResponseBody : Tea.TeaModel {
    public class RetcodeApps : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: Int64?

        public var appName: String?

        public var nickName: String?

        public var pid: String?

        public var resourceGroupId: String?

        public var retcodeAppType: String?

        public var tags: [ListRetcodeAppsResponseBody.RetcodeApps.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.retcodeAppType != nil {
                map["RetcodeAppType"] = self.retcodeAppType!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("NickName") {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RetcodeAppType") {
                self.retcodeAppType = dict["RetcodeAppType"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListRetcodeAppsResponseBody.RetcodeApps.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListRetcodeAppsResponseBody.RetcodeApps.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var requestId: String?

    public var retcodeApps: [ListRetcodeAppsResponseBody.RetcodeApps]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retcodeApps != nil {
            var tmp : [Any] = []
            for k in self.retcodeApps! {
                tmp.append(k.toMap())
            }
            map["RetcodeApps"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetcodeApps") {
            var tmp : [ListRetcodeAppsResponseBody.RetcodeApps] = []
            for v in dict["RetcodeApps"] as! [Any] {
                var model = ListRetcodeAppsResponseBody.RetcodeApps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.retcodeApps = tmp
        }
    }
}

public class ListRetcodeAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRetcodeAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRetcodeAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScenarioRequest : Tea.TeaModel {
    public var appId: String?

    public var name: String?

    public var regionId: String?

    public var scenario: String?

    public var sign: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        if self.sign != nil {
            map["Sign"] = self.sign!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scenario") {
            self.scenario = dict["Scenario"] as! String
        }
        if dict.keys.contains("Sign") {
            self.sign = dict["Sign"] as! String
        }
    }
}

public class ListScenarioResponseBody : Tea.TeaModel {
    public class ArmsScenarios : Tea.TeaModel {
        public var appId: String?

        public var createTime: String?

        public var extensions: String?

        public var id: Int64?

        public var name: String?

        public var regionId: String?

        public var sign: String?

        public var updateTime: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extensions != nil {
                map["Extensions"] = self.extensions!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.sign != nil {
                map["Sign"] = self.sign!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Extensions") {
                self.extensions = dict["Extensions"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Sign") {
                self.sign = dict["Sign"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var armsScenarios: [ListScenarioResponseBody.ArmsScenarios]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.armsScenarios != nil {
            var tmp : [Any] = []
            for k in self.armsScenarios! {
                tmp.append(k.toMap())
            }
            map["ArmsScenarios"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ArmsScenarios") {
            var tmp : [ListScenarioResponseBody.ArmsScenarios] = []
            for v in dict["ArmsScenarios"] as! [Any] {
                var model = ListScenarioResponseBody.ArmsScenarios()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.armsScenarios = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSilencePoliciesRequest : Tea.TeaModel {
    public var isDetail: Bool?

    public var name: String?

    public var page: Int64?

    public var regionId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsDetail") {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListSilencePoliciesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class SilencePolicies : Tea.TeaModel {
            public class MatchingRules : Tea.TeaModel {
                public class MatchingConditions : Tea.TeaModel {
                    public var key: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var matchingConditions: [ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules.MatchingConditions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.matchingConditions != nil {
                        var tmp : [Any] = []
                        for k in self.matchingConditions! {
                            tmp.append(k.toMap())
                        }
                        map["MatchingConditions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MatchingConditions") {
                        var tmp : [ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules.MatchingConditions] = []
                        for v in dict["MatchingConditions"] as! [Any] {
                            var model = ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules.MatchingConditions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.matchingConditions = tmp
                    }
                }
            }
            public var id: Int64?

            public var matchingRules: [ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules]?

            public var name: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.matchingRules != nil {
                    var tmp : [Any] = []
                    for k in self.matchingRules! {
                        tmp.append(k.toMap())
                    }
                    map["MatchingRules"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MatchingRules") {
                    var tmp : [ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules] = []
                    for v in dict["MatchingRules"] as! [Any] {
                        var model = ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.matchingRules = tmp
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var page: Int64?

        public var silencePolicies: [ListSilencePoliciesResponseBody.PageBean.SilencePolicies]?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.silencePolicies != nil {
                var tmp : [Any] = []
                for k in self.silencePolicies! {
                    tmp.append(k.toMap())
                }
                map["SilencePolicies"] = tmp
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("SilencePolicies") {
                var tmp : [ListSilencePoliciesResponseBody.PageBean.SilencePolicies] = []
                for v in dict["SilencePolicies"] as! [Any] {
                    var model = ListSilencePoliciesResponseBody.PageBean.SilencePolicies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.silencePolicies = tmp
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListSilencePoliciesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = ListSilencePoliciesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSilencePoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSilencePoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSilencePoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSyntheticDetailRequest : Tea.TeaModel {
    public class AdvancedFilters : Tea.TeaModel {
        public var key: String?

        public var opType: String?

        public var value: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("OpType") {
                self.opType = dict["OpType"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! Any
            }
        }
    }
    public class ExactFilters : Tea.TeaModel {
        public var key: String?

        public var opType: String?

        public var value: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("OpType") {
                self.opType = dict["OpType"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! Any
            }
        }
    }
    public var advancedFilters: [ListSyntheticDetailRequest.AdvancedFilters]?

    public var category: String?

    public var detail: String?

    public var endTime: Int64?

    public var exactFilters: [ListSyntheticDetailRequest.ExactFilters]?

    public var filters: [String: String]?

    public var order: String?

    public var orderBy: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: Int64?

    public var syntheticType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedFilters != nil {
            var tmp : [Any] = []
            for k in self.advancedFilters! {
                tmp.append(k.toMap())
            }
            map["AdvancedFilters"] = tmp
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.detail != nil {
            map["Detail"] = self.detail!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.exactFilters != nil {
            var tmp : [Any] = []
            for k in self.exactFilters! {
                tmp.append(k.toMap())
            }
            map["ExactFilters"] = tmp
        }
        if self.filters != nil {
            map["Filters"] = self.filters!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.syntheticType != nil {
            map["SyntheticType"] = self.syntheticType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdvancedFilters") {
            var tmp : [ListSyntheticDetailRequest.AdvancedFilters] = []
            for v in dict["AdvancedFilters"] as! [Any] {
                var model = ListSyntheticDetailRequest.AdvancedFilters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.advancedFilters = tmp
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Detail") {
            self.detail = dict["Detail"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExactFilters") {
            var tmp : [ListSyntheticDetailRequest.ExactFilters] = []
            for v in dict["ExactFilters"] as! [Any] {
                var model = ListSyntheticDetailRequest.ExactFilters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.exactFilters = tmp
        }
        if dict.keys.contains("Filters") {
            self.filters = dict["Filters"] as! [String: String]
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("SyntheticType") {
            self.syntheticType = dict["SyntheticType"] as! Int32
        }
    }
}

public class ListSyntheticDetailShrinkRequest : Tea.TeaModel {
    public var advancedFiltersShrink: String?

    public var category: String?

    public var detail: String?

    public var endTime: Int64?

    public var exactFiltersShrink: String?

    public var filtersShrink: String?

    public var order: String?

    public var orderBy: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: Int64?

    public var syntheticType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedFiltersShrink != nil {
            map["AdvancedFilters"] = self.advancedFiltersShrink!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.detail != nil {
            map["Detail"] = self.detail!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.exactFiltersShrink != nil {
            map["ExactFilters"] = self.exactFiltersShrink!
        }
        if self.filtersShrink != nil {
            map["Filters"] = self.filtersShrink!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.syntheticType != nil {
            map["SyntheticType"] = self.syntheticType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdvancedFilters") {
            self.advancedFiltersShrink = dict["AdvancedFilters"] as! String
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Detail") {
            self.detail = dict["Detail"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExactFilters") {
            self.exactFiltersShrink = dict["ExactFilters"] as! String
        }
        if dict.keys.contains("Filters") {
            self.filtersShrink = dict["Filters"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("SyntheticType") {
            self.syntheticType = dict["SyntheticType"] as! Int32
        }
    }
}

public class ListSyntheticDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var items: [[String: Any]]?

        public var page: Int32?

        public var pageSize: Int32?

        public var taskCreateTime: Int64?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.items != nil {
                map["Items"] = self.items!
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.taskCreateTime != nil {
                map["TaskCreateTime"] = self.taskCreateTime!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Items") {
                self.items = dict["Items"] as! [[String: Any]]
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TaskCreateTime") {
                self.taskCreateTime = dict["TaskCreateTime"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: Int64?

    public var data: ListSyntheticDetailResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = ListSyntheticDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSyntheticDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSyntheticDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSyntheticDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTimingSyntheticTasksRequest : Tea.TeaModel {
    public class Search : Tea.TeaModel {
        public var name: String?

        public var order: Int32?

        public var orderField: String?

        public var page: Int32?

        public var pageSize: Int32?

        public var status: String?

        public var taskIds: [String]?

        public var taskTypes: [Int32]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.order != nil {
                map["Order"] = self.order!
            }
            if self.orderField != nil {
                map["OrderField"] = self.orderField!
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.taskTypes != nil {
                map["TaskTypes"] = self.taskTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Order") {
                self.order = dict["Order"] as! Int32
            }
            if dict.keys.contains("OrderField") {
                self.orderField = dict["OrderField"] as! String
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskIds") {
                self.taskIds = dict["TaskIds"] as! [String]
            }
            if dict.keys.contains("TaskTypes") {
                self.taskTypes = dict["TaskTypes"] as! [Int32]
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceGroupId: String?

    public var search: ListTimingSyntheticTasksRequest.Search?

    public var tags: [ListTimingSyntheticTasksRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.search?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.search != nil {
            map["Search"] = self.search?.toMap()
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Search") {
            var model = ListTimingSyntheticTasksRequest.Search()
            model.fromMap(dict["Search"] as! [String: Any])
            self.search = model
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListTimingSyntheticTasksRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListTimingSyntheticTasksRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListTimingSyntheticTasksShrinkRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceGroupId: String?

    public var searchShrink: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.searchShrink != nil {
            map["Search"] = self.searchShrink!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Search") {
            self.searchShrink = dict["Search"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class ListTimingSyntheticTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Items : Tea.TeaModel {
            public class CommonSetting : Tea.TeaModel {
                public class CustomHost : Tea.TeaModel {
                    public class Hosts : Tea.TeaModel {
                        public var domain: String?

                        public var ipType: Int32?

                        public var ips: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.domain != nil {
                                map["Domain"] = self.domain!
                            }
                            if self.ipType != nil {
                                map["IpType"] = self.ipType!
                            }
                            if self.ips != nil {
                                map["Ips"] = self.ips!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Domain") {
                                self.domain = dict["Domain"] as! String
                            }
                            if dict.keys.contains("IpType") {
                                self.ipType = dict["IpType"] as! Int32
                            }
                            if dict.keys.contains("Ips") {
                                self.ips = dict["Ips"] as! [String]
                            }
                        }
                    }
                    public var hosts: [ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting.CustomHost.Hosts]?

                    public var selectType: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.hosts != nil {
                            var tmp : [Any] = []
                            for k in self.hosts! {
                                tmp.append(k.toMap())
                            }
                            map["Hosts"] = tmp
                        }
                        if self.selectType != nil {
                            map["SelectType"] = self.selectType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Hosts") {
                            var tmp : [ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting.CustomHost.Hosts] = []
                            for v in dict["Hosts"] as! [Any] {
                                var model = ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting.CustomHost.Hosts()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.hosts = tmp
                        }
                        if dict.keys.contains("SelectType") {
                            self.selectType = dict["SelectType"] as! Int32
                        }
                    }
                }
                public class CustomPrometheusSetting : Tea.TeaModel {
                    public var prometheusClusterId: String?

                    public var prometheusClusterRegion: String?

                    public var prometheusLabels: [String: String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.prometheusClusterId != nil {
                            map["PrometheusClusterId"] = self.prometheusClusterId!
                        }
                        if self.prometheusClusterRegion != nil {
                            map["PrometheusClusterRegion"] = self.prometheusClusterRegion!
                        }
                        if self.prometheusLabels != nil {
                            map["PrometheusLabels"] = self.prometheusLabels!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("PrometheusClusterId") {
                            self.prometheusClusterId = dict["PrometheusClusterId"] as! String
                        }
                        if dict.keys.contains("PrometheusClusterRegion") {
                            self.prometheusClusterRegion = dict["PrometheusClusterRegion"] as! String
                        }
                        if dict.keys.contains("PrometheusLabels") {
                            self.prometheusLabels = dict["PrometheusLabels"] as! [String: String]
                        }
                    }
                }
                public class CustomVPCSetting : Tea.TeaModel {
                    public var regionId: String?

                    public var secureGroupId: String?

                    public var vSwitchId: String?

                    public var vpcId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.secureGroupId != nil {
                            map["SecureGroupId"] = self.secureGroupId!
                        }
                        if self.vSwitchId != nil {
                            map["VSwitchId"] = self.vSwitchId!
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("RegionId") {
                            self.regionId = dict["RegionId"] as! String
                        }
                        if dict.keys.contains("SecureGroupId") {
                            self.secureGroupId = dict["SecureGroupId"] as! String
                        }
                        if dict.keys.contains("VSwitchId") {
                            self.vSwitchId = dict["VSwitchId"] as! String
                        }
                        if dict.keys.contains("VpcId") {
                            self.vpcId = dict["VpcId"] as! String
                        }
                    }
                }
                public var customHost: ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting.CustomHost?

                public var customPrometheusSetting: ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting.CustomPrometheusSetting?

                public var customVPCSetting: ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting.CustomVPCSetting?

                public var ipType: Int32?

                public var isOpenTrace: Bool?

                public var monitorSamples: Int32?

                public var traceClientType: Int32?

                public var xtraceRegion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.customHost?.validate()
                    try self.customPrometheusSetting?.validate()
                    try self.customVPCSetting?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.customHost != nil {
                        map["CustomHost"] = self.customHost?.toMap()
                    }
                    if self.customPrometheusSetting != nil {
                        map["CustomPrometheusSetting"] = self.customPrometheusSetting?.toMap()
                    }
                    if self.customVPCSetting != nil {
                        map["CustomVPCSetting"] = self.customVPCSetting?.toMap()
                    }
                    if self.ipType != nil {
                        map["IpType"] = self.ipType!
                    }
                    if self.isOpenTrace != nil {
                        map["IsOpenTrace"] = self.isOpenTrace!
                    }
                    if self.monitorSamples != nil {
                        map["MonitorSamples"] = self.monitorSamples!
                    }
                    if self.traceClientType != nil {
                        map["TraceClientType"] = self.traceClientType!
                    }
                    if self.xtraceRegion != nil {
                        map["XtraceRegion"] = self.xtraceRegion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CustomHost") {
                        var model = ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting.CustomHost()
                        model.fromMap(dict["CustomHost"] as! [String: Any])
                        self.customHost = model
                    }
                    if dict.keys.contains("CustomPrometheusSetting") {
                        var model = ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting.CustomPrometheusSetting()
                        model.fromMap(dict["CustomPrometheusSetting"] as! [String: Any])
                        self.customPrometheusSetting = model
                    }
                    if dict.keys.contains("CustomVPCSetting") {
                        var model = ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting.CustomVPCSetting()
                        model.fromMap(dict["CustomVPCSetting"] as! [String: Any])
                        self.customVPCSetting = model
                    }
                    if dict.keys.contains("IpType") {
                        self.ipType = dict["IpType"] as! Int32
                    }
                    if dict.keys.contains("IsOpenTrace") {
                        self.isOpenTrace = dict["IsOpenTrace"] as! Bool
                    }
                    if dict.keys.contains("MonitorSamples") {
                        self.monitorSamples = dict["MonitorSamples"] as! Int32
                    }
                    if dict.keys.contains("TraceClientType") {
                        self.traceClientType = dict["TraceClientType"] as! Int32
                    }
                    if dict.keys.contains("XtraceRegion") {
                        self.xtraceRegion = dict["XtraceRegion"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var commonSetting: ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting?

            public var frequency: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var monitorCategory: Int32?

            public var monitorNum: String?

            public var name: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var status: String?

            public var tags: [ListTimingSyntheticTasksResponseBody.Data.Items.Tags]?

            public var taskId: String?

            public var taskType: Int32?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.commonSetting?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commonSetting != nil {
                    map["CommonSetting"] = self.commonSetting?.toMap()
                }
                if self.frequency != nil {
                    map["Frequency"] = self.frequency!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.monitorCategory != nil {
                    map["MonitorCategory"] = self.monitorCategory!
                }
                if self.monitorNum != nil {
                    map["MonitorNum"] = self.monitorNum!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CommonSetting") {
                    var model = ListTimingSyntheticTasksResponseBody.Data.Items.CommonSetting()
                    model.fromMap(dict["CommonSetting"] as! [String: Any])
                    self.commonSetting = model
                }
                if dict.keys.contains("Frequency") {
                    self.frequency = dict["Frequency"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("MonitorCategory") {
                    self.monitorCategory = dict["MonitorCategory"] as! Int32
                }
                if dict.keys.contains("MonitorNum") {
                    self.monitorNum = dict["MonitorNum"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var tmp : [ListTimingSyntheticTasksResponseBody.Data.Items.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListTimingSyntheticTasksResponseBody.Data.Items.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! Int32
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var items: [ListTimingSyntheticTasksResponseBody.Data.Items]?

        public var page: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.items != nil {
                var tmp : [Any] = []
                for k in self.items! {
                    tmp.append(k.toMap())
                }
                map["Items"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Items") {
                var tmp : [ListTimingSyntheticTasksResponseBody.Data.Items] = []
                for v in dict["Items"] as! [Any] {
                    var model = ListTimingSyntheticTasksResponseBody.Data.Items()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.items = tmp
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: Int64?

    public var data: ListTimingSyntheticTasksResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = ListTimingSyntheticTasksResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTimingSyntheticTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTimingSyntheticTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTimingSyntheticTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTraceAppsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appType: String?

    public var region: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [ListTraceAppsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListTraceAppsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListTraceAppsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListTraceAppsResponseBody : Tea.TeaModel {
    public class TraceApps : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: Int64?

        public var appName: String?

        public var clusterId: String?

        public var createTime: Int64?

        public var labels: [String]?

        public var language: String?

        public var namespace: String?

        public var pid: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var show: Bool?

        public var source: String?

        public var tags: [ListTraceAppsResponseBody.TraceApps.Tags]?

        public var type: String?

        public var updateTime: Int64?

        public var userId: String?

        public var workloadKind: String?

        public var workloadName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.labels != nil {
                map["Labels"] = self.labels!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.show != nil {
                map["Show"] = self.show!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workloadKind != nil {
                map["WorkloadKind"] = self.workloadKind!
            }
            if self.workloadName != nil {
                map["WorkloadName"] = self.workloadName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Labels") {
                self.labels = dict["Labels"] as! [String]
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Show") {
                self.show = dict["Show"] as! Bool
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListTraceAppsResponseBody.TraceApps.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListTraceAppsResponseBody.TraceApps.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WorkloadKind") {
                self.workloadKind = dict["WorkloadKind"] as! String
            }
            if dict.keys.contains("WorkloadName") {
                self.workloadName = dict["WorkloadName"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceApps: [ListTraceAppsResponseBody.TraceApps]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceApps != nil {
            var tmp : [Any] = []
            for k in self.traceApps! {
                tmp.append(k.toMap())
            }
            map["TraceApps"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceApps") {
            var tmp : [ListTraceAppsResponseBody.TraceApps] = []
            for v in dict["TraceApps"] as! [Any] {
                var model = ListTraceAppsResponseBody.TraceApps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traceApps = tmp
        }
    }
}

public class ListTraceAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTraceAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTraceAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ManageGetRecordingRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var queryUserId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.queryUserId != nil {
            map["QueryUserId"] = self.queryUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("QueryUserId") {
            self.queryUserId = dict["QueryUserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ManageGetRecordingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ManageGetRecordingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ManageGetRecordingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ManageGetRecordingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ManageRecordingRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var queryUserId: String?

    public var regionId: String?

    public var ruleYaml: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.queryUserId != nil {
            map["QueryUserId"] = self.queryUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleYaml != nil {
            map["RuleYaml"] = self.ruleYaml!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("QueryUserId") {
            self.queryUserId = dict["QueryUserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleYaml") {
            self.ruleYaml = dict["RuleYaml"] as! String
        }
    }
}

public class ManageRecordingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ManageRecordingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ManageRecordingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ManageRecordingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenArmsDefaultSLRRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class OpenArmsDefaultSLRResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenArmsDefaultSLRResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenArmsDefaultSLRResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenArmsDefaultSLRResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenArmsServiceSecondVersionRequest : Tea.TeaModel {
    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class OpenArmsServiceSecondVersionResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenArmsServiceSecondVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenArmsServiceSecondVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenArmsServiceSecondVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenVClusterRequest : Tea.TeaModel {
    public var clusterType: String?

    public var length: Int32?

    public var product: String?

    public var recreateSwitch: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.recreateSwitch != nil {
            map["RecreateSwitch"] = self.recreateSwitch!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("Length") {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("Product") {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RecreateSwitch") {
            self.recreateSwitch = dict["RecreateSwitch"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class OpenVClusterResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenVClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenVClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenVClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenXtraceDefaultSLRRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class OpenXtraceDefaultSLRResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenXtraceDefaultSLRResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenXtraceDefaultSLRResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenXtraceDefaultSLRResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAppMetadataRequest : Tea.TeaModel {
    public var metaIds: String?

    public var metaType: String?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metaIds != nil {
            map["MetaIds"] = self.metaIds!
        }
        if self.metaType != nil {
            map["MetaType"] = self.metaType!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetaIds") {
            self.metaIds = dict["MetaIds"] as! String
        }
        if dict.keys.contains("MetaType") {
            self.metaType = dict["MetaType"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class QueryAppMetadataResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String: Any]?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String: Any]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAppMetadataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAppMetadataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAppMetadataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAppTopologyRequest : Tea.TeaModel {
    public var appType: String?

    public var db: String?

    public var dbName: String?

    public var endTime: Int64?

    public var filters: [String: String]?

    public var pid: String?

    public var regionId: String?

    public var rpc: String?

    public var startTime: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.db != nil {
            map["Db"] = self.db!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            map["Filters"] = self.filters!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rpc != nil {
            map["Rpc"] = self.rpc!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Db") {
            self.db = dict["Db"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Filters") {
            self.filters = dict["Filters"] as! [String: String]
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Rpc") {
            self.rpc = dict["Rpc"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class QueryAppTopologyShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var db: String?

    public var dbName: String?

    public var endTime: Int64?

    public var filtersShrink: String?

    public var pid: String?

    public var regionId: String?

    public var rpc: String?

    public var startTime: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.db != nil {
            map["Db"] = self.db!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filtersShrink != nil {
            map["Filters"] = self.filtersShrink!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rpc != nil {
            map["Rpc"] = self.rpc!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Db") {
            self.db = dict["Db"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Filters") {
            self.filtersShrink = dict["Filters"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Rpc") {
            self.rpc = dict["Rpc"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class QueryAppTopologyResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: Any?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAppTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAppTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAppTopologyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCommercialUsageRequest : Tea.TeaModel {
    public class AdvancedFilters : Tea.TeaModel {
        public var key: String?

        public var opType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("OpType") {
                self.opType = dict["OpType"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var advancedFilters: [QueryCommercialUsageRequest.AdvancedFilters]?

    public var dimensions: [String]?

    public var endTime: Int64?

    public var intervalInSec: Int32?

    public var measures: [String]?

    public var metric: String?

    public var order: String?

    public var orderBy: String?

    public var queryType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedFilters != nil {
            var tmp : [Any] = []
            for k in self.advancedFilters! {
                tmp.append(k.toMap())
            }
            map["AdvancedFilters"] = tmp
        }
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.intervalInSec != nil {
            map["IntervalInSec"] = self.intervalInSec!
        }
        if self.measures != nil {
            map["Measures"] = self.measures!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.queryType != nil {
            map["QueryType"] = self.queryType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdvancedFilters") {
            var tmp : [QueryCommercialUsageRequest.AdvancedFilters] = []
            for v in dict["AdvancedFilters"] as! [Any] {
                var model = QueryCommercialUsageRequest.AdvancedFilters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.advancedFilters = tmp
        }
        if dict.keys.contains("Dimensions") {
            self.dimensions = dict["Dimensions"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("IntervalInSec") {
            self.intervalInSec = dict["IntervalInSec"] as! Int32
        }
        if dict.keys.contains("Measures") {
            self.measures = dict["Measures"] as! [String]
        }
        if dict.keys.contains("Metric") {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("QueryType") {
            self.queryType = dict["QueryType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class QueryCommercialUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var complete: Bool?

        public var items: [[String: Any]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["Complete"] = self.complete!
            }
            if self.items != nil {
                map["Items"] = self.items!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Complete") {
                self.complete = dict["Complete"] as! Bool
            }
            if dict.keys.contains("Items") {
                self.items = dict["Items"] as! [[String: Any]]
            }
        }
    }
    public var code: String?

    public var data: QueryCommercialUsageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = QueryCommercialUsageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryCommercialUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCommercialUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryCommercialUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMetricByPageRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var customFilters: [String]?

    public var dimensions: [String]?

    public var endTime: Int64?

    public var filters: [QueryMetricByPageRequest.Filters]?

    public var intervalInSec: Int32?

    public var measures: [String]?

    public var metric: String?

    public var order: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.customFilters != nil {
            map["CustomFilters"] = self.customFilters!
        }
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.intervalInSec != nil {
            map["IntervalInSec"] = self.intervalInSec!
        }
        if self.measures != nil {
            map["Measures"] = self.measures!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("CustomFilters") {
            self.customFilters = dict["CustomFilters"] as! [String]
        }
        if dict.keys.contains("Dimensions") {
            self.dimensions = dict["Dimensions"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Filters") {
            var tmp : [QueryMetricByPageRequest.Filters] = []
            for v in dict["Filters"] as! [Any] {
                var model = QueryMetricByPageRequest.Filters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filters = tmp
        }
        if dict.keys.contains("IntervalInSec") {
            self.intervalInSec = dict["IntervalInSec"] as! Int32
        }
        if dict.keys.contains("Measures") {
            self.measures = dict["Measures"] as! [String]
        }
        if dict.keys.contains("Metric") {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class QueryMetricByPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var completed: Bool?

        public var items: [[String: Any]]?

        public var page: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completed != nil {
                map["Completed"] = self.completed!
            }
            if self.items != nil {
                map["Items"] = self.items!
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Completed") {
                self.completed = dict["Completed"] as! Bool
            }
            if dict.keys.contains("Items") {
                self.items = dict["Items"] as! [[String: Any]]
            }
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: QueryMetricByPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = QueryMetricByPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMetricByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMetricByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMetricByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPromInstallStatusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class QueryPromInstallStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var isControllerInstalled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isControllerInstalled != nil {
                map["isControllerInstalled"] = self.isControllerInstalled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("isControllerInstalled") {
                self.isControllerInstalled = dict["isControllerInstalled"] as! Bool
            }
        }
    }
    public var data: QueryPromInstallStatusResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryPromInstallStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryPromInstallStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPromInstallStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryPromInstallStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryReleaseMetricRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public var createTime: Int64?

    public var metricType: String?

    public var pid: String?

    public var proxyUserId: String?

    public var releaseEndTime: Int64?

    public var releaseStartTime: Int64?

    public var service: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.proxyUserId != nil {
            map["ProxyUserId"] = self.proxyUserId!
        }
        if self.releaseEndTime != nil {
            map["ReleaseEndTime"] = self.releaseEndTime!
        }
        if self.releaseStartTime != nil {
            map["ReleaseStartTime"] = self.releaseStartTime!
        }
        if self.service != nil {
            map["Service"] = self.service!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("ProxyUserId") {
            self.proxyUserId = dict["ProxyUserId"] as! String
        }
        if dict.keys.contains("ReleaseEndTime") {
            self.releaseEndTime = dict["ReleaseEndTime"] as! Int64
        }
        if dict.keys.contains("ReleaseStartTime") {
            self.releaseStartTime = dict["ReleaseStartTime"] as! Int64
        }
        if dict.keys.contains("Service") {
            self.service = dict["Service"] as! String
        }
    }
}

public class QueryReleaseMetricResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryReleaseMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryReleaseMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryReleaseMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAliClusterIdsFromPrometheusGlobalViewRequest : Tea.TeaModel {
    public var clusterIds: String?

    public var globalViewClusterId: String?

    public var groupName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") {
            self.clusterIds = dict["ClusterIds"] as! String
        }
        if dict.keys.contains("GlobalViewClusterId") {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveAliClusterIdsFromPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveSourcesFromPrometheusGlobalViewRequest : Tea.TeaModel {
    public var globalViewClusterId: String?

    public var groupName: String?

    public var regionId: String?

    public var sourceNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sourceNames != nil {
            map["SourceNames"] = self.sourceNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalViewClusterId") {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SourceNames") {
            self.sourceNames = dict["SourceNames"] as! String
        }
    }
}

public class RemoveSourcesFromPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: RemoveSourcesFromPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = RemoveSourcesFromPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveSourcesFromPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSourcesFromPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveSourcesFromPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartEnvironmentFeatureRequest : Tea.TeaModel {
    public var environmentId: String?

    public var featureName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RestartEnvironmentFeatureResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestartEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveTraceAppConfigRequest : Tea.TeaModel {
    public class Settings : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pid: String?

    public var settings: [SaveTraceAppConfigRequest.Settings]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.settings != nil {
            var tmp : [Any] = []
            for k in self.settings! {
                tmp.append(k.toMap())
            }
            map["Settings"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("Settings") {
            var tmp : [SaveTraceAppConfigRequest.Settings] = []
            for v in dict["Settings"] as! [Any] {
                var model = SaveTraceAppConfigRequest.Settings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.settings = tmp
        }
    }
}

public class SaveTraceAppConfigResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveTraceAppConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveTraceAppConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveTraceAppConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchAlertContactRequest : Tea.TeaModel {
    public var contactIds: String?

    public var contactName: String?

    public var currentPage: String?

    public var email: String?

    public var pageSize: String?

    public var phone: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIds") {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("Email") {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Phone") {
            self.phone = dict["Phone"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SearchAlertContactResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class Contacts : Tea.TeaModel {
            public var contactId: Int64?

            public var contactName: String?

            public var content: String?

            public var createTime: Int64?

            public var dingRobot: String?

            public var email: String?

            public var phone: String?

            public var resourceGroupId: String?

            public var systemNoc: Bool?

            public var updateTime: Int64?

            public var userId: String?

            public var webhook: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dingRobot != nil {
                    map["DingRobot"] = self.dingRobot!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.systemNoc != nil {
                    map["SystemNoc"] = self.systemNoc!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.webhook != nil {
                    map["Webhook"] = self.webhook!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! Int64
                }
                if dict.keys.contains("ContactName") {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DingRobot") {
                    self.dingRobot = dict["DingRobot"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Phone") {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SystemNoc") {
                    self.systemNoc = dict["SystemNoc"] as! Bool
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Webhook") {
                    self.webhook = dict["Webhook"] as! String
                }
            }
        }
        public var contacts: [SearchAlertContactResponseBody.PageBean.Contacts]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contacts != nil {
                var tmp : [Any] = []
                for k in self.contacts! {
                    tmp.append(k.toMap())
                }
                map["Contacts"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Contacts") {
                var tmp : [SearchAlertContactResponseBody.PageBean.Contacts] = []
                for v in dict["Contacts"] as! [Any] {
                    var model = SearchAlertContactResponseBody.PageBean.Contacts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contacts = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageBean: SearchAlertContactResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = SearchAlertContactResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchAlertContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchAlertContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchAlertContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchAlertContactGroupRequest : Tea.TeaModel {
    public var contactGroupIds: String?

    public var contactGroupName: String?

    public var contactId: Int64?

    public var contactName: String?

    public var isDetail: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupIds != nil {
            map["ContactGroupIds"] = self.contactGroupIds!
        }
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupIds") {
            self.contactGroupIds = dict["ContactGroupIds"] as! String
        }
        if dict.keys.contains("ContactGroupName") {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("IsDetail") {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SearchAlertContactGroupResponseBody : Tea.TeaModel {
    public class ContactGroups : Tea.TeaModel {
        public class Contacts : Tea.TeaModel {
            public var contactId: Int64?

            public var contactName: String?

            public var createTime: Int64?

            public var dingRobot: String?

            public var email: String?

            public var phone: String?

            public var systemNoc: Bool?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dingRobot != nil {
                    map["DingRobot"] = self.dingRobot!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.systemNoc != nil {
                    map["SystemNoc"] = self.systemNoc!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! Int64
                }
                if dict.keys.contains("ContactName") {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DingRobot") {
                    self.dingRobot = dict["DingRobot"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Phone") {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("SystemNoc") {
                    self.systemNoc = dict["SystemNoc"] as! Bool
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var contactGroupId: Int64?

        public var contactGroupName: String?

        public var contacts: [SearchAlertContactGroupResponseBody.ContactGroups.Contacts]?

        public var createTime: Int64?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactGroupId != nil {
                map["ContactGroupId"] = self.contactGroupId!
            }
            if self.contactGroupName != nil {
                map["ContactGroupName"] = self.contactGroupName!
            }
            if self.contacts != nil {
                var tmp : [Any] = []
                for k in self.contacts! {
                    tmp.append(k.toMap())
                }
                map["Contacts"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactGroupId") {
                self.contactGroupId = dict["ContactGroupId"] as! Int64
            }
            if dict.keys.contains("ContactGroupName") {
                self.contactGroupName = dict["ContactGroupName"] as! String
            }
            if dict.keys.contains("Contacts") {
                var tmp : [SearchAlertContactGroupResponseBody.ContactGroups.Contacts] = []
                for v in dict["Contacts"] as! [Any] {
                    var model = SearchAlertContactGroupResponseBody.ContactGroups.Contacts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contacts = tmp
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var contactGroups: [SearchAlertContactGroupResponseBody.ContactGroups]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroups != nil {
            var tmp : [Any] = []
            for k in self.contactGroups! {
                tmp.append(k.toMap())
            }
            map["ContactGroups"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroups") {
            var tmp : [SearchAlertContactGroupResponseBody.ContactGroups] = []
            for v in dict["ContactGroups"] as! [Any] {
                var model = SearchAlertContactGroupResponseBody.ContactGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contactGroups = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchAlertContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchAlertContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchAlertContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchAlertHistoriesRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var alertType: Int32?

    public var currentPage: Int32?

    public var endTime: Int64?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("AlertType") {
            self.alertType = dict["AlertType"] as! Int32
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class SearchAlertHistoriesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlarmHistories : Tea.TeaModel {
            public var alarmContent: String?

            public var alarmResponseCode: Int32?

            public var alarmSources: String?

            public var alarmTime: Int64?

            public var alarmType: Int32?

            public var emails: String?

            public var id: Int64?

            public var phones: String?

            public var strategyId: String?

            public var target: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmContent != nil {
                    map["AlarmContent"] = self.alarmContent!
                }
                if self.alarmResponseCode != nil {
                    map["AlarmResponseCode"] = self.alarmResponseCode!
                }
                if self.alarmSources != nil {
                    map["AlarmSources"] = self.alarmSources!
                }
                if self.alarmTime != nil {
                    map["AlarmTime"] = self.alarmTime!
                }
                if self.alarmType != nil {
                    map["AlarmType"] = self.alarmType!
                }
                if self.emails != nil {
                    map["Emails"] = self.emails!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.phones != nil {
                    map["Phones"] = self.phones!
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.target != nil {
                    map["Target"] = self.target!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmContent") {
                    self.alarmContent = dict["AlarmContent"] as! String
                }
                if dict.keys.contains("AlarmResponseCode") {
                    self.alarmResponseCode = dict["AlarmResponseCode"] as! Int32
                }
                if dict.keys.contains("AlarmSources") {
                    self.alarmSources = dict["AlarmSources"] as! String
                }
                if dict.keys.contains("AlarmTime") {
                    self.alarmTime = dict["AlarmTime"] as! Int64
                }
                if dict.keys.contains("AlarmType") {
                    self.alarmType = dict["AlarmType"] as! Int32
                }
                if dict.keys.contains("Emails") {
                    self.emails = dict["Emails"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Phones") {
                    self.phones = dict["Phones"] as! String
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("Target") {
                    self.target = dict["Target"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var alarmHistories: [SearchAlertHistoriesResponseBody.PageBean.AlarmHistories]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmHistories != nil {
                var tmp : [Any] = []
                for k in self.alarmHistories! {
                    tmp.append(k.toMap())
                }
                map["AlarmHistories"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmHistories") {
                var tmp : [SearchAlertHistoriesResponseBody.PageBean.AlarmHistories] = []
                for v in dict["AlarmHistories"] as! [Any] {
                    var model = SearchAlertHistoriesResponseBody.PageBean.AlarmHistories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarmHistories = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageBean: SearchAlertHistoriesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = SearchAlertHistoriesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchAlertHistoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchAlertHistoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchAlertHistoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchAlertRulesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertRuleId: String?

    public var appType: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var pid: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var systemRegionId: String?

    public var tags: [SearchAlertRulesRequest.Tags]?

    public var title: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertRuleId != nil {
            map["AlertRuleId"] = self.alertRuleId!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.systemRegionId != nil {
            map["SystemRegionId"] = self.systemRegionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertRuleId") {
            self.alertRuleId = dict["AlertRuleId"] as! String
        }
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SystemRegionId") {
            self.systemRegionId = dict["SystemRegionId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [SearchAlertRulesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchAlertRulesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class SearchAlertRulesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertRules : Tea.TeaModel {
            public class AlarmContext : Tea.TeaModel {
                public var alarmContentSubTitle: String?

                public var alarmContentTemplate: String?

                public var content: String?

                public var subTitle: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alarmContentSubTitle != nil {
                        map["AlarmContentSubTitle"] = self.alarmContentSubTitle!
                    }
                    if self.alarmContentTemplate != nil {
                        map["AlarmContentTemplate"] = self.alarmContentTemplate!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.subTitle != nil {
                        map["SubTitle"] = self.subTitle!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlarmContentSubTitle") {
                        self.alarmContentSubTitle = dict["AlarmContentSubTitle"] as! String
                    }
                    if dict.keys.contains("AlarmContentTemplate") {
                        self.alarmContentTemplate = dict["AlarmContentTemplate"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("SubTitle") {
                        self.subTitle = dict["SubTitle"] as! String
                    }
                }
            }
            public class AlertRule : Tea.TeaModel {
                public class Rules : Tea.TeaModel {
                    public var aggregates: String?

                    public var alias: String?

                    public var measure: String?

                    public var NValue: Int32?

                    public var operator_: String?

                    public var value: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.aggregates != nil {
                            map["Aggregates"] = self.aggregates!
                        }
                        if self.alias != nil {
                            map["Alias"] = self.alias!
                        }
                        if self.measure != nil {
                            map["Measure"] = self.measure!
                        }
                        if self.NValue != nil {
                            map["NValue"] = self.NValue!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Aggregates") {
                            self.aggregates = dict["Aggregates"] as! String
                        }
                        if dict.keys.contains("Alias") {
                            self.alias = dict["Alias"] as! String
                        }
                        if dict.keys.contains("Measure") {
                            self.measure = dict["Measure"] as! String
                        }
                        if dict.keys.contains("NValue") {
                            self.NValue = dict["NValue"] as! Int32
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! Double
                        }
                    }
                }
                public var operator_: String?

                public var rules: [SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule.Rules]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.rules != nil {
                        var tmp : [Any] = []
                        for k in self.rules! {
                            tmp.append(k.toMap())
                        }
                        map["Rules"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Rules") {
                        var tmp : [SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule.Rules] = []
                        for v in dict["Rules"] as! [Any] {
                            var model = SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule.Rules()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.rules = tmp
                    }
                }
            }
            public class MetricParam : Tea.TeaModel {
                public class Dimensions : Tea.TeaModel {
                    public var key: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var appGroupId: String?

                public var appId: String?

                public var dimensions: [SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam.Dimensions]?

                public var pid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appGroupId != nil {
                        map["AppGroupId"] = self.appGroupId!
                    }
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.dimensions != nil {
                        var tmp : [Any] = []
                        for k in self.dimensions! {
                            tmp.append(k.toMap())
                        }
                        map["Dimensions"] = tmp
                    }
                    if self.pid != nil {
                        map["Pid"] = self.pid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppGroupId") {
                        self.appGroupId = dict["AppGroupId"] as! String
                    }
                    if dict.keys.contains("AppId") {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("Dimensions") {
                        var tmp : [SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam.Dimensions] = []
                        for v in dict["Dimensions"] as! [Any] {
                            var model = SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam.Dimensions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dimensions = tmp
                    }
                    if dict.keys.contains("Pid") {
                        self.pid = dict["Pid"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Notice : Tea.TeaModel {
                public var endTime: Int64?

                public var noticeEndTime: Int64?

                public var noticeStartTime: Int64?

                public var startTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.noticeEndTime != nil {
                        map["NoticeEndTime"] = self.noticeEndTime!
                    }
                    if self.noticeStartTime != nil {
                        map["NoticeStartTime"] = self.noticeStartTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! Int64
                    }
                    if dict.keys.contains("NoticeEndTime") {
                        self.noticeEndTime = dict["NoticeEndTime"] as! Int64
                    }
                    if dict.keys.contains("NoticeStartTime") {
                        self.noticeStartTime = dict["NoticeStartTime"] as! Int64
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                }
            }
            public var alarmContext: SearchAlertRulesResponseBody.PageBean.AlertRules.AlarmContext?

            public var alertLevel: String?

            public var alertRule: SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule?

            public var alertTitle: String?

            public var alertType: Int32?

            public var alertVersion: Int32?

            public var alertWays: [String]?

            public var config: String?

            public var contactGroupIdList: String?

            public var contactGroupIds: String?

            public var createTime: Int64?

            public var hostByAlertManager: Bool?

            public var id: Int64?

            public var metricParam: SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam?

            public var notice: SearchAlertRulesResponseBody.PageBean.AlertRules.Notice?

            public var regionId: String?

            public var resourceGroupId: String?

            public var status: String?

            public var taskId: Int64?

            public var taskStatus: String?

            public var title: String?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.alarmContext?.validate()
                try self.alertRule?.validate()
                try self.metricParam?.validate()
                try self.notice?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmContext != nil {
                    map["AlarmContext"] = self.alarmContext?.toMap()
                }
                if self.alertLevel != nil {
                    map["AlertLevel"] = self.alertLevel!
                }
                if self.alertRule != nil {
                    map["AlertRule"] = self.alertRule?.toMap()
                }
                if self.alertTitle != nil {
                    map["AlertTitle"] = self.alertTitle!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.alertVersion != nil {
                    map["AlertVersion"] = self.alertVersion!
                }
                if self.alertWays != nil {
                    map["AlertWays"] = self.alertWays!
                }
                if self.config != nil {
                    map["Config"] = self.config!
                }
                if self.contactGroupIdList != nil {
                    map["ContactGroupIdList"] = self.contactGroupIdList!
                }
                if self.contactGroupIds != nil {
                    map["ContactGroupIds"] = self.contactGroupIds!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.hostByAlertManager != nil {
                    map["HostByAlertManager"] = self.hostByAlertManager!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.metricParam != nil {
                    map["MetricParam"] = self.metricParam?.toMap()
                }
                if self.notice != nil {
                    map["Notice"] = self.notice?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmContext") {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules.AlarmContext()
                    model.fromMap(dict["AlarmContext"] as! [String: Any])
                    self.alarmContext = model
                }
                if dict.keys.contains("AlertLevel") {
                    self.alertLevel = dict["AlertLevel"] as! String
                }
                if dict.keys.contains("AlertRule") {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule()
                    model.fromMap(dict["AlertRule"] as! [String: Any])
                    self.alertRule = model
                }
                if dict.keys.contains("AlertTitle") {
                    self.alertTitle = dict["AlertTitle"] as! String
                }
                if dict.keys.contains("AlertType") {
                    self.alertType = dict["AlertType"] as! Int32
                }
                if dict.keys.contains("AlertVersion") {
                    self.alertVersion = dict["AlertVersion"] as! Int32
                }
                if dict.keys.contains("AlertWays") {
                    self.alertWays = dict["AlertWays"] as! [String]
                }
                if dict.keys.contains("Config") {
                    self.config = dict["Config"] as! String
                }
                if dict.keys.contains("ContactGroupIdList") {
                    self.contactGroupIdList = dict["ContactGroupIdList"] as! String
                }
                if dict.keys.contains("ContactGroupIds") {
                    self.contactGroupIds = dict["ContactGroupIds"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("HostByAlertManager") {
                    self.hostByAlertManager = dict["HostByAlertManager"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MetricParam") {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam()
                    model.fromMap(dict["MetricParam"] as! [String: Any])
                    self.metricParam = model
                }
                if dict.keys.contains("Notice") {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules.Notice()
                    model.fromMap(dict["Notice"] as! [String: Any])
                    self.notice = model
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! Int64
                }
                if dict.keys.contains("TaskStatus") {
                    self.taskStatus = dict["TaskStatus"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var alertRules: [SearchAlertRulesResponseBody.PageBean.AlertRules]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertRules != nil {
                var tmp : [Any] = []
                for k in self.alertRules! {
                    tmp.append(k.toMap())
                }
                map["AlertRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertRules") {
                var tmp : [SearchAlertRulesResponseBody.PageBean.AlertRules] = []
                for v in dict["AlertRules"] as! [Any] {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertRules = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageBean: SearchAlertRulesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = SearchAlertRulesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEventsRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var alertType: Int32?

    public var appType: String?

    public var currentPage: Int32?

    public var endTime: Int64?

    public var isTrigger: Int32?

    public var pageSize: Int32?

    public var pid: String?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.isTrigger != nil {
            map["IsTrigger"] = self.isTrigger!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("AlertType") {
            self.alertType = dict["AlertType"] as! Int32
        }
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("IsTrigger") {
            self.isTrigger = dict["IsTrigger"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class SearchEventsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class Event : Tea.TeaModel {
            public var alertId: Int64?

            public var alertName: String?

            public var alertRule: String?

            public var alertType: Int32?

            public var eventLevel: String?

            public var eventTime: Int64?

            public var id: Int64?

            public var links: [String]?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.alertRule != nil {
                    map["AlertRule"] = self.alertRule!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.eventLevel != nil {
                    map["EventLevel"] = self.eventLevel!
                }
                if self.eventTime != nil {
                    map["EventTime"] = self.eventTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.links != nil {
                    map["Links"] = self.links!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertId") {
                    self.alertId = dict["AlertId"] as! Int64
                }
                if dict.keys.contains("AlertName") {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("AlertRule") {
                    self.alertRule = dict["AlertRule"] as! String
                }
                if dict.keys.contains("AlertType") {
                    self.alertType = dict["AlertType"] as! Int32
                }
                if dict.keys.contains("EventLevel") {
                    self.eventLevel = dict["EventLevel"] as! String
                }
                if dict.keys.contains("EventTime") {
                    self.eventTime = dict["EventTime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Links") {
                    self.links = dict["Links"] as! [String]
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var event: [SearchEventsResponseBody.PageBean.Event]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.event != nil {
                var tmp : [Any] = []
                for k in self.event! {
                    tmp.append(k.toMap())
                }
                map["Event"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Event") {
                var tmp : [SearchEventsResponseBody.PageBean.Event] = []
                for v in dict["Event"] as! [Any] {
                    var model = SearchEventsResponseBody.PageBean.Event()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.event = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var isTrigger: Int32?

    public var pageBean: SearchEventsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isTrigger != nil {
            map["IsTrigger"] = self.isTrigger!
        }
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsTrigger") {
            self.isTrigger = dict["IsTrigger"] as! Int32
        }
        if dict.keys.contains("PageBean") {
            var model = SearchEventsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchRetcodeAppByPageRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var retcodeAppId: String?

    public var retcodeAppName: String?

    public var tags: [SearchRetcodeAppByPageRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.retcodeAppId != nil {
            map["RetcodeAppId"] = self.retcodeAppId!
        }
        if self.retcodeAppName != nil {
            map["RetcodeAppName"] = self.retcodeAppName!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RetcodeAppId") {
            self.retcodeAppId = dict["RetcodeAppId"] as! String
        }
        if dict.keys.contains("RetcodeAppName") {
            self.retcodeAppName = dict["RetcodeAppName"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [SearchRetcodeAppByPageRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchRetcodeAppByPageRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class SearchRetcodeAppByPageResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class RetcodeApps : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var appId: Int64?

            public var appName: String?

            public var createTime: Int64?

            public var nickName: String?

            public var pid: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var retcodeAppType: String?

            public var tags: [SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps.Tags]?

            public var type: String?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.retcodeAppType != nil {
                    map["RetcodeAppType"] = self.retcodeAppType!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("NickName") {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("Pid") {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RetcodeAppType") {
                    self.retcodeAppType = dict["RetcodeAppType"] as! String
                }
                if dict.keys.contains("Tags") {
                    var tmp : [SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var retcodeApps: [SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.retcodeApps != nil {
                var tmp : [Any] = []
                for k in self.retcodeApps! {
                    tmp.append(k.toMap())
                }
                map["RetcodeApps"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("RetcodeApps") {
                var tmp : [SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps] = []
                for v in dict["RetcodeApps"] as! [Any] {
                    var model = SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.retcodeApps = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageBean: SearchRetcodeAppByPageResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = SearchRetcodeAppByPageResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchRetcodeAppByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchRetcodeAppByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchRetcodeAppByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTraceAppByNameRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var tags: [SearchTraceAppByNameRequest.Tags]?

    public var traceAppName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.traceAppName != nil {
            map["TraceAppName"] = self.traceAppName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [SearchTraceAppByNameRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchTraceAppByNameRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TraceAppName") {
            self.traceAppName = dict["TraceAppName"] as! String
        }
    }
}

public class SearchTraceAppByNameResponseBody : Tea.TeaModel {
    public class TraceApps : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: Int64?

        public var appName: String?

        public var createTime: Int64?

        public var labels: [String]?

        public var pid: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var show: Bool?

        public var tags: [SearchTraceAppByNameResponseBody.TraceApps.Tags]?

        public var type: String?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.labels != nil {
                map["Labels"] = self.labels!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.show != nil {
                map["Show"] = self.show!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Labels") {
                self.labels = dict["Labels"] as! [String]
            }
            if dict.keys.contains("Pid") {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Show") {
                self.show = dict["Show"] as! Bool
            }
            if dict.keys.contains("Tags") {
                var tmp : [SearchTraceAppByNameResponseBody.TraceApps.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = SearchTraceAppByNameResponseBody.TraceApps.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var requestId: String?

    public var traceApps: [SearchTraceAppByNameResponseBody.TraceApps]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceApps != nil {
            var tmp : [Any] = []
            for k in self.traceApps! {
                tmp.append(k.toMap())
            }
            map["TraceApps"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TraceApps") {
            var tmp : [SearchTraceAppByNameResponseBody.TraceApps] = []
            for v in dict["TraceApps"] as! [Any] {
                var model = SearchTraceAppByNameResponseBody.TraceApps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traceApps = tmp
        }
    }
}

public class SearchTraceAppByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTraceAppByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchTraceAppByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTraceAppByPageRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [SearchTraceAppByPageRequest.Tags]?

    public var traceAppName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.traceAppName != nil {
            map["TraceAppName"] = self.traceAppName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [SearchTraceAppByPageRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchTraceAppByPageRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TraceAppName") {
            self.traceAppName = dict["TraceAppName"] as! String
        }
    }
}

public class SearchTraceAppByPageResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class TraceApps : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var appId: Int64?

            public var appName: String?

            public var createTime: Int64?

            public var labels: [String]?

            public var pid: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var show: Bool?

            public var tags: [SearchTraceAppByPageResponseBody.PageBean.TraceApps.Tags]?

            public var type: String?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.show != nil {
                    map["Show"] = self.show!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Labels") {
                    self.labels = dict["Labels"] as! [String]
                }
                if dict.keys.contains("Pid") {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Show") {
                    self.show = dict["Show"] as! Bool
                }
                if dict.keys.contains("Tags") {
                    var tmp : [SearchTraceAppByPageResponseBody.PageBean.TraceApps.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = SearchTraceAppByPageResponseBody.PageBean.TraceApps.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public var traceApps: [SearchTraceAppByPageResponseBody.PageBean.TraceApps]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.traceApps != nil {
                var tmp : [Any] = []
                for k in self.traceApps! {
                    tmp.append(k.toMap())
                }
                map["TraceApps"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TraceApps") {
                var tmp : [SearchTraceAppByPageResponseBody.PageBean.TraceApps] = []
                for v in dict["TraceApps"] as! [Any] {
                    var model = SearchTraceAppByPageResponseBody.PageBean.TraceApps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.traceApps = tmp
            }
        }
    }
    public var pageBean: SearchTraceAppByPageResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = SearchTraceAppByPageResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchTraceAppByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTraceAppByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchTraceAppByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTracesRequest : Tea.TeaModel {
    public class ExclusionFilters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var exclusionFilters: [SearchTracesRequest.ExclusionFilters]?

    public var minDuration: Int64?

    public var operationName: String?

    public var pid: String?

    public var regionId: String?

    public var reverse: Bool?

    public var serviceIp: String?

    public var serviceName: String?

    public var startTime: Int64?

    public var tag: [SearchTracesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.exclusionFilters != nil {
            var tmp : [Any] = []
            for k in self.exclusionFilters! {
                tmp.append(k.toMap())
            }
            map["ExclusionFilters"] = tmp
        }
        if self.minDuration != nil {
            map["MinDuration"] = self.minDuration!
        }
        if self.operationName != nil {
            map["OperationName"] = self.operationName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.serviceIp != nil {
            map["ServiceIp"] = self.serviceIp!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExclusionFilters") {
            var tmp : [SearchTracesRequest.ExclusionFilters] = []
            for v in dict["ExclusionFilters"] as! [Any] {
                var model = SearchTracesRequest.ExclusionFilters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.exclusionFilters = tmp
        }
        if dict.keys.contains("MinDuration") {
            self.minDuration = dict["MinDuration"] as! Int64
        }
        if dict.keys.contains("OperationName") {
            self.operationName = dict["OperationName"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reverse") {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("ServiceIp") {
            self.serviceIp = dict["ServiceIp"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [SearchTracesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = SearchTracesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class SearchTracesResponseBody : Tea.TeaModel {
    public class TraceInfos : Tea.TeaModel {
        public var duration: Int64?

        public var operationName: String?

        public var serviceIp: String?

        public var serviceName: String?

        public var timestamp: Int64?

        public var traceID: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.operationName != nil {
                map["OperationName"] = self.operationName!
            }
            if self.serviceIp != nil {
                map["ServiceIp"] = self.serviceIp!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.traceID != nil {
                map["TraceID"] = self.traceID!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("OperationName") {
                self.operationName = dict["OperationName"] as! String
            }
            if dict.keys.contains("ServiceIp") {
                self.serviceIp = dict["ServiceIp"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TraceID") {
                self.traceID = dict["TraceID"] as! String
            }
        }
    }
    public var requestId: String?

    public var traceInfos: [SearchTracesResponseBody.TraceInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceInfos != nil {
            var tmp : [Any] = []
            for k in self.traceInfos! {
                tmp.append(k.toMap())
            }
            map["TraceInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TraceInfos") {
            var tmp : [SearchTracesResponseBody.TraceInfos] = []
            for v in dict["TraceInfos"] as! [Any] {
                var model = SearchTracesResponseBody.TraceInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traceInfos = tmp
        }
    }
}

public class SearchTracesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTracesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchTracesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTracesByPageRequest : Tea.TeaModel {
    public class ExclusionFilters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var exclusionFilters: [SearchTracesByPageRequest.ExclusionFilters]?

    public var isError: Bool?

    public var minDuration: Int64?

    public var operationName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pid: String?

    public var regionId: String?

    public var reverse: Bool?

    public var serviceIp: String?

    public var serviceName: String?

    public var startTime: Int64?

    public var tags: [SearchTracesByPageRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.exclusionFilters != nil {
            var tmp : [Any] = []
            for k in self.exclusionFilters! {
                tmp.append(k.toMap())
            }
            map["ExclusionFilters"] = tmp
        }
        if self.isError != nil {
            map["IsError"] = self.isError!
        }
        if self.minDuration != nil {
            map["MinDuration"] = self.minDuration!
        }
        if self.operationName != nil {
            map["OperationName"] = self.operationName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.serviceIp != nil {
            map["ServiceIp"] = self.serviceIp!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExclusionFilters") {
            var tmp : [SearchTracesByPageRequest.ExclusionFilters] = []
            for v in dict["ExclusionFilters"] as! [Any] {
                var model = SearchTracesByPageRequest.ExclusionFilters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.exclusionFilters = tmp
        }
        if dict.keys.contains("IsError") {
            self.isError = dict["IsError"] as! Bool
        }
        if dict.keys.contains("MinDuration") {
            self.minDuration = dict["MinDuration"] as! Int64
        }
        if dict.keys.contains("OperationName") {
            self.operationName = dict["OperationName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reverse") {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("ServiceIp") {
            self.serviceIp = dict["ServiceIp"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [SearchTracesByPageRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchTracesByPageRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class SearchTracesByPageResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class TraceInfos : Tea.TeaModel {
            public var duration: Int64?

            public var operationName: String?

            public var serviceIp: String?

            public var serviceName: String?

            public var timestamp: Int64?

            public var traceID: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.operationName != nil {
                    map["OperationName"] = self.operationName!
                }
                if self.serviceIp != nil {
                    map["ServiceIp"] = self.serviceIp!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.traceID != nil {
                    map["TraceID"] = self.traceID!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("OperationName") {
                    self.operationName = dict["OperationName"] as! String
                }
                if dict.keys.contains("ServiceIp") {
                    self.serviceIp = dict["ServiceIp"] as! String
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("TraceID") {
                    self.traceID = dict["TraceID"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public var traceInfos: [SearchTracesByPageResponseBody.PageBean.TraceInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            if self.traceInfos != nil {
                var tmp : [Any] = []
                for k in self.traceInfos! {
                    tmp.append(k.toMap())
                }
                map["TraceInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
            if dict.keys.contains("TraceInfos") {
                var tmp : [SearchTracesByPageResponseBody.PageBean.TraceInfos] = []
                for v in dict["TraceInfos"] as! [Any] {
                    var model = SearchTracesByPageResponseBody.PageBean.TraceInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.traceInfos = tmp
            }
        }
    }
    public var pageBean: SearchTracesByPageResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") {
            var model = SearchTracesByPageResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchTracesByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTracesByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchTracesByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendTTSVerifyLinkRequest : Tea.TeaModel {
    public var contactId: Int64?

    public var phone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("Phone") {
            self.phone = dict["Phone"] as! String
        }
    }
}

public class SendTTSVerifyLinkResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendTTSVerifyLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendTTSVerifyLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendTTSVerifyLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetRetcodeShareStatusRequest : Tea.TeaModel {
    public var appName: String?

    public var pid: String?

    public var status: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Bool
        }
    }
}

public class SetRetcodeShareStatusResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetRetcodeShareStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetRetcodeShareStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetRetcodeShareStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartAlertRequest : Tea.TeaModel {
    public var alertId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class StartAlertResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartTimingSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") {
            self.taskIds = dict["TaskIds"] as! [String]
        }
    }
}

public class StartTimingSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIdsShrink != nil {
            map["TaskIds"] = self.taskIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") {
            self.taskIdsShrink = dict["TaskIds"] as! String
        }
    }
}

public class StartTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopAlertRequest : Tea.TeaModel {
    public var alertId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class StopAlertResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopTimingSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") {
            self.taskIds = dict["TaskIds"] as! [String]
        }
    }
}

public class StopTimingSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIdsShrink != nil {
            map["TaskIds"] = self.taskIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") {
            self.taskIdsShrink = dict["TaskIds"] as! String
        }
    }
}

public class StopTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchSyntheticTaskStatusRequest : Tea.TeaModel {
    public var switchStatus: Int64?

    public var taskIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.switchStatus != nil {
            map["SwitchStatus"] = self.switchStatus!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SwitchStatus") {
            self.switchStatus = dict["SwitchStatus"] as! Int64
        }
        if dict.keys.contains("TaskIds") {
            self.taskIds = dict["TaskIds"] as! [Int64]
        }
    }
}

public class SwitchSyntheticTaskStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class SwitchSyntheticTaskStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchSyntheticTaskStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchSyntheticTaskStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncRecordingRulesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var targetClusters: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.targetClusters != nil {
            map["TargetClusters"] = self.targetClusters!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TargetClusters") {
            self.targetClusters = dict["TargetClusters"] as! String
        }
    }
}

public class SyncRecordingRulesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SyncRecordingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncRecordingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SyncRecordingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallManagedPrometheusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class UninstallManagedPrometheusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UninstallManagedPrometheusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallManagedPrometheusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UninstallManagedPrometheusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallPromClusterRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UninstallPromClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UninstallPromClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallPromClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UninstallPromClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var all: Bool?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public var tags: [UntagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
        if dict.keys.contains("Tags") {
            var tmp : [UntagResourcesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = UntagResourcesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAlertContactRequest : Tea.TeaModel {
    public var contactId: Int64?

    public var contactName: String?

    public var dingRobotWebhookUrl: String?

    public var email: String?

    public var phoneNum: String?

    public var regionId: String?

    public var systemNoc: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.dingRobotWebhookUrl != nil {
            map["DingRobotWebhookUrl"] = self.dingRobotWebhookUrl!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.phoneNum != nil {
            map["PhoneNum"] = self.phoneNum!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.systemNoc != nil {
            map["SystemNoc"] = self.systemNoc!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("DingRobotWebhookUrl") {
            self.dingRobotWebhookUrl = dict["DingRobotWebhookUrl"] as! String
        }
        if dict.keys.contains("Email") {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("PhoneNum") {
            self.phoneNum = dict["PhoneNum"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SystemNoc") {
            self.systemNoc = dict["SystemNoc"] as! Bool
        }
    }
}

public class UpdateAlertContactResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAlertContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAlertContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAlertContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAlertContactGroupRequest : Tea.TeaModel {
    public var contactGroupId: Int64?

    public var contactGroupName: String?

    public var contactIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") {
            self.contactGroupId = dict["ContactGroupId"] as! Int64
        }
        if dict.keys.contains("ContactGroupName") {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactIds") {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateAlertContactGroupResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAlertContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAlertContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAlertContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAlertRuleRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var contactGroupIds: String?

    public var isAutoStart: Bool?

    public var regionId: String?

    public var templageAlertConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.contactGroupIds != nil {
            map["ContactGroupIds"] = self.contactGroupIds!
        }
        if self.isAutoStart != nil {
            map["IsAutoStart"] = self.isAutoStart!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templageAlertConfig != nil {
            map["TemplageAlertConfig"] = self.templageAlertConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("ContactGroupIds") {
            self.contactGroupIds = dict["ContactGroupIds"] as! String
        }
        if dict.keys.contains("IsAutoStart") {
            self.isAutoStart = dict["IsAutoStart"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TemplageAlertConfig") {
            self.templageAlertConfig = dict["TemplageAlertConfig"] as! String
        }
    }
}

public class UpdateAlertRuleResponseBody : Tea.TeaModel {
    public var alertId: Int64?

    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDispatchRuleRequest : Tea.TeaModel {
    public var dispatchRule: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRule != nil {
            map["DispatchRule"] = self.dispatchRule!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRule") {
            self.dispatchRule = dict["DispatchRule"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateDispatchRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEnvCustomJobRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var customJobName: String?

    public var environmentId: String?

    public var regionId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.customJobName != nil {
            map["CustomJobName"] = self.customJobName!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("CustomJobName") {
            self.customJobName = dict["CustomJobName"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateEnvCustomJobResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEnvCustomJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEnvCustomJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEnvCustomJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEnvPodMonitorRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var namespace: String?

    public var podMonitorName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.podMonitorName != nil {
            map["PodMonitorName"] = self.podMonitorName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PodMonitorName") {
            self.podMonitorName = dict["PodMonitorName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateEnvPodMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var matchedMsg: String?

        public var matchedTargetCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchedMsg != nil {
                map["MatchedMsg"] = self.matchedMsg!
            }
            if self.matchedTargetCount != nil {
                map["MatchedTargetCount"] = self.matchedTargetCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchedMsg") {
                self.matchedMsg = dict["MatchedMsg"] as! String
            }
            if dict.keys.contains("MatchedTargetCount") {
                self.matchedTargetCount = dict["MatchedTargetCount"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: UpdateEnvPodMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = UpdateEnvPodMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEnvPodMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEnvPodMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEnvPodMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEnvServiceMonitorRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var namespace: String?

    public var regionId: String?

    public var serviceMonitorName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serviceMonitorName != nil {
            map["ServiceMonitorName"] = self.serviceMonitorName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ServiceMonitorName") {
            self.serviceMonitorName = dict["ServiceMonitorName"] as! String
        }
    }
}

public class UpdateEnvServiceMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var matchedMsg: String?

        public var matchedTargetCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchedMsg != nil {
                map["MatchedMsg"] = self.matchedMsg!
            }
            if self.matchedTargetCount != nil {
                map["MatchedTargetCount"] = self.matchedTargetCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchedMsg") {
                self.matchedMsg = dict["MatchedMsg"] as! String
            }
            if dict.keys.contains("MatchedTargetCount") {
                self.matchedTargetCount = dict["MatchedTargetCount"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: UpdateEnvServiceMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = UpdateEnvServiceMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEnvServiceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEnvServiceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEnvServiceMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEnvironmentRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var environmentId: String?

    public var environmentName: String?

    public var feePackage: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.environmentName != nil {
            map["EnvironmentName"] = self.environmentName!
        }
        if self.feePackage != nil {
            map["FeePackage"] = self.feePackage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("EnvironmentName") {
            self.environmentName = dict["EnvironmentName"] as! String
        }
        if dict.keys.contains("FeePackage") {
            self.feePackage = dict["FeePackage"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateEnvironmentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGrafanaWorkspaceRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var description_: String?

    public var grafanaWorkspaceId: String?

    public var grafanaWorkspaceName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.grafanaWorkspaceId != nil {
            map["GrafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.grafanaWorkspaceName != nil {
            map["GrafanaWorkspaceName"] = self.grafanaWorkspaceName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GrafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["GrafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("GrafanaWorkspaceName") {
            self.grafanaWorkspaceName = dict["GrafanaWorkspaceName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateGrafanaWorkspaceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateGrafanaWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGrafanaWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGrafanaWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGrafanaWorkspaceVersionRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var grafanaVersion: String?

    public var grafanaWorkspaceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.grafanaVersion != nil {
            map["GrafanaVersion"] = self.grafanaVersion!
        }
        if self.grafanaWorkspaceId != nil {
            map["GrafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("GrafanaVersion") {
            self.grafanaVersion = dict["GrafanaVersion"] as! String
        }
        if dict.keys.contains("GrafanaWorkspaceId") {
            self.grafanaWorkspaceId = dict["GrafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateGrafanaWorkspaceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateGrafanaWorkspaceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGrafanaWorkspaceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGrafanaWorkspaceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIntegrationRequest : Tea.TeaModel {
    public var autoRecover: Bool?

    public var description_: String?

    public var duplicateKey: String?

    public var extendedFieldRedefineRules: String?

    public var fieldRedefineRules: String?

    public var initiativeRecoverField: String?

    public var initiativeRecoverValue: String?

    public var integrationId: Int64?

    public var integrationName: String?

    public var integrationProductType: String?

    public var liveness: String?

    public var recoverTime: Int64?

    public var stat: String?

    public var state: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRecover != nil {
            map["AutoRecover"] = self.autoRecover!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duplicateKey != nil {
            map["DuplicateKey"] = self.duplicateKey!
        }
        if self.extendedFieldRedefineRules != nil {
            map["ExtendedFieldRedefineRules"] = self.extendedFieldRedefineRules!
        }
        if self.fieldRedefineRules != nil {
            map["FieldRedefineRules"] = self.fieldRedefineRules!
        }
        if self.initiativeRecoverField != nil {
            map["InitiativeRecoverField"] = self.initiativeRecoverField!
        }
        if self.initiativeRecoverValue != nil {
            map["InitiativeRecoverValue"] = self.initiativeRecoverValue!
        }
        if self.integrationId != nil {
            map["IntegrationId"] = self.integrationId!
        }
        if self.integrationName != nil {
            map["IntegrationName"] = self.integrationName!
        }
        if self.integrationProductType != nil {
            map["IntegrationProductType"] = self.integrationProductType!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.recoverTime != nil {
            map["RecoverTime"] = self.recoverTime!
        }
        if self.stat != nil {
            map["Stat"] = self.stat!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRecover") {
            self.autoRecover = dict["AutoRecover"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DuplicateKey") {
            self.duplicateKey = dict["DuplicateKey"] as! String
        }
        if dict.keys.contains("ExtendedFieldRedefineRules") {
            self.extendedFieldRedefineRules = dict["ExtendedFieldRedefineRules"] as! String
        }
        if dict.keys.contains("FieldRedefineRules") {
            self.fieldRedefineRules = dict["FieldRedefineRules"] as! String
        }
        if dict.keys.contains("InitiativeRecoverField") {
            self.initiativeRecoverField = dict["InitiativeRecoverField"] as! String
        }
        if dict.keys.contains("InitiativeRecoverValue") {
            self.initiativeRecoverValue = dict["InitiativeRecoverValue"] as! String
        }
        if dict.keys.contains("IntegrationId") {
            self.integrationId = dict["IntegrationId"] as! Int64
        }
        if dict.keys.contains("IntegrationName") {
            self.integrationName = dict["IntegrationName"] as! String
        }
        if dict.keys.contains("IntegrationProductType") {
            self.integrationProductType = dict["IntegrationProductType"] as! String
        }
        if dict.keys.contains("Liveness") {
            self.liveness = dict["Liveness"] as! String
        }
        if dict.keys.contains("RecoverTime") {
            self.recoverTime = dict["RecoverTime"] as! Int64
        }
        if dict.keys.contains("Stat") {
            self.stat = dict["Stat"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! Bool
        }
    }
}

public class UpdateIntegrationResponseBody : Tea.TeaModel {
    public class Integration : Tea.TeaModel {
        public var apiEndpoint: String?

        public var autoRecover: Bool?

        public var description_: String?

        public var duplicateKey: String?

        public var extendedFieldRedefineRules: [[String: Any]]?

        public var fieldRedefineRules: [[String: Any]]?

        public var initiativeRecoverField: String?

        public var initiativeRecoverValue: String?

        public var integrationId: Int64?

        public var integrationName: String?

        public var integrationProductType: String?

        public var liveness: String?

        public var recoverTime: Int64?

        public var shortToken: String?

        public var stat: [Int64]?

        public var state: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiEndpoint != nil {
                map["ApiEndpoint"] = self.apiEndpoint!
            }
            if self.autoRecover != nil {
                map["AutoRecover"] = self.autoRecover!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duplicateKey != nil {
                map["DuplicateKey"] = self.duplicateKey!
            }
            if self.extendedFieldRedefineRules != nil {
                map["ExtendedFieldRedefineRules"] = self.extendedFieldRedefineRules!
            }
            if self.fieldRedefineRules != nil {
                map["FieldRedefineRules"] = self.fieldRedefineRules!
            }
            if self.initiativeRecoverField != nil {
                map["InitiativeRecoverField"] = self.initiativeRecoverField!
            }
            if self.initiativeRecoverValue != nil {
                map["InitiativeRecoverValue"] = self.initiativeRecoverValue!
            }
            if self.integrationId != nil {
                map["IntegrationId"] = self.integrationId!
            }
            if self.integrationName != nil {
                map["IntegrationName"] = self.integrationName!
            }
            if self.integrationProductType != nil {
                map["IntegrationProductType"] = self.integrationProductType!
            }
            if self.liveness != nil {
                map["Liveness"] = self.liveness!
            }
            if self.recoverTime != nil {
                map["RecoverTime"] = self.recoverTime!
            }
            if self.shortToken != nil {
                map["ShortToken"] = self.shortToken!
            }
            if self.stat != nil {
                map["Stat"] = self.stat!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiEndpoint") {
                self.apiEndpoint = dict["ApiEndpoint"] as! String
            }
            if dict.keys.contains("AutoRecover") {
                self.autoRecover = dict["AutoRecover"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DuplicateKey") {
                self.duplicateKey = dict["DuplicateKey"] as! String
            }
            if dict.keys.contains("ExtendedFieldRedefineRules") {
                self.extendedFieldRedefineRules = dict["ExtendedFieldRedefineRules"] as! [[String: Any]]
            }
            if dict.keys.contains("FieldRedefineRules") {
                self.fieldRedefineRules = dict["FieldRedefineRules"] as! [[String: Any]]
            }
            if dict.keys.contains("InitiativeRecoverField") {
                self.initiativeRecoverField = dict["InitiativeRecoverField"] as! String
            }
            if dict.keys.contains("InitiativeRecoverValue") {
                self.initiativeRecoverValue = dict["InitiativeRecoverValue"] as! String
            }
            if dict.keys.contains("IntegrationId") {
                self.integrationId = dict["IntegrationId"] as! Int64
            }
            if dict.keys.contains("IntegrationName") {
                self.integrationName = dict["IntegrationName"] as! String
            }
            if dict.keys.contains("IntegrationProductType") {
                self.integrationProductType = dict["IntegrationProductType"] as! String
            }
            if dict.keys.contains("Liveness") {
                self.liveness = dict["Liveness"] as! String
            }
            if dict.keys.contains("RecoverTime") {
                self.recoverTime = dict["RecoverTime"] as! Int64
            }
            if dict.keys.contains("ShortToken") {
                self.shortToken = dict["ShortToken"] as! String
            }
            if dict.keys.contains("Stat") {
                self.stat = dict["Stat"] as! [Int64]
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! Bool
            }
        }
    }
    public var integration: UpdateIntegrationResponseBody.Integration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.integration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.integration != nil {
            map["Integration"] = self.integration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Integration") {
            var model = UpdateIntegrationResponseBody.Integration()
            model.fromMap(dict["Integration"] as! [String: Any])
            self.integration = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMetricDropRequest : Tea.TeaModel {
    public var clusterId: String?

    public var metricDrop: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.metricDrop != nil {
            map["MetricDrop"] = self.metricDrop!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MetricDrop") {
            self.metricDrop = dict["MetricDrop"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateMetricDropResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateMetricDropResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetricDropResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMetricDropResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusAlertRuleRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertId: Int64?

    public var alertName: String?

    public var annotations: String?

    public var clusterId: String?

    public var dispatchRuleId: Int64?

    public var duration: String?

    public var expression: String?

    public var labels: String?

    public var message: String?

    public var notifyType: String?

    public var regionId: String?

    public var tags: [UpdatePrometheusAlertRuleRequest.Tags]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dispatchRuleId != nil {
            map["DispatchRuleId"] = self.dispatchRuleId!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.expression != nil {
            map["Expression"] = self.expression!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("AlertName") {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("Annotations") {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DispatchRuleId") {
            self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("Expression") {
            self.expression = dict["Expression"] as! String
        }
        if dict.keys.contains("Labels") {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NotifyType") {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [UpdatePrometheusAlertRuleRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = UpdatePrometheusAlertRuleRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdatePrometheusAlertRuleResponseBody : Tea.TeaModel {
    public class PrometheusAlertRule : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertId: Int64?

        public var alertName: String?

        public var annotations: [UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations]?

        public var clusterId: String?

        public var dispatchRuleId: Int64?

        public var duration: String?

        public var expression: String?

        public var labels: [UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels]?

        public var message: String?

        public var notifyType: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dispatchRuleId != nil {
                map["DispatchRuleId"] = self.dispatchRuleId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertId") {
                self.alertId = dict["AlertId"] as! Int64
            }
            if dict.keys.contains("AlertName") {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") {
                var tmp : [UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("DispatchRuleId") {
                self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") {
                var tmp : [UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NotifyType") {
                self.notifyType = dict["NotifyType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int64?

    public var message: String?

    public var prometheusAlertRule: UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prometheusAlertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.prometheusAlertRule != nil {
            map["PrometheusAlertRule"] = self.prometheusAlertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PrometheusAlertRule") {
            var model = UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule()
            model.fromMap(dict["PrometheusAlertRule"] as! [String: Any])
            self.prometheusAlertRule = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePrometheusAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePrometheusAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusGlobalViewRequest : Tea.TeaModel {
    public var allSubClustersSuccess: Bool?

    public var clusterId: String?

    public var groupName: String?

    public var mostRegionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subClustersJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allSubClustersSuccess != nil {
            map["AllSubClustersSuccess"] = self.allSubClustersSuccess!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.mostRegionId != nil {
            map["MostRegionId"] = self.mostRegionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subClustersJson != nil {
            map["SubClustersJson"] = self.subClustersJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllSubClustersSuccess") {
            self.allSubClustersSuccess = dict["AllSubClustersSuccess"] as! Bool
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("MostRegionId") {
            self.mostRegionId = dict["MostRegionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubClustersJson") {
            self.subClustersJson = dict["SubClustersJson"] as! String
        }
    }
}

public class UpdatePrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FailedInstances : Tea.TeaModel {
            public var clusterId: String?

            public var sourceName: String?

            public var sourceType: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.sourceName != nil {
                    map["SourceName"] = self.sourceName!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("SourceName") {
                    self.sourceName = dict["SourceName"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var failedInstances: [UpdatePrometheusGlobalViewResponseBody.Data.FailedInstances]?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedInstances != nil {
                var tmp : [Any] = []
                for k in self.failedInstances! {
                    tmp.append(k.toMap())
                }
                map["FailedInstances"] = tmp
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedInstances") {
                var tmp : [UpdatePrometheusGlobalViewResponseBody.Data.FailedInstances] = []
                for v in dict["FailedInstances"] as! [Any] {
                    var model = UpdatePrometheusGlobalViewResponseBody.Data.FailedInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.failedInstances = tmp
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: UpdatePrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = UpdatePrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusInstanceRequest : Tea.TeaModel {
    public var archiveDuration: Int32?

    public var clusterId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var storageDuration: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.archiveDuration != nil {
            map["ArchiveDuration"] = self.archiveDuration!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.storageDuration != nil {
            map["StorageDuration"] = self.storageDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ArchiveDuration") {
            self.archiveDuration = dict["ArchiveDuration"] as! Int32
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StorageDuration") {
            self.storageDuration = dict["StorageDuration"] as! Int32
        }
    }
}

public class UpdatePrometheusInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePrometheusInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePrometheusInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceId: Int64?

    public var integrationType: String?

    public var param: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.param != nil {
            map["Param"] = self.param!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("IntegrationType") {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("Param") {
            self.param = dict["Param"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdatePrometheusIntegrationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: Int64?

        public var instanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: UpdatePrometheusIntegrationResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = UpdatePrometheusIntegrationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var configYaml: String?

    public var monitoringName: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.monitoringName != nil {
            map["MonitoringName"] = self.monitoringName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigYaml") {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("MonitoringName") {
            self.monitoringName = dict["MonitoringName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdatePrometheusMonitoringResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusMonitoringStatusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var monitoringName: String?

    public var regionId: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.monitoringName != nil {
            map["MonitoringName"] = self.monitoringName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MonitoringName") {
            self.monitoringName = dict["MonitoringName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdatePrometheusMonitoringStatusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePrometheusMonitoringStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusMonitoringStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePrometheusMonitoringStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusRemoteWriteRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var remoteWriteName: String?

    public var remoteWriteYaml: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteWriteName != nil {
            map["RemoteWriteName"] = self.remoteWriteName!
        }
        if self.remoteWriteYaml != nil {
            map["RemoteWriteYaml"] = self.remoteWriteYaml!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteWriteName") {
            self.remoteWriteName = dict["RemoteWriteName"] as! String
        }
        if dict.keys.contains("RemoteWriteYaml") {
            self.remoteWriteYaml = dict["RemoteWriteYaml"] as! String
        }
    }
}

public class UpdatePrometheusRemoteWriteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePrometheusRemoteWriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusRemoteWriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePrometheusRemoteWriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRumAppRequest : Tea.TeaModel {
    public var autoRestart: Bool?

    public var description_: String?

    public var isSubscribe: Bool?

    public var nickname: String?

    public var pid: String?

    public var regionId: String?

    public var restart: Bool?

    public var serviceDomainOperationJson: String?

    public var stop: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRestart != nil {
            map["AutoRestart"] = self.autoRestart!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.isSubscribe != nil {
            map["IsSubscribe"] = self.isSubscribe!
        }
        if self.nickname != nil {
            map["Nickname"] = self.nickname!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.restart != nil {
            map["Restart"] = self.restart!
        }
        if self.serviceDomainOperationJson != nil {
            map["ServiceDomainOperationJson"] = self.serviceDomainOperationJson!
        }
        if self.stop != nil {
            map["Stop"] = self.stop!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRestart") {
            self.autoRestart = dict["AutoRestart"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IsSubscribe") {
            self.isSubscribe = dict["IsSubscribe"] as! Bool
        }
        if dict.keys.contains("Nickname") {
            self.nickname = dict["Nickname"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Restart") {
            self.restart = dict["Restart"] as! Bool
        }
        if dict.keys.contains("ServiceDomainOperationJson") {
            self.serviceDomainOperationJson = dict["ServiceDomainOperationJson"] as! String
        }
        if dict.keys.contains("Stop") {
            self.stop = dict["Stop"] as! Bool
        }
    }
}

public class UpdateRumAppResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var config: String?

        public var limit: Int32?

        public var limited: Bool?

        public var usage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.limit != nil {
                map["Limit"] = self.limit!
            }
            if self.limited != nil {
                map["Limited"] = self.limited!
            }
            if self.usage != nil {
                map["Usage"] = self.usage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("Limit") {
                self.limit = dict["Limit"] as! Int32
            }
            if dict.keys.contains("Limited") {
                self.limited = dict["Limited"] as! Bool
            }
            if dict.keys.contains("Usage") {
                self.usage = dict["Usage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: UpdateRumAppResponseBody.Data?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateRumAppResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class UpdateRumAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRumAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRumAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRumFileStatusRequest : Tea.TeaModel {
    public var fileName: String?

    public var pid: String?

    public var regionId: String?

    public var size: String?

    public var status: String?

    public var uuid: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("VersionId") {
            self.versionId = dict["VersionId"] as! String
        }
    }
}

public class UpdateRumFileStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateRumFileStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRumFileStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRumFileStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTimingSyntheticTaskRequest : Tea.TeaModel {
    public class AvailableAssertions : Tea.TeaModel {
        public var expect: String?

        public var operator_: String?

        public var target: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expect != nil {
                map["Expect"] = self.expect!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Expect") {
                self.expect = dict["Expect"] as! String
            }
            if dict.keys.contains("Operator") {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Target") {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class CommonSetting : Tea.TeaModel {
        public class CustomHost : Tea.TeaModel {
            public class Hosts : Tea.TeaModel {
                public var domain: String?

                public var ipType: Int32?

                public var ips: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.domain != nil {
                        map["Domain"] = self.domain!
                    }
                    if self.ipType != nil {
                        map["IpType"] = self.ipType!
                    }
                    if self.ips != nil {
                        map["Ips"] = self.ips!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Domain") {
                        self.domain = dict["Domain"] as! String
                    }
                    if dict.keys.contains("IpType") {
                        self.ipType = dict["IpType"] as! Int32
                    }
                    if dict.keys.contains("Ips") {
                        self.ips = dict["Ips"] as! [String]
                    }
                }
            }
            public var hosts: [UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts]?

            public var selectType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hosts != nil {
                    var tmp : [Any] = []
                    for k in self.hosts! {
                        tmp.append(k.toMap())
                    }
                    map["Hosts"] = tmp
                }
                if self.selectType != nil {
                    map["SelectType"] = self.selectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Hosts") {
                    var tmp : [UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts] = []
                    for v in dict["Hosts"] as! [Any] {
                        var model = UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.hosts = tmp
                }
                if dict.keys.contains("SelectType") {
                    self.selectType = dict["SelectType"] as! Int32
                }
            }
        }
        public class CustomPrometheusSetting : Tea.TeaModel {
            public var prometheusClusterId: String?

            public var prometheusClusterRegion: String?

            public var prometheusLabels: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.prometheusClusterId != nil {
                    map["PrometheusClusterId"] = self.prometheusClusterId!
                }
                if self.prometheusClusterRegion != nil {
                    map["PrometheusClusterRegion"] = self.prometheusClusterRegion!
                }
                if self.prometheusLabels != nil {
                    map["PrometheusLabels"] = self.prometheusLabels!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PrometheusClusterId") {
                    self.prometheusClusterId = dict["PrometheusClusterId"] as! String
                }
                if dict.keys.contains("PrometheusClusterRegion") {
                    self.prometheusClusterRegion = dict["PrometheusClusterRegion"] as! String
                }
                if dict.keys.contains("PrometheusLabels") {
                    self.prometheusLabels = dict["PrometheusLabels"] as! [String: String]
                }
            }
        }
        public class CustomVPCSetting : Tea.TeaModel {
            public var regionId: String?

            public var secureGroupId: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.secureGroupId != nil {
                    map["SecureGroupId"] = self.secureGroupId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SecureGroupId") {
                    self.secureGroupId = dict["SecureGroupId"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var customHost: UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost?

        public var customPrometheusSetting: UpdateTimingSyntheticTaskRequest.CommonSetting.CustomPrometheusSetting?

        public var customVPCSetting: UpdateTimingSyntheticTaskRequest.CommonSetting.CustomVPCSetting?

        public var ipType: Int32?

        public var isOpenTrace: Bool?

        public var monitorSamples: Int32?

        public var traceClientType: Int32?

        public var xtraceRegion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customHost?.validate()
            try self.customPrometheusSetting?.validate()
            try self.customVPCSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customHost != nil {
                map["CustomHost"] = self.customHost?.toMap()
            }
            if self.customPrometheusSetting != nil {
                map["CustomPrometheusSetting"] = self.customPrometheusSetting?.toMap()
            }
            if self.customVPCSetting != nil {
                map["CustomVPCSetting"] = self.customVPCSetting?.toMap()
            }
            if self.ipType != nil {
                map["IpType"] = self.ipType!
            }
            if self.isOpenTrace != nil {
                map["IsOpenTrace"] = self.isOpenTrace!
            }
            if self.monitorSamples != nil {
                map["MonitorSamples"] = self.monitorSamples!
            }
            if self.traceClientType != nil {
                map["TraceClientType"] = self.traceClientType!
            }
            if self.xtraceRegion != nil {
                map["XtraceRegion"] = self.xtraceRegion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomHost") {
                var model = UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost()
                model.fromMap(dict["CustomHost"] as! [String: Any])
                self.customHost = model
            }
            if dict.keys.contains("CustomPrometheusSetting") {
                var model = UpdateTimingSyntheticTaskRequest.CommonSetting.CustomPrometheusSetting()
                model.fromMap(dict["CustomPrometheusSetting"] as! [String: Any])
                self.customPrometheusSetting = model
            }
            if dict.keys.contains("CustomVPCSetting") {
                var model = UpdateTimingSyntheticTaskRequest.CommonSetting.CustomVPCSetting()
                model.fromMap(dict["CustomVPCSetting"] as! [String: Any])
                self.customVPCSetting = model
            }
            if dict.keys.contains("IpType") {
                self.ipType = dict["IpType"] as! Int32
            }
            if dict.keys.contains("IsOpenTrace") {
                self.isOpenTrace = dict["IsOpenTrace"] as! Bool
            }
            if dict.keys.contains("MonitorSamples") {
                self.monitorSamples = dict["MonitorSamples"] as! Int32
            }
            if dict.keys.contains("TraceClientType") {
                self.traceClientType = dict["TraceClientType"] as! Int32
            }
            if dict.keys.contains("XtraceRegion") {
                self.xtraceRegion = dict["XtraceRegion"] as! String
            }
        }
    }
    public class CustomPeriod : Tea.TeaModel {
        public var endHour: Int32?

        public var startHour: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endHour != nil {
                map["EndHour"] = self.endHour!
            }
            if self.startHour != nil {
                map["StartHour"] = self.startHour!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndHour") {
                self.endHour = dict["EndHour"] as! Int32
            }
            if dict.keys.contains("StartHour") {
                self.startHour = dict["StartHour"] as! Int32
            }
        }
    }
    public class MonitorConf : Tea.TeaModel {
        public class ApiHTTP : Tea.TeaModel {
            public class RequestBody : Tea.TeaModel {
                public var content: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var checkCert: Bool?

            public var connectTimeout: Int64?

            public var method: String?

            public var protocolAlpnProtocol: Int32?

            public var requestBody: UpdateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP.RequestBody?

            public var requestHeaders: [String: String]?

            public var targetUrl: String?

            public var timeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.requestBody?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkCert != nil {
                    map["CheckCert"] = self.checkCert!
                }
                if self.connectTimeout != nil {
                    map["ConnectTimeout"] = self.connectTimeout!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.protocolAlpnProtocol != nil {
                    map["ProtocolAlpnProtocol"] = self.protocolAlpnProtocol!
                }
                if self.requestBody != nil {
                    map["RequestBody"] = self.requestBody?.toMap()
                }
                if self.requestHeaders != nil {
                    map["RequestHeaders"] = self.requestHeaders!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckCert") {
                    self.checkCert = dict["CheckCert"] as! Bool
                }
                if dict.keys.contains("ConnectTimeout") {
                    self.connectTimeout = dict["ConnectTimeout"] as! Int64
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("ProtocolAlpnProtocol") {
                    self.protocolAlpnProtocol = dict["ProtocolAlpnProtocol"] as! Int32
                }
                if dict.keys.contains("RequestBody") {
                    var model = UpdateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP.RequestBody()
                    model.fromMap(dict["RequestBody"] as! [String: Any])
                    self.requestBody = model
                }
                if dict.keys.contains("RequestHeaders") {
                    self.requestHeaders = dict["RequestHeaders"] as! [String: String]
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
            }
        }
        public class FileDownload : Tea.TeaModel {
            public var connectionTimeout: Int64?

            public var customHeaderContent: [String: String]?

            public var downloadKernel: Int32?

            public var ignoreCertificateAuthError: Int32?

            public var ignoreCertificateCanceledError: Int32?

            public var ignoreCertificateOutOfDateError: Int32?

            public var ignoreCertificateStatusError: Int32?

            public var ignoreCertificateUntrustworthyError: Int32?

            public var ignoreCertificateUsingError: Int32?

            public var ignoreInvalidHostError: Int32?

            public var monitorTimeout: Int64?

            public var quickProtocol: Int32?

            public var redirection: Int32?

            public var targetUrl: String?

            public var transmissionSize: Int64?

            public var validateKeywords: String?

            public var verifyWay: Int32?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectionTimeout != nil {
                    map["ConnectionTimeout"] = self.connectionTimeout!
                }
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.downloadKernel != nil {
                    map["DownloadKernel"] = self.downloadKernel!
                }
                if self.ignoreCertificateAuthError != nil {
                    map["IgnoreCertificateAuthError"] = self.ignoreCertificateAuthError!
                }
                if self.ignoreCertificateCanceledError != nil {
                    map["IgnoreCertificateCanceledError"] = self.ignoreCertificateCanceledError!
                }
                if self.ignoreCertificateOutOfDateError != nil {
                    map["IgnoreCertificateOutOfDateError"] = self.ignoreCertificateOutOfDateError!
                }
                if self.ignoreCertificateStatusError != nil {
                    map["IgnoreCertificateStatusError"] = self.ignoreCertificateStatusError!
                }
                if self.ignoreCertificateUntrustworthyError != nil {
                    map["IgnoreCertificateUntrustworthyError"] = self.ignoreCertificateUntrustworthyError!
                }
                if self.ignoreCertificateUsingError != nil {
                    map["IgnoreCertificateUsingError"] = self.ignoreCertificateUsingError!
                }
                if self.ignoreInvalidHostError != nil {
                    map["IgnoreInvalidHostError"] = self.ignoreInvalidHostError!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.quickProtocol != nil {
                    map["QuickProtocol"] = self.quickProtocol!
                }
                if self.redirection != nil {
                    map["Redirection"] = self.redirection!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.transmissionSize != nil {
                    map["TransmissionSize"] = self.transmissionSize!
                }
                if self.validateKeywords != nil {
                    map["ValidateKeywords"] = self.validateKeywords!
                }
                if self.verifyWay != nil {
                    map["VerifyWay"] = self.verifyWay!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectionTimeout") {
                    self.connectionTimeout = dict["ConnectionTimeout"] as! Int64
                }
                if dict.keys.contains("CustomHeaderContent") {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("DownloadKernel") {
                    self.downloadKernel = dict["DownloadKernel"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateAuthError") {
                    self.ignoreCertificateAuthError = dict["IgnoreCertificateAuthError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateCanceledError") {
                    self.ignoreCertificateCanceledError = dict["IgnoreCertificateCanceledError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateOutOfDateError") {
                    self.ignoreCertificateOutOfDateError = dict["IgnoreCertificateOutOfDateError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateStatusError") {
                    self.ignoreCertificateStatusError = dict["IgnoreCertificateStatusError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateUntrustworthyError") {
                    self.ignoreCertificateUntrustworthyError = dict["IgnoreCertificateUntrustworthyError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateUsingError") {
                    self.ignoreCertificateUsingError = dict["IgnoreCertificateUsingError"] as! Int32
                }
                if dict.keys.contains("IgnoreInvalidHostError") {
                    self.ignoreInvalidHostError = dict["IgnoreInvalidHostError"] as! Int32
                }
                if dict.keys.contains("MonitorTimeout") {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("QuickProtocol") {
                    self.quickProtocol = dict["QuickProtocol"] as! Int32
                }
                if dict.keys.contains("Redirection") {
                    self.redirection = dict["Redirection"] as! Int32
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("TransmissionSize") {
                    self.transmissionSize = dict["TransmissionSize"] as! Int64
                }
                if dict.keys.contains("ValidateKeywords") {
                    self.validateKeywords = dict["ValidateKeywords"] as! String
                }
                if dict.keys.contains("VerifyWay") {
                    self.verifyWay = dict["VerifyWay"] as! Int32
                }
                if dict.keys.contains("WhiteList") {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class NetDNS : Tea.TeaModel {
            public var dig: Int32?

            public var dnsServerIpType: Int32?

            public var nsServer: String?

            public var queryMethod: Int32?

            public var targetUrl: String?

            public var timeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dig != nil {
                    map["Dig"] = self.dig!
                }
                if self.dnsServerIpType != nil {
                    map["DnsServerIpType"] = self.dnsServerIpType!
                }
                if self.nsServer != nil {
                    map["NsServer"] = self.nsServer!
                }
                if self.queryMethod != nil {
                    map["QueryMethod"] = self.queryMethod!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dig") {
                    self.dig = dict["Dig"] as! Int32
                }
                if dict.keys.contains("DnsServerIpType") {
                    self.dnsServerIpType = dict["DnsServerIpType"] as! Int32
                }
                if dict.keys.contains("NsServer") {
                    self.nsServer = dict["NsServer"] as! String
                }
                if dict.keys.contains("QueryMethod") {
                    self.queryMethod = dict["QueryMethod"] as! Int32
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
            }
        }
        public class NetICMP : Tea.TeaModel {
            public var interval: Int64?

            public var packageNum: Int32?

            public var packageSize: Int32?

            public var splitPackage: Bool?

            public var targetUrl: String?

            public var timeout: Int64?

            public var tracertEnable: Bool?

            public var tracertNumMax: Int32?

            public var tracertTimeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.packageNum != nil {
                    map["PackageNum"] = self.packageNum!
                }
                if self.packageSize != nil {
                    map["PackageSize"] = self.packageSize!
                }
                if self.splitPackage != nil {
                    map["SplitPackage"] = self.splitPackage!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.tracertEnable != nil {
                    map["TracertEnable"] = self.tracertEnable!
                }
                if self.tracertNumMax != nil {
                    map["TracertNumMax"] = self.tracertNumMax!
                }
                if self.tracertTimeout != nil {
                    map["TracertTimeout"] = self.tracertTimeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("PackageNum") {
                    self.packageNum = dict["PackageNum"] as! Int32
                }
                if dict.keys.contains("PackageSize") {
                    self.packageSize = dict["PackageSize"] as! Int32
                }
                if dict.keys.contains("SplitPackage") {
                    self.splitPackage = dict["SplitPackage"] as! Bool
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("TracertEnable") {
                    self.tracertEnable = dict["TracertEnable"] as! Bool
                }
                if dict.keys.contains("TracertNumMax") {
                    self.tracertNumMax = dict["TracertNumMax"] as! Int32
                }
                if dict.keys.contains("TracertTimeout") {
                    self.tracertTimeout = dict["TracertTimeout"] as! Int64
                }
            }
        }
        public class NetTCP : Tea.TeaModel {
            public var connectTimes: Int32?

            public var interval: Int64?

            public var targetUrl: String?

            public var timeout: Int64?

            public var tracertEnable: Bool?

            public var tracertNumMax: Int32?

            public var tracertTimeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectTimes != nil {
                    map["ConnectTimes"] = self.connectTimes!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.tracertEnable != nil {
                    map["TracertEnable"] = self.tracertEnable!
                }
                if self.tracertNumMax != nil {
                    map["TracertNumMax"] = self.tracertNumMax!
                }
                if self.tracertTimeout != nil {
                    map["TracertTimeout"] = self.tracertTimeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectTimes") {
                    self.connectTimes = dict["ConnectTimes"] as! Int32
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("TracertEnable") {
                    self.tracertEnable = dict["TracertEnable"] as! Bool
                }
                if dict.keys.contains("TracertNumMax") {
                    self.tracertNumMax = dict["TracertNumMax"] as! Int32
                }
                if dict.keys.contains("TracertTimeout") {
                    self.tracertTimeout = dict["TracertTimeout"] as! Int64
                }
            }
        }
        public class Stream : Tea.TeaModel {
            public var customHeaderContent: [String: String]?

            public var playerType: Int32?

            public var streamAddressType: Int32?

            public var streamMonitorTimeout: Int32?

            public var streamType: Int32?

            public var targetUrl: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.playerType != nil {
                    map["PlayerType"] = self.playerType!
                }
                if self.streamAddressType != nil {
                    map["StreamAddressType"] = self.streamAddressType!
                }
                if self.streamMonitorTimeout != nil {
                    map["StreamMonitorTimeout"] = self.streamMonitorTimeout!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomHeaderContent") {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("PlayerType") {
                    self.playerType = dict["PlayerType"] as! Int32
                }
                if dict.keys.contains("StreamAddressType") {
                    self.streamAddressType = dict["StreamAddressType"] as! Int32
                }
                if dict.keys.contains("StreamMonitorTimeout") {
                    self.streamMonitorTimeout = dict["StreamMonitorTimeout"] as! Int32
                }
                if dict.keys.contains("StreamType") {
                    self.streamType = dict["StreamType"] as! Int32
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("WhiteList") {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class Website : Tea.TeaModel {
            public var automaticScrolling: Int32?

            public var customHeader: Int32?

            public var customHeaderContent: [String: String]?

            public var DNSHijackWhitelist: String?

            public var disableCache: Int32?

            public var disableCompression: Int32?

            public var elementBlacklist: String?

            public var filterInvalidIP: Int32?

            public var flowHijackJumpTimes: Int32?

            public var flowHijackLogo: String?

            public var ignoreCertificateError: Int32?

            public var monitorTimeout: Int64?

            public var pageTamper: String?

            public var redirection: Int32?

            public var slowElementThreshold: Int64?

            public var targetUrl: String?

            public var verifyStringBlacklist: String?

            public var verifyStringWhitelist: String?

            public var waitCompletionTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.automaticScrolling != nil {
                    map["AutomaticScrolling"] = self.automaticScrolling!
                }
                if self.customHeader != nil {
                    map["CustomHeader"] = self.customHeader!
                }
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.DNSHijackWhitelist != nil {
                    map["DNSHijackWhitelist"] = self.DNSHijackWhitelist!
                }
                if self.disableCache != nil {
                    map["DisableCache"] = self.disableCache!
                }
                if self.disableCompression != nil {
                    map["DisableCompression"] = self.disableCompression!
                }
                if self.elementBlacklist != nil {
                    map["ElementBlacklist"] = self.elementBlacklist!
                }
                if self.filterInvalidIP != nil {
                    map["FilterInvalidIP"] = self.filterInvalidIP!
                }
                if self.flowHijackJumpTimes != nil {
                    map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
                }
                if self.flowHijackLogo != nil {
                    map["FlowHijackLogo"] = self.flowHijackLogo!
                }
                if self.ignoreCertificateError != nil {
                    map["IgnoreCertificateError"] = self.ignoreCertificateError!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.pageTamper != nil {
                    map["PageTamper"] = self.pageTamper!
                }
                if self.redirection != nil {
                    map["Redirection"] = self.redirection!
                }
                if self.slowElementThreshold != nil {
                    map["SlowElementThreshold"] = self.slowElementThreshold!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.verifyStringBlacklist != nil {
                    map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
                }
                if self.verifyStringWhitelist != nil {
                    map["VerifyStringWhitelist"] = self.verifyStringWhitelist!
                }
                if self.waitCompletionTime != nil {
                    map["WaitCompletionTime"] = self.waitCompletionTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutomaticScrolling") {
                    self.automaticScrolling = dict["AutomaticScrolling"] as! Int32
                }
                if dict.keys.contains("CustomHeader") {
                    self.customHeader = dict["CustomHeader"] as! Int32
                }
                if dict.keys.contains("CustomHeaderContent") {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("DNSHijackWhitelist") {
                    self.DNSHijackWhitelist = dict["DNSHijackWhitelist"] as! String
                }
                if dict.keys.contains("DisableCache") {
                    self.disableCache = dict["DisableCache"] as! Int32
                }
                if dict.keys.contains("DisableCompression") {
                    self.disableCompression = dict["DisableCompression"] as! Int32
                }
                if dict.keys.contains("ElementBlacklist") {
                    self.elementBlacklist = dict["ElementBlacklist"] as! String
                }
                if dict.keys.contains("FilterInvalidIP") {
                    self.filterInvalidIP = dict["FilterInvalidIP"] as! Int32
                }
                if dict.keys.contains("FlowHijackJumpTimes") {
                    self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int32
                }
                if dict.keys.contains("FlowHijackLogo") {
                    self.flowHijackLogo = dict["FlowHijackLogo"] as! String
                }
                if dict.keys.contains("IgnoreCertificateError") {
                    self.ignoreCertificateError = dict["IgnoreCertificateError"] as! Int32
                }
                if dict.keys.contains("MonitorTimeout") {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("PageTamper") {
                    self.pageTamper = dict["PageTamper"] as! String
                }
                if dict.keys.contains("Redirection") {
                    self.redirection = dict["Redirection"] as! Int32
                }
                if dict.keys.contains("SlowElementThreshold") {
                    self.slowElementThreshold = dict["SlowElementThreshold"] as! Int64
                }
                if dict.keys.contains("TargetUrl") {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("VerifyStringBlacklist") {
                    self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
                }
                if dict.keys.contains("VerifyStringWhitelist") {
                    self.verifyStringWhitelist = dict["VerifyStringWhitelist"] as! String
                }
                if dict.keys.contains("WaitCompletionTime") {
                    self.waitCompletionTime = dict["WaitCompletionTime"] as! Int64
                }
            }
        }
        public var apiHTTP: UpdateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP?

        public var fileDownload: UpdateTimingSyntheticTaskRequest.MonitorConf.FileDownload?

        public var netDNS: UpdateTimingSyntheticTaskRequest.MonitorConf.NetDNS?

        public var netICMP: UpdateTimingSyntheticTaskRequest.MonitorConf.NetICMP?

        public var netTCP: UpdateTimingSyntheticTaskRequest.MonitorConf.NetTCP?

        public var stream: UpdateTimingSyntheticTaskRequest.MonitorConf.Stream?

        public var website: UpdateTimingSyntheticTaskRequest.MonitorConf.Website?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.apiHTTP?.validate()
            try self.fileDownload?.validate()
            try self.netDNS?.validate()
            try self.netICMP?.validate()
            try self.netTCP?.validate()
            try self.stream?.validate()
            try self.website?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiHTTP != nil {
                map["ApiHTTP"] = self.apiHTTP?.toMap()
            }
            if self.fileDownload != nil {
                map["FileDownload"] = self.fileDownload?.toMap()
            }
            if self.netDNS != nil {
                map["NetDNS"] = self.netDNS?.toMap()
            }
            if self.netICMP != nil {
                map["NetICMP"] = self.netICMP?.toMap()
            }
            if self.netTCP != nil {
                map["NetTCP"] = self.netTCP?.toMap()
            }
            if self.stream != nil {
                map["Stream"] = self.stream?.toMap()
            }
            if self.website != nil {
                map["Website"] = self.website?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiHTTP") {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP()
                model.fromMap(dict["ApiHTTP"] as! [String: Any])
                self.apiHTTP = model
            }
            if dict.keys.contains("FileDownload") {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.FileDownload()
                model.fromMap(dict["FileDownload"] as! [String: Any])
                self.fileDownload = model
            }
            if dict.keys.contains("NetDNS") {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.NetDNS()
                model.fromMap(dict["NetDNS"] as! [String: Any])
                self.netDNS = model
            }
            if dict.keys.contains("NetICMP") {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.NetICMP()
                model.fromMap(dict["NetICMP"] as! [String: Any])
                self.netICMP = model
            }
            if dict.keys.contains("NetTCP") {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.NetTCP()
                model.fromMap(dict["NetTCP"] as! [String: Any])
                self.netTCP = model
            }
            if dict.keys.contains("Stream") {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.Stream()
                model.fromMap(dict["Stream"] as! [String: Any])
                self.stream = model
            }
            if dict.keys.contains("Website") {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.Website()
                model.fromMap(dict["Website"] as! [String: Any])
                self.website = model
            }
        }
    }
    public class Monitors : Tea.TeaModel {
        public var cityCode: String?

        public var clientType: Int32?

        public var operatorCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.operatorCode != nil {
                map["OperatorCode"] = self.operatorCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("ClientType") {
                self.clientType = dict["ClientType"] as! Int32
            }
            if dict.keys.contains("OperatorCode") {
                self.operatorCode = dict["OperatorCode"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var availableAssertions: [UpdateTimingSyntheticTaskRequest.AvailableAssertions]?

    public var commonSetting: UpdateTimingSyntheticTaskRequest.CommonSetting?

    public var customPeriod: UpdateTimingSyntheticTaskRequest.CustomPeriod?

    public var frequency: String?

    public var monitorConf: UpdateTimingSyntheticTaskRequest.MonitorConf?

    public var monitors: [UpdateTimingSyntheticTaskRequest.Monitors]?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [UpdateTimingSyntheticTaskRequest.Tags]?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonSetting?.validate()
        try self.customPeriod?.validate()
        try self.monitorConf?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAssertions != nil {
            var tmp : [Any] = []
            for k in self.availableAssertions! {
                tmp.append(k.toMap())
            }
            map["AvailableAssertions"] = tmp
        }
        if self.commonSetting != nil {
            map["CommonSetting"] = self.commonSetting?.toMap()
        }
        if self.customPeriod != nil {
            map["CustomPeriod"] = self.customPeriod?.toMap()
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.monitorConf != nil {
            map["MonitorConf"] = self.monitorConf?.toMap()
        }
        if self.monitors != nil {
            var tmp : [Any] = []
            for k in self.monitors! {
                tmp.append(k.toMap())
            }
            map["Monitors"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAssertions") {
            var tmp : [UpdateTimingSyntheticTaskRequest.AvailableAssertions] = []
            for v in dict["AvailableAssertions"] as! [Any] {
                var model = UpdateTimingSyntheticTaskRequest.AvailableAssertions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.availableAssertions = tmp
        }
        if dict.keys.contains("CommonSetting") {
            var model = UpdateTimingSyntheticTaskRequest.CommonSetting()
            model.fromMap(dict["CommonSetting"] as! [String: Any])
            self.commonSetting = model
        }
        if dict.keys.contains("CustomPeriod") {
            var model = UpdateTimingSyntheticTaskRequest.CustomPeriod()
            model.fromMap(dict["CustomPeriod"] as! [String: Any])
            self.customPeriod = model
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("MonitorConf") {
            var model = UpdateTimingSyntheticTaskRequest.MonitorConf()
            model.fromMap(dict["MonitorConf"] as! [String: Any])
            self.monitorConf = model
        }
        if dict.keys.contains("Monitors") {
            var tmp : [UpdateTimingSyntheticTaskRequest.Monitors] = []
            for v in dict["Monitors"] as! [Any] {
                var model = UpdateTimingSyntheticTaskRequest.Monitors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.monitors = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [UpdateTimingSyntheticTaskRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = UpdateTimingSyntheticTaskRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class UpdateTimingSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var availableAssertionsShrink: String?

    public var commonSettingShrink: String?

    public var customPeriodShrink: String?

    public var frequency: String?

    public var monitorConfShrink: String?

    public var monitorsShrink: String?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tagsShrink: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAssertionsShrink != nil {
            map["AvailableAssertions"] = self.availableAssertionsShrink!
        }
        if self.commonSettingShrink != nil {
            map["CommonSetting"] = self.commonSettingShrink!
        }
        if self.customPeriodShrink != nil {
            map["CustomPeriod"] = self.customPeriodShrink!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.monitorConfShrink != nil {
            map["MonitorConf"] = self.monitorConfShrink!
        }
        if self.monitorsShrink != nil {
            map["Monitors"] = self.monitorsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAssertions") {
            self.availableAssertionsShrink = dict["AvailableAssertions"] as! String
        }
        if dict.keys.contains("CommonSetting") {
            self.commonSettingShrink = dict["CommonSetting"] as! String
        }
        if dict.keys.contains("CustomPeriod") {
            self.customPeriodShrink = dict["CustomPeriod"] as! String
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("MonitorConf") {
            self.monitorConfShrink = dict["MonitorConf"] as! String
        }
        if dict.keys.contains("Monitors") {
            self.monitorsShrink = dict["Monitors"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class UpdateTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: UpdateTimingSyntheticTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = UpdateTimingSyntheticTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWebhookRequest : Tea.TeaModel {
    public var body: String?

    public var contactId: Int64?

    public var contactName: String?

    public var httpHeaders: String?

    public var httpParams: String?

    public var method: String?

    public var recoverBody: String?

    public var regionId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["Body"] = self.body!
        }
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.httpHeaders != nil {
            map["HttpHeaders"] = self.httpHeaders!
        }
        if self.httpParams != nil {
            map["HttpParams"] = self.httpParams!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.recoverBody != nil {
            map["RecoverBody"] = self.recoverBody!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Body") {
            self.body = dict["Body"] as! String
        }
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("HttpHeaders") {
            self.httpHeaders = dict["HttpHeaders"] as! String
        }
        if dict.keys.contains("HttpParams") {
            self.httpParams = dict["HttpParams"] as! String
        }
        if dict.keys.contains("Method") {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("RecoverBody") {
            self.recoverBody = dict["RecoverBody"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class UpdateWebhookResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeAddonReleaseRequest : Tea.TeaModel {
    public var addonVersion: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var regionId: String?

    public var releaseName: String?

    public var values: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonVersion != nil {
            map["AddonVersion"] = self.addonVersion!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseName != nil {
            map["ReleaseName"] = self.releaseName!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonVersion") {
            self.addonVersion = dict["AddonVersion"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseName") {
            self.releaseName = dict["ReleaseName"] as! String
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! String
        }
    }
}

public class UpgradeAddonReleaseResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeAddonReleaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeAddonReleaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeAddonReleaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeEnvironmentFeatureRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var environmentId: String?

    public var featureName: String?

    public var featureVersion: String?

    public var regionId: String?

    public var values: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.featureVersion != nil {
            map["FeatureVersion"] = self.featureVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("EnvironmentId") {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("FeatureVersion") {
            self.featureVersion = dict["FeatureVersion"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! String
        }
    }
}

public class UpgradeEnvironmentFeatureResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String: String]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String: String]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadRequest : Tea.TeaModel {
    public var edition: String?

    public var file: String?

    public var fileName: String?

    public var pid: String?

    public var regionId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.edition != nil {
            map["Edition"] = self.edition!
        }
        if self.file != nil {
            map["File"] = self.file!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Edition") {
            self.edition = dict["Edition"] as! String
        }
        if dict.keys.contains("File") {
            self.file = dict["File"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Pid") {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Version") {
            self.version = dict["Version"] as! String
        }
    }
}

public class UploadResponseBody : Tea.TeaModel {
    public class UploadResult : Tea.TeaModel {
        public var fid: String?

        public var fileName: String?

        public var uploadTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fid != nil {
                map["Fid"] = self.fid!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.uploadTime != nil {
                map["UploadTime"] = self.uploadTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Fid") {
                self.fid = dict["Fid"] as! String
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("UploadTime") {
                self.uploadTime = dict["UploadTime"] as! String
            }
        }
    }
    public var requestId: String?

    public var uploadResult: UploadResponseBody.UploadResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadResult != nil {
            map["UploadResult"] = self.uploadResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadResult") {
            var model = UploadResponseBody.UploadResult()
            model.fromMap(dict["UploadResult"] as! [String: Any])
            self.uploadResult = model
        }
    }
}

public class UploadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
