import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class CallChainInfo : Tea.TeaModel {
    public var additionalInfo: String?

    public var appName: String?

    public var appType: String?

    public var children: [CallChainInfo]?

    public var haveSpan: Bool?

    public var logMap: [String: [String: Any]]?

    public var logTime: Int64?

    public var parentSpanId: String?

    public var pid: String?

    public var regionId: String?

    public var resultCode: String?

    public var rpc: String?

    public var rpcId: String?

    public var rpcType: Int64?

    public var serverIp: String?

    public var span: Int64?

    public var spanId: String?

    public var tagMap: [String: String]?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalInfo != nil {
            map["AdditionalInfo"] = self.additionalInfo!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.children != nil {
            var tmp : [Any] = []
            for k in self.children! {
                tmp.append(k.toMap())
            }
            map["Children"] = tmp
        }
        if self.haveSpan != nil {
            map["HaveSpan"] = self.haveSpan!
        }
        if self.logMap != nil {
            map["LogMap"] = self.logMap!
        }
        if self.logTime != nil {
            map["LogTime"] = self.logTime!
        }
        if self.parentSpanId != nil {
            map["ParentSpanId"] = self.parentSpanId!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.rpc != nil {
            map["Rpc"] = self.rpc!
        }
        if self.rpcId != nil {
            map["RpcId"] = self.rpcId!
        }
        if self.rpcType != nil {
            map["RpcType"] = self.rpcType!
        }
        if self.serverIp != nil {
            map["ServerIp"] = self.serverIp!
        }
        if self.span != nil {
            map["Span"] = self.span!
        }
        if self.spanId != nil {
            map["SpanId"] = self.spanId!
        }
        if self.tagMap != nil {
            map["TagMap"] = self.tagMap!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionalInfo") && dict["AdditionalInfo"] != nil {
            self.additionalInfo = dict["AdditionalInfo"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Children") && dict["Children"] != nil {
            var tmp : [CallChainInfo] = []
            for v in dict["Children"] as! [Any] {
                var model = CallChainInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.children = tmp
        }
        if dict.keys.contains("HaveSpan") && dict["HaveSpan"] != nil {
            self.haveSpan = dict["HaveSpan"] as! Bool
        }
        if dict.keys.contains("LogMap") && dict["LogMap"] != nil {
            self.logMap = dict["LogMap"] as! [String: [String: Any]]
        }
        if dict.keys.contains("LogTime") && dict["LogTime"] != nil {
            self.logTime = dict["LogTime"] as! Int64
        }
        if dict.keys.contains("ParentSpanId") && dict["ParentSpanId"] != nil {
            self.parentSpanId = dict["ParentSpanId"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("Rpc") && dict["Rpc"] != nil {
            self.rpc = dict["Rpc"] as! String
        }
        if dict.keys.contains("RpcId") && dict["RpcId"] != nil {
            self.rpcId = dict["RpcId"] as! String
        }
        if dict.keys.contains("RpcType") && dict["RpcType"] != nil {
            self.rpcType = dict["RpcType"] as! Int64
        }
        if dict.keys.contains("ServerIp") && dict["ServerIp"] != nil {
            self.serverIp = dict["ServerIp"] as! String
        }
        if dict.keys.contains("Span") && dict["Span"] != nil {
            self.span = dict["Span"] as! Int64
        }
        if dict.keys.contains("SpanId") && dict["SpanId"] != nil {
            self.spanId = dict["SpanId"] as! String
        }
        if dict.keys.contains("TagMap") && dict["TagMap"] != nil {
            self.tagMap = dict["TagMap"] as! [String: String]
        }
        if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class GrafanaWorkspace : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("key") && dict["key"] != nil {
                self.key = dict["key"] as! String
            }
            if dict.keys.contains("value") && dict["value"] != nil {
                self.value = dict["value"] as! String
            }
        }
    }
    public var commercial: Bool?

    public var deployType: String?

    public var description_: String?

    public var endTime: Double?

    public var gmtCreate: Double?

    public var grafanaVersion: String?

    public var grafanaWorkspaceDomain: String?

    public var grafanaWorkspaceEdition: String?

    public var grafanaWorkspaceId: String?

    public var grafanaWorkspaceIp: String?

    public var grafanaWorkspaceName: String?

    public var maxAccount: String?

    public var ntmId: String?

    public var personalDomain: String?

    public var personalDomainPrefix: String?

    public var privateDomain: String?

    public var privateIp: String?

    public var protocol_: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var shareSynced: Bool?

    public var snatIp: String?

    public var status: String?

    public var tags: [GrafanaWorkspace.Tags]?

    public var upgradeVersion: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commercial != nil {
            map["commercial"] = self.commercial!
        }
        if self.deployType != nil {
            map["deployType"] = self.deployType!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.grafanaVersion != nil {
            map["grafanaVersion"] = self.grafanaVersion!
        }
        if self.grafanaWorkspaceDomain != nil {
            map["grafanaWorkspaceDomain"] = self.grafanaWorkspaceDomain!
        }
        if self.grafanaWorkspaceEdition != nil {
            map["grafanaWorkspaceEdition"] = self.grafanaWorkspaceEdition!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.grafanaWorkspaceIp != nil {
            map["grafanaWorkspaceIp"] = self.grafanaWorkspaceIp!
        }
        if self.grafanaWorkspaceName != nil {
            map["grafanaWorkspaceName"] = self.grafanaWorkspaceName!
        }
        if self.maxAccount != nil {
            map["maxAccount"] = self.maxAccount!
        }
        if self.ntmId != nil {
            map["ntmId"] = self.ntmId!
        }
        if self.personalDomain != nil {
            map["personalDomain"] = self.personalDomain!
        }
        if self.personalDomainPrefix != nil {
            map["personalDomainPrefix"] = self.personalDomainPrefix!
        }
        if self.privateDomain != nil {
            map["privateDomain"] = self.privateDomain!
        }
        if self.privateIp != nil {
            map["privateIp"] = self.privateIp!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.shareSynced != nil {
            map["shareSynced"] = self.shareSynced!
        }
        if self.snatIp != nil {
            map["snatIp"] = self.snatIp!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["tags"] = tmp
        }
        if self.upgradeVersion != nil {
            map["upgradeVersion"] = self.upgradeVersion!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commercial") && dict["commercial"] != nil {
            self.commercial = dict["commercial"] as! Bool
        }
        if dict.keys.contains("deployType") && dict["deployType"] != nil {
            self.deployType = dict["deployType"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! Double
        }
        if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
            self.gmtCreate = dict["gmtCreate"] as! Double
        }
        if dict.keys.contains("grafanaVersion") && dict["grafanaVersion"] != nil {
            self.grafanaVersion = dict["grafanaVersion"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceDomain") && dict["grafanaWorkspaceDomain"] != nil {
            self.grafanaWorkspaceDomain = dict["grafanaWorkspaceDomain"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceEdition") && dict["grafanaWorkspaceEdition"] != nil {
            self.grafanaWorkspaceEdition = dict["grafanaWorkspaceEdition"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceId") && dict["grafanaWorkspaceId"] != nil {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceIp") && dict["grafanaWorkspaceIp"] != nil {
            self.grafanaWorkspaceIp = dict["grafanaWorkspaceIp"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceName") && dict["grafanaWorkspaceName"] != nil {
            self.grafanaWorkspaceName = dict["grafanaWorkspaceName"] as! String
        }
        if dict.keys.contains("maxAccount") && dict["maxAccount"] != nil {
            self.maxAccount = dict["maxAccount"] as! String
        }
        if dict.keys.contains("ntmId") && dict["ntmId"] != nil {
            self.ntmId = dict["ntmId"] as! String
        }
        if dict.keys.contains("personalDomain") && dict["personalDomain"] != nil {
            self.personalDomain = dict["personalDomain"] as! String
        }
        if dict.keys.contains("personalDomainPrefix") && dict["personalDomainPrefix"] != nil {
            self.personalDomainPrefix = dict["personalDomainPrefix"] as! String
        }
        if dict.keys.contains("privateDomain") && dict["privateDomain"] != nil {
            self.privateDomain = dict["privateDomain"] as! String
        }
        if dict.keys.contains("privateIp") && dict["privateIp"] != nil {
            self.privateIp = dict["privateIp"] as! String
        }
        if dict.keys.contains("protocol") && dict["protocol"] != nil {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("regionId") && dict["regionId"] != nil {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("resourceGroupId") && dict["resourceGroupId"] != nil {
            self.resourceGroupId = dict["resourceGroupId"] as! String
        }
        if dict.keys.contains("shareSynced") && dict["shareSynced"] != nil {
            self.shareSynced = dict["shareSynced"] as! Bool
        }
        if dict.keys.contains("snatIp") && dict["snatIp"] != nil {
            self.snatIp = dict["snatIp"] as! String
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("tags") && dict["tags"] != nil {
            var tmp : [GrafanaWorkspace.Tags] = []
            for v in dict["tags"] as! [Any] {
                var model = GrafanaWorkspace.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("upgradeVersion") && dict["upgradeVersion"] != nil {
            self.upgradeVersion = dict["upgradeVersion"] as! [String]
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceAccount : Tea.TeaModel {
    public var accountId: Int64?

    public var accountNotes: String?

    public var aliyunUid: String?

    public var aliyunUserName: String?

    public var gmtCreate: Double?

    public var orgs: [GrafanaWorkspaceUserOrg]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        if self.accountNotes != nil {
            map["accountNotes"] = self.accountNotes!
        }
        if self.aliyunUid != nil {
            map["aliyunUid"] = self.aliyunUid!
        }
        if self.aliyunUserName != nil {
            map["aliyunUserName"] = self.aliyunUserName!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.orgs != nil {
            var tmp : [Any] = []
            for k in self.orgs! {
                tmp.append(k.toMap())
            }
            map["orgs"] = tmp
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accountId") && dict["accountId"] != nil {
            self.accountId = dict["accountId"] as! Int64
        }
        if dict.keys.contains("accountNotes") && dict["accountNotes"] != nil {
            self.accountNotes = dict["accountNotes"] as! String
        }
        if dict.keys.contains("aliyunUid") && dict["aliyunUid"] != nil {
            self.aliyunUid = dict["aliyunUid"] as! String
        }
        if dict.keys.contains("aliyunUserName") && dict["aliyunUserName"] != nil {
            self.aliyunUserName = dict["aliyunUserName"] as! String
        }
        if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
            self.gmtCreate = dict["gmtCreate"] as! Double
        }
        if dict.keys.contains("orgs") && dict["orgs"] != nil {
            var tmp : [GrafanaWorkspaceUserOrg] = []
            for v in dict["orgs"] as! [Any] {
                var model = GrafanaWorkspaceUserOrg()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orgs = tmp
        }
        if dict.keys.contains("type") && dict["type"] != nil {
            self.type = dict["type"] as! String
        }
    }
}

public class GrafanaWorkspaceAlertNotification : Tea.TeaModel {
    public var id: Int64?

    public var isArms: Bool?

    public var isDefault: Bool?

    public var name: String?

    public var sendReminder: Bool?

    public var settings: String?

    public var type: String?

    public var uid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isArms != nil {
            map["isArms"] = self.isArms!
        }
        if self.isDefault != nil {
            map["isDefault"] = self.isDefault!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.sendReminder != nil {
            map["sendReminder"] = self.sendReminder!
        }
        if self.settings != nil {
            map["settings"] = self.settings!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.uid != nil {
            map["uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("isArms") && dict["isArms"] != nil {
            self.isArms = dict["isArms"] as! Bool
        }
        if dict.keys.contains("isDefault") && dict["isDefault"] != nil {
            self.isDefault = dict["isDefault"] as! Bool
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("sendReminder") && dict["sendReminder"] != nil {
            self.sendReminder = dict["sendReminder"] as! Bool
        }
        if dict.keys.contains("settings") && dict["settings"] != nil {
            self.settings = dict["settings"] as! String
        }
        if dict.keys.contains("type") && dict["type"] != nil {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("uid") && dict["uid"] != nil {
            self.uid = dict["uid"] as! String
        }
    }
}

public class GrafanaWorkspaceArmsAlertConfig : Tea.TeaModel {
    public var armsAlertsEnable: String?

    public var armsAlertsWebhookUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.armsAlertsEnable != nil {
            map["armsAlertsEnable"] = self.armsAlertsEnable!
        }
        if self.armsAlertsWebhookUrl != nil {
            map["armsAlertsWebhookUrl"] = self.armsAlertsWebhookUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("armsAlertsEnable") && dict["armsAlertsEnable"] != nil {
            self.armsAlertsEnable = dict["armsAlertsEnable"] as! String
        }
        if dict.keys.contains("armsAlertsWebhookUrl") && dict["armsAlertsWebhookUrl"] != nil {
            self.armsAlertsWebhookUrl = dict["armsAlertsWebhookUrl"] as! String
        }
    }
}

public class GrafanaWorkspaceCustomDomain : Tea.TeaModel {
    public var cert: String?

    public var date: Int64?

    public var domain: String?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var key: String?

    public var privateZone: String?

    public var protocol_: String?

    public var status: String?

    public var uri: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cert != nil {
            map["cert"] = self.cert!
        }
        if self.date != nil {
            map["date"] = self.date!
        }
        if self.domain != nil {
            map["domain"] = self.domain!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.key != nil {
            map["key"] = self.key!
        }
        if self.privateZone != nil {
            map["privateZone"] = self.privateZone!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.uri != nil {
            map["uri"] = self.uri!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("cert") && dict["cert"] != nil {
            self.cert = dict["cert"] as! String
        }
        if dict.keys.contains("date") && dict["date"] != nil {
            self.date = dict["date"] as! Int64
        }
        if dict.keys.contains("domain") && dict["domain"] != nil {
            self.domain = dict["domain"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceId") && dict["grafanaWorkspaceId"] != nil {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("key") && dict["key"] != nil {
            self.key = dict["key"] as! String
        }
        if dict.keys.contains("privateZone") && dict["privateZone"] != nil {
            self.privateZone = dict["privateZone"] as! String
        }
        if dict.keys.contains("protocol") && dict["protocol"] != nil {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("uri") && dict["uri"] != nil {
            self.uri = dict["uri"] as! String
        }
    }
}

public class GrafanaWorkspaceDashboardReport : Tea.TeaModel {
    public var gmtCreate: Int64?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var lastSendTime: Int64?

    public var msg: String?

    public var name: String?

    public var reportChannelTarget: String?

    public var reportChannelType: String?

    public var reportStyle: String?

    public var reportType: String?

    public var status: String?

    public var triggerDay: String?

    public var triggerTime: String?

    public var triggerType: String?

    public var url: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.lastSendTime != nil {
            map["lastSendTime"] = self.lastSendTime!
        }
        if self.msg != nil {
            map["msg"] = self.msg!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.reportChannelTarget != nil {
            map["reportChannelTarget"] = self.reportChannelTarget!
        }
        if self.reportChannelType != nil {
            map["reportChannelType"] = self.reportChannelType!
        }
        if self.reportStyle != nil {
            map["reportStyle"] = self.reportStyle!
        }
        if self.reportType != nil {
            map["reportType"] = self.reportType!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.triggerDay != nil {
            map["triggerDay"] = self.triggerDay!
        }
        if self.triggerTime != nil {
            map["triggerTime"] = self.triggerTime!
        }
        if self.triggerType != nil {
            map["triggerType"] = self.triggerType!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
            self.gmtCreate = dict["gmtCreate"] as! Int64
        }
        if dict.keys.contains("grafanaWorkspaceId") && dict["grafanaWorkspaceId"] != nil {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("lastSendTime") && dict["lastSendTime"] != nil {
            self.lastSendTime = dict["lastSendTime"] as! Int64
        }
        if dict.keys.contains("msg") && dict["msg"] != nil {
            self.msg = dict["msg"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("reportChannelTarget") && dict["reportChannelTarget"] != nil {
            self.reportChannelTarget = dict["reportChannelTarget"] as! String
        }
        if dict.keys.contains("reportChannelType") && dict["reportChannelType"] != nil {
            self.reportChannelType = dict["reportChannelType"] as! String
        }
        if dict.keys.contains("reportStyle") && dict["reportStyle"] != nil {
            self.reportStyle = dict["reportStyle"] as! String
        }
        if dict.keys.contains("reportType") && dict["reportType"] != nil {
            self.reportType = dict["reportType"] as! String
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("triggerDay") && dict["triggerDay"] != nil {
            self.triggerDay = dict["triggerDay"] as! String
        }
        if dict.keys.contains("triggerTime") && dict["triggerTime"] != nil {
            self.triggerTime = dict["triggerTime"] as! String
        }
        if dict.keys.contains("triggerType") && dict["triggerType"] != nil {
            self.triggerType = dict["triggerType"] as! String
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceDashboardSync : Tea.TeaModel {
    public var dashboardTitle: String?

    public var dashboardURL: String?

    public var dashboardUid: String?

    public var folderId: String?

    public var folderTitle: String?

    public var folderURL: String?

    public var folderUid: String?

    public var orgId: String?

    public var orgName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dashboardTitle != nil {
            map["dashboardTitle"] = self.dashboardTitle!
        }
        if self.dashboardURL != nil {
            map["dashboardURL"] = self.dashboardURL!
        }
        if self.dashboardUid != nil {
            map["dashboardUid"] = self.dashboardUid!
        }
        if self.folderId != nil {
            map["folderId"] = self.folderId!
        }
        if self.folderTitle != nil {
            map["folderTitle"] = self.folderTitle!
        }
        if self.folderURL != nil {
            map["folderURL"] = self.folderURL!
        }
        if self.folderUid != nil {
            map["folderUid"] = self.folderUid!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.orgName != nil {
            map["orgName"] = self.orgName!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dashboardTitle") && dict["dashboardTitle"] != nil {
            self.dashboardTitle = dict["dashboardTitle"] as! String
        }
        if dict.keys.contains("dashboardURL") && dict["dashboardURL"] != nil {
            self.dashboardURL = dict["dashboardURL"] as! String
        }
        if dict.keys.contains("dashboardUid") && dict["dashboardUid"] != nil {
            self.dashboardUid = dict["dashboardUid"] as! String
        }
        if dict.keys.contains("folderId") && dict["folderId"] != nil {
            self.folderId = dict["folderId"] as! String
        }
        if dict.keys.contains("folderTitle") && dict["folderTitle"] != nil {
            self.folderTitle = dict["folderTitle"] as! String
        }
        if dict.keys.contains("folderURL") && dict["folderURL"] != nil {
            self.folderURL = dict["folderURL"] as! String
        }
        if dict.keys.contains("folderUid") && dict["folderUid"] != nil {
            self.folderUid = dict["folderUid"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! String
        }
        if dict.keys.contains("orgName") && dict["orgName"] != nil {
            self.orgName = dict["orgName"] as! String
        }
        if dict.keys.contains("type") && dict["type"] != nil {
            self.type = dict["type"] as! String
        }
    }
}

public class GrafanaWorkspaceDataBackup : Tea.TeaModel {
    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var msg: String?

    public var processName: String?

    public var processStatus: String?

    public var subType: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["gmtModified"] = self.gmtModified!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.msg != nil {
            map["msg"] = self.msg!
        }
        if self.processName != nil {
            map["processName"] = self.processName!
        }
        if self.processStatus != nil {
            map["processStatus"] = self.processStatus!
        }
        if self.subType != nil {
            map["subType"] = self.subType!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
            self.gmtCreate = dict["gmtCreate"] as! Int64
        }
        if dict.keys.contains("gmtModified") && dict["gmtModified"] != nil {
            self.gmtModified = dict["gmtModified"] as! Int64
        }
        if dict.keys.contains("grafanaWorkspaceId") && dict["grafanaWorkspaceId"] != nil {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("msg") && dict["msg"] != nil {
            self.msg = dict["msg"] as! String
        }
        if dict.keys.contains("processName") && dict["processName"] != nil {
            self.processName = dict["processName"] as! String
        }
        if dict.keys.contains("processStatus") && dict["processStatus"] != nil {
            self.processStatus = dict["processStatus"] as! String
        }
        if dict.keys.contains("subType") && dict["subType"] != nil {
            self.subType = dict["subType"] as! String
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceIniBackup : Tea.TeaModel {
    public var ext: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var msg: String?

    public var processName: String?

    public var processStatus: String?

    public var subType: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ext != nil {
            map["ext"] = self.ext!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["gmtModified"] = self.gmtModified!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.msg != nil {
            map["msg"] = self.msg!
        }
        if self.processName != nil {
            map["processName"] = self.processName!
        }
        if self.processStatus != nil {
            map["processStatus"] = self.processStatus!
        }
        if self.subType != nil {
            map["subType"] = self.subType!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ext") && dict["ext"] != nil {
            self.ext = dict["ext"] as! String
        }
        if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
            self.gmtCreate = dict["gmtCreate"] as! Int64
        }
        if dict.keys.contains("gmtModified") && dict["gmtModified"] != nil {
            self.gmtModified = dict["gmtModified"] as! Int64
        }
        if dict.keys.contains("grafanaWorkspaceId") && dict["grafanaWorkspaceId"] != nil {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("msg") && dict["msg"] != nil {
            self.msg = dict["msg"] as! String
        }
        if dict.keys.contains("processName") && dict["processName"] != nil {
            self.processName = dict["processName"] as! String
        }
        if dict.keys.contains("processStatus") && dict["processStatus"] != nil {
            self.processStatus = dict["processStatus"] as! String
        }
        if dict.keys.contains("subType") && dict["subType"] != nil {
            self.subType = dict["subType"] as! String
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceIniProperty : Tea.TeaModel {
    public var defaultValue: String?

    public var description_: String?

    public var example: String?

    public var key: String?

    public var secret: Bool?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultValue != nil {
            map["defaultValue"] = self.defaultValue!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.example != nil {
            map["example"] = self.example!
        }
        if self.key != nil {
            map["key"] = self.key!
        }
        if self.secret != nil {
            map["secret"] = self.secret!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("defaultValue") && dict["defaultValue"] != nil {
            self.defaultValue = dict["defaultValue"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("example") && dict["example"] != nil {
            self.example = dict["example"] as! String
        }
        if dict.keys.contains("key") && dict["key"] != nil {
            self.key = dict["key"] as! String
        }
        if dict.keys.contains("secret") && dict["secret"] != nil {
            self.secret = dict["secret"] as! Bool
        }
        if dict.keys.contains("value") && dict["value"] != nil {
            self.value = dict["value"] as! String
        }
    }
}

public class GrafanaWorkspaceIniSection : Tea.TeaModel {
    public var propertys: [GrafanaWorkspaceIniProperty]?

    public var section: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.propertys != nil {
            var tmp : [Any] = []
            for k in self.propertys! {
                tmp.append(k.toMap())
            }
            map["propertys"] = tmp
        }
        if self.section != nil {
            map["section"] = self.section!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("propertys") && dict["propertys"] != nil {
            var tmp : [GrafanaWorkspaceIniProperty] = []
            for v in dict["propertys"] as! [Any] {
                var model = GrafanaWorkspaceIniProperty()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertys = tmp
        }
        if dict.keys.contains("section") && dict["section"] != nil {
            self.section = dict["section"] as! String
        }
    }
}

public class GrafanaWorkspaceIntegration : Tea.TeaModel {
    public var datasourceAmount: Int64?

    public var integrationId: String?

    public var integrationName: String?

    public var previews: [GrafanaWorkspaceIntegrationPreview]?

    public var status: String?

    public var supportRegions: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasourceAmount != nil {
            map["datasourceAmount"] = self.datasourceAmount!
        }
        if self.integrationId != nil {
            map["integrationId"] = self.integrationId!
        }
        if self.integrationName != nil {
            map["integrationName"] = self.integrationName!
        }
        if self.previews != nil {
            var tmp : [Any] = []
            for k in self.previews! {
                tmp.append(k.toMap())
            }
            map["previews"] = tmp
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.supportRegions != nil {
            map["supportRegions"] = self.supportRegions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("datasourceAmount") && dict["datasourceAmount"] != nil {
            self.datasourceAmount = dict["datasourceAmount"] as! Int64
        }
        if dict.keys.contains("integrationId") && dict["integrationId"] != nil {
            self.integrationId = dict["integrationId"] as! String
        }
        if dict.keys.contains("integrationName") && dict["integrationName"] != nil {
            self.integrationName = dict["integrationName"] as! String
        }
        if dict.keys.contains("previews") && dict["previews"] != nil {
            var tmp : [GrafanaWorkspaceIntegrationPreview] = []
            for v in dict["previews"] as! [Any] {
                var model = GrafanaWorkspaceIntegrationPreview()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.previews = tmp
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("supportRegions") && dict["supportRegions"] != nil {
            self.supportRegions = dict["supportRegions"] as! [String]
        }
    }
}

public class GrafanaWorkspaceIntegrationDataSource : Tea.TeaModel {
    public var clusterType: String?

    public var datasourceId: String?

    public var datasourceName: String?

    public var datasourceUrl: String?

    public var description_: String?

    public var exploreUrl: String?

    public var folderUrl: String?

    public var regionId: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["clusterType"] = self.clusterType!
        }
        if self.datasourceId != nil {
            map["datasourceId"] = self.datasourceId!
        }
        if self.datasourceName != nil {
            map["datasourceName"] = self.datasourceName!
        }
        if self.datasourceUrl != nil {
            map["datasourceUrl"] = self.datasourceUrl!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.exploreUrl != nil {
            map["exploreUrl"] = self.exploreUrl!
        }
        if self.folderUrl != nil {
            map["folderUrl"] = self.folderUrl!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clusterType") && dict["clusterType"] != nil {
            self.clusterType = dict["clusterType"] as! String
        }
        if dict.keys.contains("datasourceId") && dict["datasourceId"] != nil {
            self.datasourceId = dict["datasourceId"] as! String
        }
        if dict.keys.contains("datasourceName") && dict["datasourceName"] != nil {
            self.datasourceName = dict["datasourceName"] as! String
        }
        if dict.keys.contains("datasourceUrl") && dict["datasourceUrl"] != nil {
            self.datasourceUrl = dict["datasourceUrl"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("exploreUrl") && dict["exploreUrl"] != nil {
            self.exploreUrl = dict["exploreUrl"] as! String
        }
        if dict.keys.contains("folderUrl") && dict["folderUrl"] != nil {
            self.folderUrl = dict["folderUrl"] as! String
        }
        if dict.keys.contains("regionId") && dict["regionId"] != nil {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("type") && dict["type"] != nil {
            self.type = dict["type"] as! String
        }
    }
}

public class GrafanaWorkspaceIntegrationDetail : Tea.TeaModel {
    public var dataSources: [GrafanaWorkspaceIntegrationDataSource]?

    public var integrationId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSources != nil {
            var tmp : [Any] = []
            for k in self.dataSources! {
                tmp.append(k.toMap())
            }
            map["dataSources"] = tmp
        }
        if self.integrationId != nil {
            map["integrationId"] = self.integrationId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dataSources") && dict["dataSources"] != nil {
            var tmp : [GrafanaWorkspaceIntegrationDataSource] = []
            for v in dict["dataSources"] as! [Any] {
                var model = GrafanaWorkspaceIntegrationDataSource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataSources = tmp
        }
        if dict.keys.contains("integrationId") && dict["integrationId"] != nil {
            self.integrationId = dict["integrationId"] as! String
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
    }
}

public class GrafanaWorkspaceIntegrationPreview : Tea.TeaModel {
    public var id: String?

    public var image: String?

    public var name: String?

    public var thumbnail: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.image != nil {
            map["image"] = self.image!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.thumbnail != nil {
            map["thumbnail"] = self.thumbnail!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("image") && dict["image"] != nil {
            self.image = dict["image"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("thumbnail") && dict["thumbnail"] != nil {
            self.thumbnail = dict["thumbnail"] as! String
        }
    }
}

public class GrafanaWorkspaceNews : Tea.TeaModel {
    public var date: Int64?

    public var description_: String?

    public var image: String?

    public var link: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["date"] = self.date!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.image != nil {
            map["image"] = self.image!
        }
        if self.link != nil {
            map["link"] = self.link!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("date") && dict["date"] != nil {
            self.date = dict["date"] as! Int64
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("image") && dict["image"] != nil {
            self.image = dict["image"] as! String
        }
        if dict.keys.contains("link") && dict["link"] != nil {
            self.link = dict["link"] as! String
        }
        if dict.keys.contains("title") && dict["title"] != nil {
            self.title = dict["title"] as! String
        }
    }
}

public class GrafanaWorkspaceOperateLog : Tea.TeaModel {
    public var date: Double?

    public var detail: String?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var operatorId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["date"] = self.date!
        }
        if self.detail != nil {
            map["detail"] = self.detail!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("date") && dict["date"] != nil {
            self.date = dict["date"] as! Double
        }
        if dict.keys.contains("detail") && dict["detail"] != nil {
            self.detail = dict["detail"] as! String
        }
        if dict.keys.contains("grafanaWorkspaceId") && dict["grafanaWorkspaceId"] != nil {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
    }
}

public class GrafanaWorkspaceOrg : Tea.TeaModel {
    public var id: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
    }
}

public class GrafanaWorkspaceTrans : Tea.TeaModel {
    public var apiUrl: String?

    public var authType: String?

    public var gmtCreate: Double?

    public var gmtModified: Double?

    public var grafanaWorkspaceId: String?

    public var id: Int64?

    public var msg: String?

    public var processStatus: String?

    public var transDetails: [GrafanaWorkspaceTransDetail]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiUrl != nil {
            map["apiUrl"] = self.apiUrl!
        }
        if self.authType != nil {
            map["authType"] = self.authType!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["gmtModified"] = self.gmtModified!
        }
        if self.grafanaWorkspaceId != nil {
            map["grafanaWorkspaceId"] = self.grafanaWorkspaceId!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.msg != nil {
            map["msg"] = self.msg!
        }
        if self.processStatus != nil {
            map["processStatus"] = self.processStatus!
        }
        if self.transDetails != nil {
            var tmp : [Any] = []
            for k in self.transDetails! {
                tmp.append(k.toMap())
            }
            map["transDetails"] = tmp
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("apiUrl") && dict["apiUrl"] != nil {
            self.apiUrl = dict["apiUrl"] as! String
        }
        if dict.keys.contains("authType") && dict["authType"] != nil {
            self.authType = dict["authType"] as! String
        }
        if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
            self.gmtCreate = dict["gmtCreate"] as! Double
        }
        if dict.keys.contains("gmtModified") && dict["gmtModified"] != nil {
            self.gmtModified = dict["gmtModified"] as! Double
        }
        if dict.keys.contains("grafanaWorkspaceId") && dict["grafanaWorkspaceId"] != nil {
            self.grafanaWorkspaceId = dict["grafanaWorkspaceId"] as! String
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("msg") && dict["msg"] != nil {
            self.msg = dict["msg"] as! String
        }
        if dict.keys.contains("processStatus") && dict["processStatus"] != nil {
            self.processStatus = dict["processStatus"] as! String
        }
        if dict.keys.contains("transDetails") && dict["transDetails"] != nil {
            var tmp : [GrafanaWorkspaceTransDetail] = []
            for v in dict["transDetails"] as! [Any] {
                var model = GrafanaWorkspaceTransDetail()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transDetails = tmp
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class GrafanaWorkspaceTransDetail : Tea.TeaModel {
    public var dashboardAmount: Int32?

    public var dataSourceAmount: Int32?

    public var original: Int64?

    public var originalName: String?

    public var target: Int64?

    public var targetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dashboardAmount != nil {
            map["dashboardAmount"] = self.dashboardAmount!
        }
        if self.dataSourceAmount != nil {
            map["dataSourceAmount"] = self.dataSourceAmount!
        }
        if self.original != nil {
            map["original"] = self.original!
        }
        if self.originalName != nil {
            map["originalName"] = self.originalName!
        }
        if self.target != nil {
            map["target"] = self.target!
        }
        if self.targetName != nil {
            map["targetName"] = self.targetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dashboardAmount") && dict["dashboardAmount"] != nil {
            self.dashboardAmount = dict["dashboardAmount"] as! Int32
        }
        if dict.keys.contains("dataSourceAmount") && dict["dataSourceAmount"] != nil {
            self.dataSourceAmount = dict["dataSourceAmount"] as! Int32
        }
        if dict.keys.contains("original") && dict["original"] != nil {
            self.original = dict["original"] as! Int64
        }
        if dict.keys.contains("originalName") && dict["originalName"] != nil {
            self.originalName = dict["originalName"] as! String
        }
        if dict.keys.contains("target") && dict["target"] != nil {
            self.target = dict["target"] as! Int64
        }
        if dict.keys.contains("targetName") && dict["targetName"] != nil {
            self.targetName = dict["targetName"] as! String
        }
    }
}

public class GrafanaWorkspaceUserCert : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
    }
}

public class GrafanaWorkspaceUserOrg : Tea.TeaModel {
    public var orgId: Int64?

    public var orgName: String?

    public var role: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.orgName != nil {
            map["orgName"] = self.orgName!
        }
        if self.role != nil {
            map["role"] = self.role!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("orgName") && dict["orgName"] != nil {
            self.orgName = dict["orgName"] as! String
        }
        if dict.keys.contains("role") && dict["role"] != nil {
            self.role = dict["role"] as! String
        }
    }
}

public class GrafanaWorkspaceVpcConfig : Tea.TeaModel {
    public var fcConfig: String?

    public var id: Int64?

    public var installMsg: String?

    public var installStatus: String?

    public var name: String?

    public var regionId: String?

    public var securityGroupId: String?

    public var userId: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fcConfig != nil {
            map["fcConfig"] = self.fcConfig!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.installMsg != nil {
            map["installMsg"] = self.installMsg!
        }
        if self.installStatus != nil {
            map["installStatus"] = self.installStatus!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["securityGroupId"] = self.securityGroupId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.vSwitchId != nil {
            map["vSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fcConfig") && dict["fcConfig"] != nil {
            self.fcConfig = dict["fcConfig"] as! String
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("installMsg") && dict["installMsg"] != nil {
            self.installMsg = dict["installMsg"] as! String
        }
        if dict.keys.contains("installStatus") && dict["installStatus"] != nil {
            self.installStatus = dict["installStatus"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regionId") && dict["regionId"] != nil {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("securityGroupId") && dict["securityGroupId"] != nil {
            self.securityGroupId = dict["securityGroupId"] as! String
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("vSwitchId") && dict["vSwitchId"] != nil {
            self.vSwitchId = dict["vSwitchId"] as! String
        }
        if dict.keys.contains("vpcId") && dict["vpcId"] != nil {
            self.vpcId = dict["vpcId"] as! String
        }
    }
}

public class GrafanaWorkspaceVpcRegion : Tea.TeaModel {
    public var regionId: String?

    public var regionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.regionName != nil {
            map["regionName"] = self.regionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("regionId") && dict["regionId"] != nil {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("regionName") && dict["regionName"] != nil {
            self.regionName = dict["regionName"] as! String
        }
    }
}

public class GrafanaWorkspaceVpcRegionDetail : Tea.TeaModel {
    public var fcConfig: String?

    public var id: Int64?

    public var installStatus: String?

    public var name: String?

    public var regionId: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var userId: String?

    public var vSwitchId: String?

    public var vSwitchIds: [String]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fcConfig != nil {
            map["fcConfig"] = self.fcConfig!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.installStatus != nil {
            map["installStatus"] = self.installStatus!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["securityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["securityGroupIds"] = self.securityGroupIds!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.vSwitchId != nil {
            map["vSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchIds != nil {
            map["vSwitchIds"] = self.vSwitchIds!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fcConfig") && dict["fcConfig"] != nil {
            self.fcConfig = dict["fcConfig"] as! String
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("installStatus") && dict["installStatus"] != nil {
            self.installStatus = dict["installStatus"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("regionId") && dict["regionId"] != nil {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("securityGroupId") && dict["securityGroupId"] != nil {
            self.securityGroupId = dict["securityGroupId"] as! String
        }
        if dict.keys.contains("securityGroupIds") && dict["securityGroupIds"] != nil {
            self.securityGroupIds = dict["securityGroupIds"] as! [String]
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("vSwitchId") && dict["vSwitchId"] != nil {
            self.vSwitchId = dict["vSwitchId"] as! String
        }
        if dict.keys.contains("vSwitchIds") && dict["vSwitchIds"] != nil {
            self.vSwitchIds = dict["vSwitchIds"] as! [String]
        }
        if dict.keys.contains("vpcId") && dict["vpcId"] != nil {
            self.vpcId = dict["vpcId"] as! String
        }
    }
}

public class QueryDataResponse : Tea.TeaModel {
    public var results: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.results != nil {
            map["results"] = self.results!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("results") && dict["results"] != nil {
            self.results = dict["results"] as! String
        }
    }
}

public class AddAliClusterIdsToPrometheusGlobalViewRequest : Tea.TeaModel {
    public var clusterIds: String?

    public var globalViewClusterId: String?

    public var groupName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") && dict["ClusterIds"] != nil {
            self.clusterIds = dict["ClusterIds"] as! String
        }
        if dict.keys.contains("GlobalViewClusterId") && dict["GlobalViewClusterId"] != nil {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddAliClusterIdsToPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") && dict["Info"] != nil {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") && dict["Msg"] != nil {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: AddAliClusterIdsToPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AddAliClusterIdsToPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAliClusterIdsToPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAliClusterIdsToPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddAliClusterIdsToPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGrafanaRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integration: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integration != nil {
            map["Integration"] = self.integration!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Integration") && dict["Integration"] != nil {
            self.integration = dict["Integration"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddGrafanaResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddGrafanaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGrafanaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddGrafanaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integration: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integration != nil {
            map["Integration"] = self.integration!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Integration") && dict["Integration"] != nil {
            self.integration = dict["Integration"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddIntegrationResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusGlobalViewRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clusters: String?

    public var groupName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [AddPrometheusGlobalViewRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            map["Clusters"] = self.clusters!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") && dict["Clusters"] != nil {
            self.clusters = dict["Clusters"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [AddPrometheusGlobalViewRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AddPrometheusGlobalViewRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class AddPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Info : Tea.TeaModel {
            public var failedInstances: String?

            public var globalViewClusterId: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedInstances != nil {
                    map["FailedInstances"] = self.failedInstances!
                }
                if self.globalViewClusterId != nil {
                    map["GlobalViewClusterId"] = self.globalViewClusterId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedInstances") && dict["FailedInstances"] != nil {
                    self.failedInstances = dict["FailedInstances"] as! String
                }
                if dict.keys.contains("GlobalViewClusterId") && dict["GlobalViewClusterId"] != nil {
                    self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var info: AddPrometheusGlobalViewResponseBody.Data.Info?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.info?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info?.toMap()
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") && dict["Info"] != nil {
                var model = AddPrometheusGlobalViewResponseBody.Data.Info()
                model.fromMap(dict["Info"] as! [String: Any])
                self.info = model
            }
            if dict.keys.contains("Msg") && dict["Msg"] != nil {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: AddPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AddPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusGlobalViewByAliClusterIdsRequest : Tea.TeaModel {
    public var clusterIds: String?

    public var groupName: String?

    public var productCode: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") && dict["ClusterIds"] != nil {
            self.clusterIds = dict["ClusterIds"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddPrometheusGlobalViewByAliClusterIdsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") && dict["Info"] != nil {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") && dict["Msg"] != nil {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: AddPrometheusGlobalViewByAliClusterIdsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AddPrometheusGlobalViewByAliClusterIdsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPrometheusGlobalViewByAliClusterIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusGlobalViewByAliClusterIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddPrometheusGlobalViewByAliClusterIdsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusInstanceRequest : Tea.TeaModel {
    public var name: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddPrometheusInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddPrometheusInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddPrometheusInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integrationType: String?

    public var param: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.param != nil {
            map["Param"] = self.param!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.param = dict["Param"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddPrometheusIntegrationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: Int64?

        public var instanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AddPrometheusIntegrationResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AddPrometheusIntegrationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddPrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrometheusRemoteWriteRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var remoteWriteYaml: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteWriteYaml != nil {
            map["RemoteWriteYaml"] = self.remoteWriteYaml!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteWriteYaml") && dict["RemoteWriteYaml"] != nil {
            self.remoteWriteYaml = dict["RemoteWriteYaml"] as! String
        }
    }
}

public class AddPrometheusRemoteWriteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddPrometheusRemoteWriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrometheusRemoteWriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddPrometheusRemoteWriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddRecordingRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var ruleYaml: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleYaml != nil {
            map["RuleYaml"] = self.ruleYaml!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleYaml") && dict["RuleYaml"] != nil {
            self.ruleYaml = dict["RuleYaml"] as! String
        }
    }
}

public class AddRecordingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddRecordingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRecordingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddRecordingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AppendInstancesToPrometheusGlobalViewRequest : Tea.TeaModel {
    public var clusters: String?

    public var globalViewClusterId: String?

    public var groupName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            map["Clusters"] = self.clusters!
        }
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") && dict["Clusters"] != nil {
            self.clusters = dict["Clusters"] as! String
        }
        if dict.keys.contains("GlobalViewClusterId") && dict["GlobalViewClusterId"] != nil {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AppendInstancesToPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") && dict["Info"] != nil {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") && dict["Msg"] != nil {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: AppendInstancesToPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AppendInstancesToPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AppendInstancesToPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AppendInstancesToPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AppendInstancesToPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyScenarioRequest : Tea.TeaModel {
    public var appId: String?

    public var config: [String: Any]?

    public var name: String?

    public var regionId: String?

    public var scenario: String?

    public var sign: String?

    public var snDump: Bool?

    public var snForce: Bool?

    public var snStat: Bool?

    public var snTransfer: Bool?

    public var updateOption: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        if self.sign != nil {
            map["Sign"] = self.sign!
        }
        if self.snDump != nil {
            map["SnDump"] = self.snDump!
        }
        if self.snForce != nil {
            map["SnForce"] = self.snForce!
        }
        if self.snStat != nil {
            map["SnStat"] = self.snStat!
        }
        if self.snTransfer != nil {
            map["SnTransfer"] = self.snTransfer!
        }
        if self.updateOption != nil {
            map["UpdateOption"] = self.updateOption!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! [String: Any]
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scenario") && dict["Scenario"] != nil {
            self.scenario = dict["Scenario"] as! String
        }
        if dict.keys.contains("Sign") && dict["Sign"] != nil {
            self.sign = dict["Sign"] as! String
        }
        if dict.keys.contains("SnDump") && dict["SnDump"] != nil {
            self.snDump = dict["SnDump"] as! Bool
        }
        if dict.keys.contains("SnForce") && dict["SnForce"] != nil {
            self.snForce = dict["SnForce"] as! Bool
        }
        if dict.keys.contains("SnStat") && dict["SnStat"] != nil {
            self.snStat = dict["SnStat"] as! Bool
        }
        if dict.keys.contains("SnTransfer") && dict["SnTransfer"] != nil {
            self.snTransfer = dict["SnTransfer"] as! Bool
        }
        if dict.keys.contains("UpdateOption") && dict["UpdateOption"] != nil {
            self.updateOption = dict["UpdateOption"] as! Bool
        }
    }
}

public class ApplyScenarioShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var configShrink: String?

    public var name: String?

    public var regionId: String?

    public var scenario: String?

    public var sign: String?

    public var snDump: Bool?

    public var snForce: Bool?

    public var snStat: Bool?

    public var snTransfer: Bool?

    public var updateOption: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.configShrink != nil {
            map["Config"] = self.configShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        if self.sign != nil {
            map["Sign"] = self.sign!
        }
        if self.snDump != nil {
            map["SnDump"] = self.snDump!
        }
        if self.snForce != nil {
            map["SnForce"] = self.snForce!
        }
        if self.snStat != nil {
            map["SnStat"] = self.snStat!
        }
        if self.snTransfer != nil {
            map["SnTransfer"] = self.snTransfer!
        }
        if self.updateOption != nil {
            map["UpdateOption"] = self.updateOption!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.configShrink = dict["Config"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scenario") && dict["Scenario"] != nil {
            self.scenario = dict["Scenario"] as! String
        }
        if dict.keys.contains("Sign") && dict["Sign"] != nil {
            self.sign = dict["Sign"] as! String
        }
        if dict.keys.contains("SnDump") && dict["SnDump"] != nil {
            self.snDump = dict["SnDump"] as! Bool
        }
        if dict.keys.contains("SnForce") && dict["SnForce"] != nil {
            self.snForce = dict["SnForce"] as! Bool
        }
        if dict.keys.contains("SnStat") && dict["SnStat"] != nil {
            self.snStat = dict["SnStat"] as! Bool
        }
        if dict.keys.contains("SnTransfer") && dict["SnTransfer"] != nil {
            self.snTransfer = dict["SnTransfer"] as! Bool
        }
        if dict.keys.contains("UpdateOption") && dict["UpdateOption"] != nil {
            self.updateOption = dict["UpdateOption"] as! Bool
        }
    }
}

public class ApplyScenarioResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! String
        }
    }
}

public class ApplyScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApplyScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindPrometheusGrafanaInstanceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var grafanaInstanceId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.grafanaInstanceId != nil {
            map["GrafanaInstanceId"] = self.grafanaInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("GrafanaInstanceId") && dict["GrafanaInstanceId"] != nil {
            self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class BindPrometheusGrafanaInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindPrometheusGrafanaInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindPrometheusGrafanaInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BindPrometheusGrafanaInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BlockAlarmNotificationRequest : Tea.TeaModel {
    public var alarmId: Int64?

    public var handlerId: Int64?

    public var regionId: String?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmId != nil {
            map["AlarmId"] = self.alarmId!
        }
        if self.handlerId != nil {
            map["HandlerId"] = self.handlerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmId") && dict["AlarmId"] != nil {
            self.alarmId = dict["AlarmId"] as! Int64
        }
        if dict.keys.contains("HandlerId") && dict["HandlerId"] != nil {
            self.handlerId = dict["HandlerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class BlockAlarmNotificationResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BlockAlarmNotificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BlockAlarmNotificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BlockAlarmNotificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeAlarmSeverityRequest : Tea.TeaModel {
    public var alarmId: Int64?

    public var handlerId: Int64?

    public var regionId: String?

    public var severity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmId != nil {
            map["AlarmId"] = self.alarmId!
        }
        if self.handlerId != nil {
            map["HandlerId"] = self.handlerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmId") && dict["AlarmId"] != nil {
            self.alarmId = dict["AlarmId"] as! Int64
        }
        if dict.keys.contains("HandlerId") && dict["HandlerId"] != nil {
            self.handlerId = dict["HandlerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Severity") && dict["Severity"] != nil {
            self.severity = dict["Severity"] as! String
        }
    }
}

public class ChangeAlarmSeverityResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ChangeAlarmSeverityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeAlarmSeverityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeAlarmSeverityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewResourceGroupId") && dict["NewResourceGroupId"] != nil {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var resourceGroupId: String?

        public var resourceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                self.resourceId = dict["ResourceId"] as! String
            }
        }
    }
    public var code: String?

    public var data: ChangeResourceGroupResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ChangeResourceGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckServiceStatusRequest : Tea.TeaModel {
    public var regionId: String?

    public var svcCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.svcCode != nil {
            map["SvcCode"] = self.svcCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SvcCode") && dict["SvcCode"] != nil {
            self.svcCode = dict["SvcCode"] as! String
        }
    }
}

public class CheckServiceStatusResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckServiceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClaimAlarmRequest : Tea.TeaModel {
    public var alarmId: Int64?

    public var handlerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmId != nil {
            map["AlarmId"] = self.alarmId!
        }
        if self.handlerId != nil {
            map["HandlerId"] = self.handlerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmId") && dict["AlarmId"] != nil {
            self.alarmId = dict["AlarmId"] as! Int64
        }
        if dict.keys.contains("HandlerId") && dict["HandlerId"] != nil {
            self.handlerId = dict["HandlerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ClaimAlarmResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ClaimAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClaimAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ClaimAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseAlarmRequest : Tea.TeaModel {
    public var alarmId: Int64?

    public var handlerId: Int64?

    public var regionId: String?

    public var solution: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmId != nil {
            map["AlarmId"] = self.alarmId!
        }
        if self.handlerId != nil {
            map["HandlerId"] = self.handlerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.solution != nil {
            map["Solution"] = self.solution!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmId") && dict["AlarmId"] != nil {
            self.alarmId = dict["AlarmId"] as! Int64
        }
        if dict.keys.contains("HandlerId") && dict["HandlerId"] != nil {
            self.handlerId = dict["HandlerId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Solution") && dict["Solution"] != nil {
            self.solution = dict["Solution"] as! String
        }
    }
}

public class CloseAlarmResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CloseAlarmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseAlarmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CloseAlarmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigAppRequest : Tea.TeaModel {
    public var appIds: String?

    public var enable: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ConfigAppResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfigAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConfigAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAlertContactRequest : Tea.TeaModel {
    public var contactName: String?

    public var dingRobotWebhookUrl: String?

    public var email: String?

    public var phoneNum: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var systemNoc: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.dingRobotWebhookUrl != nil {
            map["DingRobotWebhookUrl"] = self.dingRobotWebhookUrl!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.phoneNum != nil {
            map["PhoneNum"] = self.phoneNum!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.systemNoc != nil {
            map["SystemNoc"] = self.systemNoc!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("DingRobotWebhookUrl") && dict["DingRobotWebhookUrl"] != nil {
            self.dingRobotWebhookUrl = dict["DingRobotWebhookUrl"] as! String
        }
        if dict.keys.contains("Email") && dict["Email"] != nil {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("PhoneNum") && dict["PhoneNum"] != nil {
            self.phoneNum = dict["PhoneNum"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SystemNoc") && dict["SystemNoc"] != nil {
            self.systemNoc = dict["SystemNoc"] as! Bool
        }
    }
}

public class CreateAlertContactResponseBody : Tea.TeaModel {
    public var contactId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAlertContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAlertContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAlertContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAlertContactGroupRequest : Tea.TeaModel {
    public var contactGroupName: String?

    public var contactIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactIds") && dict["ContactIds"] != nil {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateAlertContactGroupResponseBody : Tea.TeaModel {
    public var contactGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") && dict["ContactGroupId"] != nil {
            self.contactGroupId = dict["ContactGroupId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAlertContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAlertContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAlertContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDispatchRuleRequest : Tea.TeaModel {
    public var dispatchRule: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRule != nil {
            map["DispatchRule"] = self.dispatchRule!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRule") && dict["DispatchRule"] != nil {
            self.dispatchRule = dict["DispatchRule"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateDispatchRuleResponseBody : Tea.TeaModel {
    public var dispatchRuleId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRuleId != nil {
            map["DispatchRuleId"] = self.dispatchRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRuleId") && dict["DispatchRuleId"] != nil {
            self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnvCustomJobRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var customJobName: String?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.customJobName != nil {
            map["CustomJobName"] = self.customJobName!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("CustomJobName") && dict["CustomJobName"] != nil {
            self.customJobName = dict["CustomJobName"] as! String
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateEnvCustomJobResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnvCustomJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnvCustomJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEnvCustomJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnvPodMonitorRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateEnvPodMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var matchedMsg: String?

        public var matchedTargetCount: String?

        public var namespace: String?

        public var podMonitorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchedMsg != nil {
                map["MatchedMsg"] = self.matchedMsg!
            }
            if self.matchedTargetCount != nil {
                map["MatchedTargetCount"] = self.matchedTargetCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.podMonitorName != nil {
                map["PodMonitorName"] = self.podMonitorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchedMsg") && dict["MatchedMsg"] != nil {
                self.matchedMsg = dict["MatchedMsg"] as! String
            }
            if dict.keys.contains("MatchedTargetCount") && dict["MatchedTargetCount"] != nil {
                self.matchedTargetCount = dict["MatchedTargetCount"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PodMonitorName") && dict["PodMonitorName"] != nil {
                self.podMonitorName = dict["PodMonitorName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateEnvPodMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateEnvPodMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnvPodMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnvPodMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEnvPodMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnvServiceMonitorRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateEnvServiceMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var matchedMsg: String?

        public var matchedTargetCount: Int32?

        public var namespace: String?

        public var serviceMonitorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchedMsg != nil {
                map["MatchedMsg"] = self.matchedMsg!
            }
            if self.matchedTargetCount != nil {
                map["MatchedTargetCount"] = self.matchedTargetCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.serviceMonitorName != nil {
                map["ServiceMonitorName"] = self.serviceMonitorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchedMsg") && dict["MatchedMsg"] != nil {
                self.matchedMsg = dict["MatchedMsg"] as! String
            }
            if dict.keys.contains("MatchedTargetCount") && dict["MatchedTargetCount"] != nil {
                self.matchedTargetCount = dict["MatchedTargetCount"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServiceMonitorName") && dict["ServiceMonitorName"] != nil {
                self.serviceMonitorName = dict["ServiceMonitorName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateEnvServiceMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateEnvServiceMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnvServiceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnvServiceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEnvServiceMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnvironmentRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aliyunLang: String?

    public var bindResourceId: String?

    public var environmentName: String?

    public var environmentSubType: String?

    public var environmentType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [CreateEnvironmentRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.bindResourceId != nil {
            map["BindResourceId"] = self.bindResourceId!
        }
        if self.environmentName != nil {
            map["EnvironmentName"] = self.environmentName!
        }
        if self.environmentSubType != nil {
            map["EnvironmentSubType"] = self.environmentSubType!
        }
        if self.environmentType != nil {
            map["EnvironmentType"] = self.environmentType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("BindResourceId") && dict["BindResourceId"] != nil {
            self.bindResourceId = dict["BindResourceId"] as! String
        }
        if dict.keys.contains("EnvironmentName") && dict["EnvironmentName"] != nil {
            self.environmentName = dict["EnvironmentName"] as! String
        }
        if dict.keys.contains("EnvironmentSubType") && dict["EnvironmentSubType"] != nil {
            self.environmentSubType = dict["EnvironmentSubType"] as! String
        }
        if dict.keys.contains("EnvironmentType") && dict["EnvironmentType"] != nil {
            self.environmentType = dict["EnvironmentType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [CreateEnvironmentRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateEnvironmentRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateEnvironmentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIntegrationRequest : Tea.TeaModel {
    public var autoRecover: Bool?

    public var description_: String?

    public var integrationName: String?

    public var integrationProductType: String?

    public var recoverTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRecover != nil {
            map["AutoRecover"] = self.autoRecover!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.integrationName != nil {
            map["IntegrationName"] = self.integrationName!
        }
        if self.integrationProductType != nil {
            map["IntegrationProductType"] = self.integrationProductType!
        }
        if self.recoverTime != nil {
            map["RecoverTime"] = self.recoverTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRecover") && dict["AutoRecover"] != nil {
            self.autoRecover = dict["AutoRecover"] as! Bool
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IntegrationName") && dict["IntegrationName"] != nil {
            self.integrationName = dict["IntegrationName"] as! String
        }
        if dict.keys.contains("IntegrationProductType") && dict["IntegrationProductType"] != nil {
            self.integrationProductType = dict["IntegrationProductType"] as! String
        }
        if dict.keys.contains("RecoverTime") && dict["RecoverTime"] != nil {
            self.recoverTime = dict["RecoverTime"] as! Int64
        }
    }
}

public class CreateIntegrationResponseBody : Tea.TeaModel {
    public class Integration : Tea.TeaModel {
        public var autoRecover: Bool?

        public var description_: String?

        public var integrationId: Int64?

        public var integrationName: String?

        public var integrationProductType: String?

        public var recoverTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRecover != nil {
                map["AutoRecover"] = self.autoRecover!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.integrationId != nil {
                map["IntegrationId"] = self.integrationId!
            }
            if self.integrationName != nil {
                map["IntegrationName"] = self.integrationName!
            }
            if self.integrationProductType != nil {
                map["IntegrationProductType"] = self.integrationProductType!
            }
            if self.recoverTime != nil {
                map["RecoverTime"] = self.recoverTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoRecover") && dict["AutoRecover"] != nil {
                self.autoRecover = dict["AutoRecover"] as! Bool
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IntegrationId") && dict["IntegrationId"] != nil {
                self.integrationId = dict["IntegrationId"] as! Int64
            }
            if dict.keys.contains("IntegrationName") && dict["IntegrationName"] != nil {
                self.integrationName = dict["IntegrationName"] as! String
            }
            if dict.keys.contains("IntegrationProductType") && dict["IntegrationProductType"] != nil {
                self.integrationProductType = dict["IntegrationProductType"] as! String
            }
            if dict.keys.contains("RecoverTime") && dict["RecoverTime"] != nil {
                self.recoverTime = dict["RecoverTime"] as! Int64
            }
        }
    }
    public var integration: CreateIntegrationResponseBody.Integration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.integration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.integration != nil {
            map["Integration"] = self.integration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Integration") && dict["Integration"] != nil {
            var model = CreateIntegrationResponseBody.Integration()
            model.fromMap(dict["Integration"] as! [String: Any])
            self.integration = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateAlertRuleRequest : Tea.TeaModel {
    public class MarkTags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertCheckType: String?

    public var alertGroup: Int64?

    public var alertId: Int64?

    public var alertName: String?

    public var alertPiplines: String?

    public var alertRuleContent: String?

    public var alertStatus: String?

    public var alertType: String?

    public var annotations: String?

    public var autoAddNewApplication: Bool?

    public var clusterId: String?

    public var dataConfig: String?

    public var duration: Int64?

    public var filters: String?

    public var labels: String?

    public var level: String?

    public var markTags: [CreateOrUpdateAlertRuleRequest.MarkTags]?

    public var message: String?

    public var metricsKey: String?

    public var metricsType: String?

    public var notice: String?

    public var notifyMode: String?

    public var notifyStrategy: String?

    public var pids: String?

    public var promQL: String?

    public var regionId: String?

    public var tags: [CreateOrUpdateAlertRuleRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertCheckType != nil {
            map["AlertCheckType"] = self.alertCheckType!
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.alertPiplines != nil {
            map["AlertPiplines"] = self.alertPiplines!
        }
        if self.alertRuleContent != nil {
            map["AlertRuleContent"] = self.alertRuleContent!
        }
        if self.alertStatus != nil {
            map["AlertStatus"] = self.alertStatus!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.autoAddNewApplication != nil {
            map["AutoAddNewApplication"] = self.autoAddNewApplication!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dataConfig != nil {
            map["DataConfig"] = self.dataConfig!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.filters != nil {
            map["Filters"] = self.filters!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.markTags != nil {
            var tmp : [Any] = []
            for k in self.markTags! {
                tmp.append(k.toMap())
            }
            map["MarkTags"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.metricsKey != nil {
            map["MetricsKey"] = self.metricsKey!
        }
        if self.metricsType != nil {
            map["MetricsType"] = self.metricsType!
        }
        if self.notice != nil {
            map["Notice"] = self.notice!
        }
        if self.notifyMode != nil {
            map["NotifyMode"] = self.notifyMode!
        }
        if self.notifyStrategy != nil {
            map["NotifyStrategy"] = self.notifyStrategy!
        }
        if self.pids != nil {
            map["Pids"] = self.pids!
        }
        if self.promQL != nil {
            map["PromQL"] = self.promQL!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertCheckType") && dict["AlertCheckType"] != nil {
            self.alertCheckType = dict["AlertCheckType"] as! String
        }
        if dict.keys.contains("AlertGroup") && dict["AlertGroup"] != nil {
            self.alertGroup = dict["AlertGroup"] as! Int64
        }
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("AlertPiplines") && dict["AlertPiplines"] != nil {
            self.alertPiplines = dict["AlertPiplines"] as! String
        }
        if dict.keys.contains("AlertRuleContent") && dict["AlertRuleContent"] != nil {
            self.alertRuleContent = dict["AlertRuleContent"] as! String
        }
        if dict.keys.contains("AlertStatus") && dict["AlertStatus"] != nil {
            self.alertStatus = dict["AlertStatus"] as! String
        }
        if dict.keys.contains("AlertType") && dict["AlertType"] != nil {
            self.alertType = dict["AlertType"] as! String
        }
        if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("AutoAddNewApplication") && dict["AutoAddNewApplication"] != nil {
            self.autoAddNewApplication = dict["AutoAddNewApplication"] as! Bool
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DataConfig") && dict["DataConfig"] != nil {
            self.dataConfig = dict["DataConfig"] as! String
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! Int64
        }
        if dict.keys.contains("Filters") && dict["Filters"] != nil {
            self.filters = dict["Filters"] as! String
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MarkTags") && dict["MarkTags"] != nil {
            var tmp : [CreateOrUpdateAlertRuleRequest.MarkTags] = []
            for v in dict["MarkTags"] as! [Any] {
                var model = CreateOrUpdateAlertRuleRequest.MarkTags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.markTags = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("MetricsKey") && dict["MetricsKey"] != nil {
            self.metricsKey = dict["MetricsKey"] as! String
        }
        if dict.keys.contains("MetricsType") && dict["MetricsType"] != nil {
            self.metricsType = dict["MetricsType"] as! String
        }
        if dict.keys.contains("Notice") && dict["Notice"] != nil {
            self.notice = dict["Notice"] as! String
        }
        if dict.keys.contains("NotifyMode") && dict["NotifyMode"] != nil {
            self.notifyMode = dict["NotifyMode"] as! String
        }
        if dict.keys.contains("NotifyStrategy") && dict["NotifyStrategy"] != nil {
            self.notifyStrategy = dict["NotifyStrategy"] as! String
        }
        if dict.keys.contains("Pids") && dict["Pids"] != nil {
            self.pids = dict["Pids"] as! String
        }
        if dict.keys.contains("PromQL") && dict["PromQL"] != nil {
            self.promQL = dict["PromQL"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [CreateOrUpdateAlertRuleRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateOrUpdateAlertRuleRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateOrUpdateAlertRuleResponseBody : Tea.TeaModel {
    public class AlertRule : Tea.TeaModel {
        public class AlertRuleContent : Tea.TeaModel {
            public class AlertRuleItems : Tea.TeaModel {
                public var aggregate: String?

                public var metricKey: String?

                public var n: Double?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aggregate != nil {
                        map["Aggregate"] = self.aggregate!
                    }
                    if self.metricKey != nil {
                        map["MetricKey"] = self.metricKey!
                    }
                    if self.n != nil {
                        map["N"] = self.n!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Aggregate") && dict["Aggregate"] != nil {
                        self.aggregate = dict["Aggregate"] as! String
                    }
                    if dict.keys.contains("MetricKey") && dict["MetricKey"] != nil {
                        self.metricKey = dict["MetricKey"] as! String
                    }
                    if dict.keys.contains("N") && dict["N"] != nil {
                        self.n = dict["N"] as! Double
                    }
                    if dict.keys.contains("Operator") && dict["Operator"] != nil {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var alertRuleItems: [CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent.AlertRuleItems]?

            public var condition: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertRuleItems != nil {
                    var tmp : [Any] = []
                    for k in self.alertRuleItems! {
                        tmp.append(k.toMap())
                    }
                    map["AlertRuleItems"] = tmp
                }
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertRuleItems") && dict["AlertRuleItems"] != nil {
                    var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent.AlertRuleItems] = []
                    for v in dict["AlertRuleItems"] as! [Any] {
                        var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent.AlertRuleItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alertRuleItems = tmp
                }
                if dict.keys.contains("Condition") && dict["Condition"] != nil {
                    self.condition = dict["Condition"] as! String
                }
            }
        }
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Filters : Tea.TeaModel {
            public class CustomSLSFilters : Tea.TeaModel {
                public var key: String?

                public var opt: String?

                public var show: Bool?

                public var t: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.opt != nil {
                        map["Opt"] = self.opt!
                    }
                    if self.show != nil {
                        map["Show"] = self.show!
                    }
                    if self.t != nil {
                        map["T"] = self.t!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Opt") && dict["Opt"] != nil {
                        self.opt = dict["Opt"] as! String
                    }
                    if dict.keys.contains("Show") && dict["Show"] != nil {
                        self.show = dict["Show"] as! Bool
                    }
                    if dict.keys.contains("T") && dict["T"] != nil {
                        self.t = dict["T"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class DimFilters : Tea.TeaModel {
                public var filterKey: String?

                public var filterOpt: String?

                public var filterValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.filterKey != nil {
                        map["FilterKey"] = self.filterKey!
                    }
                    if self.filterOpt != nil {
                        map["FilterOpt"] = self.filterOpt!
                    }
                    if self.filterValues != nil {
                        map["FilterValues"] = self.filterValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FilterKey") && dict["FilterKey"] != nil {
                        self.filterKey = dict["FilterKey"] as! String
                    }
                    if dict.keys.contains("FilterOpt") && dict["FilterOpt"] != nil {
                        self.filterOpt = dict["FilterOpt"] as! String
                    }
                    if dict.keys.contains("FilterValues") && dict["FilterValues"] != nil {
                        self.filterValues = dict["FilterValues"] as! [String]
                    }
                }
            }
            public var customSLSFilters: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.CustomSLSFilters]?

            public var customSLSGroupByDimensions: [String]?

            public var customSLSWheres: [String]?

            public var dimFilters: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.DimFilters]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customSLSFilters != nil {
                    var tmp : [Any] = []
                    for k in self.customSLSFilters! {
                        tmp.append(k.toMap())
                    }
                    map["CustomSLSFilters"] = tmp
                }
                if self.customSLSGroupByDimensions != nil {
                    map["CustomSLSGroupByDimensions"] = self.customSLSGroupByDimensions!
                }
                if self.customSLSWheres != nil {
                    map["CustomSLSWheres"] = self.customSLSWheres!
                }
                if self.dimFilters != nil {
                    var tmp : [Any] = []
                    for k in self.dimFilters! {
                        tmp.append(k.toMap())
                    }
                    map["DimFilters"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomSLSFilters") && dict["CustomSLSFilters"] != nil {
                    var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.CustomSLSFilters] = []
                    for v in dict["CustomSLSFilters"] as! [Any] {
                        var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.CustomSLSFilters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.customSLSFilters = tmp
                }
                if dict.keys.contains("CustomSLSGroupByDimensions") && dict["CustomSLSGroupByDimensions"] != nil {
                    self.customSLSGroupByDimensions = dict["CustomSLSGroupByDimensions"] as! [String]
                }
                if dict.keys.contains("CustomSLSWheres") && dict["CustomSLSWheres"] != nil {
                    self.customSLSWheres = dict["CustomSLSWheres"] as! [String]
                }
                if dict.keys.contains("DimFilters") && dict["DimFilters"] != nil {
                    var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.DimFilters] = []
                    for v in dict["DimFilters"] as! [Any] {
                        var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters.DimFilters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dimFilters = tmp
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertCheckType: String?

        public var alertGroup: Int64?

        public var alertId: Double?

        public var alertName: String?

        public var alertRuleContent: CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent?

        public var alertStatus: String?

        public var alertType: String?

        public var annotations: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Annotations]?

        public var autoAddNewApplication: Bool?

        public var clusterId: String?

        public var createdTime: Int64?

        public var duration: String?

        public var extend: String?

        public var filters: CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters?

        public var labels: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Labels]?

        public var level: String?

        public var message: String?

        public var metricsType: String?

        public var notifyMode: String?

        public var notifyStrategy: String?

        public var pids: [String]?

        public var promQL: String?

        public var regionId: String?

        public var tags: [CreateOrUpdateAlertRuleResponseBody.AlertRule.Tags]?

        public var updatedTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alertRuleContent?.validate()
            try self.filters?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertCheckType != nil {
                map["AlertCheckType"] = self.alertCheckType!
            }
            if self.alertGroup != nil {
                map["AlertGroup"] = self.alertGroup!
            }
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.alertRuleContent != nil {
                map["AlertRuleContent"] = self.alertRuleContent?.toMap()
            }
            if self.alertStatus != nil {
                map["AlertStatus"] = self.alertStatus!
            }
            if self.alertType != nil {
                map["AlertType"] = self.alertType!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.autoAddNewApplication != nil {
                map["AutoAddNewApplication"] = self.autoAddNewApplication!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.filters != nil {
                map["Filters"] = self.filters?.toMap()
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.metricsType != nil {
                map["MetricsType"] = self.metricsType!
            }
            if self.notifyMode != nil {
                map["NotifyMode"] = self.notifyMode!
            }
            if self.notifyStrategy != nil {
                map["NotifyStrategy"] = self.notifyStrategy!
            }
            if self.pids != nil {
                map["Pids"] = self.pids!
            }
            if self.promQL != nil {
                map["PromQL"] = self.promQL!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertCheckType") && dict["AlertCheckType"] != nil {
                self.alertCheckType = dict["AlertCheckType"] as! String
            }
            if dict.keys.contains("AlertGroup") && dict["AlertGroup"] != nil {
                self.alertGroup = dict["AlertGroup"] as! Int64
            }
            if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
                self.alertId = dict["AlertId"] as! Double
            }
            if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("AlertRuleContent") && dict["AlertRuleContent"] != nil {
                var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.AlertRuleContent()
                model.fromMap(dict["AlertRuleContent"] as! [String: Any])
                self.alertRuleContent = model
            }
            if dict.keys.contains("AlertStatus") && dict["AlertStatus"] != nil {
                self.alertStatus = dict["AlertStatus"] as! String
            }
            if dict.keys.contains("AlertType") && dict["AlertType"] != nil {
                self.alertType = dict["AlertType"] as! String
            }
            if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("AutoAddNewApplication") && dict["AutoAddNewApplication"] != nil {
                self.autoAddNewApplication = dict["AutoAddNewApplication"] as! Bool
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Extend") && dict["Extend"] != nil {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("Filters") && dict["Filters"] != nil {
                var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Filters()
                model.fromMap(dict["Filters"] as! [String: Any])
                self.filters = model
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MetricsType") && dict["MetricsType"] != nil {
                self.metricsType = dict["MetricsType"] as! String
            }
            if dict.keys.contains("NotifyMode") && dict["NotifyMode"] != nil {
                self.notifyMode = dict["NotifyMode"] as! String
            }
            if dict.keys.contains("NotifyStrategy") && dict["NotifyStrategy"] != nil {
                self.notifyStrategy = dict["NotifyStrategy"] as! String
            }
            if dict.keys.contains("Pids") && dict["Pids"] != nil {
                self.pids = dict["Pids"] as! [String]
            }
            if dict.keys.contains("PromQL") && dict["PromQL"] != nil {
                self.promQL = dict["PromQL"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [CreateOrUpdateAlertRuleResponseBody.AlertRule.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = CreateOrUpdateAlertRuleResponseBody.AlertRule.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var alertRule: CreateOrUpdateAlertRuleResponseBody.AlertRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertRule != nil {
            map["AlertRule"] = self.alertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertRule") && dict["AlertRule"] != nil {
            var model = CreateOrUpdateAlertRuleResponseBody.AlertRule()
            model.fromMap(dict["AlertRule"] as! [String: Any])
            self.alertRule = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateContactRequest : Tea.TeaModel {
    public var contactId: Int64?

    public var contactName: String?

    public var dingRobotUrl: String?

    public var email: String?

    public var isEmailVerify: Bool?

    public var phone: String?

    public var reissueSendNotice: Int64?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.dingRobotUrl != nil {
            map["DingRobotUrl"] = self.dingRobotUrl!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.isEmailVerify != nil {
            map["IsEmailVerify"] = self.isEmailVerify!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        if self.reissueSendNotice != nil {
            map["ReissueSendNotice"] = self.reissueSendNotice!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("DingRobotUrl") && dict["DingRobotUrl"] != nil {
            self.dingRobotUrl = dict["DingRobotUrl"] as! String
        }
        if dict.keys.contains("Email") && dict["Email"] != nil {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("IsEmailVerify") && dict["IsEmailVerify"] != nil {
            self.isEmailVerify = dict["IsEmailVerify"] as! Bool
        }
        if dict.keys.contains("Phone") && dict["Phone"] != nil {
            self.phone = dict["Phone"] as! String
        }
        if dict.keys.contains("ReissueSendNotice") && dict["ReissueSendNotice"] != nil {
            self.reissueSendNotice = dict["ReissueSendNotice"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateOrUpdateContactResponseBody : Tea.TeaModel {
    public class AlertContact : Tea.TeaModel {
        public var contactId: Double?

        public var contactName: String?

        public var dingRobotUrl: String?

        public var email: String?

        public var isVerify: Bool?

        public var phone: String?

        public var reissueSendNotice: Int64?

        public var isEmailVerify: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.contactName != nil {
                map["ContactName"] = self.contactName!
            }
            if self.dingRobotUrl != nil {
                map["DingRobotUrl"] = self.dingRobotUrl!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.isVerify != nil {
                map["IsVerify"] = self.isVerify!
            }
            if self.phone != nil {
                map["Phone"] = self.phone!
            }
            if self.reissueSendNotice != nil {
                map["ReissueSendNotice"] = self.reissueSendNotice!
            }
            if self.isEmailVerify != nil {
                map["isEmailVerify"] = self.isEmailVerify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                self.contactId = dict["ContactId"] as! Double
            }
            if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                self.contactName = dict["ContactName"] as! String
            }
            if dict.keys.contains("DingRobotUrl") && dict["DingRobotUrl"] != nil {
                self.dingRobotUrl = dict["DingRobotUrl"] as! String
            }
            if dict.keys.contains("Email") && dict["Email"] != nil {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("IsVerify") && dict["IsVerify"] != nil {
                self.isVerify = dict["IsVerify"] as! Bool
            }
            if dict.keys.contains("Phone") && dict["Phone"] != nil {
                self.phone = dict["Phone"] as! String
            }
            if dict.keys.contains("ReissueSendNotice") && dict["ReissueSendNotice"] != nil {
                self.reissueSendNotice = dict["ReissueSendNotice"] as! Int64
            }
            if dict.keys.contains("isEmailVerify") && dict["isEmailVerify"] != nil {
                self.isEmailVerify = dict["isEmailVerify"] as! Bool
            }
        }
    }
    public var alertContact: CreateOrUpdateContactResponseBody.AlertContact?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertContact?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertContact != nil {
            map["AlertContact"] = self.alertContact?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertContact") && dict["AlertContact"] != nil {
            var model = CreateOrUpdateContactResponseBody.AlertContact()
            model.fromMap(dict["AlertContact"] as! [String: Any])
            self.alertContact = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateContactGroupRequest : Tea.TeaModel {
    public var contactGroupId: Int64?

    public var contactGroupName: String?

    public var contactIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") && dict["ContactGroupId"] != nil {
            self.contactGroupId = dict["ContactGroupId"] as! Int64
        }
        if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactIds") && dict["ContactIds"] != nil {
            self.contactIds = dict["ContactIds"] as! String
        }
    }
}

public class CreateOrUpdateContactGroupResponseBody : Tea.TeaModel {
    public class AlertContactGroup : Tea.TeaModel {
        public var contactGroupId: Double?

        public var contactGroupName: String?

        public var contactIds: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactGroupId != nil {
                map["ContactGroupId"] = self.contactGroupId!
            }
            if self.contactGroupName != nil {
                map["ContactGroupName"] = self.contactGroupName!
            }
            if self.contactIds != nil {
                map["ContactIds"] = self.contactIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactGroupId") && dict["ContactGroupId"] != nil {
                self.contactGroupId = dict["ContactGroupId"] as! Double
            }
            if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
                self.contactGroupName = dict["ContactGroupName"] as! String
            }
            if dict.keys.contains("ContactIds") && dict["ContactIds"] != nil {
                self.contactIds = dict["ContactIds"] as! String
            }
        }
    }
    public var alertContactGroup: CreateOrUpdateContactGroupResponseBody.AlertContactGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertContactGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertContactGroup != nil {
            map["AlertContactGroup"] = self.alertContactGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertContactGroup") && dict["AlertContactGroup"] != nil {
            var model = CreateOrUpdateContactGroupResponseBody.AlertContactGroup()
            model.fromMap(dict["AlertContactGroup"] as! [String: Any])
            self.alertContactGroup = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateEventBridgeIntegrationRequest : Tea.TeaModel {
    public var accessKey: String?

    public var accessSecret: String?

    public var description_: String?

    public var endpoint: String?

    public var eventBusName: String?

    public var eventBusRegionId: String?

    public var id: Int64?

    public var name: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessKey != nil {
            map["AccessKey"] = self.accessKey!
        }
        if self.accessSecret != nil {
            map["AccessSecret"] = self.accessSecret!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.eventBusName != nil {
            map["EventBusName"] = self.eventBusName!
        }
        if self.eventBusRegionId != nil {
            map["EventBusRegionId"] = self.eventBusRegionId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessKey") && dict["AccessKey"] != nil {
            self.accessKey = dict["AccessKey"] as! String
        }
        if dict.keys.contains("AccessSecret") && dict["AccessSecret"] != nil {
            self.accessSecret = dict["AccessSecret"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EventBusName") && dict["EventBusName"] != nil {
            self.eventBusName = dict["EventBusName"] as! String
        }
        if dict.keys.contains("EventBusRegionId") && dict["EventBusRegionId"] != nil {
            self.eventBusRegionId = dict["EventBusRegionId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class CreateOrUpdateEventBridgeIntegrationResponseBody : Tea.TeaModel {
    public class EventBridgeIntegration : Tea.TeaModel {
        public var accessKey: String?

        public var accessSecret: String?

        public var description_: String?

        public var endpoint: String?

        public var eventBusName: String?

        public var eventBusRegionId: String?

        public var id: Int64?

        public var name: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKey != nil {
                map["AccessKey"] = self.accessKey!
            }
            if self.accessSecret != nil {
                map["AccessSecret"] = self.accessSecret!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.eventBusName != nil {
                map["EventBusName"] = self.eventBusName!
            }
            if self.eventBusRegionId != nil {
                map["EventBusRegionId"] = self.eventBusRegionId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKey") && dict["AccessKey"] != nil {
                self.accessKey = dict["AccessKey"] as! String
            }
            if dict.keys.contains("AccessSecret") && dict["AccessSecret"] != nil {
                self.accessSecret = dict["AccessSecret"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("EventBusName") && dict["EventBusName"] != nil {
                self.eventBusName = dict["EventBusName"] as! String
            }
            if dict.keys.contains("EventBusRegionId") && dict["EventBusRegionId"] != nil {
                self.eventBusRegionId = dict["EventBusRegionId"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var eventBridgeIntegration: CreateOrUpdateEventBridgeIntegrationResponseBody.EventBridgeIntegration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventBridgeIntegration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventBridgeIntegration != nil {
            map["EventBridgeIntegration"] = self.eventBridgeIntegration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventBridgeIntegration") && dict["EventBridgeIntegration"] != nil {
            var model = CreateOrUpdateEventBridgeIntegrationResponseBody.EventBridgeIntegration()
            model.fromMap(dict["EventBridgeIntegration"] as! [String: Any])
            self.eventBridgeIntegration = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateEventBridgeIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateEventBridgeIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateEventBridgeIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateIMRobotRequest : Tea.TeaModel {
    public var cardTemplate: String?

    public var dailyNoc: Bool?

    public var dailyNocTime: String?

    public var dingSignKey: String?

    public var enableOutgoing: Bool?

    public var robotAddress: String?

    public var robotId: Int64?

    public var robotName: String?

    public var token: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cardTemplate != nil {
            map["CardTemplate"] = self.cardTemplate!
        }
        if self.dailyNoc != nil {
            map["DailyNoc"] = self.dailyNoc!
        }
        if self.dailyNocTime != nil {
            map["DailyNocTime"] = self.dailyNocTime!
        }
        if self.dingSignKey != nil {
            map["DingSignKey"] = self.dingSignKey!
        }
        if self.enableOutgoing != nil {
            map["EnableOutgoing"] = self.enableOutgoing!
        }
        if self.robotAddress != nil {
            map["RobotAddress"] = self.robotAddress!
        }
        if self.robotId != nil {
            map["RobotId"] = self.robotId!
        }
        if self.robotName != nil {
            map["RobotName"] = self.robotName!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CardTemplate") && dict["CardTemplate"] != nil {
            self.cardTemplate = dict["CardTemplate"] as! String
        }
        if dict.keys.contains("DailyNoc") && dict["DailyNoc"] != nil {
            self.dailyNoc = dict["DailyNoc"] as! Bool
        }
        if dict.keys.contains("DailyNocTime") && dict["DailyNocTime"] != nil {
            self.dailyNocTime = dict["DailyNocTime"] as! String
        }
        if dict.keys.contains("DingSignKey") && dict["DingSignKey"] != nil {
            self.dingSignKey = dict["DingSignKey"] as! String
        }
        if dict.keys.contains("EnableOutgoing") && dict["EnableOutgoing"] != nil {
            self.enableOutgoing = dict["EnableOutgoing"] as! Bool
        }
        if dict.keys.contains("RobotAddress") && dict["RobotAddress"] != nil {
            self.robotAddress = dict["RobotAddress"] as! String
        }
        if dict.keys.contains("RobotId") && dict["RobotId"] != nil {
            self.robotId = dict["RobotId"] as! Int64
        }
        if dict.keys.contains("RobotName") && dict["RobotName"] != nil {
            self.robotName = dict["RobotName"] as! String
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateOrUpdateIMRobotResponseBody : Tea.TeaModel {
    public class AlertRobot : Tea.TeaModel {
        public var cardTemplate: String?

        public var dailyNoc: Bool?

        public var dailyNocTime: String?

        public var enableOutgoing: Bool?

        public var robotAddress: String?

        public var robotId: Double?

        public var robotName: String?

        public var token: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cardTemplate != nil {
                map["CardTemplate"] = self.cardTemplate!
            }
            if self.dailyNoc != nil {
                map["DailyNoc"] = self.dailyNoc!
            }
            if self.dailyNocTime != nil {
                map["DailyNocTime"] = self.dailyNocTime!
            }
            if self.enableOutgoing != nil {
                map["EnableOutgoing"] = self.enableOutgoing!
            }
            if self.robotAddress != nil {
                map["RobotAddress"] = self.robotAddress!
            }
            if self.robotId != nil {
                map["RobotId"] = self.robotId!
            }
            if self.robotName != nil {
                map["RobotName"] = self.robotName!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CardTemplate") && dict["CardTemplate"] != nil {
                self.cardTemplate = dict["CardTemplate"] as! String
            }
            if dict.keys.contains("DailyNoc") && dict["DailyNoc"] != nil {
                self.dailyNoc = dict["DailyNoc"] as! Bool
            }
            if dict.keys.contains("DailyNocTime") && dict["DailyNocTime"] != nil {
                self.dailyNocTime = dict["DailyNocTime"] as! String
            }
            if dict.keys.contains("EnableOutgoing") && dict["EnableOutgoing"] != nil {
                self.enableOutgoing = dict["EnableOutgoing"] as! Bool
            }
            if dict.keys.contains("RobotAddress") && dict["RobotAddress"] != nil {
                self.robotAddress = dict["RobotAddress"] as! String
            }
            if dict.keys.contains("RobotId") && dict["RobotId"] != nil {
                self.robotId = dict["RobotId"] as! Double
            }
            if dict.keys.contains("RobotName") && dict["RobotName"] != nil {
                self.robotName = dict["RobotName"] as! String
            }
            if dict.keys.contains("Token") && dict["Token"] != nil {
                self.token = dict["Token"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var alertRobot: CreateOrUpdateIMRobotResponseBody.AlertRobot?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertRobot?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertRobot != nil {
            map["AlertRobot"] = self.alertRobot?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertRobot") && dict["AlertRobot"] != nil {
            var model = CreateOrUpdateIMRobotResponseBody.AlertRobot()
            model.fromMap(dict["AlertRobot"] as! [String: Any])
            self.alertRobot = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateIMRobotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateIMRobotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateIMRobotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateNotificationPolicyRequest : Tea.TeaModel {
    public var directedMode: Bool?

    public var escalationPolicyId: Int64?

    public var groupRule: String?

    public var id: Int64?

    public var integrationId: Int64?

    public var matchingRules: String?

    public var name: String?

    public var notifyRule: String?

    public var notifyTemplate: String?

    public var regionId: String?

    public var repeat_: Bool?

    public var repeatInterval: Int64?

    public var sendRecoverMessage: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directedMode != nil {
            map["DirectedMode"] = self.directedMode!
        }
        if self.escalationPolicyId != nil {
            map["EscalationPolicyId"] = self.escalationPolicyId!
        }
        if self.groupRule != nil {
            map["GroupRule"] = self.groupRule!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.integrationId != nil {
            map["IntegrationId"] = self.integrationId!
        }
        if self.matchingRules != nil {
            map["MatchingRules"] = self.matchingRules!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyRule != nil {
            map["NotifyRule"] = self.notifyRule!
        }
        if self.notifyTemplate != nil {
            map["NotifyTemplate"] = self.notifyTemplate!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeat_ != nil {
            map["Repeat"] = self.repeat_!
        }
        if self.repeatInterval != nil {
            map["RepeatInterval"] = self.repeatInterval!
        }
        if self.sendRecoverMessage != nil {
            map["SendRecoverMessage"] = self.sendRecoverMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectedMode") && dict["DirectedMode"] != nil {
            self.directedMode = dict["DirectedMode"] as! Bool
        }
        if dict.keys.contains("EscalationPolicyId") && dict["EscalationPolicyId"] != nil {
            self.escalationPolicyId = dict["EscalationPolicyId"] as! Int64
        }
        if dict.keys.contains("GroupRule") && dict["GroupRule"] != nil {
            self.groupRule = dict["GroupRule"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IntegrationId") && dict["IntegrationId"] != nil {
            self.integrationId = dict["IntegrationId"] as! Int64
        }
        if dict.keys.contains("MatchingRules") && dict["MatchingRules"] != nil {
            self.matchingRules = dict["MatchingRules"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyRule") && dict["NotifyRule"] != nil {
            self.notifyRule = dict["NotifyRule"] as! String
        }
        if dict.keys.contains("NotifyTemplate") && dict["NotifyTemplate"] != nil {
            self.notifyTemplate = dict["NotifyTemplate"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Repeat") && dict["Repeat"] != nil {
            self.repeat_ = dict["Repeat"] as! Bool
        }
        if dict.keys.contains("RepeatInterval") && dict["RepeatInterval"] != nil {
            self.repeatInterval = dict["RepeatInterval"] as! Int64
        }
        if dict.keys.contains("SendRecoverMessage") && dict["SendRecoverMessage"] != nil {
            self.sendRecoverMessage = dict["SendRecoverMessage"] as! Bool
        }
    }
}

public class CreateOrUpdateNotificationPolicyResponseBody : Tea.TeaModel {
    public class NotificationPolicy : Tea.TeaModel {
        public class GroupRule : Tea.TeaModel {
            public var groupInterval: Int64?

            public var groupWait: Int64?

            public var groupingFields: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupInterval != nil {
                    map["GroupInterval"] = self.groupInterval!
                }
                if self.groupWait != nil {
                    map["GroupWait"] = self.groupWait!
                }
                if self.groupingFields != nil {
                    map["GroupingFields"] = self.groupingFields!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupInterval") && dict["GroupInterval"] != nil {
                    self.groupInterval = dict["GroupInterval"] as! Int64
                }
                if dict.keys.contains("GroupWait") && dict["GroupWait"] != nil {
                    self.groupWait = dict["GroupWait"] as! Int64
                }
                if dict.keys.contains("GroupingFields") && dict["GroupingFields"] != nil {
                    self.groupingFields = dict["GroupingFields"] as! [String]
                }
            }
        }
        public class MatchingRules : Tea.TeaModel {
            public class MatchingConditions : Tea.TeaModel {
                public var key: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Operator") && dict["Operator"] != nil {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var matchingConditions: [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules.MatchingConditions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.matchingConditions != nil {
                    var tmp : [Any] = []
                    for k in self.matchingConditions! {
                        tmp.append(k.toMap())
                    }
                    map["MatchingConditions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MatchingConditions") && dict["MatchingConditions"] != nil {
                    var tmp : [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules.MatchingConditions] = []
                    for v in dict["MatchingConditions"] as! [Any] {
                        var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules.MatchingConditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.matchingConditions = tmp
                }
            }
        }
        public class NotifyRule : Tea.TeaModel {
            public class NotifyObjects : Tea.TeaModel {
                public var notifyChannels: [String]?

                public var notifyObjectId: Int64?

                public var notifyObjectName: String?

                public var notifyObjectType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.notifyChannels != nil {
                        map["NotifyChannels"] = self.notifyChannels!
                    }
                    if self.notifyObjectId != nil {
                        map["NotifyObjectId"] = self.notifyObjectId!
                    }
                    if self.notifyObjectName != nil {
                        map["NotifyObjectName"] = self.notifyObjectName!
                    }
                    if self.notifyObjectType != nil {
                        map["NotifyObjectType"] = self.notifyObjectType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NotifyChannels") && dict["NotifyChannels"] != nil {
                        self.notifyChannels = dict["NotifyChannels"] as! [String]
                    }
                    if dict.keys.contains("NotifyObjectId") && dict["NotifyObjectId"] != nil {
                        self.notifyObjectId = dict["NotifyObjectId"] as! Int64
                    }
                    if dict.keys.contains("NotifyObjectName") && dict["NotifyObjectName"] != nil {
                        self.notifyObjectName = dict["NotifyObjectName"] as! String
                    }
                    if dict.keys.contains("NotifyObjectType") && dict["NotifyObjectType"] != nil {
                        self.notifyObjectType = dict["NotifyObjectType"] as! String
                    }
                }
            }
            public var notifyChannels: [String]?

            public var notifyEndTime: String?

            public var notifyObjects: [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule.NotifyObjects]?

            public var notifyStartTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notifyChannels != nil {
                    map["NotifyChannels"] = self.notifyChannels!
                }
                if self.notifyEndTime != nil {
                    map["NotifyEndTime"] = self.notifyEndTime!
                }
                if self.notifyObjects != nil {
                    var tmp : [Any] = []
                    for k in self.notifyObjects! {
                        tmp.append(k.toMap())
                    }
                    map["NotifyObjects"] = tmp
                }
                if self.notifyStartTime != nil {
                    map["NotifyStartTime"] = self.notifyStartTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NotifyChannels") && dict["NotifyChannels"] != nil {
                    self.notifyChannels = dict["NotifyChannels"] as! [String]
                }
                if dict.keys.contains("NotifyEndTime") && dict["NotifyEndTime"] != nil {
                    self.notifyEndTime = dict["NotifyEndTime"] as! String
                }
                if dict.keys.contains("NotifyObjects") && dict["NotifyObjects"] != nil {
                    var tmp : [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule.NotifyObjects] = []
                    for v in dict["NotifyObjects"] as! [Any] {
                        var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule.NotifyObjects()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notifyObjects = tmp
                }
                if dict.keys.contains("NotifyStartTime") && dict["NotifyStartTime"] != nil {
                    self.notifyStartTime = dict["NotifyStartTime"] as! String
                }
            }
        }
        public class NotifyTemplate : Tea.TeaModel {
            public var emailContent: String?

            public var emailRecoverContent: String?

            public var emailRecoverTitle: String?

            public var emailTitle: String?

            public var robotContent: String?

            public var smsContent: String?

            public var smsRecoverContent: String?

            public var ttsContent: String?

            public var ttsRecoverContent: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.emailContent != nil {
                    map["EmailContent"] = self.emailContent!
                }
                if self.emailRecoverContent != nil {
                    map["EmailRecoverContent"] = self.emailRecoverContent!
                }
                if self.emailRecoverTitle != nil {
                    map["EmailRecoverTitle"] = self.emailRecoverTitle!
                }
                if self.emailTitle != nil {
                    map["EmailTitle"] = self.emailTitle!
                }
                if self.robotContent != nil {
                    map["RobotContent"] = self.robotContent!
                }
                if self.smsContent != nil {
                    map["SmsContent"] = self.smsContent!
                }
                if self.smsRecoverContent != nil {
                    map["SmsRecoverContent"] = self.smsRecoverContent!
                }
                if self.ttsContent != nil {
                    map["TtsContent"] = self.ttsContent!
                }
                if self.ttsRecoverContent != nil {
                    map["TtsRecoverContent"] = self.ttsRecoverContent!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EmailContent") && dict["EmailContent"] != nil {
                    self.emailContent = dict["EmailContent"] as! String
                }
                if dict.keys.contains("EmailRecoverContent") && dict["EmailRecoverContent"] != nil {
                    self.emailRecoverContent = dict["EmailRecoverContent"] as! String
                }
                if dict.keys.contains("EmailRecoverTitle") && dict["EmailRecoverTitle"] != nil {
                    self.emailRecoverTitle = dict["EmailRecoverTitle"] as! String
                }
                if dict.keys.contains("EmailTitle") && dict["EmailTitle"] != nil {
                    self.emailTitle = dict["EmailTitle"] as! String
                }
                if dict.keys.contains("RobotContent") && dict["RobotContent"] != nil {
                    self.robotContent = dict["RobotContent"] as! String
                }
                if dict.keys.contains("SmsContent") && dict["SmsContent"] != nil {
                    self.smsContent = dict["SmsContent"] as! String
                }
                if dict.keys.contains("SmsRecoverContent") && dict["SmsRecoverContent"] != nil {
                    self.smsRecoverContent = dict["SmsRecoverContent"] as! String
                }
                if dict.keys.contains("TtsContent") && dict["TtsContent"] != nil {
                    self.ttsContent = dict["TtsContent"] as! String
                }
                if dict.keys.contains("TtsRecoverContent") && dict["TtsRecoverContent"] != nil {
                    self.ttsRecoverContent = dict["TtsRecoverContent"] as! String
                }
            }
        }
        public var directedMode: Bool?

        public var escalationPolicyId: Int64?

        public var groupRule: CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.GroupRule?

        public var id: Int64?

        public var integrationId: Int64?

        public var matchingRules: [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules]?

        public var name: String?

        public var notifyRule: CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule?

        public var notifyTemplate: CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyTemplate?

        public var repeat_: Bool?

        public var repeatInterval: Int64?

        public var sendRecoverMessage: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.groupRule?.validate()
            try self.notifyRule?.validate()
            try self.notifyTemplate?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.directedMode != nil {
                map["DirectedMode"] = self.directedMode!
            }
            if self.escalationPolicyId != nil {
                map["EscalationPolicyId"] = self.escalationPolicyId!
            }
            if self.groupRule != nil {
                map["GroupRule"] = self.groupRule?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.integrationId != nil {
                map["IntegrationId"] = self.integrationId!
            }
            if self.matchingRules != nil {
                var tmp : [Any] = []
                for k in self.matchingRules! {
                    tmp.append(k.toMap())
                }
                map["MatchingRules"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyRule != nil {
                map["NotifyRule"] = self.notifyRule?.toMap()
            }
            if self.notifyTemplate != nil {
                map["NotifyTemplate"] = self.notifyTemplate?.toMap()
            }
            if self.repeat_ != nil {
                map["Repeat"] = self.repeat_!
            }
            if self.repeatInterval != nil {
                map["RepeatInterval"] = self.repeatInterval!
            }
            if self.sendRecoverMessage != nil {
                map["SendRecoverMessage"] = self.sendRecoverMessage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DirectedMode") && dict["DirectedMode"] != nil {
                self.directedMode = dict["DirectedMode"] as! Bool
            }
            if dict.keys.contains("EscalationPolicyId") && dict["EscalationPolicyId"] != nil {
                self.escalationPolicyId = dict["EscalationPolicyId"] as! Int64
            }
            if dict.keys.contains("GroupRule") && dict["GroupRule"] != nil {
                var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.GroupRule()
                model.fromMap(dict["GroupRule"] as! [String: Any])
                self.groupRule = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IntegrationId") && dict["IntegrationId"] != nil {
                self.integrationId = dict["IntegrationId"] as! Int64
            }
            if dict.keys.contains("MatchingRules") && dict["MatchingRules"] != nil {
                var tmp : [CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules] = []
                for v in dict["MatchingRules"] as! [Any] {
                    var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.MatchingRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.matchingRules = tmp
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyRule") && dict["NotifyRule"] != nil {
                var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyRule()
                model.fromMap(dict["NotifyRule"] as! [String: Any])
                self.notifyRule = model
            }
            if dict.keys.contains("NotifyTemplate") && dict["NotifyTemplate"] != nil {
                var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy.NotifyTemplate()
                model.fromMap(dict["NotifyTemplate"] as! [String: Any])
                self.notifyTemplate = model
            }
            if dict.keys.contains("Repeat") && dict["Repeat"] != nil {
                self.repeat_ = dict["Repeat"] as! Bool
            }
            if dict.keys.contains("RepeatInterval") && dict["RepeatInterval"] != nil {
                self.repeatInterval = dict["RepeatInterval"] as! Int64
            }
            if dict.keys.contains("SendRecoverMessage") && dict["SendRecoverMessage"] != nil {
                self.sendRecoverMessage = dict["SendRecoverMessage"] as! Bool
            }
        }
    }
    public var notificationPolicy: CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notificationPolicy != nil {
            map["NotificationPolicy"] = self.notificationPolicy?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotificationPolicy") && dict["NotificationPolicy"] != nil {
            var model = CreateOrUpdateNotificationPolicyResponseBody.NotificationPolicy()
            model.fromMap(dict["NotificationPolicy"] as! [String: Any])
            self.notificationPolicy = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateNotificationPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateNotificationPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateNotificationPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateSilencePolicyRequest : Tea.TeaModel {
    public var id: Int64?

    public var matchingRules: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.matchingRules != nil {
            map["MatchingRules"] = self.matchingRules!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MatchingRules") && dict["MatchingRules"] != nil {
            self.matchingRules = dict["MatchingRules"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateOrUpdateSilencePolicyResponseBody : Tea.TeaModel {
    public class SilencePolicy : Tea.TeaModel {
        public class MatchingRules : Tea.TeaModel {
            public class MatchingConditions : Tea.TeaModel {
                public var key: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Operator") && dict["Operator"] != nil {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var matchingConditions: [CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules.MatchingConditions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.matchingConditions != nil {
                    var tmp : [Any] = []
                    for k in self.matchingConditions! {
                        tmp.append(k.toMap())
                    }
                    map["MatchingConditions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MatchingConditions") && dict["MatchingConditions"] != nil {
                    var tmp : [CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules.MatchingConditions] = []
                    for v in dict["MatchingConditions"] as! [Any] {
                        var model = CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules.MatchingConditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.matchingConditions = tmp
                }
            }
        }
        public var id: Int64?

        public var matchingRules: [CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules]?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchingRules != nil {
                var tmp : [Any] = []
                for k in self.matchingRules! {
                    tmp.append(k.toMap())
                }
                map["MatchingRules"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MatchingRules") && dict["MatchingRules"] != nil {
                var tmp : [CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules] = []
                for v in dict["MatchingRules"] as! [Any] {
                    var model = CreateOrUpdateSilencePolicyResponseBody.SilencePolicy.MatchingRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.matchingRules = tmp
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var requestId: String?

    public var silencePolicy: CreateOrUpdateSilencePolicyResponseBody.SilencePolicy?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.silencePolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.silencePolicy != nil {
            map["SilencePolicy"] = self.silencePolicy?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SilencePolicy") && dict["SilencePolicy"] != nil {
            var model = CreateOrUpdateSilencePolicyResponseBody.SilencePolicy()
            model.fromMap(dict["SilencePolicy"] as! [String: Any])
            self.silencePolicy = model
        }
    }
}

public class CreateOrUpdateSilencePolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSilencePolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateSilencePolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateWebhookContactRequest : Tea.TeaModel {
    public var bizHeaders: String?

    public var bizParams: String?

    public var body: String?

    public var method: String?

    public var recoverBody: String?

    public var url: String?

    public var webhookId: Int64?

    public var webhookName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizHeaders != nil {
            map["BizHeaders"] = self.bizHeaders!
        }
        if self.bizParams != nil {
            map["BizParams"] = self.bizParams!
        }
        if self.body != nil {
            map["Body"] = self.body!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.recoverBody != nil {
            map["RecoverBody"] = self.recoverBody!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        if self.webhookId != nil {
            map["WebhookId"] = self.webhookId!
        }
        if self.webhookName != nil {
            map["WebhookName"] = self.webhookName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizHeaders") && dict["BizHeaders"] != nil {
            self.bizHeaders = dict["BizHeaders"] as! String
        }
        if dict.keys.contains("BizParams") && dict["BizParams"] != nil {
            self.bizParams = dict["BizParams"] as! String
        }
        if dict.keys.contains("Body") && dict["Body"] != nil {
            self.body = dict["Body"] as! String
        }
        if dict.keys.contains("Method") && dict["Method"] != nil {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("RecoverBody") && dict["RecoverBody"] != nil {
            self.recoverBody = dict["RecoverBody"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
        if dict.keys.contains("WebhookId") && dict["WebhookId"] != nil {
            self.webhookId = dict["WebhookId"] as! Int64
        }
        if dict.keys.contains("WebhookName") && dict["WebhookName"] != nil {
            self.webhookName = dict["WebhookName"] as! String
        }
    }
}

public class CreateOrUpdateWebhookContactResponseBody : Tea.TeaModel {
    public class WebhookContact : Tea.TeaModel {
        public class Webhook : Tea.TeaModel {
            public var bizHeaders: String?

            public var bizParams: String?

            public var body: String?

            public var method: String?

            public var recoverBody: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizHeaders != nil {
                    map["BizHeaders"] = self.bizHeaders!
                }
                if self.bizParams != nil {
                    map["BizParams"] = self.bizParams!
                }
                if self.body != nil {
                    map["Body"] = self.body!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.recoverBody != nil {
                    map["RecoverBody"] = self.recoverBody!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizHeaders") && dict["BizHeaders"] != nil {
                    self.bizHeaders = dict["BizHeaders"] as! String
                }
                if dict.keys.contains("BizParams") && dict["BizParams"] != nil {
                    self.bizParams = dict["BizParams"] as! String
                }
                if dict.keys.contains("Body") && dict["Body"] != nil {
                    self.body = dict["Body"] as! String
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("RecoverBody") && dict["RecoverBody"] != nil {
                    self.recoverBody = dict["RecoverBody"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var webhook: CreateOrUpdateWebhookContactResponseBody.WebhookContact.Webhook?

        public var webhookId: Double?

        public var webhookName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.webhook?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.webhook != nil {
                map["Webhook"] = self.webhook?.toMap()
            }
            if self.webhookId != nil {
                map["WebhookId"] = self.webhookId!
            }
            if self.webhookName != nil {
                map["WebhookName"] = self.webhookName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                var model = CreateOrUpdateWebhookContactResponseBody.WebhookContact.Webhook()
                model.fromMap(dict["Webhook"] as! [String: Any])
                self.webhook = model
            }
            if dict.keys.contains("WebhookId") && dict["WebhookId"] != nil {
                self.webhookId = dict["WebhookId"] as! Double
            }
            if dict.keys.contains("WebhookName") && dict["WebhookName"] != nil {
                self.webhookName = dict["WebhookName"] as! String
            }
        }
    }
    public var requestId: String?

    public var webhookContact: CreateOrUpdateWebhookContactResponseBody.WebhookContact?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webhookContact?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.webhookContact != nil {
            map["WebhookContact"] = self.webhookContact?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WebhookContact") && dict["WebhookContact"] != nil {
            var model = CreateOrUpdateWebhookContactResponseBody.WebhookContact()
            model.fromMap(dict["WebhookContact"] as! [String: Any])
            self.webhookContact = model
        }
    }
}

public class CreateOrUpdateWebhookContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateWebhookContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateWebhookContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePrometheusAlertRuleRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertName: String?

    public var annotations: String?

    public var clusterId: String?

    public var dispatchRuleId: Int64?

    public var duration: String?

    public var expression: String?

    public var labels: String?

    public var message: String?

    public var notifyType: String?

    public var regionId: String?

    public var tags: [CreatePrometheusAlertRuleRequest.Tags]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dispatchRuleId != nil {
            map["DispatchRuleId"] = self.dispatchRuleId!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.expression != nil {
            map["Expression"] = self.expression!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DispatchRuleId") && dict["DispatchRuleId"] != nil {
            self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("Expression") && dict["Expression"] != nil {
            self.expression = dict["Expression"] as! String
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [CreatePrometheusAlertRuleRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreatePrometheusAlertRuleRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreatePrometheusAlertRuleResponseBody : Tea.TeaModel {
    public class PrometheusAlertRule : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertId: Int64?

        public var alertName: String?

        public var annotations: [CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations]?

        public var clusterId: String?

        public var dispatchRuleId: Int64?

        public var duration: String?

        public var expression: String?

        public var labels: [CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels]?

        public var message: String?

        public var notifyType: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dispatchRuleId != nil {
                map["DispatchRuleId"] = self.dispatchRuleId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
                self.alertId = dict["AlertId"] as! Int64
            }
            if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                var tmp : [CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("DispatchRuleId") && dict["DispatchRuleId"] != nil {
                self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") && dict["Expression"] != nil {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
                self.notifyType = dict["NotifyType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int64?

    public var message: String?

    public var prometheusAlertRule: CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prometheusAlertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.prometheusAlertRule != nil {
            map["PrometheusAlertRule"] = self.prometheusAlertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PrometheusAlertRule") && dict["PrometheusAlertRule"] != nil {
            var model = CreatePrometheusAlertRuleResponseBody.PrometheusAlertRule()
            model.fromMap(dict["PrometheusAlertRule"] as! [String: Any])
            self.prometheusAlertRule = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreatePrometheusAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePrometheusAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreatePrometheusAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePrometheusInstanceRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var allSubClustersSuccess: Bool?

    public var clusterId: String?

    public var clusterName: String?

    public var clusterType: String?

    public var grafanaInstanceId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var securityGroupId: String?

    public var subClustersJson: String?

    public var tags: [CreatePrometheusInstanceRequest.Tags]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allSubClustersSuccess != nil {
            map["AllSubClustersSuccess"] = self.allSubClustersSuccess!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.grafanaInstanceId != nil {
            map["GrafanaInstanceId"] = self.grafanaInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.subClustersJson != nil {
            map["SubClustersJson"] = self.subClustersJson!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllSubClustersSuccess") && dict["AllSubClustersSuccess"] != nil {
            self.allSubClustersSuccess = dict["AllSubClustersSuccess"] as! Bool
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("GrafanaInstanceId") && dict["GrafanaInstanceId"] != nil {
            self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SubClustersJson") && dict["SubClustersJson"] != nil {
            self.subClustersJson = dict["SubClustersJson"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [CreatePrometheusInstanceRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreatePrometheusInstanceRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreatePrometheusInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePrometheusInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePrometheusInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreatePrometheusInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var configYaml: String?

    public var regionId: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreatePrometheusMonitoringResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreatePrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRetcodeAppRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceGroupId: String?

    public var retcodeAppName: String?

    public var retcodeAppType: String?

    public var tags: [CreateRetcodeAppRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.retcodeAppName != nil {
            map["RetcodeAppName"] = self.retcodeAppName!
        }
        if self.retcodeAppType != nil {
            map["RetcodeAppType"] = self.retcodeAppType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RetcodeAppName") && dict["RetcodeAppName"] != nil {
            self.retcodeAppName = dict["RetcodeAppName"] as! String
        }
        if dict.keys.contains("RetcodeAppType") && dict["RetcodeAppType"] != nil {
            self.retcodeAppType = dict["RetcodeAppType"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [CreateRetcodeAppRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateRetcodeAppRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateRetcodeAppResponseBody : Tea.TeaModel {
    public class RetcodeAppDataBean : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var tags: [CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var tmp : [CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
            }
        }
        public var appId: Int64?

        public var pid: String?

        public var resourceGroupId: String?

        public var tags: CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var model = CreateRetcodeAppResponseBody.RetcodeAppDataBean.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
        }
    }
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var retcodeAppDataBean: CreateRetcodeAppResponseBody.RetcodeAppDataBean?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.retcodeAppDataBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retcodeAppDataBean != nil {
            map["RetcodeAppDataBean"] = self.retcodeAppDataBean?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetcodeAppDataBean") && dict["RetcodeAppDataBean"] != nil {
            var model = CreateRetcodeAppResponseBody.RetcodeAppDataBean()
            model.fromMap(dict["RetcodeAppDataBean"] as! [String: Any])
            self.retcodeAppDataBean = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateRetcodeAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRetcodeAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateRetcodeAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSyntheticTaskRequest : Tea.TeaModel {
    public class CommonParam : Tea.TeaModel {
        public class AlertList : Tea.TeaModel {
            public var isCritical: Int64?

            public var name: String?

            public var symbols: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isCritical != nil {
                    map["IsCritical"] = self.isCritical!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.symbols != nil {
                    map["Symbols"] = self.symbols!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IsCritical") && dict["IsCritical"] != nil {
                    self.isCritical = dict["IsCritical"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Symbols") && dict["Symbols"] != nil {
                    self.symbols = dict["Symbols"] as! Int64
                }
            }
        }
        public var alarmFlag: String?

        public var alertList: [CreateSyntheticTaskRequest.CommonParam.AlertList]?

        public var alertNotifierId: String?

        public var alertPolicyId: String?

        public var monitorSamples: Int64?

        public var startExecutionTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmFlag != nil {
                map["AlarmFlag"] = self.alarmFlag!
            }
            if self.alertList != nil {
                var tmp : [Any] = []
                for k in self.alertList! {
                    tmp.append(k.toMap())
                }
                map["AlertList"] = tmp
            }
            if self.alertNotifierId != nil {
                map["AlertNotifierId"] = self.alertNotifierId!
            }
            if self.alertPolicyId != nil {
                map["AlertPolicyId"] = self.alertPolicyId!
            }
            if self.monitorSamples != nil {
                map["MonitorSamples"] = self.monitorSamples!
            }
            if self.startExecutionTime != nil {
                map["StartExecutionTime"] = self.startExecutionTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmFlag") && dict["AlarmFlag"] != nil {
                self.alarmFlag = dict["AlarmFlag"] as! String
            }
            if dict.keys.contains("AlertList") && dict["AlertList"] != nil {
                var tmp : [CreateSyntheticTaskRequest.CommonParam.AlertList] = []
                for v in dict["AlertList"] as! [Any] {
                    var model = CreateSyntheticTaskRequest.CommonParam.AlertList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertList = tmp
            }
            if dict.keys.contains("AlertNotifierId") && dict["AlertNotifierId"] != nil {
                self.alertNotifierId = dict["AlertNotifierId"] as! String
            }
            if dict.keys.contains("AlertPolicyId") && dict["AlertPolicyId"] != nil {
                self.alertPolicyId = dict["AlertPolicyId"] as! String
            }
            if dict.keys.contains("MonitorSamples") && dict["MonitorSamples"] != nil {
                self.monitorSamples = dict["MonitorSamples"] as! Int64
            }
            if dict.keys.contains("StartExecutionTime") && dict["StartExecutionTime"] != nil {
                self.startExecutionTime = dict["StartExecutionTime"] as! Int64
            }
        }
    }
    public class Download : Tea.TeaModel {
        public var connectionTimeout: Double?

        public var downloadCustomHeaderContent: String?

        public var downloadCustomHost: Int64?

        public var downloadCustomHostIp: String?

        public var downloadIgnoreCertificateError: String?

        public var downloadKernel: Int64?

        public var downloadRedirection: Int64?

        public var downloadTransmissionSize: Int64?

        public var monitorTimeout: Int64?

        public var quickProtocol: String?

        public var validateKeywords: String?

        public var verifyWay: Int64?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionTimeout != nil {
                map["ConnectionTimeout"] = self.connectionTimeout!
            }
            if self.downloadCustomHeaderContent != nil {
                map["DownloadCustomHeaderContent"] = self.downloadCustomHeaderContent!
            }
            if self.downloadCustomHost != nil {
                map["DownloadCustomHost"] = self.downloadCustomHost!
            }
            if self.downloadCustomHostIp != nil {
                map["DownloadCustomHostIp"] = self.downloadCustomHostIp!
            }
            if self.downloadIgnoreCertificateError != nil {
                map["DownloadIgnoreCertificateError"] = self.downloadIgnoreCertificateError!
            }
            if self.downloadKernel != nil {
                map["DownloadKernel"] = self.downloadKernel!
            }
            if self.downloadRedirection != nil {
                map["DownloadRedirection"] = self.downloadRedirection!
            }
            if self.downloadTransmissionSize != nil {
                map["DownloadTransmissionSize"] = self.downloadTransmissionSize!
            }
            if self.monitorTimeout != nil {
                map["MonitorTimeout"] = self.monitorTimeout!
            }
            if self.quickProtocol != nil {
                map["QuickProtocol"] = self.quickProtocol!
            }
            if self.validateKeywords != nil {
                map["ValidateKeywords"] = self.validateKeywords!
            }
            if self.verifyWay != nil {
                map["VerifyWay"] = self.verifyWay!
            }
            if self.whiteList != nil {
                map["WhiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectionTimeout") && dict["ConnectionTimeout"] != nil {
                self.connectionTimeout = dict["ConnectionTimeout"] as! Double
            }
            if dict.keys.contains("DownloadCustomHeaderContent") && dict["DownloadCustomHeaderContent"] != nil {
                self.downloadCustomHeaderContent = dict["DownloadCustomHeaderContent"] as! String
            }
            if dict.keys.contains("DownloadCustomHost") && dict["DownloadCustomHost"] != nil {
                self.downloadCustomHost = dict["DownloadCustomHost"] as! Int64
            }
            if dict.keys.contains("DownloadCustomHostIp") && dict["DownloadCustomHostIp"] != nil {
                self.downloadCustomHostIp = dict["DownloadCustomHostIp"] as! String
            }
            if dict.keys.contains("DownloadIgnoreCertificateError") && dict["DownloadIgnoreCertificateError"] != nil {
                self.downloadIgnoreCertificateError = dict["DownloadIgnoreCertificateError"] as! String
            }
            if dict.keys.contains("DownloadKernel") && dict["DownloadKernel"] != nil {
                self.downloadKernel = dict["DownloadKernel"] as! Int64
            }
            if dict.keys.contains("DownloadRedirection") && dict["DownloadRedirection"] != nil {
                self.downloadRedirection = dict["DownloadRedirection"] as! Int64
            }
            if dict.keys.contains("DownloadTransmissionSize") && dict["DownloadTransmissionSize"] != nil {
                self.downloadTransmissionSize = dict["DownloadTransmissionSize"] as! Int64
            }
            if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                self.monitorTimeout = dict["MonitorTimeout"] as! Int64
            }
            if dict.keys.contains("QuickProtocol") && dict["QuickProtocol"] != nil {
                self.quickProtocol = dict["QuickProtocol"] as! String
            }
            if dict.keys.contains("ValidateKeywords") && dict["ValidateKeywords"] != nil {
                self.validateKeywords = dict["ValidateKeywords"] as! String
            }
            if dict.keys.contains("VerifyWay") && dict["VerifyWay"] != nil {
                self.verifyWay = dict["VerifyWay"] as! Int64
            }
            if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                self.whiteList = dict["WhiteList"] as! String
            }
        }
    }
    public class ExtendInterval : Tea.TeaModel {
        public var days: [Int64]?

        public var endHour: Int64?

        public var endMinute: Int64?

        public var endTime: String?

        public var startHour: Int64?

        public var startMinute: Int64?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.days != nil {
                map["Days"] = self.days!
            }
            if self.endHour != nil {
                map["EndHour"] = self.endHour!
            }
            if self.endMinute != nil {
                map["EndMinute"] = self.endMinute!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startHour != nil {
                map["StartHour"] = self.startHour!
            }
            if self.startMinute != nil {
                map["StartMinute"] = self.startMinute!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Days") && dict["Days"] != nil {
                self.days = dict["Days"] as! [Int64]
            }
            if dict.keys.contains("EndHour") && dict["EndHour"] != nil {
                self.endHour = dict["EndHour"] as! Int64
            }
            if dict.keys.contains("EndMinute") && dict["EndMinute"] != nil {
                self.endMinute = dict["EndMinute"] as! Int64
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartHour") && dict["StartHour"] != nil {
                self.startHour = dict["StartHour"] as! Int64
            }
            if dict.keys.contains("StartMinute") && dict["StartMinute"] != nil {
                self.startMinute = dict["StartMinute"] as! Int64
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class MonitorList : Tea.TeaModel {
        public var cityCode: Int64?

        public var monitorType: Int64?

        public var netServiceId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.monitorType != nil {
                map["MonitorType"] = self.monitorType!
            }
            if self.netServiceId != nil {
                map["NetServiceId"] = self.netServiceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
                self.cityCode = dict["CityCode"] as! Int64
            }
            if dict.keys.contains("MonitorType") && dict["MonitorType"] != nil {
                self.monitorType = dict["MonitorType"] as! Int64
            }
            if dict.keys.contains("NetServiceId") && dict["NetServiceId"] != nil {
                self.netServiceId = dict["NetServiceId"] as! Int64
            }
        }
    }
    public class Navigation : Tea.TeaModel {
        public var DNSHijackWhiteList: String?

        public var elementBlacklist: String?

        public var executeActiveX: Int64?

        public var executeApplication: Int64?

        public var executeScript: Int64?

        public var filterInvalidIP: Int64?

        public var flowHijackJumpTimes: Int64?

        public var flowHijackLogo: String?

        public var monitorTimeout: String?

        public var navAutomaticScrolling: String?

        public var navCustomHeader: String?

        public var navCustomHeaderContent: String?

        public var navCustomHost: Int64?

        public var navCustomHostIp: String?

        public var navDisableCache: Int64?

        public var navDisableCompression: String?

        public var navIgnoreCertificateError: Int64?

        public var navRedirection: Int64?

        public var navReturnElement: Int64?

        public var pageTamper: String?

        public var processName: String?

        public var QUICDomain: String?

        public var QUICVersion: Int64?

        public var requestHeader: Int64?

        public var responseHeader: Int64?

        public var slowElementThreshold: Double?

        public var verifyStringBlacklist: String?

        public var verifyStringWhiteList: String?

        public var waitCompletionTime: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DNSHijackWhiteList != nil {
                map["DNSHijackWhiteList"] = self.DNSHijackWhiteList!
            }
            if self.elementBlacklist != nil {
                map["ElementBlacklist"] = self.elementBlacklist!
            }
            if self.executeActiveX != nil {
                map["ExecuteActiveX"] = self.executeActiveX!
            }
            if self.executeApplication != nil {
                map["ExecuteApplication"] = self.executeApplication!
            }
            if self.executeScript != nil {
                map["ExecuteScript"] = self.executeScript!
            }
            if self.filterInvalidIP != nil {
                map["FilterInvalidIP"] = self.filterInvalidIP!
            }
            if self.flowHijackJumpTimes != nil {
                map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
            }
            if self.flowHijackLogo != nil {
                map["FlowHijackLogo"] = self.flowHijackLogo!
            }
            if self.monitorTimeout != nil {
                map["MonitorTimeout"] = self.monitorTimeout!
            }
            if self.navAutomaticScrolling != nil {
                map["NavAutomaticScrolling"] = self.navAutomaticScrolling!
            }
            if self.navCustomHeader != nil {
                map["NavCustomHeader"] = self.navCustomHeader!
            }
            if self.navCustomHeaderContent != nil {
                map["NavCustomHeaderContent"] = self.navCustomHeaderContent!
            }
            if self.navCustomHost != nil {
                map["NavCustomHost"] = self.navCustomHost!
            }
            if self.navCustomHostIp != nil {
                map["NavCustomHostIp"] = self.navCustomHostIp!
            }
            if self.navDisableCache != nil {
                map["NavDisableCache"] = self.navDisableCache!
            }
            if self.navDisableCompression != nil {
                map["NavDisableCompression"] = self.navDisableCompression!
            }
            if self.navIgnoreCertificateError != nil {
                map["NavIgnoreCertificateError"] = self.navIgnoreCertificateError!
            }
            if self.navRedirection != nil {
                map["NavRedirection"] = self.navRedirection!
            }
            if self.navReturnElement != nil {
                map["NavReturnElement"] = self.navReturnElement!
            }
            if self.pageTamper != nil {
                map["PageTamper"] = self.pageTamper!
            }
            if self.processName != nil {
                map["ProcessName"] = self.processName!
            }
            if self.QUICDomain != nil {
                map["QUICDomain"] = self.QUICDomain!
            }
            if self.QUICVersion != nil {
                map["QUICVersion"] = self.QUICVersion!
            }
            if self.requestHeader != nil {
                map["RequestHeader"] = self.requestHeader!
            }
            if self.responseHeader != nil {
                map["ResponseHeader"] = self.responseHeader!
            }
            if self.slowElementThreshold != nil {
                map["SlowElementThreshold"] = self.slowElementThreshold!
            }
            if self.verifyStringBlacklist != nil {
                map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
            }
            if self.verifyStringWhiteList != nil {
                map["VerifyStringWhiteList"] = self.verifyStringWhiteList!
            }
            if self.waitCompletionTime != nil {
                map["WaitCompletionTime"] = self.waitCompletionTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DNSHijackWhiteList") && dict["DNSHijackWhiteList"] != nil {
                self.DNSHijackWhiteList = dict["DNSHijackWhiteList"] as! String
            }
            if dict.keys.contains("ElementBlacklist") && dict["ElementBlacklist"] != nil {
                self.elementBlacklist = dict["ElementBlacklist"] as! String
            }
            if dict.keys.contains("ExecuteActiveX") && dict["ExecuteActiveX"] != nil {
                self.executeActiveX = dict["ExecuteActiveX"] as! Int64
            }
            if dict.keys.contains("ExecuteApplication") && dict["ExecuteApplication"] != nil {
                self.executeApplication = dict["ExecuteApplication"] as! Int64
            }
            if dict.keys.contains("ExecuteScript") && dict["ExecuteScript"] != nil {
                self.executeScript = dict["ExecuteScript"] as! Int64
            }
            if dict.keys.contains("FilterInvalidIP") && dict["FilterInvalidIP"] != nil {
                self.filterInvalidIP = dict["FilterInvalidIP"] as! Int64
            }
            if dict.keys.contains("FlowHijackJumpTimes") && dict["FlowHijackJumpTimes"] != nil {
                self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int64
            }
            if dict.keys.contains("FlowHijackLogo") && dict["FlowHijackLogo"] != nil {
                self.flowHijackLogo = dict["FlowHijackLogo"] as! String
            }
            if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                self.monitorTimeout = dict["MonitorTimeout"] as! String
            }
            if dict.keys.contains("NavAutomaticScrolling") && dict["NavAutomaticScrolling"] != nil {
                self.navAutomaticScrolling = dict["NavAutomaticScrolling"] as! String
            }
            if dict.keys.contains("NavCustomHeader") && dict["NavCustomHeader"] != nil {
                self.navCustomHeader = dict["NavCustomHeader"] as! String
            }
            if dict.keys.contains("NavCustomHeaderContent") && dict["NavCustomHeaderContent"] != nil {
                self.navCustomHeaderContent = dict["NavCustomHeaderContent"] as! String
            }
            if dict.keys.contains("NavCustomHost") && dict["NavCustomHost"] != nil {
                self.navCustomHost = dict["NavCustomHost"] as! Int64
            }
            if dict.keys.contains("NavCustomHostIp") && dict["NavCustomHostIp"] != nil {
                self.navCustomHostIp = dict["NavCustomHostIp"] as! String
            }
            if dict.keys.contains("NavDisableCache") && dict["NavDisableCache"] != nil {
                self.navDisableCache = dict["NavDisableCache"] as! Int64
            }
            if dict.keys.contains("NavDisableCompression") && dict["NavDisableCompression"] != nil {
                self.navDisableCompression = dict["NavDisableCompression"] as! String
            }
            if dict.keys.contains("NavIgnoreCertificateError") && dict["NavIgnoreCertificateError"] != nil {
                self.navIgnoreCertificateError = dict["NavIgnoreCertificateError"] as! Int64
            }
            if dict.keys.contains("NavRedirection") && dict["NavRedirection"] != nil {
                self.navRedirection = dict["NavRedirection"] as! Int64
            }
            if dict.keys.contains("NavReturnElement") && dict["NavReturnElement"] != nil {
                self.navReturnElement = dict["NavReturnElement"] as! Int64
            }
            if dict.keys.contains("PageTamper") && dict["PageTamper"] != nil {
                self.pageTamper = dict["PageTamper"] as! String
            }
            if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
                self.processName = dict["ProcessName"] as! String
            }
            if dict.keys.contains("QUICDomain") && dict["QUICDomain"] != nil {
                self.QUICDomain = dict["QUICDomain"] as! String
            }
            if dict.keys.contains("QUICVersion") && dict["QUICVersion"] != nil {
                self.QUICVersion = dict["QUICVersion"] as! Int64
            }
            if dict.keys.contains("RequestHeader") && dict["RequestHeader"] != nil {
                self.requestHeader = dict["RequestHeader"] as! Int64
            }
            if dict.keys.contains("ResponseHeader") && dict["ResponseHeader"] != nil {
                self.responseHeader = dict["ResponseHeader"] as! Int64
            }
            if dict.keys.contains("SlowElementThreshold") && dict["SlowElementThreshold"] != nil {
                self.slowElementThreshold = dict["SlowElementThreshold"] as! Double
            }
            if dict.keys.contains("VerifyStringBlacklist") && dict["VerifyStringBlacklist"] != nil {
                self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
            }
            if dict.keys.contains("VerifyStringWhiteList") && dict["VerifyStringWhiteList"] != nil {
                self.verifyStringWhiteList = dict["VerifyStringWhiteList"] as! String
            }
            if dict.keys.contains("WaitCompletionTime") && dict["WaitCompletionTime"] != nil {
                self.waitCompletionTime = dict["WaitCompletionTime"] as! Double
            }
        }
    }
    public class Net : Tea.TeaModel {
        public var netDNSNs: String?

        public var netDNSQueryMethod: Int64?

        public var netDNSServer: Int64?

        public var netDNSSwitch: Int64?

        public var netDNSTimeout: Int64?

        public var netDigSwitch: Int64?

        public var netICMPActive: Int64?

        public var netICMPDataCut: Int64?

        public var netICMPInterval: Int64?

        public var netICMPNum: Int64?

        public var netICMPSize: Int64?

        public var netICMPSwitch: Int64?

        public var netICMPTimeout: Int64?

        public var netTraceRouteNum: Int64?

        public var netTraceRouteSwitch: Int64?

        public var netTraceRouteTimeout: Int64?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.netDNSNs != nil {
                map["NetDNSNs"] = self.netDNSNs!
            }
            if self.netDNSQueryMethod != nil {
                map["NetDNSQueryMethod"] = self.netDNSQueryMethod!
            }
            if self.netDNSServer != nil {
                map["NetDNSServer"] = self.netDNSServer!
            }
            if self.netDNSSwitch != nil {
                map["NetDNSSwitch"] = self.netDNSSwitch!
            }
            if self.netDNSTimeout != nil {
                map["NetDNSTimeout"] = self.netDNSTimeout!
            }
            if self.netDigSwitch != nil {
                map["NetDigSwitch"] = self.netDigSwitch!
            }
            if self.netICMPActive != nil {
                map["NetICMPActive"] = self.netICMPActive!
            }
            if self.netICMPDataCut != nil {
                map["NetICMPDataCut"] = self.netICMPDataCut!
            }
            if self.netICMPInterval != nil {
                map["NetICMPInterval"] = self.netICMPInterval!
            }
            if self.netICMPNum != nil {
                map["NetICMPNum"] = self.netICMPNum!
            }
            if self.netICMPSize != nil {
                map["NetICMPSize"] = self.netICMPSize!
            }
            if self.netICMPSwitch != nil {
                map["NetICMPSwitch"] = self.netICMPSwitch!
            }
            if self.netICMPTimeout != nil {
                map["NetICMPTimeout"] = self.netICMPTimeout!
            }
            if self.netTraceRouteNum != nil {
                map["NetTraceRouteNum"] = self.netTraceRouteNum!
            }
            if self.netTraceRouteSwitch != nil {
                map["NetTraceRouteSwitch"] = self.netTraceRouteSwitch!
            }
            if self.netTraceRouteTimeout != nil {
                map["NetTraceRouteTimeout"] = self.netTraceRouteTimeout!
            }
            if self.whiteList != nil {
                map["WhiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetDNSNs") && dict["NetDNSNs"] != nil {
                self.netDNSNs = dict["NetDNSNs"] as! String
            }
            if dict.keys.contains("NetDNSQueryMethod") && dict["NetDNSQueryMethod"] != nil {
                self.netDNSQueryMethod = dict["NetDNSQueryMethod"] as! Int64
            }
            if dict.keys.contains("NetDNSServer") && dict["NetDNSServer"] != nil {
                self.netDNSServer = dict["NetDNSServer"] as! Int64
            }
            if dict.keys.contains("NetDNSSwitch") && dict["NetDNSSwitch"] != nil {
                self.netDNSSwitch = dict["NetDNSSwitch"] as! Int64
            }
            if dict.keys.contains("NetDNSTimeout") && dict["NetDNSTimeout"] != nil {
                self.netDNSTimeout = dict["NetDNSTimeout"] as! Int64
            }
            if dict.keys.contains("NetDigSwitch") && dict["NetDigSwitch"] != nil {
                self.netDigSwitch = dict["NetDigSwitch"] as! Int64
            }
            if dict.keys.contains("NetICMPActive") && dict["NetICMPActive"] != nil {
                self.netICMPActive = dict["NetICMPActive"] as! Int64
            }
            if dict.keys.contains("NetICMPDataCut") && dict["NetICMPDataCut"] != nil {
                self.netICMPDataCut = dict["NetICMPDataCut"] as! Int64
            }
            if dict.keys.contains("NetICMPInterval") && dict["NetICMPInterval"] != nil {
                self.netICMPInterval = dict["NetICMPInterval"] as! Int64
            }
            if dict.keys.contains("NetICMPNum") && dict["NetICMPNum"] != nil {
                self.netICMPNum = dict["NetICMPNum"] as! Int64
            }
            if dict.keys.contains("NetICMPSize") && dict["NetICMPSize"] != nil {
                self.netICMPSize = dict["NetICMPSize"] as! Int64
            }
            if dict.keys.contains("NetICMPSwitch") && dict["NetICMPSwitch"] != nil {
                self.netICMPSwitch = dict["NetICMPSwitch"] as! Int64
            }
            if dict.keys.contains("NetICMPTimeout") && dict["NetICMPTimeout"] != nil {
                self.netICMPTimeout = dict["NetICMPTimeout"] as! Int64
            }
            if dict.keys.contains("NetTraceRouteNum") && dict["NetTraceRouteNum"] != nil {
                self.netTraceRouteNum = dict["NetTraceRouteNum"] as! Int64
            }
            if dict.keys.contains("NetTraceRouteSwitch") && dict["NetTraceRouteSwitch"] != nil {
                self.netTraceRouteSwitch = dict["NetTraceRouteSwitch"] as! Int64
            }
            if dict.keys.contains("NetTraceRouteTimeout") && dict["NetTraceRouteTimeout"] != nil {
                self.netTraceRouteTimeout = dict["NetTraceRouteTimeout"] as! Int64
            }
            if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                self.whiteList = dict["WhiteList"] as! String
            }
        }
    }
    public class Protocol_ : Tea.TeaModel {
        public class RequestContent : Tea.TeaModel {
            public class Body : Tea.TeaModel {
                public class FormData : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class UrlEncoding : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var formData: [CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.FormData]?

                public var language: String?

                public var mode: String?

                public var raw: String?

                public var urlEncoding: [CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.UrlEncoding]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.formData != nil {
                        var tmp : [Any] = []
                        for k in self.formData! {
                            tmp.append(k.toMap())
                        }
                        map["FormData"] = tmp
                    }
                    if self.language != nil {
                        map["Language"] = self.language!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.raw != nil {
                        map["Raw"] = self.raw!
                    }
                    if self.urlEncoding != nil {
                        var tmp : [Any] = []
                        for k in self.urlEncoding! {
                            tmp.append(k.toMap())
                        }
                        map["UrlEncoding"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FormData") && dict["FormData"] != nil {
                        var tmp : [CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.FormData] = []
                        for v in dict["FormData"] as! [Any] {
                            var model = CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.FormData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.formData = tmp
                    }
                    if dict.keys.contains("Language") && dict["Language"] != nil {
                        self.language = dict["Language"] as! String
                    }
                    if dict.keys.contains("Mode") && dict["Mode"] != nil {
                        self.mode = dict["Mode"] as! String
                    }
                    if dict.keys.contains("Raw") && dict["Raw"] != nil {
                        self.raw = dict["Raw"] as! String
                    }
                    if dict.keys.contains("UrlEncoding") && dict["UrlEncoding"] != nil {
                        var tmp : [CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.UrlEncoding] = []
                        for v in dict["UrlEncoding"] as! [Any] {
                            var model = CreateSyntheticTaskRequest.Protocol_.RequestContent.Body.UrlEncoding()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.urlEncoding = tmp
                    }
                }
            }
            public class Header : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var body: CreateSyntheticTaskRequest.Protocol_.RequestContent.Body?

            public var header: [CreateSyntheticTaskRequest.Protocol_.RequestContent.Header]?

            public var method: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.body?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body?.toMap()
                }
                if self.header != nil {
                    var tmp : [Any] = []
                    for k in self.header! {
                        tmp.append(k.toMap())
                    }
                    map["Header"] = tmp
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") && dict["Body"] != nil {
                    var model = CreateSyntheticTaskRequest.Protocol_.RequestContent.Body()
                    model.fromMap(dict["Body"] as! [String: Any])
                    self.body = model
                }
                if dict.keys.contains("Header") && dict["Header"] != nil {
                    var tmp : [CreateSyntheticTaskRequest.Protocol_.RequestContent.Header] = []
                    for v in dict["Header"] as! [Any] {
                        var model = CreateSyntheticTaskRequest.Protocol_.RequestContent.Header()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.header = tmp
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
            }
        }
        public var characterEncoding: Int64?

        public var customHost: Int64?

        public var customHostIp: String?

        public var protocolConnectionTime: Int64?

        public var protocolMonitorTimeout: String?

        public var receivedDataSize: Int64?

        public var requestContent: CreateSyntheticTaskRequest.Protocol_.RequestContent?

        public var verifyContent: String?

        public var verifyWay: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.requestContent?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.characterEncoding != nil {
                map["CharacterEncoding"] = self.characterEncoding!
            }
            if self.customHost != nil {
                map["CustomHost"] = self.customHost!
            }
            if self.customHostIp != nil {
                map["CustomHostIp"] = self.customHostIp!
            }
            if self.protocolConnectionTime != nil {
                map["ProtocolConnectionTime"] = self.protocolConnectionTime!
            }
            if self.protocolMonitorTimeout != nil {
                map["ProtocolMonitorTimeout"] = self.protocolMonitorTimeout!
            }
            if self.receivedDataSize != nil {
                map["ReceivedDataSize"] = self.receivedDataSize!
            }
            if self.requestContent != nil {
                map["RequestContent"] = self.requestContent?.toMap()
            }
            if self.verifyContent != nil {
                map["VerifyContent"] = self.verifyContent!
            }
            if self.verifyWay != nil {
                map["VerifyWay"] = self.verifyWay!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CharacterEncoding") && dict["CharacterEncoding"] != nil {
                self.characterEncoding = dict["CharacterEncoding"] as! Int64
            }
            if dict.keys.contains("CustomHost") && dict["CustomHost"] != nil {
                self.customHost = dict["CustomHost"] as! Int64
            }
            if dict.keys.contains("CustomHostIp") && dict["CustomHostIp"] != nil {
                self.customHostIp = dict["CustomHostIp"] as! String
            }
            if dict.keys.contains("ProtocolConnectionTime") && dict["ProtocolConnectionTime"] != nil {
                self.protocolConnectionTime = dict["ProtocolConnectionTime"] as! Int64
            }
            if dict.keys.contains("ProtocolMonitorTimeout") && dict["ProtocolMonitorTimeout"] != nil {
                self.protocolMonitorTimeout = dict["ProtocolMonitorTimeout"] as! String
            }
            if dict.keys.contains("ReceivedDataSize") && dict["ReceivedDataSize"] != nil {
                self.receivedDataSize = dict["ReceivedDataSize"] as! Int64
            }
            if dict.keys.contains("RequestContent") && dict["RequestContent"] != nil {
                var model = CreateSyntheticTaskRequest.Protocol_.RequestContent()
                model.fromMap(dict["RequestContent"] as! [String: Any])
                self.requestContent = model
            }
            if dict.keys.contains("VerifyContent") && dict["VerifyContent"] != nil {
                self.verifyContent = dict["VerifyContent"] as! String
            }
            if dict.keys.contains("VerifyWay") && dict["VerifyWay"] != nil {
                self.verifyWay = dict["VerifyWay"] as! Int64
            }
        }
    }
    public var commonParam: CreateSyntheticTaskRequest.CommonParam?

    public var download: CreateSyntheticTaskRequest.Download?

    public var extendInterval: CreateSyntheticTaskRequest.ExtendInterval?

    public var intervalTime: String?

    public var intervalType: String?

    public var ipType: Int64?

    public var monitorList: [CreateSyntheticTaskRequest.MonitorList]?

    public var navigation: CreateSyntheticTaskRequest.Navigation?

    public var net: CreateSyntheticTaskRequest.Net?

    public var protocol_: CreateSyntheticTaskRequest.Protocol_?

    public var regionId: String?

    public var taskName: String?

    public var taskType: Int64?

    public var updateTask: Bool?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonParam?.validate()
        try self.download?.validate()
        try self.extendInterval?.validate()
        try self.navigation?.validate()
        try self.net?.validate()
        try self.protocol_?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonParam != nil {
            map["CommonParam"] = self.commonParam?.toMap()
        }
        if self.download != nil {
            map["Download"] = self.download?.toMap()
        }
        if self.extendInterval != nil {
            map["ExtendInterval"] = self.extendInterval?.toMap()
        }
        if self.intervalTime != nil {
            map["IntervalTime"] = self.intervalTime!
        }
        if self.intervalType != nil {
            map["IntervalType"] = self.intervalType!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.monitorList != nil {
            var tmp : [Any] = []
            for k in self.monitorList! {
                tmp.append(k.toMap())
            }
            map["MonitorList"] = tmp
        }
        if self.navigation != nil {
            map["Navigation"] = self.navigation?.toMap()
        }
        if self.net != nil {
            map["Net"] = self.net?.toMap()
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.updateTask != nil {
            map["UpdateTask"] = self.updateTask!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommonParam") && dict["CommonParam"] != nil {
            var model = CreateSyntheticTaskRequest.CommonParam()
            model.fromMap(dict["CommonParam"] as! [String: Any])
            self.commonParam = model
        }
        if dict.keys.contains("Download") && dict["Download"] != nil {
            var model = CreateSyntheticTaskRequest.Download()
            model.fromMap(dict["Download"] as! [String: Any])
            self.download = model
        }
        if dict.keys.contains("ExtendInterval") && dict["ExtendInterval"] != nil {
            var model = CreateSyntheticTaskRequest.ExtendInterval()
            model.fromMap(dict["ExtendInterval"] as! [String: Any])
            self.extendInterval = model
        }
        if dict.keys.contains("IntervalTime") && dict["IntervalTime"] != nil {
            self.intervalTime = dict["IntervalTime"] as! String
        }
        if dict.keys.contains("IntervalType") && dict["IntervalType"] != nil {
            self.intervalType = dict["IntervalType"] as! String
        }
        if dict.keys.contains("IpType") && dict["IpType"] != nil {
            self.ipType = dict["IpType"] as! Int64
        }
        if dict.keys.contains("MonitorList") && dict["MonitorList"] != nil {
            var tmp : [CreateSyntheticTaskRequest.MonitorList] = []
            for v in dict["MonitorList"] as! [Any] {
                var model = CreateSyntheticTaskRequest.MonitorList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.monitorList = tmp
        }
        if dict.keys.contains("Navigation") && dict["Navigation"] != nil {
            var model = CreateSyntheticTaskRequest.Navigation()
            model.fromMap(dict["Navigation"] as! [String: Any])
            self.navigation = model
        }
        if dict.keys.contains("Net") && dict["Net"] != nil {
            var model = CreateSyntheticTaskRequest.Net()
            model.fromMap(dict["Net"] as! [String: Any])
            self.net = model
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            var model = CreateSyntheticTaskRequest.Protocol_()
            model.fromMap(dict["Protocol"] as! [String: Any])
            self.protocol_ = model
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! Int64
        }
        if dict.keys.contains("UpdateTask") && dict["UpdateTask"] != nil {
            self.updateTask = dict["UpdateTask"] as! Bool
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class CreateSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var commonParamShrink: String?

    public var downloadShrink: String?

    public var extendIntervalShrink: String?

    public var intervalTime: String?

    public var intervalType: String?

    public var ipType: Int64?

    public var monitorListShrink: String?

    public var navigationShrink: String?

    public var netShrink: String?

    public var protocolShrink: String?

    public var regionId: String?

    public var taskName: String?

    public var taskType: Int64?

    public var updateTask: Bool?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonParamShrink != nil {
            map["CommonParam"] = self.commonParamShrink!
        }
        if self.downloadShrink != nil {
            map["Download"] = self.downloadShrink!
        }
        if self.extendIntervalShrink != nil {
            map["ExtendInterval"] = self.extendIntervalShrink!
        }
        if self.intervalTime != nil {
            map["IntervalTime"] = self.intervalTime!
        }
        if self.intervalType != nil {
            map["IntervalType"] = self.intervalType!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.monitorListShrink != nil {
            map["MonitorList"] = self.monitorListShrink!
        }
        if self.navigationShrink != nil {
            map["Navigation"] = self.navigationShrink!
        }
        if self.netShrink != nil {
            map["Net"] = self.netShrink!
        }
        if self.protocolShrink != nil {
            map["Protocol"] = self.protocolShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.updateTask != nil {
            map["UpdateTask"] = self.updateTask!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommonParam") && dict["CommonParam"] != nil {
            self.commonParamShrink = dict["CommonParam"] as! String
        }
        if dict.keys.contains("Download") && dict["Download"] != nil {
            self.downloadShrink = dict["Download"] as! String
        }
        if dict.keys.contains("ExtendInterval") && dict["ExtendInterval"] != nil {
            self.extendIntervalShrink = dict["ExtendInterval"] as! String
        }
        if dict.keys.contains("IntervalTime") && dict["IntervalTime"] != nil {
            self.intervalTime = dict["IntervalTime"] as! String
        }
        if dict.keys.contains("IntervalType") && dict["IntervalType"] != nil {
            self.intervalType = dict["IntervalType"] as! String
        }
        if dict.keys.contains("IpType") && dict["IpType"] != nil {
            self.ipType = dict["IpType"] as! Int64
        }
        if dict.keys.contains("MonitorList") && dict["MonitorList"] != nil {
            self.monitorListShrink = dict["MonitorList"] as! String
        }
        if dict.keys.contains("Navigation") && dict["Navigation"] != nil {
            self.navigationShrink = dict["Navigation"] as! String
        }
        if dict.keys.contains("Net") && dict["Net"] != nil {
            self.netShrink = dict["Net"] as! String
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocolShrink = dict["Protocol"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! Int64
        }
        if dict.keys.contains("UpdateTask") && dict["UpdateTask"] != nil {
            self.updateTask = dict["UpdateTask"] as! Bool
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class CreateSyntheticTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: CreateSyntheticTaskResponseBody.Data?

    public var msg: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateSyntheticTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Msg") && dict["Msg"] != nil {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTimingSyntheticTaskRequest : Tea.TeaModel {
    public class AvailableAssertions : Tea.TeaModel {
        public var expect: String?

        public var operator_: String?

        public var target: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expect != nil {
                map["Expect"] = self.expect!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Expect") && dict["Expect"] != nil {
                self.expect = dict["Expect"] as! String
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class CommonSetting : Tea.TeaModel {
        public class CustomHost : Tea.TeaModel {
            public class Hosts : Tea.TeaModel {
                public var domain: String?

                public var ipType: Int32?

                public var ips: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.domain != nil {
                        map["Domain"] = self.domain!
                    }
                    if self.ipType != nil {
                        map["IpType"] = self.ipType!
                    }
                    if self.ips != nil {
                        map["Ips"] = self.ips!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Domain") && dict["Domain"] != nil {
                        self.domain = dict["Domain"] as! String
                    }
                    if dict.keys.contains("IpType") && dict["IpType"] != nil {
                        self.ipType = dict["IpType"] as! Int32
                    }
                    if dict.keys.contains("Ips") && dict["Ips"] != nil {
                        self.ips = dict["Ips"] as! [String]
                    }
                }
            }
            public var hosts: [CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts]?

            public var selectType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hosts != nil {
                    var tmp : [Any] = []
                    for k in self.hosts! {
                        tmp.append(k.toMap())
                    }
                    map["Hosts"] = tmp
                }
                if self.selectType != nil {
                    map["SelectType"] = self.selectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Hosts") && dict["Hosts"] != nil {
                    var tmp : [CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts] = []
                    for v in dict["Hosts"] as! [Any] {
                        var model = CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.hosts = tmp
                }
                if dict.keys.contains("SelectType") && dict["SelectType"] != nil {
                    self.selectType = dict["SelectType"] as! Int32
                }
            }
        }
        public var customHost: CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost?

        public var ipType: Int32?

        public var isOpenTrace: Bool?

        public var monitorSamples: Int32?

        public var traceClientType: Int32?

        public var xtraceRegion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customHost?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customHost != nil {
                map["CustomHost"] = self.customHost?.toMap()
            }
            if self.ipType != nil {
                map["IpType"] = self.ipType!
            }
            if self.isOpenTrace != nil {
                map["IsOpenTrace"] = self.isOpenTrace!
            }
            if self.monitorSamples != nil {
                map["MonitorSamples"] = self.monitorSamples!
            }
            if self.traceClientType != nil {
                map["TraceClientType"] = self.traceClientType!
            }
            if self.xtraceRegion != nil {
                map["XtraceRegion"] = self.xtraceRegion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomHost") && dict["CustomHost"] != nil {
                var model = CreateTimingSyntheticTaskRequest.CommonSetting.CustomHost()
                model.fromMap(dict["CustomHost"] as! [String: Any])
                self.customHost = model
            }
            if dict.keys.contains("IpType") && dict["IpType"] != nil {
                self.ipType = dict["IpType"] as! Int32
            }
            if dict.keys.contains("IsOpenTrace") && dict["IsOpenTrace"] != nil {
                self.isOpenTrace = dict["IsOpenTrace"] as! Bool
            }
            if dict.keys.contains("MonitorSamples") && dict["MonitorSamples"] != nil {
                self.monitorSamples = dict["MonitorSamples"] as! Int32
            }
            if dict.keys.contains("TraceClientType") && dict["TraceClientType"] != nil {
                self.traceClientType = dict["TraceClientType"] as! Int32
            }
            if dict.keys.contains("XtraceRegion") && dict["XtraceRegion"] != nil {
                self.xtraceRegion = dict["XtraceRegion"] as! String
            }
        }
    }
    public class CustomPeriod : Tea.TeaModel {
        public var endHour: Int32?

        public var startHour: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endHour != nil {
                map["EndHour"] = self.endHour!
            }
            if self.startHour != nil {
                map["StartHour"] = self.startHour!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndHour") && dict["EndHour"] != nil {
                self.endHour = dict["EndHour"] as! Int32
            }
            if dict.keys.contains("StartHour") && dict["StartHour"] != nil {
                self.startHour = dict["StartHour"] as! Int32
            }
        }
    }
    public class MonitorConf : Tea.TeaModel {
        public class ApiHTTP : Tea.TeaModel {
            public class RequestBody : Tea.TeaModel {
                public var content: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var connectTimeout: Int64?

            public var method: String?

            public var requestBody: CreateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP.RequestBody?

            public var requestHeaders: [String: String]?

            public var targetUrl: String?

            public var timeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.requestBody?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectTimeout != nil {
                    map["ConnectTimeout"] = self.connectTimeout!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.requestBody != nil {
                    map["RequestBody"] = self.requestBody?.toMap()
                }
                if self.requestHeaders != nil {
                    map["RequestHeaders"] = self.requestHeaders!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectTimeout") && dict["ConnectTimeout"] != nil {
                    self.connectTimeout = dict["ConnectTimeout"] as! Int64
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("RequestBody") && dict["RequestBody"] != nil {
                    var model = CreateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP.RequestBody()
                    model.fromMap(dict["RequestBody"] as! [String: Any])
                    self.requestBody = model
                }
                if dict.keys.contains("RequestHeaders") && dict["RequestHeaders"] != nil {
                    self.requestHeaders = dict["RequestHeaders"] as! [String: String]
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! Int64
                }
            }
        }
        public class FileDownload : Tea.TeaModel {
            public var connectionTimeout: Int64?

            public var customHeaderContent: [String: String]?

            public var downloadKernel: Int32?

            public var ignoreCertificateAuthError: Int32?

            public var ignoreCertificateCanceledError: Int32?

            public var ignoreCertificateOutOfDateError: Int32?

            public var ignoreCertificateStatusError: Int32?

            public var ignoreCertificateUntrustworthyError: Int32?

            public var ignoreCertificateUsingError: Int32?

            public var ignoreInvalidHostError: Int32?

            public var monitorTimeout: Int64?

            public var quickProtocol: Int32?

            public var redirection: Int32?

            public var targetUrl: String?

            public var transmissionSize: Int64?

            public var validateKeywords: String?

            public var verifyWay: Int32?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectionTimeout != nil {
                    map["ConnectionTimeout"] = self.connectionTimeout!
                }
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.downloadKernel != nil {
                    map["DownloadKernel"] = self.downloadKernel!
                }
                if self.ignoreCertificateAuthError != nil {
                    map["IgnoreCertificateAuthError"] = self.ignoreCertificateAuthError!
                }
                if self.ignoreCertificateCanceledError != nil {
                    map["IgnoreCertificateCanceledError"] = self.ignoreCertificateCanceledError!
                }
                if self.ignoreCertificateOutOfDateError != nil {
                    map["IgnoreCertificateOutOfDateError"] = self.ignoreCertificateOutOfDateError!
                }
                if self.ignoreCertificateStatusError != nil {
                    map["IgnoreCertificateStatusError"] = self.ignoreCertificateStatusError!
                }
                if self.ignoreCertificateUntrustworthyError != nil {
                    map["IgnoreCertificateUntrustworthyError"] = self.ignoreCertificateUntrustworthyError!
                }
                if self.ignoreCertificateUsingError != nil {
                    map["IgnoreCertificateUsingError"] = self.ignoreCertificateUsingError!
                }
                if self.ignoreInvalidHostError != nil {
                    map["IgnoreInvalidHostError"] = self.ignoreInvalidHostError!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.quickProtocol != nil {
                    map["QuickProtocol"] = self.quickProtocol!
                }
                if self.redirection != nil {
                    map["Redirection"] = self.redirection!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.transmissionSize != nil {
                    map["TransmissionSize"] = self.transmissionSize!
                }
                if self.validateKeywords != nil {
                    map["ValidateKeywords"] = self.validateKeywords!
                }
                if self.verifyWay != nil {
                    map["VerifyWay"] = self.verifyWay!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectionTimeout") && dict["ConnectionTimeout"] != nil {
                    self.connectionTimeout = dict["ConnectionTimeout"] as! Int64
                }
                if dict.keys.contains("CustomHeaderContent") && dict["CustomHeaderContent"] != nil {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("DownloadKernel") && dict["DownloadKernel"] != nil {
                    self.downloadKernel = dict["DownloadKernel"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateAuthError") && dict["IgnoreCertificateAuthError"] != nil {
                    self.ignoreCertificateAuthError = dict["IgnoreCertificateAuthError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateCanceledError") && dict["IgnoreCertificateCanceledError"] != nil {
                    self.ignoreCertificateCanceledError = dict["IgnoreCertificateCanceledError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateOutOfDateError") && dict["IgnoreCertificateOutOfDateError"] != nil {
                    self.ignoreCertificateOutOfDateError = dict["IgnoreCertificateOutOfDateError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateStatusError") && dict["IgnoreCertificateStatusError"] != nil {
                    self.ignoreCertificateStatusError = dict["IgnoreCertificateStatusError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateUntrustworthyError") && dict["IgnoreCertificateUntrustworthyError"] != nil {
                    self.ignoreCertificateUntrustworthyError = dict["IgnoreCertificateUntrustworthyError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateUsingError") && dict["IgnoreCertificateUsingError"] != nil {
                    self.ignoreCertificateUsingError = dict["IgnoreCertificateUsingError"] as! Int32
                }
                if dict.keys.contains("IgnoreInvalidHostError") && dict["IgnoreInvalidHostError"] != nil {
                    self.ignoreInvalidHostError = dict["IgnoreInvalidHostError"] as! Int32
                }
                if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("QuickProtocol") && dict["QuickProtocol"] != nil {
                    self.quickProtocol = dict["QuickProtocol"] as! Int32
                }
                if dict.keys.contains("Redirection") && dict["Redirection"] != nil {
                    self.redirection = dict["Redirection"] as! Int32
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("TransmissionSize") && dict["TransmissionSize"] != nil {
                    self.transmissionSize = dict["TransmissionSize"] as! Int64
                }
                if dict.keys.contains("ValidateKeywords") && dict["ValidateKeywords"] != nil {
                    self.validateKeywords = dict["ValidateKeywords"] as! String
                }
                if dict.keys.contains("VerifyWay") && dict["VerifyWay"] != nil {
                    self.verifyWay = dict["VerifyWay"] as! Int32
                }
                if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class NetDNS : Tea.TeaModel {
            public var dnsServerIpType: Int32?

            public var nsServer: String?

            public var queryMethod: Int32?

            public var targetUrl: String?

            public var timeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dnsServerIpType != nil {
                    map["DnsServerIpType"] = self.dnsServerIpType!
                }
                if self.nsServer != nil {
                    map["NsServer"] = self.nsServer!
                }
                if self.queryMethod != nil {
                    map["QueryMethod"] = self.queryMethod!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DnsServerIpType") && dict["DnsServerIpType"] != nil {
                    self.dnsServerIpType = dict["DnsServerIpType"] as! Int32
                }
                if dict.keys.contains("NsServer") && dict["NsServer"] != nil {
                    self.nsServer = dict["NsServer"] as! String
                }
                if dict.keys.contains("QueryMethod") && dict["QueryMethod"] != nil {
                    self.queryMethod = dict["QueryMethod"] as! Int32
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! Int64
                }
            }
        }
        public class NetICMP : Tea.TeaModel {
            public var interval: Int64?

            public var packageNum: Int32?

            public var packageSize: Int32?

            public var splitPackage: Bool?

            public var targetUrl: String?

            public var timeout: Int64?

            public var tracertEnable: Bool?

            public var tracertNumMax: Int32?

            public var tracertTimeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.packageNum != nil {
                    map["PackageNum"] = self.packageNum!
                }
                if self.packageSize != nil {
                    map["PackageSize"] = self.packageSize!
                }
                if self.splitPackage != nil {
                    map["SplitPackage"] = self.splitPackage!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.tracertEnable != nil {
                    map["TracertEnable"] = self.tracertEnable!
                }
                if self.tracertNumMax != nil {
                    map["TracertNumMax"] = self.tracertNumMax!
                }
                if self.tracertTimeout != nil {
                    map["TracertTimeout"] = self.tracertTimeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("PackageNum") && dict["PackageNum"] != nil {
                    self.packageNum = dict["PackageNum"] as! Int32
                }
                if dict.keys.contains("PackageSize") && dict["PackageSize"] != nil {
                    self.packageSize = dict["PackageSize"] as! Int32
                }
                if dict.keys.contains("SplitPackage") && dict["SplitPackage"] != nil {
                    self.splitPackage = dict["SplitPackage"] as! Bool
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("TracertEnable") && dict["TracertEnable"] != nil {
                    self.tracertEnable = dict["TracertEnable"] as! Bool
                }
                if dict.keys.contains("TracertNumMax") && dict["TracertNumMax"] != nil {
                    self.tracertNumMax = dict["TracertNumMax"] as! Int32
                }
                if dict.keys.contains("TracertTimeout") && dict["TracertTimeout"] != nil {
                    self.tracertTimeout = dict["TracertTimeout"] as! Int64
                }
            }
        }
        public class NetTCP : Tea.TeaModel {
            public var connectTimes: Int32?

            public var interval: Int64?

            public var targetUrl: String?

            public var timeout: Int64?

            public var tracertEnable: Bool?

            public var tracertNumMax: Int32?

            public var tracertTimeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectTimes != nil {
                    map["ConnectTimes"] = self.connectTimes!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.tracertEnable != nil {
                    map["TracertEnable"] = self.tracertEnable!
                }
                if self.tracertNumMax != nil {
                    map["TracertNumMax"] = self.tracertNumMax!
                }
                if self.tracertTimeout != nil {
                    map["TracertTimeout"] = self.tracertTimeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectTimes") && dict["ConnectTimes"] != nil {
                    self.connectTimes = dict["ConnectTimes"] as! Int32
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("TracertEnable") && dict["TracertEnable"] != nil {
                    self.tracertEnable = dict["TracertEnable"] as! Bool
                }
                if dict.keys.contains("TracertNumMax") && dict["TracertNumMax"] != nil {
                    self.tracertNumMax = dict["TracertNumMax"] as! Int32
                }
                if dict.keys.contains("TracertTimeout") && dict["TracertTimeout"] != nil {
                    self.tracertTimeout = dict["TracertTimeout"] as! Int64
                }
            }
        }
        public class Stream : Tea.TeaModel {
            public var customHeaderContent: [String: String]?

            public var playerType: Int32?

            public var streamAddressType: Int32?

            public var streamMonitorTimeout: Int32?

            public var streamType: Int32?

            public var targetUrl: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.playerType != nil {
                    map["PlayerType"] = self.playerType!
                }
                if self.streamAddressType != nil {
                    map["StreamAddressType"] = self.streamAddressType!
                }
                if self.streamMonitorTimeout != nil {
                    map["StreamMonitorTimeout"] = self.streamMonitorTimeout!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomHeaderContent") && dict["CustomHeaderContent"] != nil {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("PlayerType") && dict["PlayerType"] != nil {
                    self.playerType = dict["PlayerType"] as! Int32
                }
                if dict.keys.contains("StreamAddressType") && dict["StreamAddressType"] != nil {
                    self.streamAddressType = dict["StreamAddressType"] as! Int32
                }
                if dict.keys.contains("StreamMonitorTimeout") && dict["StreamMonitorTimeout"] != nil {
                    self.streamMonitorTimeout = dict["StreamMonitorTimeout"] as! Int32
                }
                if dict.keys.contains("StreamType") && dict["StreamType"] != nil {
                    self.streamType = dict["StreamType"] as! Int32
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class Website : Tea.TeaModel {
            public var automaticScrolling: Int32?

            public var customHeader: Int32?

            public var customHeaderContent: [String: String]?

            public var DNSHijackWhitelist: String?

            public var disableCache: Int32?

            public var disableCompression: Int32?

            public var elementBlacklist: String?

            public var filterInvalidIP: Int32?

            public var flowHijackJumpTimes: Int32?

            public var flowHijackLogo: String?

            public var ignoreCertificateError: Int32?

            public var monitorTimeout: Int64?

            public var pageTamper: String?

            public var redirection: Int32?

            public var slowElementThreshold: Int64?

            public var targetUrl: String?

            public var verifyStringBlacklist: String?

            public var verifyStringWhitelist: String?

            public var waitCompletionTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.automaticScrolling != nil {
                    map["AutomaticScrolling"] = self.automaticScrolling!
                }
                if self.customHeader != nil {
                    map["CustomHeader"] = self.customHeader!
                }
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.DNSHijackWhitelist != nil {
                    map["DNSHijackWhitelist"] = self.DNSHijackWhitelist!
                }
                if self.disableCache != nil {
                    map["DisableCache"] = self.disableCache!
                }
                if self.disableCompression != nil {
                    map["DisableCompression"] = self.disableCompression!
                }
                if self.elementBlacklist != nil {
                    map["ElementBlacklist"] = self.elementBlacklist!
                }
                if self.filterInvalidIP != nil {
                    map["FilterInvalidIP"] = self.filterInvalidIP!
                }
                if self.flowHijackJumpTimes != nil {
                    map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
                }
                if self.flowHijackLogo != nil {
                    map["FlowHijackLogo"] = self.flowHijackLogo!
                }
                if self.ignoreCertificateError != nil {
                    map["IgnoreCertificateError"] = self.ignoreCertificateError!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.pageTamper != nil {
                    map["PageTamper"] = self.pageTamper!
                }
                if self.redirection != nil {
                    map["Redirection"] = self.redirection!
                }
                if self.slowElementThreshold != nil {
                    map["SlowElementThreshold"] = self.slowElementThreshold!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.verifyStringBlacklist != nil {
                    map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
                }
                if self.verifyStringWhitelist != nil {
                    map["VerifyStringWhitelist"] = self.verifyStringWhitelist!
                }
                if self.waitCompletionTime != nil {
                    map["WaitCompletionTime"] = self.waitCompletionTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutomaticScrolling") && dict["AutomaticScrolling"] != nil {
                    self.automaticScrolling = dict["AutomaticScrolling"] as! Int32
                }
                if dict.keys.contains("CustomHeader") && dict["CustomHeader"] != nil {
                    self.customHeader = dict["CustomHeader"] as! Int32
                }
                if dict.keys.contains("CustomHeaderContent") && dict["CustomHeaderContent"] != nil {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("DNSHijackWhitelist") && dict["DNSHijackWhitelist"] != nil {
                    self.DNSHijackWhitelist = dict["DNSHijackWhitelist"] as! String
                }
                if dict.keys.contains("DisableCache") && dict["DisableCache"] != nil {
                    self.disableCache = dict["DisableCache"] as! Int32
                }
                if dict.keys.contains("DisableCompression") && dict["DisableCompression"] != nil {
                    self.disableCompression = dict["DisableCompression"] as! Int32
                }
                if dict.keys.contains("ElementBlacklist") && dict["ElementBlacklist"] != nil {
                    self.elementBlacklist = dict["ElementBlacklist"] as! String
                }
                if dict.keys.contains("FilterInvalidIP") && dict["FilterInvalidIP"] != nil {
                    self.filterInvalidIP = dict["FilterInvalidIP"] as! Int32
                }
                if dict.keys.contains("FlowHijackJumpTimes") && dict["FlowHijackJumpTimes"] != nil {
                    self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int32
                }
                if dict.keys.contains("FlowHijackLogo") && dict["FlowHijackLogo"] != nil {
                    self.flowHijackLogo = dict["FlowHijackLogo"] as! String
                }
                if dict.keys.contains("IgnoreCertificateError") && dict["IgnoreCertificateError"] != nil {
                    self.ignoreCertificateError = dict["IgnoreCertificateError"] as! Int32
                }
                if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("PageTamper") && dict["PageTamper"] != nil {
                    self.pageTamper = dict["PageTamper"] as! String
                }
                if dict.keys.contains("Redirection") && dict["Redirection"] != nil {
                    self.redirection = dict["Redirection"] as! Int32
                }
                if dict.keys.contains("SlowElementThreshold") && dict["SlowElementThreshold"] != nil {
                    self.slowElementThreshold = dict["SlowElementThreshold"] as! Int64
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("VerifyStringBlacklist") && dict["VerifyStringBlacklist"] != nil {
                    self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
                }
                if dict.keys.contains("VerifyStringWhitelist") && dict["VerifyStringWhitelist"] != nil {
                    self.verifyStringWhitelist = dict["VerifyStringWhitelist"] as! String
                }
                if dict.keys.contains("WaitCompletionTime") && dict["WaitCompletionTime"] != nil {
                    self.waitCompletionTime = dict["WaitCompletionTime"] as! Int64
                }
            }
        }
        public var apiHTTP: CreateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP?

        public var fileDownload: CreateTimingSyntheticTaskRequest.MonitorConf.FileDownload?

        public var netDNS: CreateTimingSyntheticTaskRequest.MonitorConf.NetDNS?

        public var netICMP: CreateTimingSyntheticTaskRequest.MonitorConf.NetICMP?

        public var netTCP: CreateTimingSyntheticTaskRequest.MonitorConf.NetTCP?

        public var stream: CreateTimingSyntheticTaskRequest.MonitorConf.Stream?

        public var website: CreateTimingSyntheticTaskRequest.MonitorConf.Website?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.apiHTTP?.validate()
            try self.fileDownload?.validate()
            try self.netDNS?.validate()
            try self.netICMP?.validate()
            try self.netTCP?.validate()
            try self.stream?.validate()
            try self.website?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiHTTP != nil {
                map["ApiHTTP"] = self.apiHTTP?.toMap()
            }
            if self.fileDownload != nil {
                map["FileDownload"] = self.fileDownload?.toMap()
            }
            if self.netDNS != nil {
                map["NetDNS"] = self.netDNS?.toMap()
            }
            if self.netICMP != nil {
                map["NetICMP"] = self.netICMP?.toMap()
            }
            if self.netTCP != nil {
                map["NetTCP"] = self.netTCP?.toMap()
            }
            if self.stream != nil {
                map["Stream"] = self.stream?.toMap()
            }
            if self.website != nil {
                map["Website"] = self.website?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiHTTP") && dict["ApiHTTP"] != nil {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP()
                model.fromMap(dict["ApiHTTP"] as! [String: Any])
                self.apiHTTP = model
            }
            if dict.keys.contains("FileDownload") && dict["FileDownload"] != nil {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.FileDownload()
                model.fromMap(dict["FileDownload"] as! [String: Any])
                self.fileDownload = model
            }
            if dict.keys.contains("NetDNS") && dict["NetDNS"] != nil {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.NetDNS()
                model.fromMap(dict["NetDNS"] as! [String: Any])
                self.netDNS = model
            }
            if dict.keys.contains("NetICMP") && dict["NetICMP"] != nil {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.NetICMP()
                model.fromMap(dict["NetICMP"] as! [String: Any])
                self.netICMP = model
            }
            if dict.keys.contains("NetTCP") && dict["NetTCP"] != nil {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.NetTCP()
                model.fromMap(dict["NetTCP"] as! [String: Any])
                self.netTCP = model
            }
            if dict.keys.contains("Stream") && dict["Stream"] != nil {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.Stream()
                model.fromMap(dict["Stream"] as! [String: Any])
                self.stream = model
            }
            if dict.keys.contains("Website") && dict["Website"] != nil {
                var model = CreateTimingSyntheticTaskRequest.MonitorConf.Website()
                model.fromMap(dict["Website"] as! [String: Any])
                self.website = model
            }
        }
    }
    public class Monitors : Tea.TeaModel {
        public var cityCode: String?

        public var clientType: Int32?

        public var operatorCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.operatorCode != nil {
                map["OperatorCode"] = self.operatorCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("ClientType") && dict["ClientType"] != nil {
                self.clientType = dict["ClientType"] as! Int32
            }
            if dict.keys.contains("OperatorCode") && dict["OperatorCode"] != nil {
                self.operatorCode = dict["OperatorCode"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var availableAssertions: [CreateTimingSyntheticTaskRequest.AvailableAssertions]?

    public var commonSetting: CreateTimingSyntheticTaskRequest.CommonSetting?

    public var customPeriod: CreateTimingSyntheticTaskRequest.CustomPeriod?

    public var frequency: String?

    public var monitorCategory: Int32?

    public var monitorConf: CreateTimingSyntheticTaskRequest.MonitorConf?

    public var monitors: [CreateTimingSyntheticTaskRequest.Monitors]?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [CreateTimingSyntheticTaskRequest.Tags]?

    public var taskType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonSetting?.validate()
        try self.customPeriod?.validate()
        try self.monitorConf?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAssertions != nil {
            var tmp : [Any] = []
            for k in self.availableAssertions! {
                tmp.append(k.toMap())
            }
            map["AvailableAssertions"] = tmp
        }
        if self.commonSetting != nil {
            map["CommonSetting"] = self.commonSetting?.toMap()
        }
        if self.customPeriod != nil {
            map["CustomPeriod"] = self.customPeriod?.toMap()
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.monitorCategory != nil {
            map["MonitorCategory"] = self.monitorCategory!
        }
        if self.monitorConf != nil {
            map["MonitorConf"] = self.monitorConf?.toMap()
        }
        if self.monitors != nil {
            var tmp : [Any] = []
            for k in self.monitors! {
                tmp.append(k.toMap())
            }
            map["Monitors"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAssertions") && dict["AvailableAssertions"] != nil {
            var tmp : [CreateTimingSyntheticTaskRequest.AvailableAssertions] = []
            for v in dict["AvailableAssertions"] as! [Any] {
                var model = CreateTimingSyntheticTaskRequest.AvailableAssertions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.availableAssertions = tmp
        }
        if dict.keys.contains("CommonSetting") && dict["CommonSetting"] != nil {
            var model = CreateTimingSyntheticTaskRequest.CommonSetting()
            model.fromMap(dict["CommonSetting"] as! [String: Any])
            self.commonSetting = model
        }
        if dict.keys.contains("CustomPeriod") && dict["CustomPeriod"] != nil {
            var model = CreateTimingSyntheticTaskRequest.CustomPeriod()
            model.fromMap(dict["CustomPeriod"] as! [String: Any])
            self.customPeriod = model
        }
        if dict.keys.contains("Frequency") && dict["Frequency"] != nil {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("MonitorCategory") && dict["MonitorCategory"] != nil {
            self.monitorCategory = dict["MonitorCategory"] as! Int32
        }
        if dict.keys.contains("MonitorConf") && dict["MonitorConf"] != nil {
            var model = CreateTimingSyntheticTaskRequest.MonitorConf()
            model.fromMap(dict["MonitorConf"] as! [String: Any])
            self.monitorConf = model
        }
        if dict.keys.contains("Monitors") && dict["Monitors"] != nil {
            var tmp : [CreateTimingSyntheticTaskRequest.Monitors] = []
            for v in dict["Monitors"] as! [Any] {
                var model = CreateTimingSyntheticTaskRequest.Monitors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.monitors = tmp
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [CreateTimingSyntheticTaskRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateTimingSyntheticTaskRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! Int32
        }
    }
}

public class CreateTimingSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var availableAssertionsShrink: String?

    public var commonSettingShrink: String?

    public var customPeriodShrink: String?

    public var frequency: String?

    public var monitorCategory: Int32?

    public var monitorConfShrink: String?

    public var monitorsShrink: String?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tagsShrink: String?

    public var taskType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAssertionsShrink != nil {
            map["AvailableAssertions"] = self.availableAssertionsShrink!
        }
        if self.commonSettingShrink != nil {
            map["CommonSetting"] = self.commonSettingShrink!
        }
        if self.customPeriodShrink != nil {
            map["CustomPeriod"] = self.customPeriodShrink!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.monitorCategory != nil {
            map["MonitorCategory"] = self.monitorCategory!
        }
        if self.monitorConfShrink != nil {
            map["MonitorConf"] = self.monitorConfShrink!
        }
        if self.monitorsShrink != nil {
            map["Monitors"] = self.monitorsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAssertions") && dict["AvailableAssertions"] != nil {
            self.availableAssertionsShrink = dict["AvailableAssertions"] as! String
        }
        if dict.keys.contains("CommonSetting") && dict["CommonSetting"] != nil {
            self.commonSettingShrink = dict["CommonSetting"] as! String
        }
        if dict.keys.contains("CustomPeriod") && dict["CustomPeriod"] != nil {
            self.customPeriodShrink = dict["CustomPeriod"] as! String
        }
        if dict.keys.contains("Frequency") && dict["Frequency"] != nil {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("MonitorCategory") && dict["MonitorCategory"] != nil {
            self.monitorCategory = dict["MonitorCategory"] as! Int32
        }
        if dict.keys.contains("MonitorConf") && dict["MonitorConf"] != nil {
            self.monitorConfShrink = dict["MonitorConf"] as! String
        }
        if dict.keys.contains("Monitors") && dict["Monitors"] != nil {
            self.monitorsShrink = dict["Monitors"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tagsShrink = dict["Tags"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! Int32
        }
    }
}

public class CreateTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: CreateTimingSyntheticTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateTimingSyntheticTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWebhookRequest : Tea.TeaModel {
    public var body: String?

    public var contactName: String?

    public var httpHeaders: String?

    public var httpParams: String?

    public var method: String?

    public var recoverBody: String?

    public var regionId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["Body"] = self.body!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.httpHeaders != nil {
            map["HttpHeaders"] = self.httpHeaders!
        }
        if self.httpParams != nil {
            map["HttpParams"] = self.httpParams!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.recoverBody != nil {
            map["RecoverBody"] = self.recoverBody!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Body") && dict["Body"] != nil {
            self.body = dict["Body"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("HttpHeaders") && dict["HttpHeaders"] != nil {
            self.httpHeaders = dict["HttpHeaders"] as! String
        }
        if dict.keys.contains("HttpParams") && dict["HttpParams"] != nil {
            self.httpParams = dict["HttpParams"] as! String
        }
        if dict.keys.contains("Method") && dict["Method"] != nil {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("RecoverBody") && dict["RecoverBody"] != nil {
            self.recoverBody = dict["RecoverBody"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class CreateWebhookResponseBody : Tea.TeaModel {
    public var contactId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DelAuthTokenRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DelAuthTokenResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DelAuthTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DelAuthTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DelAuthTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAddonReleaseRequest : Tea.TeaModel {
    public var environmentId: String?

    public var force: Bool?

    public var regionId: String?

    public var releaseName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseName != nil {
            map["ReleaseName"] = self.releaseName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Force") && dict["Force"] != nil {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseName") && dict["ReleaseName"] != nil {
            self.releaseName = dict["ReleaseName"] as! String
        }
    }
}

public class DeleteAddonReleaseResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAddonReleaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAddonReleaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAddonReleaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlertContactRequest : Tea.TeaModel {
    public var contactId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAlertContactResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlertContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAlertContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlertContactGroupRequest : Tea.TeaModel {
    public var contactGroupId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") && dict["ContactGroupId"] != nil {
            self.contactGroupId = dict["ContactGroupId"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAlertContactGroupResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlertContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAlertContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlertRuleRequest : Tea.TeaModel {
    public var alertId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! Int64
        }
    }
}

public class DeleteAlertRuleResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlertRulesRequest : Tea.TeaModel {
    public var alertIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertIds != nil {
            map["AlertIds"] = self.alertIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertIds") && dict["AlertIds"] != nil {
            self.alertIds = dict["AlertIds"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAlertRulesResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAppListRequest : Tea.TeaModel {
    public var pids: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pids != nil {
            map["Pids"] = self.pids!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pids") && dict["Pids"] != nil {
            self.pids = dict["Pids"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAppListResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAppListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAppListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAppListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCmsExporterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteCmsExporterResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCmsExporterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCmsExporterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCmsExporterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactRequest : Tea.TeaModel {
    public var contactId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! Int64
        }
    }
}

public class DeleteContactResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactGroupRequest : Tea.TeaModel {
    public var contactGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") && dict["ContactGroupId"] != nil {
            self.contactGroupId = dict["ContactGroupId"] as! Int64
        }
    }
}

public class DeleteContactGroupResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDispatchRuleRequest : Tea.TeaModel {
    public var id: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteDispatchRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvCustomJobRequest : Tea.TeaModel {
    public var customJobName: String?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customJobName != nil {
            map["CustomJobName"] = self.customJobName!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomJobName") && dict["CustomJobName"] != nil {
            self.customJobName = dict["CustomJobName"] as! String
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEnvCustomJobResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnvCustomJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvCustomJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEnvCustomJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvPodMonitorRequest : Tea.TeaModel {
    public var environmentId: String?

    public var namespace: String?

    public var podMonitorName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.podMonitorName != nil {
            map["PodMonitorName"] = self.podMonitorName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PodMonitorName") && dict["PodMonitorName"] != nil {
            self.podMonitorName = dict["PodMonitorName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEnvPodMonitorResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnvPodMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvPodMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEnvPodMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvServiceMonitorRequest : Tea.TeaModel {
    public var environmentId: String?

    public var namespace: String?

    public var regionId: String?

    public var serviceMonitorName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serviceMonitorName != nil {
            map["ServiceMonitorName"] = self.serviceMonitorName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ServiceMonitorName") && dict["ServiceMonitorName"] != nil {
            self.serviceMonitorName = dict["ServiceMonitorName"] as! String
        }
    }
}

public class DeleteEnvServiceMonitorResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnvServiceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvServiceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEnvServiceMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvironmentRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEnvironmentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnvironmentFeatureRequest : Tea.TeaModel {
    public var environmentId: String?

    public var featureName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") && dict["FeatureName"] != nil {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEnvironmentFeatureResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventBridgeIntegrationRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteEventBridgeIntegrationResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEventBridgeIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventBridgeIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEventBridgeIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGrafanaResourceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteGrafanaResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGrafanaResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGrafanaResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGrafanaResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIMRobotRequest : Tea.TeaModel {
    public var robotId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.robotId != nil {
            map["RobotId"] = self.robotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RobotId") && dict["RobotId"] != nil {
            self.robotId = dict["RobotId"] as! Int64
        }
    }
}

public class DeleteIMRobotResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIMRobotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIMRobotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteIMRobotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integration: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integration != nil {
            map["Integration"] = self.integration!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Integration") && dict["Integration"] != nil {
            self.integration = dict["Integration"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteIntegrationResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIntegrationsRequest : Tea.TeaModel {
    public var integrationId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.integrationId != nil {
            map["IntegrationId"] = self.integrationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IntegrationId") && dict["IntegrationId"] != nil {
            self.integrationId = dict["IntegrationId"] as! Int64
        }
    }
}

public class DeleteIntegrationsResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIntegrationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIntegrationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteIntegrationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNotificationPolicyRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteNotificationPolicyResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNotificationPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNotificationPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNotificationPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusAlertRuleRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class DeletePrometheusAlertRuleResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeletePrometheusAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeletePrometheusAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusGlobalViewRequest : Tea.TeaModel {
    public var globalViewClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalViewClusterId") && dict["GlobalViewClusterId"] != nil {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeletePrometheusGlobalViewResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeletePrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceId: Int64?

    public var integrationType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeletePrometheusIntegrationResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeletePrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var monitoringName: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.monitoringName != nil {
            map["MonitoringName"] = self.monitoringName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MonitoringName") && dict["MonitoringName"] != nil {
            self.monitoringName = dict["MonitoringName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DeletePrometheusMonitoringResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeletePrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrometheusRemoteWriteRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var remoteWriteNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteWriteNames != nil {
            map["RemoteWriteNames"] = self.remoteWriteNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteWriteNames") && dict["RemoteWriteNames"] != nil {
            self.remoteWriteNames = dict["RemoteWriteNames"] as! String
        }
    }
}

public class DeletePrometheusRemoteWriteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeletePrometheusRemoteWriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrometheusRemoteWriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeletePrometheusRemoteWriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRetcodeAppRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteRetcodeAppResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteRetcodeAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRetcodeAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteRetcodeAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScenarioRequest : Tea.TeaModel {
    public var regionId: String?

    public var scenarioId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ScenarioId") && dict["ScenarioId"] != nil {
            self.scenarioId = dict["ScenarioId"] as! Int64
        }
    }
}

public class DeleteScenarioResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSilencePolicyRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteSilencePolicyResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSilencePolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSilencePolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSilencePolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSourceMapRequest : Tea.TeaModel {
    public var fidList: [String]?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fidList != nil {
            map["FidList"] = self.fidList!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FidList") && dict["FidList"] != nil {
            self.fidList = dict["FidList"] as! [String]
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteSourceMapShrinkRequest : Tea.TeaModel {
    public var fidListShrink: String?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fidListShrink != nil {
            map["FidList"] = self.fidListShrink!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FidList") && dict["FidList"] != nil {
            self.fidListShrink = dict["FidList"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteSourceMapResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSourceMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSourceMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSourceMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIds = dict["TaskIds"] as! [String]
        }
    }
}

public class DeleteSyntheticTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! String
        }
    }
}

public class DeleteSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTimingSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceGroupId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DeleteTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTraceAppRequest : Tea.TeaModel {
    public class DeleteReason : Tea.TeaModel {
        public class ReasonIds : Tea.TeaModel {
            public var id: Int32?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var reasonIds: [DeleteTraceAppRequest.DeleteReason.ReasonIds]?

        public var remark: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reasonIds != nil {
                var tmp : [Any] = []
                for k in self.reasonIds! {
                    tmp.append(k.toMap())
                }
                map["ReasonIds"] = tmp
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReasonIds") && dict["ReasonIds"] != nil {
                var tmp : [DeleteTraceAppRequest.DeleteReason.ReasonIds] = []
                for v in dict["ReasonIds"] as! [Any] {
                    var model = DeleteTraceAppRequest.DeleteReason.ReasonIds()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reasonIds = tmp
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
        }
    }
    public var appId: String?

    public var deleteReason: DeleteTraceAppRequest.DeleteReason?

    public var pid: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deleteReason?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deleteReason != nil {
            map["DeleteReason"] = self.deleteReason?.toMap()
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeleteReason") && dict["DeleteReason"] != nil {
            var model = DeleteTraceAppRequest.DeleteReason()
            model.fromMap(dict["DeleteReason"] as! [String: Any])
            self.deleteReason = model
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DeleteTraceAppShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var deleteReasonShrink: String?

    public var pid: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deleteReasonShrink != nil {
            map["DeleteReason"] = self.deleteReasonShrink!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeleteReason") && dict["DeleteReason"] != nil {
            self.deleteReasonShrink = dict["DeleteReason"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DeleteTraceAppResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTraceAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTraceAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTraceAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWebhookContactRequest : Tea.TeaModel {
    public var webhookId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.webhookId != nil {
            map["WebhookId"] = self.webhookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WebhookId") && dict["WebhookId"] != nil {
            self.webhookId = dict["WebhookId"] as! Int64
        }
    }
}

public class DeleteWebhookContactResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteWebhookContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWebhookContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteWebhookContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAddonReleaseRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public var releaseName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseName != nil {
            map["ReleaseName"] = self.releaseName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseName") && dict["ReleaseName"] != nil {
            self.releaseName = dict["ReleaseName"] as! String
        }
    }
}

public class DescribeAddonReleaseResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Release : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var firstTransitionTime: String?

                public var lastTransitionTime: String?

                public var message: String?

                public var reason: String?

                public var status: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.firstTransitionTime != nil {
                        map["FirstTransitionTime"] = self.firstTransitionTime!
                    }
                    if self.lastTransitionTime != nil {
                        map["LastTransitionTime"] = self.lastTransitionTime!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FirstTransitionTime") && dict["FirstTransitionTime"] != nil {
                        self.firstTransitionTime = dict["FirstTransitionTime"] as! String
                    }
                    if dict.keys.contains("LastTransitionTime") && dict["LastTransitionTime"] != nil {
                        self.lastTransitionTime = dict["LastTransitionTime"] as! String
                    }
                    if dict.keys.contains("Message") && dict["Message"] != nil {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Reason") && dict["Reason"] != nil {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var addonName: String?

            public var alertRuleCount: Int64?

            public var conditions: [DescribeAddonReleaseResponseBody.Data.Release.Conditions]?

            public var createTime: String?

            public var dashboardCount: Int64?

            public var environmentId: String?

            public var exporterCount: Int64?

            public var haveConfig: Bool?

            public var installUserId: String?

            public var language: String?

            public var regionId: String?

            public var releaseId: String?

            public var releaseName: String?

            public var scene: String?

            public var status: String?

            public var updateTime: String?

            public var userID: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addonName != nil {
                    map["AddonName"] = self.addonName!
                }
                if self.alertRuleCount != nil {
                    map["AlertRuleCount"] = self.alertRuleCount!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["Conditions"] = tmp
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dashboardCount != nil {
                    map["DashboardCount"] = self.dashboardCount!
                }
                if self.environmentId != nil {
                    map["EnvironmentId"] = self.environmentId!
                }
                if self.exporterCount != nil {
                    map["ExporterCount"] = self.exporterCount!
                }
                if self.haveConfig != nil {
                    map["HaveConfig"] = self.haveConfig!
                }
                if self.installUserId != nil {
                    map["InstallUserId"] = self.installUserId!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.releaseId != nil {
                    map["ReleaseId"] = self.releaseId!
                }
                if self.releaseName != nil {
                    map["ReleaseName"] = self.releaseName!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userID != nil {
                    map["UserID"] = self.userID!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddonName") && dict["AddonName"] != nil {
                    self.addonName = dict["AddonName"] as! String
                }
                if dict.keys.contains("AlertRuleCount") && dict["AlertRuleCount"] != nil {
                    self.alertRuleCount = dict["AlertRuleCount"] as! Int64
                }
                if dict.keys.contains("Conditions") && dict["Conditions"] != nil {
                    var tmp : [DescribeAddonReleaseResponseBody.Data.Release.Conditions] = []
                    for v in dict["Conditions"] as! [Any] {
                        var model = DescribeAddonReleaseResponseBody.Data.Release.Conditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.conditions = tmp
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DashboardCount") && dict["DashboardCount"] != nil {
                    self.dashboardCount = dict["DashboardCount"] as! Int64
                }
                if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                    self.environmentId = dict["EnvironmentId"] as! String
                }
                if dict.keys.contains("ExporterCount") && dict["ExporterCount"] != nil {
                    self.exporterCount = dict["ExporterCount"] as! Int64
                }
                if dict.keys.contains("HaveConfig") && dict["HaveConfig"] != nil {
                    self.haveConfig = dict["HaveConfig"] as! Bool
                }
                if dict.keys.contains("InstallUserId") && dict["InstallUserId"] != nil {
                    self.installUserId = dict["InstallUserId"] as! String
                }
                if dict.keys.contains("Language") && dict["Language"] != nil {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReleaseId") && dict["ReleaseId"] != nil {
                    self.releaseId = dict["ReleaseId"] as! String
                }
                if dict.keys.contains("ReleaseName") && dict["ReleaseName"] != nil {
                    self.releaseName = dict["ReleaseName"] as! String
                }
                if dict.keys.contains("Scene") && dict["Scene"] != nil {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UserID") && dict["UserID"] != nil {
                    self.userID = dict["UserID"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var config: String?

        public var release: DescribeAddonReleaseResponseBody.Data.Release?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.release?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.release != nil {
                map["Release"] = self.release?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("Release") && dict["Release"] != nil {
                var model = DescribeAddonReleaseResponseBody.Data.Release()
                model.fromMap(dict["Release"] as! [String: Any])
                self.release = model
            }
        }
    }
    public var code: String?

    public var data: DescribeAddonReleaseResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeAddonReleaseResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeAddonReleaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAddonReleaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAddonReleaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContactGroupsRequest : Tea.TeaModel {
    public var contactGroupName: String?

    public var groupIds: String?

    public var isDetail: Bool?

    public var page: Int64?

    public var regionId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("GroupIds") && dict["GroupIds"] != nil {
            self.groupIds = dict["GroupIds"] as! String
        }
        if dict.keys.contains("IsDetail") && dict["IsDetail"] != nil {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class DescribeContactGroupsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertContactGroups : Tea.TeaModel {
            public class Contacts : Tea.TeaModel {
                public var armsContactId: Int64?

                public var contactId: Double?

                public var contactName: String?

                public var email: String?

                public var phone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.armsContactId != nil {
                        map["ArmsContactId"] = self.armsContactId!
                    }
                    if self.contactId != nil {
                        map["ContactId"] = self.contactId!
                    }
                    if self.contactName != nil {
                        map["ContactName"] = self.contactName!
                    }
                    if self.email != nil {
                        map["Email"] = self.email!
                    }
                    if self.phone != nil {
                        map["Phone"] = self.phone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ArmsContactId") && dict["ArmsContactId"] != nil {
                        self.armsContactId = dict["ArmsContactId"] as! Int64
                    }
                    if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                        self.contactId = dict["ContactId"] as! Double
                    }
                    if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                        self.contactName = dict["ContactName"] as! String
                    }
                    if dict.keys.contains("Email") && dict["Email"] != nil {
                        self.email = dict["Email"] as! String
                    }
                    if dict.keys.contains("Phone") && dict["Phone"] != nil {
                        self.phone = dict["Phone"] as! String
                    }
                }
            }
            public var armsContactGroupId: Int64?

            public var contactGroupId: Double?

            public var contactGroupName: String?

            public var contacts: [DescribeContactGroupsResponseBody.PageBean.AlertContactGroups.Contacts]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.armsContactGroupId != nil {
                    map["ArmsContactGroupId"] = self.armsContactGroupId!
                }
                if self.contactGroupId != nil {
                    map["ContactGroupId"] = self.contactGroupId!
                }
                if self.contactGroupName != nil {
                    map["ContactGroupName"] = self.contactGroupName!
                }
                if self.contacts != nil {
                    var tmp : [Any] = []
                    for k in self.contacts! {
                        tmp.append(k.toMap())
                    }
                    map["Contacts"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ArmsContactGroupId") && dict["ArmsContactGroupId"] != nil {
                    self.armsContactGroupId = dict["ArmsContactGroupId"] as! Int64
                }
                if dict.keys.contains("ContactGroupId") && dict["ContactGroupId"] != nil {
                    self.contactGroupId = dict["ContactGroupId"] as! Double
                }
                if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
                    self.contactGroupName = dict["ContactGroupName"] as! String
                }
                if dict.keys.contains("Contacts") && dict["Contacts"] != nil {
                    var tmp : [DescribeContactGroupsResponseBody.PageBean.AlertContactGroups.Contacts] = []
                    for v in dict["Contacts"] as! [Any] {
                        var model = DescribeContactGroupsResponseBody.PageBean.AlertContactGroups.Contacts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.contacts = tmp
                }
            }
        }
        public var alertContactGroups: [DescribeContactGroupsResponseBody.PageBean.AlertContactGroups]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertContactGroups != nil {
                var tmp : [Any] = []
                for k in self.alertContactGroups! {
                    tmp.append(k.toMap())
                }
                map["AlertContactGroups"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertContactGroups") && dict["AlertContactGroups"] != nil {
                var tmp : [DescribeContactGroupsResponseBody.PageBean.AlertContactGroups] = []
                for v in dict["AlertContactGroups"] as! [Any] {
                    var model = DescribeContactGroupsResponseBody.PageBean.AlertContactGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertContactGroups = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: DescribeContactGroupsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = DescribeContactGroupsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeContactGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContactGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContactGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContactsRequest : Tea.TeaModel {
    public var contactIds: String?

    public var contactName: String?

    public var email: String?

    public var page: Int64?

    public var phone: String?

    public var regionId: String?

    public var size: Int64?

    public var verbose: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.verbose != nil {
            map["Verbose"] = self.verbose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIds") && dict["ContactIds"] != nil {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("Email") && dict["Email"] != nil {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Phone") && dict["Phone"] != nil {
            self.phone = dict["Phone"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("Verbose") && dict["Verbose"] != nil {
            self.verbose = dict["Verbose"] as! String
        }
    }
}

public class DescribeContactsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertContacts : Tea.TeaModel {
            public var armsContactId: Int64?

            public var contactId: Double?

            public var contactName: String?

            public var email: String?

            public var isEmailVerify: Bool?

            public var isVerify: Bool?

            public var phone: String?

            public var reissueSendNotice: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.armsContactId != nil {
                    map["ArmsContactId"] = self.armsContactId!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.isEmailVerify != nil {
                    map["IsEmailVerify"] = self.isEmailVerify!
                }
                if self.isVerify != nil {
                    map["IsVerify"] = self.isVerify!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.reissueSendNotice != nil {
                    map["ReissueSendNotice"] = self.reissueSendNotice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ArmsContactId") && dict["ArmsContactId"] != nil {
                    self.armsContactId = dict["ArmsContactId"] as! Int64
                }
                if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                    self.contactId = dict["ContactId"] as! Double
                }
                if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("IsEmailVerify") && dict["IsEmailVerify"] != nil {
                    self.isEmailVerify = dict["IsEmailVerify"] as! Bool
                }
                if dict.keys.contains("IsVerify") && dict["IsVerify"] != nil {
                    self.isVerify = dict["IsVerify"] as! Bool
                }
                if dict.keys.contains("Phone") && dict["Phone"] != nil {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("ReissueSendNotice") && dict["ReissueSendNotice"] != nil {
                    self.reissueSendNotice = dict["ReissueSendNotice"] as! Int64
                }
            }
        }
        public var alertContacts: [DescribeContactsResponseBody.PageBean.AlertContacts]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertContacts != nil {
                var tmp : [Any] = []
                for k in self.alertContacts! {
                    tmp.append(k.toMap())
                }
                map["AlertContacts"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertContacts") && dict["AlertContacts"] != nil {
                var tmp : [DescribeContactsResponseBody.PageBean.AlertContacts] = []
                for v in dict["AlertContacts"] as! [Any] {
                    var model = DescribeContactsResponseBody.PageBean.AlertContacts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertContacts = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: DescribeContactsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = DescribeContactsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeContactsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContactsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContactsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDispatchRuleRequest : Tea.TeaModel {
    public var id: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeDispatchRuleResponseBody : Tea.TeaModel {
    public class DispatchRule : Tea.TeaModel {
        public class GroupRules : Tea.TeaModel {
            public var groupId: Int64?

            public var groupInterval: Int64?

            public var groupWaitTime: Int64?

            public var groupingFields: [String]?

            public var repeatInterval: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupInterval != nil {
                    map["GroupInterval"] = self.groupInterval!
                }
                if self.groupWaitTime != nil {
                    map["GroupWaitTime"] = self.groupWaitTime!
                }
                if self.groupingFields != nil {
                    map["GroupingFields"] = self.groupingFields!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupInterval") && dict["GroupInterval"] != nil {
                    self.groupInterval = dict["GroupInterval"] as! Int64
                }
                if dict.keys.contains("GroupWaitTime") && dict["GroupWaitTime"] != nil {
                    self.groupWaitTime = dict["GroupWaitTime"] as! Int64
                }
                if dict.keys.contains("GroupingFields") && dict["GroupingFields"] != nil {
                    self.groupingFields = dict["GroupingFields"] as! [String]
                }
                if dict.keys.contains("RepeatInterval") && dict["RepeatInterval"] != nil {
                    self.repeatInterval = dict["RepeatInterval"] as! Int64
                }
            }
        }
        public class LabelMatchExpressionGrid : Tea.TeaModel {
            public class LabelMatchExpressionGroups : Tea.TeaModel {
                public class LabelMatchExpressions : Tea.TeaModel {
                    public var key: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Operator") && dict["Operator"] != nil {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var labelMatchExpressions: [DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups.LabelMatchExpressions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.labelMatchExpressions != nil {
                        var tmp : [Any] = []
                        for k in self.labelMatchExpressions! {
                            tmp.append(k.toMap())
                        }
                        map["LabelMatchExpressions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LabelMatchExpressions") && dict["LabelMatchExpressions"] != nil {
                        var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups.LabelMatchExpressions] = []
                        for v in dict["LabelMatchExpressions"] as! [Any] {
                            var model = DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups.LabelMatchExpressions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.labelMatchExpressions = tmp
                    }
                }
            }
            public var labelMatchExpressionGroups: [DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.labelMatchExpressionGroups != nil {
                    var tmp : [Any] = []
                    for k in self.labelMatchExpressionGroups! {
                        tmp.append(k.toMap())
                    }
                    map["LabelMatchExpressionGroups"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LabelMatchExpressionGroups") && dict["LabelMatchExpressionGroups"] != nil {
                    var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups] = []
                    for v in dict["LabelMatchExpressionGroups"] as! [Any] {
                        var model = DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid.LabelMatchExpressionGroups()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.labelMatchExpressionGroups = tmp
                }
            }
        }
        public class NotifyRules : Tea.TeaModel {
            public class NotifyObjects : Tea.TeaModel {
                public var name: String?

                public var notifyObjectId: String?

                public var notifyType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.notifyObjectId != nil {
                        map["NotifyObjectId"] = self.notifyObjectId!
                    }
                    if self.notifyType != nil {
                        map["NotifyType"] = self.notifyType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("NotifyObjectId") && dict["NotifyObjectId"] != nil {
                        self.notifyObjectId = dict["NotifyObjectId"] as! String
                    }
                    if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
                        self.notifyType = dict["NotifyType"] as! String
                    }
                }
            }
            public var notifyChannels: [String]?

            public var notifyObjects: [DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules.NotifyObjects]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notifyChannels != nil {
                    map["NotifyChannels"] = self.notifyChannels!
                }
                if self.notifyObjects != nil {
                    var tmp : [Any] = []
                    for k in self.notifyObjects! {
                        tmp.append(k.toMap())
                    }
                    map["NotifyObjects"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NotifyChannels") && dict["NotifyChannels"] != nil {
                    self.notifyChannels = dict["NotifyChannels"] as! [String]
                }
                if dict.keys.contains("NotifyObjects") && dict["NotifyObjects"] != nil {
                    var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules.NotifyObjects] = []
                    for v in dict["NotifyObjects"] as! [Any] {
                        var model = DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules.NotifyObjects()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notifyObjects = tmp
                }
            }
        }
        public var dispatchType: String?

        public var groupRules: [DescribeDispatchRuleResponseBody.DispatchRule.GroupRules]?

        public var isRecover: Bool?

        public var labelMatchExpressionGrid: DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid?

        public var name: String?

        public var notifyRules: [DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules]?

        public var ruleId: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.labelMatchExpressionGrid?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dispatchType != nil {
                map["DispatchType"] = self.dispatchType!
            }
            if self.groupRules != nil {
                var tmp : [Any] = []
                for k in self.groupRules! {
                    tmp.append(k.toMap())
                }
                map["GroupRules"] = tmp
            }
            if self.isRecover != nil {
                map["IsRecover"] = self.isRecover!
            }
            if self.labelMatchExpressionGrid != nil {
                map["LabelMatchExpressionGrid"] = self.labelMatchExpressionGrid?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyRules != nil {
                var tmp : [Any] = []
                for k in self.notifyRules! {
                    tmp.append(k.toMap())
                }
                map["NotifyRules"] = tmp
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DispatchType") && dict["DispatchType"] != nil {
                self.dispatchType = dict["DispatchType"] as! String
            }
            if dict.keys.contains("GroupRules") && dict["GroupRules"] != nil {
                var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.GroupRules] = []
                for v in dict["GroupRules"] as! [Any] {
                    var model = DescribeDispatchRuleResponseBody.DispatchRule.GroupRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groupRules = tmp
            }
            if dict.keys.contains("IsRecover") && dict["IsRecover"] != nil {
                self.isRecover = dict["IsRecover"] as! Bool
            }
            if dict.keys.contains("LabelMatchExpressionGrid") && dict["LabelMatchExpressionGrid"] != nil {
                var model = DescribeDispatchRuleResponseBody.DispatchRule.LabelMatchExpressionGrid()
                model.fromMap(dict["LabelMatchExpressionGrid"] as! [String: Any])
                self.labelMatchExpressionGrid = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyRules") && dict["NotifyRules"] != nil {
                var tmp : [DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules] = []
                for v in dict["NotifyRules"] as! [Any] {
                    var model = DescribeDispatchRuleResponseBody.DispatchRule.NotifyRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifyRules = tmp
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! Int64
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var dispatchRule: DescribeDispatchRuleResponseBody.DispatchRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dispatchRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRule != nil {
            map["DispatchRule"] = self.dispatchRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRule") && dict["DispatchRule"] != nil {
            var model = DescribeDispatchRuleResponseBody.DispatchRule()
            model.fromMap(dict["DispatchRule"] as! [String: Any])
            self.dispatchRule = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvCustomJobRequest : Tea.TeaModel {
    public var customJobName: String?

    public var encryptYaml: Bool?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customJobName != nil {
            map["CustomJobName"] = self.customJobName!
        }
        if self.encryptYaml != nil {
            map["EncryptYaml"] = self.encryptYaml!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomJobName") && dict["CustomJobName"] != nil {
            self.customJobName = dict["CustomJobName"] as! String
        }
        if dict.keys.contains("EncryptYaml") && dict["EncryptYaml"] != nil {
            self.encryptYaml = dict["EncryptYaml"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEnvCustomJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configYaml: String?

        public var customJobName: String?

        public var environmentId: String?

        public var regionId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.customJobName != nil {
                map["CustomJobName"] = self.customJobName!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("CustomJobName") && dict["CustomJobName"] != nil {
                self.customJobName = dict["CustomJobName"] as! String
            }
            if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvCustomJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeEnvCustomJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnvCustomJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvCustomJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnvCustomJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvPodMonitorRequest : Tea.TeaModel {
    public var environmentId: String?

    public var namespace: String?

    public var podMonitorName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.podMonitorName != nil {
            map["PodMonitorName"] = self.podMonitorName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PodMonitorName") && dict["PodMonitorName"] != nil {
            self.podMonitorName = dict["PodMonitorName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEnvPodMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configYaml: String?

        public var environmentId: String?

        public var namespace: String?

        public var podMonitorName: String?

        public var regionId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.podMonitorName != nil {
                map["PodMonitorName"] = self.podMonitorName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PodMonitorName") && dict["PodMonitorName"] != nil {
                self.podMonitorName = dict["PodMonitorName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvPodMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeEnvPodMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnvPodMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvPodMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnvPodMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvServiceMonitorRequest : Tea.TeaModel {
    public var environmentId: String?

    public var namespace: String?

    public var regionId: String?

    public var serviceMonitorName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serviceMonitorName != nil {
            map["ServiceMonitorName"] = self.serviceMonitorName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ServiceMonitorName") && dict["ServiceMonitorName"] != nil {
            self.serviceMonitorName = dict["ServiceMonitorName"] as! String
        }
    }
}

public class DescribeEnvServiceMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configYaml: String?

        public var environmentId: String?

        public var namespace: String?

        public var regionId: String?

        public var serviceMonitorName: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.serviceMonitorName != nil {
                map["ServiceMonitorName"] = self.serviceMonitorName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ServiceMonitorName") && dict["ServiceMonitorName"] != nil {
                self.serviceMonitorName = dict["ServiceMonitorName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvServiceMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeEnvServiceMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnvServiceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvServiceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnvServiceMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvironmentRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEnvironmentResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var bindResourceId: String?

        public var bindResourceProfile: String?

        public var bindResourceStatus: String?

        public var bindResourceStoreDuration: String?

        public var bindResourceType: String?

        public var bindVpcCidr: String?

        public var environmentId: String?

        public var environmentName: String?

        public var environmentSubType: String?

        public var environmentType: String?

        public var grafaDataSourceName: String?

        public var grafanaDatasourceUid: String?

        public var grafanaFolderTitle: String?

        public var grafanaFolderUid: String?

        public var grafanaFolderUrl: String?

        public var prometheusInstanceId: String?

        public var prometheusInstanceName: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var tags: [DescribeEnvironmentResponseBody.Data.Tags]?

        public var userId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindResourceId != nil {
                map["BindResourceId"] = self.bindResourceId!
            }
            if self.bindResourceProfile != nil {
                map["BindResourceProfile"] = self.bindResourceProfile!
            }
            if self.bindResourceStatus != nil {
                map["BindResourceStatus"] = self.bindResourceStatus!
            }
            if self.bindResourceStoreDuration != nil {
                map["BindResourceStoreDuration"] = self.bindResourceStoreDuration!
            }
            if self.bindResourceType != nil {
                map["BindResourceType"] = self.bindResourceType!
            }
            if self.bindVpcCidr != nil {
                map["BindVpcCidr"] = self.bindVpcCidr!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.environmentName != nil {
                map["EnvironmentName"] = self.environmentName!
            }
            if self.environmentSubType != nil {
                map["EnvironmentSubType"] = self.environmentSubType!
            }
            if self.environmentType != nil {
                map["EnvironmentType"] = self.environmentType!
            }
            if self.grafaDataSourceName != nil {
                map["GrafaDataSourceName"] = self.grafaDataSourceName!
            }
            if self.grafanaDatasourceUid != nil {
                map["GrafanaDatasourceUid"] = self.grafanaDatasourceUid!
            }
            if self.grafanaFolderTitle != nil {
                map["GrafanaFolderTitle"] = self.grafanaFolderTitle!
            }
            if self.grafanaFolderUid != nil {
                map["GrafanaFolderUid"] = self.grafanaFolderUid!
            }
            if self.grafanaFolderUrl != nil {
                map["GrafanaFolderUrl"] = self.grafanaFolderUrl!
            }
            if self.prometheusInstanceId != nil {
                map["PrometheusInstanceId"] = self.prometheusInstanceId!
            }
            if self.prometheusInstanceName != nil {
                map["PrometheusInstanceName"] = self.prometheusInstanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindResourceId") && dict["BindResourceId"] != nil {
                self.bindResourceId = dict["BindResourceId"] as! String
            }
            if dict.keys.contains("BindResourceProfile") && dict["BindResourceProfile"] != nil {
                self.bindResourceProfile = dict["BindResourceProfile"] as! String
            }
            if dict.keys.contains("BindResourceStatus") && dict["BindResourceStatus"] != nil {
                self.bindResourceStatus = dict["BindResourceStatus"] as! String
            }
            if dict.keys.contains("BindResourceStoreDuration") && dict["BindResourceStoreDuration"] != nil {
                self.bindResourceStoreDuration = dict["BindResourceStoreDuration"] as! String
            }
            if dict.keys.contains("BindResourceType") && dict["BindResourceType"] != nil {
                self.bindResourceType = dict["BindResourceType"] as! String
            }
            if dict.keys.contains("BindVpcCidr") && dict["BindVpcCidr"] != nil {
                self.bindVpcCidr = dict["BindVpcCidr"] as! String
            }
            if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("EnvironmentName") && dict["EnvironmentName"] != nil {
                self.environmentName = dict["EnvironmentName"] as! String
            }
            if dict.keys.contains("EnvironmentSubType") && dict["EnvironmentSubType"] != nil {
                self.environmentSubType = dict["EnvironmentSubType"] as! String
            }
            if dict.keys.contains("EnvironmentType") && dict["EnvironmentType"] != nil {
                self.environmentType = dict["EnvironmentType"] as! String
            }
            if dict.keys.contains("GrafaDataSourceName") && dict["GrafaDataSourceName"] != nil {
                self.grafaDataSourceName = dict["GrafaDataSourceName"] as! String
            }
            if dict.keys.contains("GrafanaDatasourceUid") && dict["GrafanaDatasourceUid"] != nil {
                self.grafanaDatasourceUid = dict["GrafanaDatasourceUid"] as! String
            }
            if dict.keys.contains("GrafanaFolderTitle") && dict["GrafanaFolderTitle"] != nil {
                self.grafanaFolderTitle = dict["GrafanaFolderTitle"] as! String
            }
            if dict.keys.contains("GrafanaFolderUid") && dict["GrafanaFolderUid"] != nil {
                self.grafanaFolderUid = dict["GrafanaFolderUid"] as! String
            }
            if dict.keys.contains("GrafanaFolderUrl") && dict["GrafanaFolderUrl"] != nil {
                self.grafanaFolderUrl = dict["GrafanaFolderUrl"] as! String
            }
            if dict.keys.contains("PrometheusInstanceId") && dict["PrometheusInstanceId"] != nil {
                self.prometheusInstanceId = dict["PrometheusInstanceId"] as! String
            }
            if dict.keys.contains("PrometheusInstanceName") && dict["PrometheusInstanceName"] != nil {
                self.prometheusInstanceName = dict["PrometheusInstanceName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [DescribeEnvironmentResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeEnvironmentResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvironmentResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeEnvironmentResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnvironmentFeatureRequest : Tea.TeaModel {
    public var environmentId: String?

    public var featureName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") && dict["FeatureName"] != nil {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEnvironmentFeatureResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Feature : Tea.TeaModel {
            public var alias: String?

            public var config: [String: String]?

            public var description_: String?

            public var environmentId: String?

            public var icon: String?

            public var language: String?

            public var latestVersion: String?

            public var name: String?

            public var status: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.config != nil {
                    map["Config"] = self.config!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.environmentId != nil {
                    map["EnvironmentId"] = self.environmentId!
                }
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.latestVersion != nil {
                    map["LatestVersion"] = self.latestVersion!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("Config") && dict["Config"] != nil {
                    self.config = dict["Config"] as! [String: String]
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                    self.environmentId = dict["EnvironmentId"] as! String
                }
                if dict.keys.contains("Icon") && dict["Icon"] != nil {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Language") && dict["Language"] != nil {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("LatestVersion") && dict["LatestVersion"] != nil {
                    self.latestVersion = dict["LatestVersion"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class FeatureStatus : Tea.TeaModel {
            public class FeatureContainers : Tea.TeaModel {
                public var args: [String]?

                public var image: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.args != nil {
                        map["Args"] = self.args!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Args") && dict["Args"] != nil {
                        self.args = dict["Args"] as! [String]
                    }
                    if dict.keys.contains("Image") && dict["Image"] != nil {
                        self.image = dict["Image"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var featureContainers: [DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus.FeatureContainers]?

            public var name: String?

            public var namespace: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.featureContainers != nil {
                    var tmp : [Any] = []
                    for k in self.featureContainers! {
                        tmp.append(k.toMap())
                    }
                    map["FeatureContainers"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FeatureContainers") && dict["FeatureContainers"] != nil {
                    var tmp : [DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus.FeatureContainers] = []
                    for v in dict["FeatureContainers"] as! [Any] {
                        var model = DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus.FeatureContainers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.featureContainers = tmp
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var feature: DescribeEnvironmentFeatureResponseBody.Data.Feature?

        public var featureStatus: DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.feature?.validate()
            try self.featureStatus?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feature != nil {
                map["Feature"] = self.feature?.toMap()
            }
            if self.featureStatus != nil {
                map["FeatureStatus"] = self.featureStatus?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Feature") && dict["Feature"] != nil {
                var model = DescribeEnvironmentFeatureResponseBody.Data.Feature()
                model.fromMap(dict["Feature"] as! [String: Any])
                self.feature = model
            }
            if dict.keys.contains("FeatureStatus") && dict["FeatureStatus"] != nil {
                var model = DescribeEnvironmentFeatureResponseBody.Data.FeatureStatus()
                model.fromMap(dict["FeatureStatus"] as! [String: Any])
                self.featureStatus = model
            }
        }
    }
    public var code: Int32?

    public var data: DescribeEnvironmentFeatureResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeEnvironmentFeatureResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIMRobotsRequest : Tea.TeaModel {
    public var page: Int64?

    public var robotIds: String?

    public var robotName: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.robotIds != nil {
            map["RobotIds"] = self.robotIds!
        }
        if self.robotName != nil {
            map["RobotName"] = self.robotName!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RobotIds") && dict["RobotIds"] != nil {
            self.robotIds = dict["RobotIds"] as! String
        }
        if dict.keys.contains("RobotName") && dict["RobotName"] != nil {
            self.robotName = dict["RobotName"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class DescribeIMRobotsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertIMRobots : Tea.TeaModel {
            public class DispatchRules : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("id") && dict["id"] != nil {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public var createTime: String?

            public var dailyNoc: Bool?

            public var dailyNocTime: String?

            public var dingSignKey: String?

            public var dispatchRules: [DescribeIMRobotsResponseBody.PageBean.AlertIMRobots.DispatchRules]?

            public var robotAddr: String?

            public var robotId: Double?

            public var robotName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dailyNoc != nil {
                    map["DailyNoc"] = self.dailyNoc!
                }
                if self.dailyNocTime != nil {
                    map["DailyNocTime"] = self.dailyNocTime!
                }
                if self.dingSignKey != nil {
                    map["DingSignKey"] = self.dingSignKey!
                }
                if self.dispatchRules != nil {
                    var tmp : [Any] = []
                    for k in self.dispatchRules! {
                        tmp.append(k.toMap())
                    }
                    map["DispatchRules"] = tmp
                }
                if self.robotAddr != nil {
                    map["RobotAddr"] = self.robotAddr!
                }
                if self.robotId != nil {
                    map["RobotId"] = self.robotId!
                }
                if self.robotName != nil {
                    map["RobotName"] = self.robotName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DailyNoc") && dict["DailyNoc"] != nil {
                    self.dailyNoc = dict["DailyNoc"] as! Bool
                }
                if dict.keys.contains("DailyNocTime") && dict["DailyNocTime"] != nil {
                    self.dailyNocTime = dict["DailyNocTime"] as! String
                }
                if dict.keys.contains("DingSignKey") && dict["DingSignKey"] != nil {
                    self.dingSignKey = dict["DingSignKey"] as! String
                }
                if dict.keys.contains("DispatchRules") && dict["DispatchRules"] != nil {
                    var tmp : [DescribeIMRobotsResponseBody.PageBean.AlertIMRobots.DispatchRules] = []
                    for v in dict["DispatchRules"] as! [Any] {
                        var model = DescribeIMRobotsResponseBody.PageBean.AlertIMRobots.DispatchRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dispatchRules = tmp
                }
                if dict.keys.contains("RobotAddr") && dict["RobotAddr"] != nil {
                    self.robotAddr = dict["RobotAddr"] as! String
                }
                if dict.keys.contains("RobotId") && dict["RobotId"] != nil {
                    self.robotId = dict["RobotId"] as! Double
                }
                if dict.keys.contains("RobotName") && dict["RobotName"] != nil {
                    self.robotName = dict["RobotName"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var alertIMRobots: [DescribeIMRobotsResponseBody.PageBean.AlertIMRobots]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertIMRobots != nil {
                var tmp : [Any] = []
                for k in self.alertIMRobots! {
                    tmp.append(k.toMap())
                }
                map["AlertIMRobots"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertIMRobots") && dict["AlertIMRobots"] != nil {
                var tmp : [DescribeIMRobotsResponseBody.PageBean.AlertIMRobots] = []
                for v in dict["AlertIMRobots"] as! [Any] {
                    var model = DescribeIMRobotsResponseBody.PageBean.AlertIMRobots()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertIMRobots = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: DescribeIMRobotsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = DescribeIMRobotsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeIMRobotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIMRobotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeIMRobotsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrometheusAlertRuleRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class DescribePrometheusAlertRuleResponseBody : Tea.TeaModel {
    public class PrometheusAlertRule : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertId: Int64?

        public var alertName: String?

        public var annotations: [DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations]?

        public var clusterId: String?

        public var dispatchRuleId: Int64?

        public var duration: String?

        public var expression: String?

        public var labels: [DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels]?

        public var message: String?

        public var notifyType: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dispatchRuleId != nil {
                map["DispatchRuleId"] = self.dispatchRuleId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
                self.alertId = dict["AlertId"] as! Int64
            }
            if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                var tmp : [DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("DispatchRuleId") && dict["DispatchRuleId"] != nil {
                self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") && dict["Expression"] != nil {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
                self.notifyType = dict["NotifyType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int64?

    public var message: String?

    public var prometheusAlertRule: DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prometheusAlertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.prometheusAlertRule != nil {
            map["PrometheusAlertRule"] = self.prometheusAlertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PrometheusAlertRule") && dict["PrometheusAlertRule"] != nil {
            var model = DescribePrometheusAlertRuleResponseBody.PrometheusAlertRule()
            model.fromMap(dict["PrometheusAlertRule"] as! [String: Any])
            self.prometheusAlertRule = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribePrometheusAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrometheusAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePrometheusAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTraceLicenseKeyRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeTraceLicenseKeyResponseBody : Tea.TeaModel {
    public var licenseKey: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.licenseKey != nil {
            map["LicenseKey"] = self.licenseKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LicenseKey") && dict["LicenseKey"] != nil {
            self.licenseKey = dict["LicenseKey"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeTraceLicenseKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTraceLicenseKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTraceLicenseKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebhookContactsRequest : Tea.TeaModel {
    public var contactIds: String?

    public var page: Int64?

    public var size: Int64?

    public var webhookName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.webhookName != nil {
            map["WebhookName"] = self.webhookName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIds") && dict["ContactIds"] != nil {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("WebhookName") && dict["WebhookName"] != nil {
            self.webhookName = dict["WebhookName"] as! String
        }
    }
}

public class DescribeWebhookContactsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class WebhookContacts : Tea.TeaModel {
            public class Webhook : Tea.TeaModel {
                public var bizHeaders: [String: Any]?

                public var bizParams: [String: Any]?

                public var body: String?

                public var method: String?

                public var recoverBody: String?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizHeaders != nil {
                        map["BizHeaders"] = self.bizHeaders!
                    }
                    if self.bizParams != nil {
                        map["BizParams"] = self.bizParams!
                    }
                    if self.body != nil {
                        map["Body"] = self.body!
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    if self.recoverBody != nil {
                        map["RecoverBody"] = self.recoverBody!
                    }
                    if self.url != nil {
                        map["Url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizHeaders") && dict["BizHeaders"] != nil {
                        self.bizHeaders = dict["BizHeaders"] as! [String: Any]
                    }
                    if dict.keys.contains("BizParams") && dict["BizParams"] != nil {
                        self.bizParams = dict["BizParams"] as! [String: Any]
                    }
                    if dict.keys.contains("Body") && dict["Body"] != nil {
                        self.body = dict["Body"] as! String
                    }
                    if dict.keys.contains("Method") && dict["Method"] != nil {
                        self.method = dict["Method"] as! String
                    }
                    if dict.keys.contains("RecoverBody") && dict["RecoverBody"] != nil {
                        self.recoverBody = dict["RecoverBody"] as! String
                    }
                    if dict.keys.contains("Url") && dict["Url"] != nil {
                        self.url = dict["Url"] as! String
                    }
                }
            }
            public var webhook: DescribeWebhookContactsResponseBody.PageBean.WebhookContacts.Webhook?

            public var webhookId: Double?

            public var webhookName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.webhook?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.webhook != nil {
                    map["Webhook"] = self.webhook?.toMap()
                }
                if self.webhookId != nil {
                    map["WebhookId"] = self.webhookId!
                }
                if self.webhookName != nil {
                    map["WebhookName"] = self.webhookName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                    var model = DescribeWebhookContactsResponseBody.PageBean.WebhookContacts.Webhook()
                    model.fromMap(dict["Webhook"] as! [String: Any])
                    self.webhook = model
                }
                if dict.keys.contains("WebhookId") && dict["WebhookId"] != nil {
                    self.webhookId = dict["WebhookId"] as! Double
                }
                if dict.keys.contains("WebhookName") && dict["WebhookName"] != nil {
                    self.webhookName = dict["WebhookName"] as! String
                }
            }
        }
        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public var webhookContacts: [DescribeWebhookContactsResponseBody.PageBean.WebhookContacts]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            if self.webhookContacts != nil {
                var tmp : [Any] = []
                for k in self.webhookContacts! {
                    tmp.append(k.toMap())
                }
                map["WebhookContacts"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
            if dict.keys.contains("WebhookContacts") && dict["WebhookContacts"] != nil {
                var tmp : [DescribeWebhookContactsResponseBody.PageBean.WebhookContacts] = []
                for v in dict["WebhookContacts"] as! [Any] {
                    var model = DescribeWebhookContactsResponseBody.PageBean.WebhookContacts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.webhookContacts = tmp
            }
        }
    }
    public var pageBean: DescribeWebhookContactsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = DescribeWebhookContactsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeWebhookContactsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebhookContactsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebhookContactsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableMetricRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dropMetric: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dropMetric != nil {
            map["DropMetric"] = self.dropMetric!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DropMetric") && dict["DropMetric"] != nil {
            self.dropMetric = dict["DropMetric"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class EnableMetricResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAgentDownloadUrlRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetAgentDownloadUrlResponseBody : Tea.TeaModel {
    public var armsAgentDownloadUrl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.armsAgentDownloadUrl != nil {
            map["ArmsAgentDownloadUrl"] = self.armsAgentDownloadUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ArmsAgentDownloadUrl") && dict["ArmsAgentDownloadUrl"] != nil {
            self.armsAgentDownloadUrl = dict["ArmsAgentDownloadUrl"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAgentDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAgentDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAgentDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAlertRulesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertIds: String?

    public var alertNames: String?

    public var alertStatus: String?

    public var alertType: String?

    public var clusterId: String?

    public var page: Int64?

    public var productCode: String?

    public var regionId: String?

    public var size: Int64?

    public var tags: [GetAlertRulesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertIds != nil {
            map["AlertIds"] = self.alertIds!
        }
        if self.alertNames != nil {
            map["AlertNames"] = self.alertNames!
        }
        if self.alertStatus != nil {
            map["AlertStatus"] = self.alertStatus!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertIds") && dict["AlertIds"] != nil {
            self.alertIds = dict["AlertIds"] as! String
        }
        if dict.keys.contains("AlertNames") && dict["AlertNames"] != nil {
            self.alertNames = dict["AlertNames"] as! String
        }
        if dict.keys.contains("AlertStatus") && dict["AlertStatus"] != nil {
            self.alertStatus = dict["AlertStatus"] as! String
        }
        if dict.keys.contains("AlertType") && dict["AlertType"] != nil {
            self.alertType = dict["AlertType"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [GetAlertRulesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetAlertRulesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetAlertRulesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertRules : Tea.TeaModel {
            public class AlertRuleContent : Tea.TeaModel {
                public class AlertRuleItems : Tea.TeaModel {
                    public var aggregate: String?

                    public var metricKey: String?

                    public var n: Double?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.aggregate != nil {
                            map["Aggregate"] = self.aggregate!
                        }
                        if self.metricKey != nil {
                            map["MetricKey"] = self.metricKey!
                        }
                        if self.n != nil {
                            map["N"] = self.n!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Aggregate") && dict["Aggregate"] != nil {
                            self.aggregate = dict["Aggregate"] as! String
                        }
                        if dict.keys.contains("MetricKey") && dict["MetricKey"] != nil {
                            self.metricKey = dict["MetricKey"] as! String
                        }
                        if dict.keys.contains("N") && dict["N"] != nil {
                            self.n = dict["N"] as! Double
                        }
                        if dict.keys.contains("Operator") && dict["Operator"] != nil {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var alertRuleItems: [GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent.AlertRuleItems]?

                public var condition: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alertRuleItems != nil {
                        var tmp : [Any] = []
                        for k in self.alertRuleItems! {
                            tmp.append(k.toMap())
                        }
                        map["AlertRuleItems"] = tmp
                    }
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlertRuleItems") && dict["AlertRuleItems"] != nil {
                        var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent.AlertRuleItems] = []
                        for v in dict["AlertRuleItems"] as! [Any] {
                            var model = GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent.AlertRuleItems()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.alertRuleItems = tmp
                    }
                    if dict.keys.contains("Condition") && dict["Condition"] != nil {
                        self.condition = dict["Condition"] as! String
                    }
                }
            }
            public class Annotations : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Filters : Tea.TeaModel {
                public class CustomSLSFilters : Tea.TeaModel {
                    public var key: String?

                    public var opt: String?

                    public var show: Bool?

                    public var t: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.opt != nil {
                            map["Opt"] = self.opt!
                        }
                        if self.show != nil {
                            map["Show"] = self.show!
                        }
                        if self.t != nil {
                            map["T"] = self.t!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Opt") && dict["Opt"] != nil {
                            self.opt = dict["Opt"] as! String
                        }
                        if dict.keys.contains("Show") && dict["Show"] != nil {
                            self.show = dict["Show"] as! Bool
                        }
                        if dict.keys.contains("T") && dict["T"] != nil {
                            self.t = dict["T"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class DimFilters : Tea.TeaModel {
                    public var filterKey: String?

                    public var filterOpt: String?

                    public var filterValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.filterKey != nil {
                            map["FilterKey"] = self.filterKey!
                        }
                        if self.filterOpt != nil {
                            map["FilterOpt"] = self.filterOpt!
                        }
                        if self.filterValues != nil {
                            map["FilterValues"] = self.filterValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FilterKey") && dict["FilterKey"] != nil {
                            self.filterKey = dict["FilterKey"] as! String
                        }
                        if dict.keys.contains("FilterOpt") && dict["FilterOpt"] != nil {
                            self.filterOpt = dict["FilterOpt"] as! String
                        }
                        if dict.keys.contains("FilterValues") && dict["FilterValues"] != nil {
                            self.filterValues = dict["FilterValues"] as! [String]
                        }
                    }
                }
                public var customSLSFilters: [GetAlertRulesResponseBody.PageBean.AlertRules.Filters.CustomSLSFilters]?

                public var customSLSGroupByDimensions: [String]?

                public var customSLSWheres: [String]?

                public var dimFilters: [GetAlertRulesResponseBody.PageBean.AlertRules.Filters.DimFilters]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.customSLSFilters != nil {
                        var tmp : [Any] = []
                        for k in self.customSLSFilters! {
                            tmp.append(k.toMap())
                        }
                        map["CustomSLSFilters"] = tmp
                    }
                    if self.customSLSGroupByDimensions != nil {
                        map["CustomSLSGroupByDimensions"] = self.customSLSGroupByDimensions!
                    }
                    if self.customSLSWheres != nil {
                        map["CustomSLSWheres"] = self.customSLSWheres!
                    }
                    if self.dimFilters != nil {
                        var tmp : [Any] = []
                        for k in self.dimFilters! {
                            tmp.append(k.toMap())
                        }
                        map["DimFilters"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CustomSLSFilters") && dict["CustomSLSFilters"] != nil {
                        var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Filters.CustomSLSFilters] = []
                        for v in dict["CustomSLSFilters"] as! [Any] {
                            var model = GetAlertRulesResponseBody.PageBean.AlertRules.Filters.CustomSLSFilters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.customSLSFilters = tmp
                    }
                    if dict.keys.contains("CustomSLSGroupByDimensions") && dict["CustomSLSGroupByDimensions"] != nil {
                        self.customSLSGroupByDimensions = dict["CustomSLSGroupByDimensions"] as! [String]
                    }
                    if dict.keys.contains("CustomSLSWheres") && dict["CustomSLSWheres"] != nil {
                        self.customSLSWheres = dict["CustomSLSWheres"] as! [String]
                    }
                    if dict.keys.contains("DimFilters") && dict["DimFilters"] != nil {
                        var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Filters.DimFilters] = []
                        for v in dict["DimFilters"] as! [Any] {
                            var model = GetAlertRulesResponseBody.PageBean.AlertRules.Filters.DimFilters()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dimFilters = tmp
                    }
                }
            }
            public class Labels : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var alertCheckType: String?

            public var alertGroup: Int64?

            public var alertId: Double?

            public var alertName: String?

            public var alertRuleContent: GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent?

            public var alertStatus: String?

            public var alertType: String?

            public var annotations: [GetAlertRulesResponseBody.PageBean.AlertRules.Annotations]?

            public var autoAddNewApplication: Bool?

            public var clusterId: String?

            public var createdTime: Int64?

            public var duration: String?

            public var extend: String?

            public var filters: GetAlertRulesResponseBody.PageBean.AlertRules.Filters?

            public var labels: [GetAlertRulesResponseBody.PageBean.AlertRules.Labels]?

            public var level: String?

            public var message: String?

            public var metricsType: String?

            public var notifyStrategy: String?

            public var pids: [String]?

            public var promQL: String?

            public var regionId: String?

            public var tags: [GetAlertRulesResponseBody.PageBean.AlertRules.Tags]?

            public var updatedTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.alertRuleContent?.validate()
                try self.filters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertCheckType != nil {
                    map["AlertCheckType"] = self.alertCheckType!
                }
                if self.alertGroup != nil {
                    map["AlertGroup"] = self.alertGroup!
                }
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.alertRuleContent != nil {
                    map["AlertRuleContent"] = self.alertRuleContent?.toMap()
                }
                if self.alertStatus != nil {
                    map["AlertStatus"] = self.alertStatus!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.annotations != nil {
                    var tmp : [Any] = []
                    for k in self.annotations! {
                        tmp.append(k.toMap())
                    }
                    map["Annotations"] = tmp
                }
                if self.autoAddNewApplication != nil {
                    map["AutoAddNewApplication"] = self.autoAddNewApplication!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.extend != nil {
                    map["Extend"] = self.extend!
                }
                if self.filters != nil {
                    map["Filters"] = self.filters?.toMap()
                }
                if self.labels != nil {
                    var tmp : [Any] = []
                    for k in self.labels! {
                        tmp.append(k.toMap())
                    }
                    map["Labels"] = tmp
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.metricsType != nil {
                    map["MetricsType"] = self.metricsType!
                }
                if self.notifyStrategy != nil {
                    map["NotifyStrategy"] = self.notifyStrategy!
                }
                if self.pids != nil {
                    map["Pids"] = self.pids!
                }
                if self.promQL != nil {
                    map["PromQL"] = self.promQL!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertCheckType") && dict["AlertCheckType"] != nil {
                    self.alertCheckType = dict["AlertCheckType"] as! String
                }
                if dict.keys.contains("AlertGroup") && dict["AlertGroup"] != nil {
                    self.alertGroup = dict["AlertGroup"] as! Int64
                }
                if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
                    self.alertId = dict["AlertId"] as! Double
                }
                if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("AlertRuleContent") && dict["AlertRuleContent"] != nil {
                    var model = GetAlertRulesResponseBody.PageBean.AlertRules.AlertRuleContent()
                    model.fromMap(dict["AlertRuleContent"] as! [String: Any])
                    self.alertRuleContent = model
                }
                if dict.keys.contains("AlertStatus") && dict["AlertStatus"] != nil {
                    self.alertStatus = dict["AlertStatus"] as! String
                }
                if dict.keys.contains("AlertType") && dict["AlertType"] != nil {
                    self.alertType = dict["AlertType"] as! String
                }
                if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                    var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Annotations] = []
                    for v in dict["Annotations"] as! [Any] {
                        var model = GetAlertRulesResponseBody.PageBean.AlertRules.Annotations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.annotations = tmp
                }
                if dict.keys.contains("AutoAddNewApplication") && dict["AutoAddNewApplication"] != nil {
                    self.autoAddNewApplication = dict["AutoAddNewApplication"] as! Bool
                }
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! Int64
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Extend") && dict["Extend"] != nil {
                    self.extend = dict["Extend"] as! String
                }
                if dict.keys.contains("Filters") && dict["Filters"] != nil {
                    var model = GetAlertRulesResponseBody.PageBean.AlertRules.Filters()
                    model.fromMap(dict["Filters"] as! [String: Any])
                    self.filters = model
                }
                if dict.keys.contains("Labels") && dict["Labels"] != nil {
                    var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Labels] = []
                    for v in dict["Labels"] as! [Any] {
                        var model = GetAlertRulesResponseBody.PageBean.AlertRules.Labels()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.labels = tmp
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("MetricsType") && dict["MetricsType"] != nil {
                    self.metricsType = dict["MetricsType"] as! String
                }
                if dict.keys.contains("NotifyStrategy") && dict["NotifyStrategy"] != nil {
                    self.notifyStrategy = dict["NotifyStrategy"] as! String
                }
                if dict.keys.contains("Pids") && dict["Pids"] != nil {
                    self.pids = dict["Pids"] as! [String]
                }
                if dict.keys.contains("PromQL") && dict["PromQL"] != nil {
                    self.promQL = dict["PromQL"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = GetAlertRulesResponseBody.PageBean.AlertRules.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                    self.updatedTime = dict["UpdatedTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var alertRules: [GetAlertRulesResponseBody.PageBean.AlertRules]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertRules != nil {
                var tmp : [Any] = []
                for k in self.alertRules! {
                    tmp.append(k.toMap())
                }
                map["AlertRules"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertRules") && dict["AlertRules"] != nil {
                var tmp : [GetAlertRulesResponseBody.PageBean.AlertRules] = []
                for v in dict["AlertRules"] as! [Any] {
                    var model = GetAlertRulesResponseBody.PageBean.AlertRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertRules = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: GetAlertRulesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = GetAlertRulesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppApiByPageRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var endTime: Int64?

    public var intervalMills: Int32?

    public var PId: String?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.intervalMills != nil {
            map["IntervalMills"] = self.intervalMills!
        }
        if self.PId != nil {
            map["PId"] = self.PId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("IntervalMills") && dict["IntervalMills"] != nil {
            self.intervalMills = dict["IntervalMills"] as! Int32
        }
        if dict.keys.contains("PId") && dict["PId"] != nil {
            self.PId = dict["PId"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetAppApiByPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var completed: Bool?

        public var items: [[String: Any]]?

        public var page: Int32?

        public var pageSize: Int32?

        public var total: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completed != nil {
                map["Completed"] = self.completed!
            }
            if self.items != nil {
                map["Items"] = self.items!
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Completed") && dict["Completed"] != nil {
                self.completed = dict["Completed"] as! Bool
            }
            if dict.keys.contains("Items") && dict["Items"] != nil {
                self.items = dict["Items"] as! [[String: Any]]
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetAppApiByPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetAppApiByPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAppApiByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppApiByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAppApiByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuthTokenRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetAuthTokenResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAuthTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuthTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAuthTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCloudClusterAllUrlRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetCloudClusterAllUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RemoteUrl : Tea.TeaModel {
            public var authToken: Bool?

            public var grafanaUrl: String?

            public var internetGrafanaUrl: String?

            public var internetPushGatewayUrl: String?

            public var internetRemoteReadUrl: String?

            public var internetRemoteWriteUrl: String?

            public var pushGatewayUrl: String?

            public var remoteReadUrl: String?

            public var remoteWriteUrl: String?

            public var token: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authToken != nil {
                    map["AuthToken"] = self.authToken!
                }
                if self.grafanaUrl != nil {
                    map["GrafanaUrl"] = self.grafanaUrl!
                }
                if self.internetGrafanaUrl != nil {
                    map["InternetGrafanaUrl"] = self.internetGrafanaUrl!
                }
                if self.internetPushGatewayUrl != nil {
                    map["InternetPushGatewayUrl"] = self.internetPushGatewayUrl!
                }
                if self.internetRemoteReadUrl != nil {
                    map["InternetRemoteReadUrl"] = self.internetRemoteReadUrl!
                }
                if self.internetRemoteWriteUrl != nil {
                    map["InternetRemoteWriteUrl"] = self.internetRemoteWriteUrl!
                }
                if self.pushGatewayUrl != nil {
                    map["PushGatewayUrl"] = self.pushGatewayUrl!
                }
                if self.remoteReadUrl != nil {
                    map["RemoteReadUrl"] = self.remoteReadUrl!
                }
                if self.remoteWriteUrl != nil {
                    map["RemoteWriteUrl"] = self.remoteWriteUrl!
                }
                if self.token != nil {
                    map["Token"] = self.token!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthToken") && dict["AuthToken"] != nil {
                    self.authToken = dict["AuthToken"] as! Bool
                }
                if dict.keys.contains("GrafanaUrl") && dict["GrafanaUrl"] != nil {
                    self.grafanaUrl = dict["GrafanaUrl"] as! String
                }
                if dict.keys.contains("InternetGrafanaUrl") && dict["InternetGrafanaUrl"] != nil {
                    self.internetGrafanaUrl = dict["InternetGrafanaUrl"] as! String
                }
                if dict.keys.contains("InternetPushGatewayUrl") && dict["InternetPushGatewayUrl"] != nil {
                    self.internetPushGatewayUrl = dict["InternetPushGatewayUrl"] as! String
                }
                if dict.keys.contains("InternetRemoteReadUrl") && dict["InternetRemoteReadUrl"] != nil {
                    self.internetRemoteReadUrl = dict["InternetRemoteReadUrl"] as! String
                }
                if dict.keys.contains("InternetRemoteWriteUrl") && dict["InternetRemoteWriteUrl"] != nil {
                    self.internetRemoteWriteUrl = dict["InternetRemoteWriteUrl"] as! String
                }
                if dict.keys.contains("PushGatewayUrl") && dict["PushGatewayUrl"] != nil {
                    self.pushGatewayUrl = dict["PushGatewayUrl"] as! String
                }
                if dict.keys.contains("RemoteReadUrl") && dict["RemoteReadUrl"] != nil {
                    self.remoteReadUrl = dict["RemoteReadUrl"] as! String
                }
                if dict.keys.contains("RemoteWriteUrl") && dict["RemoteWriteUrl"] != nil {
                    self.remoteWriteUrl = dict["RemoteWriteUrl"] as! String
                }
                if dict.keys.contains("Token") && dict["Token"] != nil {
                    self.token = dict["Token"] as! String
                }
            }
        }
        public var productCode: String?

        public var region: String?

        public var remoteUrl: GetCloudClusterAllUrlResponseBody.Data.RemoteUrl?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.remoteUrl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.productCode != nil {
                map["ProductCode"] = self.productCode!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.remoteUrl != nil {
                map["RemoteUrl"] = self.remoteUrl?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
                self.productCode = dict["ProductCode"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("RemoteUrl") && dict["RemoteUrl"] != nil {
                var model = GetCloudClusterAllUrlResponseBody.Data.RemoteUrl()
                model.fromMap(dict["RemoteUrl"] as! [String: Any])
                self.remoteUrl = model
            }
        }
    }
    public var code: Int32?

    public var data: [GetCloudClusterAllUrlResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetCloudClusterAllUrlResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetCloudClusterAllUrlResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetCloudClusterAllUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCloudClusterAllUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCloudClusterAllUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClusterAllUrlRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetClusterAllUrlResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetClusterAllUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterAllUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetClusterAllUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetExploreUrlRequest : Tea.TeaModel {
    public var clusterId: String?

    public var expression: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.expression != nil {
            map["Expression"] = self.expression!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Expression") && dict["Expression"] != nil {
            self.expression = dict["Expression"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetExploreUrlResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetExploreUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetExploreUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetExploreUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIntegrationStateRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integration: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integration != nil {
            map["Integration"] = self.integration!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Integration") && dict["Integration"] != nil {
            self.integration = dict["Integration"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetIntegrationStateResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var state: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! Bool
        }
    }
}

public class GetIntegrationStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIntegrationStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetIntegrationStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetManagedPrometheusStatusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class GetManagedPrometheusStatusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetManagedPrometheusStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetManagedPrometheusStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetManagedPrometheusStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultipleTraceRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var regionId: String?

    public var startTime: Int64?

    public var traceIDs: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.traceIDs != nil {
            map["TraceIDs"] = self.traceIDs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TraceIDs") && dict["TraceIDs"] != nil {
            self.traceIDs = dict["TraceIDs"] as! [String]
        }
    }
}

public class GetMultipleTraceResponseBody : Tea.TeaModel {
    public class MultiCallChainInfos : Tea.TeaModel {
        public class Spans : Tea.TeaModel {
            public class LogEventList : Tea.TeaModel {
                public class TagEntryList : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagEntryList: [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList.TagEntryList]?

                public var timestamp: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagEntryList != nil {
                        var tmp : [Any] = []
                        for k in self.tagEntryList! {
                            tmp.append(k.toMap())
                        }
                        map["TagEntryList"] = tmp
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagEntryList") && dict["TagEntryList"] != nil {
                        var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList.TagEntryList] = []
                        for v in dict["TagEntryList"] as! [Any] {
                            var model = GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList.TagEntryList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tagEntryList = tmp
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                }
            }
            public class TagEntryList : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var duration: Int64?

            public var haveStack: Bool?

            public var logEventList: [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList]?

            public var operationName: String?

            public var parentSpanId: String?

            public var resultCode: String?

            public var rpcId: String?

            public var rpcType: Int32?

            public var serviceIp: String?

            public var serviceName: String?

            public var spanId: String?

            public var tagEntryList: [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.TagEntryList]?

            public var timestamp: Int64?

            public var traceID: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.haveStack != nil {
                    map["HaveStack"] = self.haveStack!
                }
                if self.logEventList != nil {
                    var tmp : [Any] = []
                    for k in self.logEventList! {
                        tmp.append(k.toMap())
                    }
                    map["LogEventList"] = tmp
                }
                if self.operationName != nil {
                    map["OperationName"] = self.operationName!
                }
                if self.parentSpanId != nil {
                    map["ParentSpanId"] = self.parentSpanId!
                }
                if self.resultCode != nil {
                    map["ResultCode"] = self.resultCode!
                }
                if self.rpcId != nil {
                    map["RpcId"] = self.rpcId!
                }
                if self.rpcType != nil {
                    map["RpcType"] = self.rpcType!
                }
                if self.serviceIp != nil {
                    map["ServiceIp"] = self.serviceIp!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.spanId != nil {
                    map["SpanId"] = self.spanId!
                }
                if self.tagEntryList != nil {
                    var tmp : [Any] = []
                    for k in self.tagEntryList! {
                        tmp.append(k.toMap())
                    }
                    map["TagEntryList"] = tmp
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.traceID != nil {
                    map["TraceID"] = self.traceID!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("HaveStack") && dict["HaveStack"] != nil {
                    self.haveStack = dict["HaveStack"] as! Bool
                }
                if dict.keys.contains("LogEventList") && dict["LogEventList"] != nil {
                    var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList] = []
                    for v in dict["LogEventList"] as! [Any] {
                        var model = GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.LogEventList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.logEventList = tmp
                }
                if dict.keys.contains("OperationName") && dict["OperationName"] != nil {
                    self.operationName = dict["OperationName"] as! String
                }
                if dict.keys.contains("ParentSpanId") && dict["ParentSpanId"] != nil {
                    self.parentSpanId = dict["ParentSpanId"] as! String
                }
                if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
                    self.resultCode = dict["ResultCode"] as! String
                }
                if dict.keys.contains("RpcId") && dict["RpcId"] != nil {
                    self.rpcId = dict["RpcId"] as! String
                }
                if dict.keys.contains("RpcType") && dict["RpcType"] != nil {
                    self.rpcType = dict["RpcType"] as! Int32
                }
                if dict.keys.contains("ServiceIp") && dict["ServiceIp"] != nil {
                    self.serviceIp = dict["ServiceIp"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("SpanId") && dict["SpanId"] != nil {
                    self.spanId = dict["SpanId"] as! String
                }
                if dict.keys.contains("TagEntryList") && dict["TagEntryList"] != nil {
                    var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.TagEntryList] = []
                    for v in dict["TagEntryList"] as! [Any] {
                        var model = GetMultipleTraceResponseBody.MultiCallChainInfos.Spans.TagEntryList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tagEntryList = tmp
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("TraceID") && dict["TraceID"] != nil {
                    self.traceID = dict["TraceID"] as! String
                }
            }
        }
        public var spans: [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans]?

        public var traceID: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.spans != nil {
                var tmp : [Any] = []
                for k in self.spans! {
                    tmp.append(k.toMap())
                }
                map["Spans"] = tmp
            }
            if self.traceID != nil {
                map["TraceID"] = self.traceID!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Spans") && dict["Spans"] != nil {
                var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos.Spans] = []
                for v in dict["Spans"] as! [Any] {
                    var model = GetMultipleTraceResponseBody.MultiCallChainInfos.Spans()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.spans = tmp
            }
            if dict.keys.contains("TraceID") && dict["TraceID"] != nil {
                self.traceID = dict["TraceID"] as! String
            }
        }
    }
    public var multiCallChainInfos: [GetMultipleTraceResponseBody.MultiCallChainInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.multiCallChainInfos != nil {
            var tmp : [Any] = []
            for k in self.multiCallChainInfos! {
                tmp.append(k.toMap())
            }
            map["MultiCallChainInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MultiCallChainInfos") && dict["MultiCallChainInfos"] != nil {
            var tmp : [GetMultipleTraceResponseBody.MultiCallChainInfos] = []
            for v in dict["MultiCallChainInfos"] as! [Any] {
                var model = GetMultipleTraceResponseBody.MultiCallChainInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.multiCallChainInfos = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMultipleTraceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultipleTraceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMultipleTraceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOnCallSchedulesDetailRequest : Tea.TeaModel {
    public var endTime: String?

    public var id: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetOnCallSchedulesDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RenderedFinnalEntries : Tea.TeaModel {
            public class SimpleContact : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var end: String?

            public var simpleContact: GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries.SimpleContact?

            public var start: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.simpleContact?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.simpleContact != nil {
                    map["SimpleContact"] = self.simpleContact?.toMap()
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") && dict["End"] != nil {
                    self.end = dict["End"] as! String
                }
                if dict.keys.contains("SimpleContact") && dict["SimpleContact"] != nil {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries.SimpleContact()
                    model.fromMap(dict["SimpleContact"] as! [String: Any])
                    self.simpleContact = model
                }
                if dict.keys.contains("Start") && dict["Start"] != nil {
                    self.start = dict["Start"] as! String
                }
            }
        }
        public class RenderedLayerEntries : Tea.TeaModel {
            public class SimpleContact : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var start: String?

            public var end: String?

            public var simpleContact: GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries.SimpleContact?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.simpleContact?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.start != nil {
                    map["Start"] = self.start!
                }
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.simpleContact != nil {
                    map["SimpleContact"] = self.simpleContact?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Start") && dict["Start"] != nil {
                    self.start = dict["Start"] as! String
                }
                if dict.keys.contains("End") && dict["End"] != nil {
                    self.end = dict["End"] as! String
                }
                if dict.keys.contains("SimpleContact") && dict["SimpleContact"] != nil {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries.SimpleContact()
                    model.fromMap(dict["SimpleContact"] as! [String: Any])
                    self.simpleContact = model
                }
            }
        }
        public class RenderedSubstitudeEntries : Tea.TeaModel {
            public class SimpleContact : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var end: String?

            public var simpleContact: GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries.SimpleContact?

            public var start: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.simpleContact?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.simpleContact != nil {
                    map["SimpleContact"] = self.simpleContact?.toMap()
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") && dict["End"] != nil {
                    self.end = dict["End"] as! String
                }
                if dict.keys.contains("SimpleContact") && dict["SimpleContact"] != nil {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries.SimpleContact()
                    model.fromMap(dict["SimpleContact"] as! [String: Any])
                    self.simpleContact = model
                }
                if dict.keys.contains("Start") && dict["Start"] != nil {
                    self.start = dict["Start"] as! String
                }
            }
        }
        public class ScheduleLayers : Tea.TeaModel {
            public class Restrictions : Tea.TeaModel {
                public var endTimeOfDay: String?

                public var restrictionType: String?

                public var startTimeOfDay: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTimeOfDay != nil {
                        map["EndTimeOfDay"] = self.endTimeOfDay!
                    }
                    if self.restrictionType != nil {
                        map["RestrictionType"] = self.restrictionType!
                    }
                    if self.startTimeOfDay != nil {
                        map["StartTimeOfDay"] = self.startTimeOfDay!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTimeOfDay") && dict["EndTimeOfDay"] != nil {
                        self.endTimeOfDay = dict["EndTimeOfDay"] as! String
                    }
                    if dict.keys.contains("RestrictionType") && dict["RestrictionType"] != nil {
                        self.restrictionType = dict["RestrictionType"] as! String
                    }
                    if dict.keys.contains("StartTimeOfDay") && dict["StartTimeOfDay"] != nil {
                        self.startTimeOfDay = dict["StartTimeOfDay"] as! String
                    }
                }
            }
            public var contactIds: [Int64]?

            public var restrictions: [GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers.Restrictions]?

            public var rotationType: String?

            public var shiftLength: Int64?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactIds != nil {
                    map["ContactIds"] = self.contactIds!
                }
                if self.restrictions != nil {
                    var tmp : [Any] = []
                    for k in self.restrictions! {
                        tmp.append(k.toMap())
                    }
                    map["Restrictions"] = tmp
                }
                if self.rotationType != nil {
                    map["RotationType"] = self.rotationType!
                }
                if self.shiftLength != nil {
                    map["ShiftLength"] = self.shiftLength!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactIds") && dict["ContactIds"] != nil {
                    self.contactIds = dict["ContactIds"] as! [Int64]
                }
                if dict.keys.contains("Restrictions") && dict["Restrictions"] != nil {
                    var tmp : [GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers.Restrictions] = []
                    for v in dict["Restrictions"] as! [Any] {
                        var model = GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers.Restrictions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restrictions = tmp
                }
                if dict.keys.contains("RotationType") && dict["RotationType"] != nil {
                    self.rotationType = dict["RotationType"] as! String
                }
                if dict.keys.contains("ShiftLength") && dict["ShiftLength"] != nil {
                    self.shiftLength = dict["ShiftLength"] as! Int64
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var alertRobotId: Int64?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var renderedFinnalEntries: [GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries]?

        public var renderedLayerEntries: [[GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries]]?

        public var renderedSubstitudeEntries: [GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries]?

        public var scheduleLayers: [GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertRobotId != nil {
                map["AlertRobotId"] = self.alertRobotId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.renderedFinnalEntries != nil {
                var tmp : [Any] = []
                for k in self.renderedFinnalEntries! {
                    tmp.append(k.toMap())
                }
                map["RenderedFinnalEntries"] = tmp
            }
            if self.renderedLayerEntries != nil {
                var tmp : [Any] = []
                for k in self.renderedLayerEntries! {
                    var l1 : [Any] = []
                    for k1 in k {
                        l1.append(k1.toMap())
                    }
                    tmp.append(l1)
                }
                map["RenderedLayerEntries"] = tmp
            }
            if self.renderedSubstitudeEntries != nil {
                var tmp : [Any] = []
                for k in self.renderedSubstitudeEntries! {
                    tmp.append(k.toMap())
                }
                map["RenderedSubstitudeEntries"] = tmp
            }
            if self.scheduleLayers != nil {
                var tmp : [Any] = []
                for k in self.scheduleLayers! {
                    tmp.append(k.toMap())
                }
                map["ScheduleLayers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertRobotId") && dict["AlertRobotId"] != nil {
                self.alertRobotId = dict["AlertRobotId"] as! Int64
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RenderedFinnalEntries") && dict["RenderedFinnalEntries"] != nil {
                var tmp : [GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries] = []
                for v in dict["RenderedFinnalEntries"] as! [Any] {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedFinnalEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.renderedFinnalEntries = tmp
            }
            if dict.keys.contains("RenderedLayerEntries") && dict["RenderedLayerEntries"] != nil {
                var tmp : [[GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries]] = []
                for v in dict["RenderedLayerEntries"] as! [Any] {
                    var l1 : [GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries] = []
                    for v1 in v as! [Any] {
                        var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedLayerEntries()
                        if v1 != nil {
                            model.fromMap(v1 as! [String: Any])
                        }
                        l1.append(model)
                    }
                    tmp.append(l1)
                }
                self.renderedLayerEntries = tmp
            }
            if dict.keys.contains("RenderedSubstitudeEntries") && dict["RenderedSubstitudeEntries"] != nil {
                var tmp : [GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries] = []
                for v in dict["RenderedSubstitudeEntries"] as! [Any] {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.RenderedSubstitudeEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.renderedSubstitudeEntries = tmp
            }
            if dict.keys.contains("ScheduleLayers") && dict["ScheduleLayers"] != nil {
                var tmp : [GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers] = []
                for v in dict["ScheduleLayers"] as! [Any] {
                    var model = GetOnCallSchedulesDetailResponseBody.Data.ScheduleLayers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scheduleLayers = tmp
            }
        }
    }
    public var data: GetOnCallSchedulesDetailResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetOnCallSchedulesDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetOnCallSchedulesDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOnCallSchedulesDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOnCallSchedulesDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusApiTokenRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetPrometheusApiTokenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetPrometheusApiTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusApiTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPrometheusApiTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusGlobalViewRequest : Tea.TeaModel {
    public var globalViewClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalViewClusterId") && dict["GlobalViewClusterId"] != nil {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusInstanceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetPrometheusInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: String?

        public var grafanaInstanceId: String?

        public var paymentType: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var resourceType: String?

        public var securityGroupId: String?

        public var subClustersJson: String?

        public var tags: [GetPrometheusInstanceResponseBody.Data.Tags]?

        public var userId: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.grafanaInstanceId != nil {
                map["GrafanaInstanceId"] = self.grafanaInstanceId!
            }
            if self.paymentType != nil {
                map["PaymentType"] = self.paymentType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.subClustersJson != nil {
                map["SubClustersJson"] = self.subClustersJson!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("GrafanaInstanceId") && dict["GrafanaInstanceId"] != nil {
                self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
            }
            if dict.keys.contains("PaymentType") && dict["PaymentType"] != nil {
                self.paymentType = dict["PaymentType"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SubClustersJson") && dict["SubClustersJson"] != nil {
                self.subClustersJson = dict["SubClustersJson"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [GetPrometheusInstanceResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetPrometheusInstanceResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetPrometheusInstanceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetPrometheusInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPrometheusInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPrometheusInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceId: Int64?

    public var integrationType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetPrometheusIntegrationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var canDelete: Bool?

        public var canEditor: Bool?

        public var clusterId: String?

        public var containerName: String?

        public var describe: String?

        public var exporterType: String?

        public var instanceId: Int64?

        public var instanceName: String?

        public var integrationType: String?

        public var namespace: String?

        public var needUpgrade: Bool?

        public var param: String?

        public var showDescribe: Bool?

        public var showLog: String?

        public var status: String?

        public var target: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canDelete != nil {
                map["CanDelete"] = self.canDelete!
            }
            if self.canEditor != nil {
                map["CanEditor"] = self.canEditor!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.containerName != nil {
                map["ContainerName"] = self.containerName!
            }
            if self.describe != nil {
                map["Describe"] = self.describe!
            }
            if self.exporterType != nil {
                map["ExporterType"] = self.exporterType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.integrationType != nil {
                map["IntegrationType"] = self.integrationType!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.needUpgrade != nil {
                map["NeedUpgrade"] = self.needUpgrade!
            }
            if self.param != nil {
                map["Param"] = self.param!
            }
            if self.showDescribe != nil {
                map["ShowDescribe"] = self.showDescribe!
            }
            if self.showLog != nil {
                map["ShowLog"] = self.showLog!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanDelete") && dict["CanDelete"] != nil {
                self.canDelete = dict["CanDelete"] as! Bool
            }
            if dict.keys.contains("CanEditor") && dict["CanEditor"] != nil {
                self.canEditor = dict["CanEditor"] as! Bool
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ContainerName") && dict["ContainerName"] != nil {
                self.containerName = dict["ContainerName"] as! String
            }
            if dict.keys.contains("Describe") && dict["Describe"] != nil {
                self.describe = dict["Describe"] as! String
            }
            if dict.keys.contains("ExporterType") && dict["ExporterType"] != nil {
                self.exporterType = dict["ExporterType"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
                self.integrationType = dict["IntegrationType"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NeedUpgrade") && dict["NeedUpgrade"] != nil {
                self.needUpgrade = dict["NeedUpgrade"] as! Bool
            }
            if dict.keys.contains("Param") && dict["Param"] != nil {
                self.param = dict["Param"] as! String
            }
            if dict.keys.contains("ShowDescribe") && dict["ShowDescribe"] != nil {
                self.showDescribe = dict["ShowDescribe"] as! Bool
            }
            if dict.keys.contains("ShowLog") && dict["ShowLog"] != nil {
                self.showLog = dict["ShowLog"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetPrometheusIntegrationResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetPrometheusIntegrationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var monitoringName: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.monitoringName != nil {
            map["MonitoringName"] = self.monitoringName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MonitoringName") && dict["MonitoringName"] != nil {
            self.monitoringName = dict["MonitoringName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetPrometheusMonitoringResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var configYaml: String?

        public var monitoringName: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.monitoringName != nil {
                map["MonitoringName"] = self.monitoringName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("MonitoringName") && dict["MonitoringName"] != nil {
                self.monitoringName = dict["MonitoringName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetPrometheusMonitoringResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetPrometheusMonitoringResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPrometheusRemoteWriteRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var remoteWriteName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteWriteName != nil {
            map["RemoteWriteName"] = self.remoteWriteName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteWriteName") && dict["RemoteWriteName"] != nil {
            self.remoteWriteName = dict["RemoteWriteName"] as! String
        }
    }
}

public class GetPrometheusRemoteWriteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var remoteWriteName: String?

        public var remoteWriteYaml: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.remoteWriteName != nil {
                map["RemoteWriteName"] = self.remoteWriteName!
            }
            if self.remoteWriteYaml != nil {
                map["RemoteWriteYaml"] = self.remoteWriteYaml!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("RemoteWriteName") && dict["RemoteWriteName"] != nil {
                self.remoteWriteName = dict["RemoteWriteName"] as! String
            }
            if dict.keys.contains("RemoteWriteYaml") && dict["RemoteWriteYaml"] != nil {
                self.remoteWriteYaml = dict["RemoteWriteYaml"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetPrometheusRemoteWriteResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetPrometheusRemoteWriteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPrometheusRemoteWriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPrometheusRemoteWriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPrometheusRemoteWriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRecordingRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetRecordingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetRecordingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRecordingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRecordingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRetcodeAppByPidRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pid: String?

    public var regionId: String?

    public var tags: [GetRetcodeAppByPidRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [GetRetcodeAppByPidRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetRetcodeAppByPidRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetRetcodeAppByPidResponseBody : Tea.TeaModel {
    public class RetcodeApp : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: String?

        public var appName: String?

        public var pid: String?

        public var resourceGroupId: String?

        public var retcodeAppType: String?

        public var tags: [GetRetcodeAppByPidResponseBody.RetcodeApp.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.retcodeAppType != nil {
                map["RetcodeAppType"] = self.retcodeAppType!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RetcodeAppType") && dict["RetcodeAppType"] != nil {
                self.retcodeAppType = dict["RetcodeAppType"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [GetRetcodeAppByPidResponseBody.RetcodeApp.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetRetcodeAppByPidResponseBody.RetcodeApp.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var requestId: String?

    public var retcodeApp: GetRetcodeAppByPidResponseBody.RetcodeApp?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.retcodeApp?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retcodeApp != nil {
            map["RetcodeApp"] = self.retcodeApp?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetcodeApp") && dict["RetcodeApp"] != nil {
            var model = GetRetcodeAppByPidResponseBody.RetcodeApp()
            model.fromMap(dict["RetcodeApp"] as! [String: Any])
            self.retcodeApp = model
        }
    }
}

public class GetRetcodeAppByPidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRetcodeAppByPidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRetcodeAppByPidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRetcodeDataByQueryRequest : Tea.TeaModel {
    public var from: Int64?

    public var pid: String?

    public var query: String?

    public var regionId: String?

    public var to: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! Int64
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("Query") && dict["Query"] != nil {
            self.query = dict["Query"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("To") && dict["To"] != nil {
            self.to = dict["To"] as! Int64
        }
    }
}

public class GetRetcodeDataByQueryResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRetcodeDataByQueryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRetcodeDataByQueryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRetcodeDataByQueryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRetcodeLogstoreRequest : Tea.TeaModel {
    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetRetcodeLogstoreResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RetcodeSLSConfig : Tea.TeaModel {
            public var logstore: String?

            public var project: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logstore != nil {
                    map["Logstore"] = self.logstore!
                }
                if self.project != nil {
                    map["Project"] = self.project!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Logstore") && dict["Logstore"] != nil {
                    self.logstore = dict["Logstore"] as! String
                }
                if dict.keys.contains("Project") && dict["Project"] != nil {
                    self.project = dict["Project"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var message: String?

        public var retcodeSLSConfig: GetRetcodeLogstoreResponseBody.Data.RetcodeSLSConfig?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.retcodeSLSConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.retcodeSLSConfig != nil {
                map["RetcodeSLSConfig"] = self.retcodeSLSConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RetcodeSLSConfig") && dict["RetcodeSLSConfig"] != nil {
                var model = GetRetcodeLogstoreResponseBody.Data.RetcodeSLSConfig()
                model.fromMap(dict["RetcodeSLSConfig"] as! [String: Any])
                self.retcodeSLSConfig = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var data: GetRetcodeLogstoreResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetRetcodeLogstoreResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetRetcodeLogstoreResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRetcodeLogstoreResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRetcodeLogstoreResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRetcodeShareUrlRequest : Tea.TeaModel {
    public var pid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
    }
}

public class GetRetcodeShareUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetRetcodeShareUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRetcodeShareUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRetcodeShareUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSourceMapInfoRequest : Tea.TeaModel {
    public var ascendingSequence: Bool?

    public var edition: String?

    public var ID: String?

    public var keyword: String?

    public var orderField: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ascendingSequence != nil {
            map["AscendingSequence"] = self.ascendingSequence!
        }
        if self.edition != nil {
            map["Edition"] = self.edition!
        }
        if self.ID != nil {
            map["ID"] = self.ID!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.orderField != nil {
            map["OrderField"] = self.orderField!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AscendingSequence") && dict["AscendingSequence"] != nil {
            self.ascendingSequence = dict["AscendingSequence"] as! Bool
        }
        if dict.keys.contains("Edition") && dict["Edition"] != nil {
            self.edition = dict["Edition"] as! String
        }
        if dict.keys.contains("ID") && dict["ID"] != nil {
            self.ID = dict["ID"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("OrderField") && dict["OrderField"] != nil {
            self.orderField = dict["OrderField"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetSourceMapInfoResponseBody : Tea.TeaModel {
    public class SourceMapList : Tea.TeaModel {
        public var fid: String?

        public var fileName: String?

        public var size: String?

        public var uploadTime: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fid != nil {
                map["Fid"] = self.fid!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.uploadTime != nil {
                map["UploadTime"] = self.uploadTime!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Fid") && dict["Fid"] != nil {
                self.fid = dict["Fid"] as! String
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("UploadTime") && dict["UploadTime"] != nil {
                self.uploadTime = dict["UploadTime"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var sourceMapList: [GetSourceMapInfoResponseBody.SourceMapList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceMapList != nil {
            var tmp : [Any] = []
            for k in self.sourceMapList! {
                tmp.append(k.toMap())
            }
            map["SourceMapList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceMapList") && dict["SourceMapList"] != nil {
            var tmp : [GetSourceMapInfoResponseBody.SourceMapList] = []
            for v in dict["SourceMapList"] as! [Any] {
                var model = GetSourceMapInfoResponseBody.SourceMapList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sourceMapList = tmp
        }
    }
}

public class GetSourceMapInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSourceMapInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSourceMapInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStackRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var pid: String?

    public var regionId: String?

    public var rpcID: String?

    public var startTime: Int64?

    public var traceID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rpcID != nil {
            map["RpcID"] = self.rpcID!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.traceID != nil {
            map["TraceID"] = self.traceID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RpcID") && dict["RpcID"] != nil {
            self.rpcID = dict["RpcID"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TraceID") && dict["TraceID"] != nil {
            self.traceID = dict["TraceID"] as! String
        }
    }
}

public class GetStackResponseBody : Tea.TeaModel {
    public class StackInfo : Tea.TeaModel {
        public class ExtInfo : Tea.TeaModel {
            public var info: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.info != nil {
                    map["Info"] = self.info!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Info") && dict["Info"] != nil {
                    self.info = dict["Info"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var api: String?

        public var duration: Int64?

        public var exception: String?

        public var extInfo: GetStackResponseBody.StackInfo.ExtInfo?

        public var line: String?

        public var rpcId: String?

        public var serviceName: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.api != nil {
                map["Api"] = self.api!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.exception != nil {
                map["Exception"] = self.exception!
            }
            if self.extInfo != nil {
                map["ExtInfo"] = self.extInfo?.toMap()
            }
            if self.line != nil {
                map["Line"] = self.line!
            }
            if self.rpcId != nil {
                map["RpcId"] = self.rpcId!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Api") && dict["Api"] != nil {
                self.api = dict["Api"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Exception") && dict["Exception"] != nil {
                self.exception = dict["Exception"] as! String
            }
            if dict.keys.contains("ExtInfo") && dict["ExtInfo"] != nil {
                var model = GetStackResponseBody.StackInfo.ExtInfo()
                model.fromMap(dict["ExtInfo"] as! [String: Any])
                self.extInfo = model
            }
            if dict.keys.contains("Line") && dict["Line"] != nil {
                self.line = dict["Line"] as! String
            }
            if dict.keys.contains("RpcId") && dict["RpcId"] != nil {
                self.rpcId = dict["RpcId"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var stackInfo: [GetStackResponseBody.StackInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.stackInfo != nil {
            var tmp : [Any] = []
            for k in self.stackInfo! {
                tmp.append(k.toMap())
            }
            map["StackInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StackInfo") && dict["StackInfo"] != nil {
            var tmp : [GetStackResponseBody.StackInfo] = []
            for v in dict["StackInfo"] as! [Any] {
                var model = GetStackResponseBody.StackInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.stackInfo = tmp
        }
    }
}

public class GetStackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetStackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSyntheticMonitorsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var monitorCategory: Int32?

        public var network: Int32?

        public var taskType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorCategory != nil {
                map["MonitorCategory"] = self.monitorCategory!
            }
            if self.network != nil {
                map["Network"] = self.network!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorCategory") && dict["MonitorCategory"] != nil {
                self.monitorCategory = dict["MonitorCategory"] as! Int32
            }
            if dict.keys.contains("Network") && dict["Network"] != nil {
                self.network = dict["Network"] as! Int32
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! Int32
            }
        }
    }
    public var filter: GetSyntheticMonitorsRequest.Filter?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filter?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            map["Filter"] = self.filter?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") && dict["Filter"] != nil {
            var model = GetSyntheticMonitorsRequest.Filter()
            model.fromMap(dict["Filter"] as! [String: Any])
            self.filter = model
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetSyntheticMonitorsShrinkRequest : Tea.TeaModel {
    public var filterShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterShrink != nil {
            map["Filter"] = self.filterShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") && dict["Filter"] != nil {
            self.filterShrink = dict["Filter"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetSyntheticMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var available: String?

        public var canBeSelected: Bool?

        public var city: String?

        public var cityCode: String?

        public var clientType: Int32?

        public var country: String?

        public var ipv6: Int32?

        public var operator_: String?

        public var operatorCode: String?

        public var region: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.available != nil {
                map["Available"] = self.available!
            }
            if self.canBeSelected != nil {
                map["CanBeSelected"] = self.canBeSelected!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.country != nil {
                map["Country"] = self.country!
            }
            if self.ipv6 != nil {
                map["Ipv6"] = self.ipv6!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.operatorCode != nil {
                map["OperatorCode"] = self.operatorCode!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Available") && dict["Available"] != nil {
                self.available = dict["Available"] as! String
            }
            if dict.keys.contains("CanBeSelected") && dict["CanBeSelected"] != nil {
                self.canBeSelected = dict["CanBeSelected"] as! Bool
            }
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("ClientType") && dict["ClientType"] != nil {
                self.clientType = dict["ClientType"] as! Int32
            }
            if dict.keys.contains("Country") && dict["Country"] != nil {
                self.country = dict["Country"] as! String
            }
            if dict.keys.contains("Ipv6") && dict["Ipv6"] != nil {
                self.ipv6 = dict["Ipv6"] as! Int32
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("OperatorCode") && dict["OperatorCode"] != nil {
                self.operatorCode = dict["OperatorCode"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: [GetSyntheticMonitorsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetSyntheticMonitorsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetSyntheticMonitorsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSyntheticMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSyntheticMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSyntheticMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSyntheticTaskDetailRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetSyntheticTaskDetailResponseBody : Tea.TeaModel {
    public class TaskDetail : Tea.TeaModel {
        public class CommonParam : Tea.TeaModel {
            public class AlertList : Tea.TeaModel {
                public var generalAlert: String?

                public var isCritical: String?

                public var name: String?

                public var seriousAlert: String?

                public var symbols: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.generalAlert != nil {
                        map["GeneralAlert"] = self.generalAlert!
                    }
                    if self.isCritical != nil {
                        map["IsCritical"] = self.isCritical!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.seriousAlert != nil {
                        map["SeriousAlert"] = self.seriousAlert!
                    }
                    if self.symbols != nil {
                        map["Symbols"] = self.symbols!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GeneralAlert") && dict["GeneralAlert"] != nil {
                        self.generalAlert = dict["GeneralAlert"] as! String
                    }
                    if dict.keys.contains("IsCritical") && dict["IsCritical"] != nil {
                        self.isCritical = dict["IsCritical"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("SeriousAlert") && dict["SeriousAlert"] != nil {
                        self.seriousAlert = dict["SeriousAlert"] as! String
                    }
                    if dict.keys.contains("Symbols") && dict["Symbols"] != nil {
                        self.symbols = dict["Symbols"] as! String
                    }
                }
            }
            public var alarmFlag: Int64?

            public var alertList: [GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam.AlertList]?

            public var alertNotifierId: String?

            public var alertPolicyId: String?

            public var monitorSamples: String?

            public var startExecutionTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmFlag != nil {
                    map["AlarmFlag"] = self.alarmFlag!
                }
                if self.alertList != nil {
                    var tmp : [Any] = []
                    for k in self.alertList! {
                        tmp.append(k.toMap())
                    }
                    map["AlertList"] = tmp
                }
                if self.alertNotifierId != nil {
                    map["AlertNotifierId"] = self.alertNotifierId!
                }
                if self.alertPolicyId != nil {
                    map["AlertPolicyId"] = self.alertPolicyId!
                }
                if self.monitorSamples != nil {
                    map["MonitorSamples"] = self.monitorSamples!
                }
                if self.startExecutionTime != nil {
                    map["StartExecutionTime"] = self.startExecutionTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmFlag") && dict["AlarmFlag"] != nil {
                    self.alarmFlag = dict["AlarmFlag"] as! Int64
                }
                if dict.keys.contains("AlertList") && dict["AlertList"] != nil {
                    var tmp : [GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam.AlertList] = []
                    for v in dict["AlertList"] as! [Any] {
                        var model = GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam.AlertList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alertList = tmp
                }
                if dict.keys.contains("AlertNotifierId") && dict["AlertNotifierId"] != nil {
                    self.alertNotifierId = dict["AlertNotifierId"] as! String
                }
                if dict.keys.contains("AlertPolicyId") && dict["AlertPolicyId"] != nil {
                    self.alertPolicyId = dict["AlertPolicyId"] as! String
                }
                if dict.keys.contains("MonitorSamples") && dict["MonitorSamples"] != nil {
                    self.monitorSamples = dict["MonitorSamples"] as! String
                }
                if dict.keys.contains("StartExecutionTime") && dict["StartExecutionTime"] != nil {
                    self.startExecutionTime = dict["StartExecutionTime"] as! String
                }
            }
        }
        public class Download : Tea.TeaModel {
            public var connectionTimeout: Int64?

            public var downloadCustomHeaderContent: String?

            public var downloadCustomHost: Int64?

            public var downloadCustomHostIp: String?

            public var downloadKernel: Int64?

            public var downloadRedirect: Int64?

            public var downloadTransmissionSize: Int64?

            public var monitorTimeout: Int64?

            public var quickProtocol: String?

            public var validateKeywords: String?

            public var verifyWay: Int64?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectionTimeout != nil {
                    map["ConnectionTimeout"] = self.connectionTimeout!
                }
                if self.downloadCustomHeaderContent != nil {
                    map["DownloadCustomHeaderContent"] = self.downloadCustomHeaderContent!
                }
                if self.downloadCustomHost != nil {
                    map["DownloadCustomHost"] = self.downloadCustomHost!
                }
                if self.downloadCustomHostIp != nil {
                    map["DownloadCustomHostIp"] = self.downloadCustomHostIp!
                }
                if self.downloadKernel != nil {
                    map["DownloadKernel"] = self.downloadKernel!
                }
                if self.downloadRedirect != nil {
                    map["DownloadRedirect"] = self.downloadRedirect!
                }
                if self.downloadTransmissionSize != nil {
                    map["DownloadTransmissionSize"] = self.downloadTransmissionSize!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.quickProtocol != nil {
                    map["QuickProtocol"] = self.quickProtocol!
                }
                if self.validateKeywords != nil {
                    map["ValidateKeywords"] = self.validateKeywords!
                }
                if self.verifyWay != nil {
                    map["VerifyWay"] = self.verifyWay!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectionTimeout") && dict["ConnectionTimeout"] != nil {
                    self.connectionTimeout = dict["ConnectionTimeout"] as! Int64
                }
                if dict.keys.contains("DownloadCustomHeaderContent") && dict["DownloadCustomHeaderContent"] != nil {
                    self.downloadCustomHeaderContent = dict["DownloadCustomHeaderContent"] as! String
                }
                if dict.keys.contains("DownloadCustomHost") && dict["DownloadCustomHost"] != nil {
                    self.downloadCustomHost = dict["DownloadCustomHost"] as! Int64
                }
                if dict.keys.contains("DownloadCustomHostIp") && dict["DownloadCustomHostIp"] != nil {
                    self.downloadCustomHostIp = dict["DownloadCustomHostIp"] as! String
                }
                if dict.keys.contains("DownloadKernel") && dict["DownloadKernel"] != nil {
                    self.downloadKernel = dict["DownloadKernel"] as! Int64
                }
                if dict.keys.contains("DownloadRedirect") && dict["DownloadRedirect"] != nil {
                    self.downloadRedirect = dict["DownloadRedirect"] as! Int64
                }
                if dict.keys.contains("DownloadTransmissionSize") && dict["DownloadTransmissionSize"] != nil {
                    self.downloadTransmissionSize = dict["DownloadTransmissionSize"] as! Int64
                }
                if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("QuickProtocol") && dict["QuickProtocol"] != nil {
                    self.quickProtocol = dict["QuickProtocol"] as! String
                }
                if dict.keys.contains("ValidateKeywords") && dict["ValidateKeywords"] != nil {
                    self.validateKeywords = dict["ValidateKeywords"] as! String
                }
                if dict.keys.contains("VerifyWay") && dict["VerifyWay"] != nil {
                    self.verifyWay = dict["VerifyWay"] as! Int64
                }
                if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class ExtendInterval : Tea.TeaModel {
            public var days: [Int64]?

            public var endMinute: Int64?

            public var endTime: String?

            public var endhour: Int64?

            public var startHour: Int64?

            public var startMinute: Int64?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.days != nil {
                    map["Days"] = self.days!
                }
                if self.endMinute != nil {
                    map["EndMinute"] = self.endMinute!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.endhour != nil {
                    map["Endhour"] = self.endhour!
                }
                if self.startHour != nil {
                    map["StartHour"] = self.startHour!
                }
                if self.startMinute != nil {
                    map["StartMinute"] = self.startMinute!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Days") && dict["Days"] != nil {
                    self.days = dict["Days"] as! [Int64]
                }
                if dict.keys.contains("EndMinute") && dict["EndMinute"] != nil {
                    self.endMinute = dict["EndMinute"] as! Int64
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("Endhour") && dict["Endhour"] != nil {
                    self.endhour = dict["Endhour"] as! Int64
                }
                if dict.keys.contains("StartHour") && dict["StartHour"] != nil {
                    self.startHour = dict["StartHour"] as! Int64
                }
                if dict.keys.contains("StartMinute") && dict["StartMinute"] != nil {
                    self.startMinute = dict["StartMinute"] as! Int64
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public class MonitorList : Tea.TeaModel {
            public var cityCode: Int64?

            public var monitorType: Int64?

            public var netServiceId: Int64?

            public var sendCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.monitorType != nil {
                    map["MonitorType"] = self.monitorType!
                }
                if self.netServiceId != nil {
                    map["NetServiceId"] = self.netServiceId!
                }
                if self.sendCount != nil {
                    map["SendCount"] = self.sendCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
                    self.cityCode = dict["CityCode"] as! Int64
                }
                if dict.keys.contains("MonitorType") && dict["MonitorType"] != nil {
                    self.monitorType = dict["MonitorType"] as! Int64
                }
                if dict.keys.contains("NetServiceId") && dict["NetServiceId"] != nil {
                    self.netServiceId = dict["NetServiceId"] as! Int64
                }
                if dict.keys.contains("SendCount") && dict["SendCount"] != nil {
                    self.sendCount = dict["SendCount"] as! Int64
                }
            }
        }
        public class Nav : Tea.TeaModel {
            public var dnsHijackWhitelist: String?

            public var elementBlacklist: String?

            public var executeActiveX: Int64?

            public var executeApplet: Int64?

            public var executeScript: Int64?

            public var filterInvalidIP: Int64?

            public var flowHijackJumpTimes: Int64?

            public var flowHijackLogo: String?

            public var monitorTimeout: Int64?

            public var navAutomaticScrolling: Int64?

            public var navCustomHeader: String?

            public var navCustomHeaderContent: String?

            public var navCustomHost: Int64?

            public var navCustomHostIp: String?

            public var navDisableCache: Int64?

            public var navDisableCompression: Int64?

            public var navIgnoreCertificateError: Int64?

            public var navRedirect: Int64?

            public var navReturnElement: Int64?

            public var pageTampering: String?

            public var processName: String?

            public var quicDomain: String?

            public var quicVersion: Int64?

            public var requestHeader: Int64?

            public var slowElementThreshold: Int64?

            public var verifyStringBlacklist: String?

            public var verifyStringWhitelist: String?

            public var waitCompletionTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dnsHijackWhitelist != nil {
                    map["DnsHijackWhitelist"] = self.dnsHijackWhitelist!
                }
                if self.elementBlacklist != nil {
                    map["ElementBlacklist"] = self.elementBlacklist!
                }
                if self.executeActiveX != nil {
                    map["ExecuteActiveX"] = self.executeActiveX!
                }
                if self.executeApplet != nil {
                    map["ExecuteApplet"] = self.executeApplet!
                }
                if self.executeScript != nil {
                    map["ExecuteScript"] = self.executeScript!
                }
                if self.filterInvalidIP != nil {
                    map["FilterInvalidIP"] = self.filterInvalidIP!
                }
                if self.flowHijackJumpTimes != nil {
                    map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
                }
                if self.flowHijackLogo != nil {
                    map["FlowHijackLogo"] = self.flowHijackLogo!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.navAutomaticScrolling != nil {
                    map["NavAutomaticScrolling"] = self.navAutomaticScrolling!
                }
                if self.navCustomHeader != nil {
                    map["NavCustomHeader"] = self.navCustomHeader!
                }
                if self.navCustomHeaderContent != nil {
                    map["NavCustomHeaderContent"] = self.navCustomHeaderContent!
                }
                if self.navCustomHost != nil {
                    map["NavCustomHost"] = self.navCustomHost!
                }
                if self.navCustomHostIp != nil {
                    map["NavCustomHostIp"] = self.navCustomHostIp!
                }
                if self.navDisableCache != nil {
                    map["NavDisableCache"] = self.navDisableCache!
                }
                if self.navDisableCompression != nil {
                    map["NavDisableCompression"] = self.navDisableCompression!
                }
                if self.navIgnoreCertificateError != nil {
                    map["NavIgnoreCertificateError"] = self.navIgnoreCertificateError!
                }
                if self.navRedirect != nil {
                    map["NavRedirect"] = self.navRedirect!
                }
                if self.navReturnElement != nil {
                    map["NavReturnElement"] = self.navReturnElement!
                }
                if self.pageTampering != nil {
                    map["PageTampering"] = self.pageTampering!
                }
                if self.processName != nil {
                    map["ProcessName"] = self.processName!
                }
                if self.quicDomain != nil {
                    map["QuicDomain"] = self.quicDomain!
                }
                if self.quicVersion != nil {
                    map["QuicVersion"] = self.quicVersion!
                }
                if self.requestHeader != nil {
                    map["RequestHeader"] = self.requestHeader!
                }
                if self.slowElementThreshold != nil {
                    map["SlowElementThreshold"] = self.slowElementThreshold!
                }
                if self.verifyStringBlacklist != nil {
                    map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
                }
                if self.verifyStringWhitelist != nil {
                    map["VerifyStringWhitelist"] = self.verifyStringWhitelist!
                }
                if self.waitCompletionTime != nil {
                    map["WaitCompletionTime"] = self.waitCompletionTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DnsHijackWhitelist") && dict["DnsHijackWhitelist"] != nil {
                    self.dnsHijackWhitelist = dict["DnsHijackWhitelist"] as! String
                }
                if dict.keys.contains("ElementBlacklist") && dict["ElementBlacklist"] != nil {
                    self.elementBlacklist = dict["ElementBlacklist"] as! String
                }
                if dict.keys.contains("ExecuteActiveX") && dict["ExecuteActiveX"] != nil {
                    self.executeActiveX = dict["ExecuteActiveX"] as! Int64
                }
                if dict.keys.contains("ExecuteApplet") && dict["ExecuteApplet"] != nil {
                    self.executeApplet = dict["ExecuteApplet"] as! Int64
                }
                if dict.keys.contains("ExecuteScript") && dict["ExecuteScript"] != nil {
                    self.executeScript = dict["ExecuteScript"] as! Int64
                }
                if dict.keys.contains("FilterInvalidIP") && dict["FilterInvalidIP"] != nil {
                    self.filterInvalidIP = dict["FilterInvalidIP"] as! Int64
                }
                if dict.keys.contains("FlowHijackJumpTimes") && dict["FlowHijackJumpTimes"] != nil {
                    self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int64
                }
                if dict.keys.contains("FlowHijackLogo") && dict["FlowHijackLogo"] != nil {
                    self.flowHijackLogo = dict["FlowHijackLogo"] as! String
                }
                if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("NavAutomaticScrolling") && dict["NavAutomaticScrolling"] != nil {
                    self.navAutomaticScrolling = dict["NavAutomaticScrolling"] as! Int64
                }
                if dict.keys.contains("NavCustomHeader") && dict["NavCustomHeader"] != nil {
                    self.navCustomHeader = dict["NavCustomHeader"] as! String
                }
                if dict.keys.contains("NavCustomHeaderContent") && dict["NavCustomHeaderContent"] != nil {
                    self.navCustomHeaderContent = dict["NavCustomHeaderContent"] as! String
                }
                if dict.keys.contains("NavCustomHost") && dict["NavCustomHost"] != nil {
                    self.navCustomHost = dict["NavCustomHost"] as! Int64
                }
                if dict.keys.contains("NavCustomHostIp") && dict["NavCustomHostIp"] != nil {
                    self.navCustomHostIp = dict["NavCustomHostIp"] as! String
                }
                if dict.keys.contains("NavDisableCache") && dict["NavDisableCache"] != nil {
                    self.navDisableCache = dict["NavDisableCache"] as! Int64
                }
                if dict.keys.contains("NavDisableCompression") && dict["NavDisableCompression"] != nil {
                    self.navDisableCompression = dict["NavDisableCompression"] as! Int64
                }
                if dict.keys.contains("NavIgnoreCertificateError") && dict["NavIgnoreCertificateError"] != nil {
                    self.navIgnoreCertificateError = dict["NavIgnoreCertificateError"] as! Int64
                }
                if dict.keys.contains("NavRedirect") && dict["NavRedirect"] != nil {
                    self.navRedirect = dict["NavRedirect"] as! Int64
                }
                if dict.keys.contains("NavReturnElement") && dict["NavReturnElement"] != nil {
                    self.navReturnElement = dict["NavReturnElement"] as! Int64
                }
                if dict.keys.contains("PageTampering") && dict["PageTampering"] != nil {
                    self.pageTampering = dict["PageTampering"] as! String
                }
                if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
                    self.processName = dict["ProcessName"] as! String
                }
                if dict.keys.contains("QuicDomain") && dict["QuicDomain"] != nil {
                    self.quicDomain = dict["QuicDomain"] as! String
                }
                if dict.keys.contains("QuicVersion") && dict["QuicVersion"] != nil {
                    self.quicVersion = dict["QuicVersion"] as! Int64
                }
                if dict.keys.contains("RequestHeader") && dict["RequestHeader"] != nil {
                    self.requestHeader = dict["RequestHeader"] as! Int64
                }
                if dict.keys.contains("SlowElementThreshold") && dict["SlowElementThreshold"] != nil {
                    self.slowElementThreshold = dict["SlowElementThreshold"] as! Int64
                }
                if dict.keys.contains("VerifyStringBlacklist") && dict["VerifyStringBlacklist"] != nil {
                    self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
                }
                if dict.keys.contains("VerifyStringWhitelist") && dict["VerifyStringWhitelist"] != nil {
                    self.verifyStringWhitelist = dict["VerifyStringWhitelist"] as! String
                }
                if dict.keys.contains("WaitCompletionTime") && dict["WaitCompletionTime"] != nil {
                    self.waitCompletionTime = dict["WaitCompletionTime"] as! Int64
                }
            }
        }
        public class Net : Tea.TeaModel {
            public var netDigSwitch: Int64?

            public var netDnsNs: String?

            public var netDnsQueryMethod: String?

            public var netDnsServer: Int64?

            public var netDnsSwitch: Int64?

            public var netDnsTimeout: String?

            public var netIcmpActive: Int64?

            public var netIcmpDataCut: Int64?

            public var netIcmpInterval: Int64?

            public var netIcmpNum: Int64?

            public var netIcmpSize: Int64?

            public var netIcmpSwitch: Int64?

            public var netIcmpTimeout: Int64?

            public var netTraceRouteNum: Int64?

            public var netTraceRouteSwitch: Int64?

            public var netTraceRouteTimeout: Int64?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.netDigSwitch != nil {
                    map["NetDigSwitch"] = self.netDigSwitch!
                }
                if self.netDnsNs != nil {
                    map["NetDnsNs"] = self.netDnsNs!
                }
                if self.netDnsQueryMethod != nil {
                    map["NetDnsQueryMethod"] = self.netDnsQueryMethod!
                }
                if self.netDnsServer != nil {
                    map["NetDnsServer"] = self.netDnsServer!
                }
                if self.netDnsSwitch != nil {
                    map["NetDnsSwitch"] = self.netDnsSwitch!
                }
                if self.netDnsTimeout != nil {
                    map["NetDnsTimeout"] = self.netDnsTimeout!
                }
                if self.netIcmpActive != nil {
                    map["NetIcmpActive"] = self.netIcmpActive!
                }
                if self.netIcmpDataCut != nil {
                    map["NetIcmpDataCut"] = self.netIcmpDataCut!
                }
                if self.netIcmpInterval != nil {
                    map["NetIcmpInterval"] = self.netIcmpInterval!
                }
                if self.netIcmpNum != nil {
                    map["NetIcmpNum"] = self.netIcmpNum!
                }
                if self.netIcmpSize != nil {
                    map["NetIcmpSize"] = self.netIcmpSize!
                }
                if self.netIcmpSwitch != nil {
                    map["NetIcmpSwitch"] = self.netIcmpSwitch!
                }
                if self.netIcmpTimeout != nil {
                    map["NetIcmpTimeout"] = self.netIcmpTimeout!
                }
                if self.netTraceRouteNum != nil {
                    map["NetTraceRouteNum"] = self.netTraceRouteNum!
                }
                if self.netTraceRouteSwitch != nil {
                    map["NetTraceRouteSwitch"] = self.netTraceRouteSwitch!
                }
                if self.netTraceRouteTimeout != nil {
                    map["NetTraceRouteTimeout"] = self.netTraceRouteTimeout!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NetDigSwitch") && dict["NetDigSwitch"] != nil {
                    self.netDigSwitch = dict["NetDigSwitch"] as! Int64
                }
                if dict.keys.contains("NetDnsNs") && dict["NetDnsNs"] != nil {
                    self.netDnsNs = dict["NetDnsNs"] as! String
                }
                if dict.keys.contains("NetDnsQueryMethod") && dict["NetDnsQueryMethod"] != nil {
                    self.netDnsQueryMethod = dict["NetDnsQueryMethod"] as! String
                }
                if dict.keys.contains("NetDnsServer") && dict["NetDnsServer"] != nil {
                    self.netDnsServer = dict["NetDnsServer"] as! Int64
                }
                if dict.keys.contains("NetDnsSwitch") && dict["NetDnsSwitch"] != nil {
                    self.netDnsSwitch = dict["NetDnsSwitch"] as! Int64
                }
                if dict.keys.contains("NetDnsTimeout") && dict["NetDnsTimeout"] != nil {
                    self.netDnsTimeout = dict["NetDnsTimeout"] as! String
                }
                if dict.keys.contains("NetIcmpActive") && dict["NetIcmpActive"] != nil {
                    self.netIcmpActive = dict["NetIcmpActive"] as! Int64
                }
                if dict.keys.contains("NetIcmpDataCut") && dict["NetIcmpDataCut"] != nil {
                    self.netIcmpDataCut = dict["NetIcmpDataCut"] as! Int64
                }
                if dict.keys.contains("NetIcmpInterval") && dict["NetIcmpInterval"] != nil {
                    self.netIcmpInterval = dict["NetIcmpInterval"] as! Int64
                }
                if dict.keys.contains("NetIcmpNum") && dict["NetIcmpNum"] != nil {
                    self.netIcmpNum = dict["NetIcmpNum"] as! Int64
                }
                if dict.keys.contains("NetIcmpSize") && dict["NetIcmpSize"] != nil {
                    self.netIcmpSize = dict["NetIcmpSize"] as! Int64
                }
                if dict.keys.contains("NetIcmpSwitch") && dict["NetIcmpSwitch"] != nil {
                    self.netIcmpSwitch = dict["NetIcmpSwitch"] as! Int64
                }
                if dict.keys.contains("NetIcmpTimeout") && dict["NetIcmpTimeout"] != nil {
                    self.netIcmpTimeout = dict["NetIcmpTimeout"] as! Int64
                }
                if dict.keys.contains("NetTraceRouteNum") && dict["NetTraceRouteNum"] != nil {
                    self.netTraceRouteNum = dict["NetTraceRouteNum"] as! Int64
                }
                if dict.keys.contains("NetTraceRouteSwitch") && dict["NetTraceRouteSwitch"] != nil {
                    self.netTraceRouteSwitch = dict["NetTraceRouteSwitch"] as! Int64
                }
                if dict.keys.contains("NetTraceRouteTimeout") && dict["NetTraceRouteTimeout"] != nil {
                    self.netTraceRouteTimeout = dict["NetTraceRouteTimeout"] as! Int64
                }
                if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class Protocol_ : Tea.TeaModel {
            public class RequestContent : Tea.TeaModel {
                public class Body : Tea.TeaModel {
                    public class Formdata : Tea.TeaModel {
                        public var key: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Key") && dict["Key"] != nil {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("Value") && dict["Value"] != nil {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Urlencoded : Tea.TeaModel {
                        public var key: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Key") && dict["Key"] != nil {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("Value") && dict["Value"] != nil {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var formdata: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body.Formdata?

                    public var language: String?

                    public var mode: String?

                    public var raw: String?

                    public var urlencoded: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body.Urlencoded?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.formdata?.validate()
                        try self.urlencoded?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.formdata != nil {
                            map["Formdata"] = self.formdata?.toMap()
                        }
                        if self.language != nil {
                            map["Language"] = self.language!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.raw != nil {
                            map["Raw"] = self.raw!
                        }
                        if self.urlencoded != nil {
                            map["Urlencoded"] = self.urlencoded?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Formdata") && dict["Formdata"] != nil {
                            var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body.Formdata()
                            model.fromMap(dict["Formdata"] as! [String: Any])
                            self.formdata = model
                        }
                        if dict.keys.contains("Language") && dict["Language"] != nil {
                            self.language = dict["Language"] as! String
                        }
                        if dict.keys.contains("Mode") && dict["Mode"] != nil {
                            self.mode = dict["Mode"] as! String
                        }
                        if dict.keys.contains("Raw") && dict["Raw"] != nil {
                            self.raw = dict["Raw"] as! String
                        }
                        if dict.keys.contains("Urlencoded") && dict["Urlencoded"] != nil {
                            var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body.Urlencoded()
                            model.fromMap(dict["Urlencoded"] as! [String: Any])
                            self.urlencoded = model
                        }
                    }
                }
                public class Header : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var body: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body?

                public var header: [GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Header]?

                public var method: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.body?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body?.toMap()
                    }
                    if self.header != nil {
                        var tmp : [Any] = []
                        for k in self.header! {
                            tmp.append(k.toMap())
                        }
                        map["Header"] = tmp
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") && dict["Body"] != nil {
                        var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Body()
                        model.fromMap(dict["Body"] as! [String: Any])
                        self.body = model
                    }
                    if dict.keys.contains("Header") && dict["Header"] != nil {
                        var tmp : [GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Header] = []
                        for v in dict["Header"] as! [Any] {
                            var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent.Header()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.header = tmp
                    }
                    if dict.keys.contains("Method") && dict["Method"] != nil {
                        self.method = dict["Method"] as! String
                    }
                }
            }
            public var characterEncoding: Int64?

            public var customHost: Int64?

            public var customHostIp: String?

            public var protocolConnectionTimeout: Int64?

            public var protocolMonitorTimeout: Int64?

            public var receivedDataSize: Int64?

            public var requestContent: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent?

            public var verifyContent: String?

            public var verifyWay: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.requestContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.characterEncoding != nil {
                    map["CharacterEncoding"] = self.characterEncoding!
                }
                if self.customHost != nil {
                    map["CustomHost"] = self.customHost!
                }
                if self.customHostIp != nil {
                    map["CustomHostIp"] = self.customHostIp!
                }
                if self.protocolConnectionTimeout != nil {
                    map["ProtocolConnectionTimeout"] = self.protocolConnectionTimeout!
                }
                if self.protocolMonitorTimeout != nil {
                    map["ProtocolMonitorTimeout"] = self.protocolMonitorTimeout!
                }
                if self.receivedDataSize != nil {
                    map["ReceivedDataSize"] = self.receivedDataSize!
                }
                if self.requestContent != nil {
                    map["RequestContent"] = self.requestContent?.toMap()
                }
                if self.verifyContent != nil {
                    map["VerifyContent"] = self.verifyContent!
                }
                if self.verifyWay != nil {
                    map["VerifyWay"] = self.verifyWay!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CharacterEncoding") && dict["CharacterEncoding"] != nil {
                    self.characterEncoding = dict["CharacterEncoding"] as! Int64
                }
                if dict.keys.contains("CustomHost") && dict["CustomHost"] != nil {
                    self.customHost = dict["CustomHost"] as! Int64
                }
                if dict.keys.contains("CustomHostIp") && dict["CustomHostIp"] != nil {
                    self.customHostIp = dict["CustomHostIp"] as! String
                }
                if dict.keys.contains("ProtocolConnectionTimeout") && dict["ProtocolConnectionTimeout"] != nil {
                    self.protocolConnectionTimeout = dict["ProtocolConnectionTimeout"] as! Int64
                }
                if dict.keys.contains("ProtocolMonitorTimeout") && dict["ProtocolMonitorTimeout"] != nil {
                    self.protocolMonitorTimeout = dict["ProtocolMonitorTimeout"] as! Int64
                }
                if dict.keys.contains("ReceivedDataSize") && dict["ReceivedDataSize"] != nil {
                    self.receivedDataSize = dict["ReceivedDataSize"] as! Int64
                }
                if dict.keys.contains("RequestContent") && dict["RequestContent"] != nil {
                    var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_.RequestContent()
                    model.fromMap(dict["RequestContent"] as! [String: Any])
                    self.requestContent = model
                }
                if dict.keys.contains("VerifyContent") && dict["VerifyContent"] != nil {
                    self.verifyContent = dict["VerifyContent"] as! String
                }
                if dict.keys.contains("VerifyWay") && dict["VerifyWay"] != nil {
                    self.verifyWay = dict["VerifyWay"] as! Int64
                }
            }
        }
        public var commonParam: GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam?

        public var download: GetSyntheticTaskDetailResponseBody.TaskDetail.Download?

        public var extendInterval: GetSyntheticTaskDetailResponseBody.TaskDetail.ExtendInterval?

        public var intervalTime: Int64?

        public var intervalType: Int64?

        public var ipType: Int64?

        public var monitorList: [GetSyntheticTaskDetailResponseBody.TaskDetail.MonitorList]?

        public var monitorListString: String?

        public var nav: GetSyntheticTaskDetailResponseBody.TaskDetail.Nav?

        public var net: GetSyntheticTaskDetailResponseBody.TaskDetail.Net?

        public var protocol_: GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_?

        public var taskId: Int64?

        public var taskName: String?

        public var taskType: Int64?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commonParam?.validate()
            try self.download?.validate()
            try self.extendInterval?.validate()
            try self.nav?.validate()
            try self.net?.validate()
            try self.protocol_?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commonParam != nil {
                map["CommonParam"] = self.commonParam?.toMap()
            }
            if self.download != nil {
                map["Download"] = self.download?.toMap()
            }
            if self.extendInterval != nil {
                map["ExtendInterval"] = self.extendInterval?.toMap()
            }
            if self.intervalTime != nil {
                map["IntervalTime"] = self.intervalTime!
            }
            if self.intervalType != nil {
                map["IntervalType"] = self.intervalType!
            }
            if self.ipType != nil {
                map["IpType"] = self.ipType!
            }
            if self.monitorList != nil {
                var tmp : [Any] = []
                for k in self.monitorList! {
                    tmp.append(k.toMap())
                }
                map["MonitorList"] = tmp
            }
            if self.monitorListString != nil {
                map["MonitorListString"] = self.monitorListString!
            }
            if self.nav != nil {
                map["Nav"] = self.nav?.toMap()
            }
            if self.net != nil {
                map["Net"] = self.net?.toMap()
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_?.toMap()
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommonParam") && dict["CommonParam"] != nil {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.CommonParam()
                model.fromMap(dict["CommonParam"] as! [String: Any])
                self.commonParam = model
            }
            if dict.keys.contains("Download") && dict["Download"] != nil {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Download()
                model.fromMap(dict["Download"] as! [String: Any])
                self.download = model
            }
            if dict.keys.contains("ExtendInterval") && dict["ExtendInterval"] != nil {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.ExtendInterval()
                model.fromMap(dict["ExtendInterval"] as! [String: Any])
                self.extendInterval = model
            }
            if dict.keys.contains("IntervalTime") && dict["IntervalTime"] != nil {
                self.intervalTime = dict["IntervalTime"] as! Int64
            }
            if dict.keys.contains("IntervalType") && dict["IntervalType"] != nil {
                self.intervalType = dict["IntervalType"] as! Int64
            }
            if dict.keys.contains("IpType") && dict["IpType"] != nil {
                self.ipType = dict["IpType"] as! Int64
            }
            if dict.keys.contains("MonitorList") && dict["MonitorList"] != nil {
                var tmp : [GetSyntheticTaskDetailResponseBody.TaskDetail.MonitorList] = []
                for v in dict["MonitorList"] as! [Any] {
                    var model = GetSyntheticTaskDetailResponseBody.TaskDetail.MonitorList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitorList = tmp
            }
            if dict.keys.contains("MonitorListString") && dict["MonitorListString"] != nil {
                self.monitorListString = dict["MonitorListString"] as! String
            }
            if dict.keys.contains("Nav") && dict["Nav"] != nil {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Nav()
                model.fromMap(dict["Nav"] as! [String: Any])
                self.nav = model
            }
            if dict.keys.contains("Net") && dict["Net"] != nil {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Net()
                model.fromMap(dict["Net"] as! [String: Any])
                self.net = model
            }
            if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                var model = GetSyntheticTaskDetailResponseBody.TaskDetail.Protocol_()
                model.fromMap(dict["Protocol"] as! [String: Any])
                self.protocol_ = model
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! Int64
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! Int64
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var requestId: String?

    public var taskDetail: GetSyntheticTaskDetailResponseBody.TaskDetail?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskDetail != nil {
            map["TaskDetail"] = self.taskDetail?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskDetail") && dict["TaskDetail"] != nil {
            var model = GetSyntheticTaskDetailResponseBody.TaskDetail()
            model.fromMap(dict["TaskDetail"] as! [String: Any])
            self.taskDetail = model
        }
    }
}

public class GetSyntheticTaskDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSyntheticTaskDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSyntheticTaskDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSyntheticTaskListRequest : Tea.TeaModel {
    public var direction: String?

    public var order: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var taskName: String?

    public var taskStatus: String?

    public var taskType: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") && dict["Direction"] != nil {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("Order") && dict["Order"] != nil {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
            self.taskStatus = dict["TaskStatus"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetSyntheticTaskListResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var createTime: String?

            public var monitorNumber: Int64?

            public var taskId: String?

            public var taskName: String?

            public var taskStatus: String?

            public var taskType: Int64?

            public var taskTypeName: String?

            public var url: String?

            public var usable: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.monitorNumber != nil {
                    map["MonitorNumber"] = self.monitorNumber!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.taskTypeName != nil {
                    map["TaskTypeName"] = self.taskTypeName!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.usable != nil {
                    map["Usable"] = self.usable!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("MonitorNumber") && dict["MonitorNumber"] != nil {
                    self.monitorNumber = dict["MonitorNumber"] as! Int64
                }
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                    self.taskStatus = dict["TaskStatus"] as! String
                }
                if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                    self.taskType = dict["TaskType"] as! Int64
                }
                if dict.keys.contains("TaskTypeName") && dict["TaskTypeName"] != nil {
                    self.taskTypeName = dict["TaskTypeName"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Usable") && dict["Usable"] != nil {
                    self.usable = dict["Usable"] as! Double
                }
            }
        }
        public var hasNextPage: String?

        public var hasPreviousPage: Bool?

        public var isFirstPage: Bool?

        public var isLastPage: Bool?

        public var list: [GetSyntheticTaskListResponseBody.PageInfo.List]?

        public var navigateFirstPage: String?

        public var navigateLastPage: String?

        public var navigatePageNums: String?

        public var nextPage: String?

        public var pages: String?

        public var prepage: String?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasNextPage != nil {
                map["HasNextPage"] = self.hasNextPage!
            }
            if self.hasPreviousPage != nil {
                map["HasPreviousPage"] = self.hasPreviousPage!
            }
            if self.isFirstPage != nil {
                map["IsFirstPage"] = self.isFirstPage!
            }
            if self.isLastPage != nil {
                map["IsLastPage"] = self.isLastPage!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.navigateFirstPage != nil {
                map["NavigateFirstPage"] = self.navigateFirstPage!
            }
            if self.navigateLastPage != nil {
                map["NavigateLastPage"] = self.navigateLastPage!
            }
            if self.navigatePageNums != nil {
                map["NavigatePageNums"] = self.navigatePageNums!
            }
            if self.nextPage != nil {
                map["NextPage"] = self.nextPage!
            }
            if self.pages != nil {
                map["Pages"] = self.pages!
            }
            if self.prepage != nil {
                map["Prepage"] = self.prepage!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HasNextPage") && dict["HasNextPage"] != nil {
                self.hasNextPage = dict["HasNextPage"] as! String
            }
            if dict.keys.contains("HasPreviousPage") && dict["HasPreviousPage"] != nil {
                self.hasPreviousPage = dict["HasPreviousPage"] as! Bool
            }
            if dict.keys.contains("IsFirstPage") && dict["IsFirstPage"] != nil {
                self.isFirstPage = dict["IsFirstPage"] as! Bool
            }
            if dict.keys.contains("IsLastPage") && dict["IsLastPage"] != nil {
                self.isLastPage = dict["IsLastPage"] as! Bool
            }
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [GetSyntheticTaskListResponseBody.PageInfo.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetSyntheticTaskListResponseBody.PageInfo.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("NavigateFirstPage") && dict["NavigateFirstPage"] != nil {
                self.navigateFirstPage = dict["NavigateFirstPage"] as! String
            }
            if dict.keys.contains("NavigateLastPage") && dict["NavigateLastPage"] != nil {
                self.navigateLastPage = dict["NavigateLastPage"] as! String
            }
            if dict.keys.contains("NavigatePageNums") && dict["NavigatePageNums"] != nil {
                self.navigatePageNums = dict["NavigatePageNums"] as! String
            }
            if dict.keys.contains("NextPage") && dict["NextPage"] != nil {
                self.nextPage = dict["NextPage"] as! String
            }
            if dict.keys.contains("Pages") && dict["Pages"] != nil {
                self.pages = dict["Pages"] as! String
            }
            if dict.keys.contains("Prepage") && dict["Prepage"] != nil {
                self.prepage = dict["Prepage"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageInfo: GetSyntheticTaskListResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = GetSyntheticTaskListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSyntheticTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSyntheticTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSyntheticTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSyntheticTaskMonitorsRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetSyntheticTaskMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var busy: Int64?

        public var city: String?

        public var cityCode: Int64?

        public var clientType: Int64?

        public var district: String?

        public var netServiceId: Int64?

        public var netServiceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.busy != nil {
                map["Busy"] = self.busy!
            }
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.district != nil {
                map["District"] = self.district!
            }
            if self.netServiceId != nil {
                map["NetServiceId"] = self.netServiceId!
            }
            if self.netServiceName != nil {
                map["NetServiceName"] = self.netServiceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Busy") && dict["Busy"] != nil {
                self.busy = dict["Busy"] as! Int64
            }
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
                self.cityCode = dict["CityCode"] as! Int64
            }
            if dict.keys.contains("ClientType") && dict["ClientType"] != nil {
                self.clientType = dict["ClientType"] as! Int64
            }
            if dict.keys.contains("District") && dict["District"] != nil {
                self.district = dict["District"] as! String
            }
            if dict.keys.contains("NetServiceId") && dict["NetServiceId"] != nil {
                self.netServiceId = dict["NetServiceId"] as! Int64
            }
            if dict.keys.contains("NetServiceName") && dict["NetServiceName"] != nil {
                self.netServiceName = dict["NetServiceName"] as! String
            }
        }
    }
    public var code: String?

    public var data: [GetSyntheticTaskMonitorsResponseBody.Data]?

    public var msg: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetSyntheticTaskMonitorsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetSyntheticTaskMonitorsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Msg") && dict["Msg"] != nil {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSyntheticTaskMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSyntheticTaskMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSyntheticTaskMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTimingSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvailableAssertions : Tea.TeaModel {
            public var expect: String?

            public var operator_: String?

            public var target: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expect != nil {
                    map["Expect"] = self.expect!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.target != nil {
                    map["Target"] = self.target!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Expect") && dict["Expect"] != nil {
                    self.expect = dict["Expect"] as! String
                }
                if dict.keys.contains("Operator") && dict["Operator"] != nil {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Target") && dict["Target"] != nil {
                    self.target = dict["Target"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class CommonSetting : Tea.TeaModel {
            public class CustomHost : Tea.TeaModel {
                public class Hosts : Tea.TeaModel {
                    public var domain: String?

                    public var ipType: Int32?

                    public var ips: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.domain != nil {
                            map["Domain"] = self.domain!
                        }
                        if self.ipType != nil {
                            map["IpType"] = self.ipType!
                        }
                        if self.ips != nil {
                            map["Ips"] = self.ips!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Domain") && dict["Domain"] != nil {
                            self.domain = dict["Domain"] as! String
                        }
                        if dict.keys.contains("IpType") && dict["IpType"] != nil {
                            self.ipType = dict["IpType"] as! Int32
                        }
                        if dict.keys.contains("Ips") && dict["Ips"] != nil {
                            self.ips = dict["Ips"] as! [String]
                        }
                    }
                }
                public var hosts: [GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost.Hosts]?

                public var selectType: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.hosts != nil {
                        var tmp : [Any] = []
                        for k in self.hosts! {
                            tmp.append(k.toMap())
                        }
                        map["Hosts"] = tmp
                    }
                    if self.selectType != nil {
                        map["SelectType"] = self.selectType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Hosts") && dict["Hosts"] != nil {
                        var tmp : [GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost.Hosts] = []
                        for v in dict["Hosts"] as! [Any] {
                            var model = GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost.Hosts()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.hosts = tmp
                    }
                    if dict.keys.contains("SelectType") && dict["SelectType"] != nil {
                        self.selectType = dict["SelectType"] as! Int32
                    }
                }
            }
            public var customHost: GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost?

            public var ipType: Int32?

            public var isOpenTrace: Bool?

            public var monitorSamples: Int32?

            public var traceClientType: Int32?

            public var xtraceRegion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.customHost?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customHost != nil {
                    map["CustomHost"] = self.customHost?.toMap()
                }
                if self.ipType != nil {
                    map["IpType"] = self.ipType!
                }
                if self.isOpenTrace != nil {
                    map["IsOpenTrace"] = self.isOpenTrace!
                }
                if self.monitorSamples != nil {
                    map["MonitorSamples"] = self.monitorSamples!
                }
                if self.traceClientType != nil {
                    map["TraceClientType"] = self.traceClientType!
                }
                if self.xtraceRegion != nil {
                    map["XtraceRegion"] = self.xtraceRegion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomHost") && dict["CustomHost"] != nil {
                    var model = GetTimingSyntheticTaskResponseBody.Data.CommonSetting.CustomHost()
                    model.fromMap(dict["CustomHost"] as! [String: Any])
                    self.customHost = model
                }
                if dict.keys.contains("IpType") && dict["IpType"] != nil {
                    self.ipType = dict["IpType"] as! Int32
                }
                if dict.keys.contains("IsOpenTrace") && dict["IsOpenTrace"] != nil {
                    self.isOpenTrace = dict["IsOpenTrace"] as! Bool
                }
                if dict.keys.contains("MonitorSamples") && dict["MonitorSamples"] != nil {
                    self.monitorSamples = dict["MonitorSamples"] as! Int32
                }
                if dict.keys.contains("TraceClientType") && dict["TraceClientType"] != nil {
                    self.traceClientType = dict["TraceClientType"] as! Int32
                }
                if dict.keys.contains("XtraceRegion") && dict["XtraceRegion"] != nil {
                    self.xtraceRegion = dict["XtraceRegion"] as! String
                }
            }
        }
        public class CustomPeriod : Tea.TeaModel {
            public var endHour: Int64?

            public var startHour: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endHour != nil {
                    map["EndHour"] = self.endHour!
                }
                if self.startHour != nil {
                    map["StartHour"] = self.startHour!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndHour") && dict["EndHour"] != nil {
                    self.endHour = dict["EndHour"] as! Int64
                }
                if dict.keys.contains("StartHour") && dict["StartHour"] != nil {
                    self.startHour = dict["StartHour"] as! Int64
                }
            }
        }
        public class MonitorConf : Tea.TeaModel {
            public class ApiHTTP : Tea.TeaModel {
                public class RequestBody : Tea.TeaModel {
                    public var content: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") && dict["Content"] != nil {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var connectTimeout: Int64?

                public var method: String?

                public var requestBody: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.ApiHTTP.RequestBody?

                public var requestHeaders: [String: String]?

                public var targetUrl: String?

                public var timeout: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.requestBody?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectTimeout != nil {
                        map["ConnectTimeout"] = self.connectTimeout!
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    if self.requestBody != nil {
                        map["RequestBody"] = self.requestBody?.toMap()
                    }
                    if self.requestHeaders != nil {
                        map["RequestHeaders"] = self.requestHeaders!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectTimeout") && dict["ConnectTimeout"] != nil {
                        self.connectTimeout = dict["ConnectTimeout"] as! Int64
                    }
                    if dict.keys.contains("Method") && dict["Method"] != nil {
                        self.method = dict["Method"] as! String
                    }
                    if dict.keys.contains("RequestBody") && dict["RequestBody"] != nil {
                        var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.ApiHTTP.RequestBody()
                        model.fromMap(dict["RequestBody"] as! [String: Any])
                        self.requestBody = model
                    }
                    if dict.keys.contains("RequestHeaders") && dict["RequestHeaders"] != nil {
                        self.requestHeaders = dict["RequestHeaders"] as! [String: String]
                    }
                    if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                        self.timeout = dict["Timeout"] as! Int64
                    }
                }
            }
            public class FileDownload : Tea.TeaModel {
                public var connectionTimeout: Int64?

                public var customHeaderContent: [String: String]?

                public var downloadKernel: Int64?

                public var ignoreCertificateAuthError: Int32?

                public var ignoreCertificateCanceledError: Int32?

                public var ignoreCertificateOutOfDateError: Int32?

                public var ignoreCertificateStatusError: Int32?

                public var ignoreCertificateUntrustworthyError: Int32?

                public var ignoreCertificateUsingError: Int32?

                public var ignoreInvalidHostError: Int32?

                public var monitorTimeout: Int64?

                public var quickProtocol: Int64?

                public var redirection: Int32?

                public var targetUrl: String?

                public var transmissionSize: Int64?

                public var validateKeywords: String?

                public var verifyWay: Int32?

                public var whiteList: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionTimeout != nil {
                        map["ConnectionTimeout"] = self.connectionTimeout!
                    }
                    if self.customHeaderContent != nil {
                        map["CustomHeaderContent"] = self.customHeaderContent!
                    }
                    if self.downloadKernel != nil {
                        map["DownloadKernel"] = self.downloadKernel!
                    }
                    if self.ignoreCertificateAuthError != nil {
                        map["IgnoreCertificateAuthError"] = self.ignoreCertificateAuthError!
                    }
                    if self.ignoreCertificateCanceledError != nil {
                        map["IgnoreCertificateCanceledError"] = self.ignoreCertificateCanceledError!
                    }
                    if self.ignoreCertificateOutOfDateError != nil {
                        map["IgnoreCertificateOutOfDateError"] = self.ignoreCertificateOutOfDateError!
                    }
                    if self.ignoreCertificateStatusError != nil {
                        map["IgnoreCertificateStatusError"] = self.ignoreCertificateStatusError!
                    }
                    if self.ignoreCertificateUntrustworthyError != nil {
                        map["IgnoreCertificateUntrustworthyError"] = self.ignoreCertificateUntrustworthyError!
                    }
                    if self.ignoreCertificateUsingError != nil {
                        map["IgnoreCertificateUsingError"] = self.ignoreCertificateUsingError!
                    }
                    if self.ignoreInvalidHostError != nil {
                        map["IgnoreInvalidHostError"] = self.ignoreInvalidHostError!
                    }
                    if self.monitorTimeout != nil {
                        map["MonitorTimeout"] = self.monitorTimeout!
                    }
                    if self.quickProtocol != nil {
                        map["QuickProtocol"] = self.quickProtocol!
                    }
                    if self.redirection != nil {
                        map["Redirection"] = self.redirection!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.transmissionSize != nil {
                        map["TransmissionSize"] = self.transmissionSize!
                    }
                    if self.validateKeywords != nil {
                        map["ValidateKeywords"] = self.validateKeywords!
                    }
                    if self.verifyWay != nil {
                        map["VerifyWay"] = self.verifyWay!
                    }
                    if self.whiteList != nil {
                        map["WhiteList"] = self.whiteList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectionTimeout") && dict["ConnectionTimeout"] != nil {
                        self.connectionTimeout = dict["ConnectionTimeout"] as! Int64
                    }
                    if dict.keys.contains("CustomHeaderContent") && dict["CustomHeaderContent"] != nil {
                        self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                    }
                    if dict.keys.contains("DownloadKernel") && dict["DownloadKernel"] != nil {
                        self.downloadKernel = dict["DownloadKernel"] as! Int64
                    }
                    if dict.keys.contains("IgnoreCertificateAuthError") && dict["IgnoreCertificateAuthError"] != nil {
                        self.ignoreCertificateAuthError = dict["IgnoreCertificateAuthError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateCanceledError") && dict["IgnoreCertificateCanceledError"] != nil {
                        self.ignoreCertificateCanceledError = dict["IgnoreCertificateCanceledError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateOutOfDateError") && dict["IgnoreCertificateOutOfDateError"] != nil {
                        self.ignoreCertificateOutOfDateError = dict["IgnoreCertificateOutOfDateError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateStatusError") && dict["IgnoreCertificateStatusError"] != nil {
                        self.ignoreCertificateStatusError = dict["IgnoreCertificateStatusError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateUntrustworthyError") && dict["IgnoreCertificateUntrustworthyError"] != nil {
                        self.ignoreCertificateUntrustworthyError = dict["IgnoreCertificateUntrustworthyError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreCertificateUsingError") && dict["IgnoreCertificateUsingError"] != nil {
                        self.ignoreCertificateUsingError = dict["IgnoreCertificateUsingError"] as! Int32
                    }
                    if dict.keys.contains("IgnoreInvalidHostError") && dict["IgnoreInvalidHostError"] != nil {
                        self.ignoreInvalidHostError = dict["IgnoreInvalidHostError"] as! Int32
                    }
                    if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                        self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                    }
                    if dict.keys.contains("QuickProtocol") && dict["QuickProtocol"] != nil {
                        self.quickProtocol = dict["QuickProtocol"] as! Int64
                    }
                    if dict.keys.contains("Redirection") && dict["Redirection"] != nil {
                        self.redirection = dict["Redirection"] as! Int32
                    }
                    if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("TransmissionSize") && dict["TransmissionSize"] != nil {
                        self.transmissionSize = dict["TransmissionSize"] as! Int64
                    }
                    if dict.keys.contains("ValidateKeywords") && dict["ValidateKeywords"] != nil {
                        self.validateKeywords = dict["ValidateKeywords"] as! String
                    }
                    if dict.keys.contains("VerifyWay") && dict["VerifyWay"] != nil {
                        self.verifyWay = dict["VerifyWay"] as! Int32
                    }
                    if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                        self.whiteList = dict["WhiteList"] as! String
                    }
                }
            }
            public class NetDNS : Tea.TeaModel {
                public var dnsServerIpType: Int32?

                public var nsServer: String?

                public var queryMethod: Int32?

                public var targetUrl: String?

                public var timeout: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dnsServerIpType != nil {
                        map["DnsServerIpType"] = self.dnsServerIpType!
                    }
                    if self.nsServer != nil {
                        map["NsServer"] = self.nsServer!
                    }
                    if self.queryMethod != nil {
                        map["QueryMethod"] = self.queryMethod!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DnsServerIpType") && dict["DnsServerIpType"] != nil {
                        self.dnsServerIpType = dict["DnsServerIpType"] as! Int32
                    }
                    if dict.keys.contains("NsServer") && dict["NsServer"] != nil {
                        self.nsServer = dict["NsServer"] as! String
                    }
                    if dict.keys.contains("QueryMethod") && dict["QueryMethod"] != nil {
                        self.queryMethod = dict["QueryMethod"] as! Int32
                    }
                    if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                        self.timeout = dict["Timeout"] as! Int64
                    }
                }
            }
            public class NetICMP : Tea.TeaModel {
                public var interval: Int32?

                public var packageNum: Int32?

                public var packageSize: Int32?

                public var splitPackage: Bool?

                public var targetUrl: String?

                public var timeout: Int64?

                public var tracertEnable: Bool?

                public var tracertNumMax: Int32?

                public var tracertTimeout: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.packageNum != nil {
                        map["PackageNum"] = self.packageNum!
                    }
                    if self.packageSize != nil {
                        map["PackageSize"] = self.packageSize!
                    }
                    if self.splitPackage != nil {
                        map["SplitPackage"] = self.splitPackage!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.tracertEnable != nil {
                        map["TracertEnable"] = self.tracertEnable!
                    }
                    if self.tracertNumMax != nil {
                        map["TracertNumMax"] = self.tracertNumMax!
                    }
                    if self.tracertTimeout != nil {
                        map["TracertTimeout"] = self.tracertTimeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("PackageNum") && dict["PackageNum"] != nil {
                        self.packageNum = dict["PackageNum"] as! Int32
                    }
                    if dict.keys.contains("PackageSize") && dict["PackageSize"] != nil {
                        self.packageSize = dict["PackageSize"] as! Int32
                    }
                    if dict.keys.contains("SplitPackage") && dict["SplitPackage"] != nil {
                        self.splitPackage = dict["SplitPackage"] as! Bool
                    }
                    if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                        self.timeout = dict["Timeout"] as! Int64
                    }
                    if dict.keys.contains("TracertEnable") && dict["TracertEnable"] != nil {
                        self.tracertEnable = dict["TracertEnable"] as! Bool
                    }
                    if dict.keys.contains("TracertNumMax") && dict["TracertNumMax"] != nil {
                        self.tracertNumMax = dict["TracertNumMax"] as! Int32
                    }
                    if dict.keys.contains("TracertTimeout") && dict["TracertTimeout"] != nil {
                        self.tracertTimeout = dict["TracertTimeout"] as! Int64
                    }
                }
            }
            public class NetTCP : Tea.TeaModel {
                public var connectTimes: Int32?

                public var interval: Int64?

                public var targetUrl: String?

                public var timeout: Int64?

                public var tracertEnable: Bool?

                public var tracertNumMax: Int32?

                public var tracertTimeout: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectTimes != nil {
                        map["ConnectTimes"] = self.connectTimes!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.tracertEnable != nil {
                        map["TracertEnable"] = self.tracertEnable!
                    }
                    if self.tracertNumMax != nil {
                        map["TracertNumMax"] = self.tracertNumMax!
                    }
                    if self.tracertTimeout != nil {
                        map["TracertTimeout"] = self.tracertTimeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectTimes") && dict["ConnectTimes"] != nil {
                        self.connectTimes = dict["ConnectTimes"] as! Int32
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int64
                    }
                    if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                        self.timeout = dict["Timeout"] as! Int64
                    }
                    if dict.keys.contains("TracertEnable") && dict["TracertEnable"] != nil {
                        self.tracertEnable = dict["TracertEnable"] as! Bool
                    }
                    if dict.keys.contains("TracertNumMax") && dict["TracertNumMax"] != nil {
                        self.tracertNumMax = dict["TracertNumMax"] as! Int32
                    }
                    if dict.keys.contains("TracertTimeout") && dict["TracertTimeout"] != nil {
                        self.tracertTimeout = dict["TracertTimeout"] as! Int64
                    }
                }
            }
            public class Stream : Tea.TeaModel {
                public var customHeaderContent: [String: String]?

                public var playerType: Int32?

                public var streamAddressType: Int32?

                public var streamMonitorTimeout: Int32?

                public var streamType: Int32?

                public var targetUrl: String?

                public var whiteList: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.customHeaderContent != nil {
                        map["CustomHeaderContent"] = self.customHeaderContent!
                    }
                    if self.playerType != nil {
                        map["PlayerType"] = self.playerType!
                    }
                    if self.streamAddressType != nil {
                        map["StreamAddressType"] = self.streamAddressType!
                    }
                    if self.streamMonitorTimeout != nil {
                        map["StreamMonitorTimeout"] = self.streamMonitorTimeout!
                    }
                    if self.streamType != nil {
                        map["StreamType"] = self.streamType!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.whiteList != nil {
                        map["WhiteList"] = self.whiteList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CustomHeaderContent") && dict["CustomHeaderContent"] != nil {
                        self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                    }
                    if dict.keys.contains("PlayerType") && dict["PlayerType"] != nil {
                        self.playerType = dict["PlayerType"] as! Int32
                    }
                    if dict.keys.contains("StreamAddressType") && dict["StreamAddressType"] != nil {
                        self.streamAddressType = dict["StreamAddressType"] as! Int32
                    }
                    if dict.keys.contains("StreamMonitorTimeout") && dict["StreamMonitorTimeout"] != nil {
                        self.streamMonitorTimeout = dict["StreamMonitorTimeout"] as! Int32
                    }
                    if dict.keys.contains("StreamType") && dict["StreamType"] != nil {
                        self.streamType = dict["StreamType"] as! Int32
                    }
                    if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                        self.whiteList = dict["WhiteList"] as! String
                    }
                }
            }
            public class Website : Tea.TeaModel {
                public var automaticScrolling: Int32?

                public var customHeader: Int32?

                public var customHeaderContent: [String: String]?

                public var DNSHijackWhitelist: String?

                public var disableCache: Int32?

                public var disableCompression: Int32?

                public var elementBlacklist: String?

                public var filterInvalidIP: Int32?

                public var flowHijackJumpTimes: Int32?

                public var flowHijackLogo: String?

                public var ignoreCertificateError: Int32?

                public var monitorTimeout: Int32?

                public var pageTamper: String?

                public var redirection: Int32?

                public var slowElementThreshold: Int64?

                public var targetUrl: String?

                public var verifyStringBlacklist: String?

                public var verifyStringWhitelist: String?

                public var waitCompletionTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.automaticScrolling != nil {
                        map["AutomaticScrolling"] = self.automaticScrolling!
                    }
                    if self.customHeader != nil {
                        map["CustomHeader"] = self.customHeader!
                    }
                    if self.customHeaderContent != nil {
                        map["CustomHeaderContent"] = self.customHeaderContent!
                    }
                    if self.DNSHijackWhitelist != nil {
                        map["DNSHijackWhitelist"] = self.DNSHijackWhitelist!
                    }
                    if self.disableCache != nil {
                        map["DisableCache"] = self.disableCache!
                    }
                    if self.disableCompression != nil {
                        map["DisableCompression"] = self.disableCompression!
                    }
                    if self.elementBlacklist != nil {
                        map["ElementBlacklist"] = self.elementBlacklist!
                    }
                    if self.filterInvalidIP != nil {
                        map["FilterInvalidIP"] = self.filterInvalidIP!
                    }
                    if self.flowHijackJumpTimes != nil {
                        map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
                    }
                    if self.flowHijackLogo != nil {
                        map["FlowHijackLogo"] = self.flowHijackLogo!
                    }
                    if self.ignoreCertificateError != nil {
                        map["IgnoreCertificateError"] = self.ignoreCertificateError!
                    }
                    if self.monitorTimeout != nil {
                        map["MonitorTimeout"] = self.monitorTimeout!
                    }
                    if self.pageTamper != nil {
                        map["PageTamper"] = self.pageTamper!
                    }
                    if self.redirection != nil {
                        map["Redirection"] = self.redirection!
                    }
                    if self.slowElementThreshold != nil {
                        map["SlowElementThreshold"] = self.slowElementThreshold!
                    }
                    if self.targetUrl != nil {
                        map["TargetUrl"] = self.targetUrl!
                    }
                    if self.verifyStringBlacklist != nil {
                        map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
                    }
                    if self.verifyStringWhitelist != nil {
                        map["VerifyStringWhitelist"] = self.verifyStringWhitelist!
                    }
                    if self.waitCompletionTime != nil {
                        map["WaitCompletionTime"] = self.waitCompletionTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutomaticScrolling") && dict["AutomaticScrolling"] != nil {
                        self.automaticScrolling = dict["AutomaticScrolling"] as! Int32
                    }
                    if dict.keys.contains("CustomHeader") && dict["CustomHeader"] != nil {
                        self.customHeader = dict["CustomHeader"] as! Int32
                    }
                    if dict.keys.contains("CustomHeaderContent") && dict["CustomHeaderContent"] != nil {
                        self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                    }
                    if dict.keys.contains("DNSHijackWhitelist") && dict["DNSHijackWhitelist"] != nil {
                        self.DNSHijackWhitelist = dict["DNSHijackWhitelist"] as! String
                    }
                    if dict.keys.contains("DisableCache") && dict["DisableCache"] != nil {
                        self.disableCache = dict["DisableCache"] as! Int32
                    }
                    if dict.keys.contains("DisableCompression") && dict["DisableCompression"] != nil {
                        self.disableCompression = dict["DisableCompression"] as! Int32
                    }
                    if dict.keys.contains("ElementBlacklist") && dict["ElementBlacklist"] != nil {
                        self.elementBlacklist = dict["ElementBlacklist"] as! String
                    }
                    if dict.keys.contains("FilterInvalidIP") && dict["FilterInvalidIP"] != nil {
                        self.filterInvalidIP = dict["FilterInvalidIP"] as! Int32
                    }
                    if dict.keys.contains("FlowHijackJumpTimes") && dict["FlowHijackJumpTimes"] != nil {
                        self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int32
                    }
                    if dict.keys.contains("FlowHijackLogo") && dict["FlowHijackLogo"] != nil {
                        self.flowHijackLogo = dict["FlowHijackLogo"] as! String
                    }
                    if dict.keys.contains("IgnoreCertificateError") && dict["IgnoreCertificateError"] != nil {
                        self.ignoreCertificateError = dict["IgnoreCertificateError"] as! Int32
                    }
                    if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                        self.monitorTimeout = dict["MonitorTimeout"] as! Int32
                    }
                    if dict.keys.contains("PageTamper") && dict["PageTamper"] != nil {
                        self.pageTamper = dict["PageTamper"] as! String
                    }
                    if dict.keys.contains("Redirection") && dict["Redirection"] != nil {
                        self.redirection = dict["Redirection"] as! Int32
                    }
                    if dict.keys.contains("SlowElementThreshold") && dict["SlowElementThreshold"] != nil {
                        self.slowElementThreshold = dict["SlowElementThreshold"] as! Int64
                    }
                    if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                        self.targetUrl = dict["TargetUrl"] as! String
                    }
                    if dict.keys.contains("VerifyStringBlacklist") && dict["VerifyStringBlacklist"] != nil {
                        self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
                    }
                    if dict.keys.contains("VerifyStringWhitelist") && dict["VerifyStringWhitelist"] != nil {
                        self.verifyStringWhitelist = dict["VerifyStringWhitelist"] as! String
                    }
                    if dict.keys.contains("WaitCompletionTime") && dict["WaitCompletionTime"] != nil {
                        self.waitCompletionTime = dict["WaitCompletionTime"] as! Int64
                    }
                }
            }
            public var apiHTTP: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.ApiHTTP?

            public var fileDownload: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.FileDownload?

            public var netDNS: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetDNS?

            public var netICMP: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetICMP?

            public var netTCP: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetTCP?

            public var stream: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.Stream?

            public var website: GetTimingSyntheticTaskResponseBody.Data.MonitorConf.Website?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.apiHTTP?.validate()
                try self.fileDownload?.validate()
                try self.netDNS?.validate()
                try self.netICMP?.validate()
                try self.netTCP?.validate()
                try self.stream?.validate()
                try self.website?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiHTTP != nil {
                    map["ApiHTTP"] = self.apiHTTP?.toMap()
                }
                if self.fileDownload != nil {
                    map["FileDownload"] = self.fileDownload?.toMap()
                }
                if self.netDNS != nil {
                    map["NetDNS"] = self.netDNS?.toMap()
                }
                if self.netICMP != nil {
                    map["NetICMP"] = self.netICMP?.toMap()
                }
                if self.netTCP != nil {
                    map["NetTCP"] = self.netTCP?.toMap()
                }
                if self.stream != nil {
                    map["Stream"] = self.stream?.toMap()
                }
                if self.website != nil {
                    map["Website"] = self.website?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiHTTP") && dict["ApiHTTP"] != nil {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.ApiHTTP()
                    model.fromMap(dict["ApiHTTP"] as! [String: Any])
                    self.apiHTTP = model
                }
                if dict.keys.contains("FileDownload") && dict["FileDownload"] != nil {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.FileDownload()
                    model.fromMap(dict["FileDownload"] as! [String: Any])
                    self.fileDownload = model
                }
                if dict.keys.contains("NetDNS") && dict["NetDNS"] != nil {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetDNS()
                    model.fromMap(dict["NetDNS"] as! [String: Any])
                    self.netDNS = model
                }
                if dict.keys.contains("NetICMP") && dict["NetICMP"] != nil {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetICMP()
                    model.fromMap(dict["NetICMP"] as! [String: Any])
                    self.netICMP = model
                }
                if dict.keys.contains("NetTCP") && dict["NetTCP"] != nil {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.NetTCP()
                    model.fromMap(dict["NetTCP"] as! [String: Any])
                    self.netTCP = model
                }
                if dict.keys.contains("Stream") && dict["Stream"] != nil {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.Stream()
                    model.fromMap(dict["Stream"] as! [String: Any])
                    self.stream = model
                }
                if dict.keys.contains("Website") && dict["Website"] != nil {
                    var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf.Website()
                    model.fromMap(dict["Website"] as! [String: Any])
                    self.website = model
                }
            }
        }
        public class Monitors : Tea.TeaModel {
            public var cityCode: String?

            public var clientType: Int32?

            public var operatorCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.clientType != nil {
                    map["ClientType"] = self.clientType!
                }
                if self.operatorCode != nil {
                    map["OperatorCode"] = self.operatorCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("ClientType") && dict["ClientType"] != nil {
                    self.clientType = dict["ClientType"] as! Int32
                }
                if dict.keys.contains("OperatorCode") && dict["OperatorCode"] != nil {
                    self.operatorCode = dict["OperatorCode"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var availableAssertions: [GetTimingSyntheticTaskResponseBody.Data.AvailableAssertions]?

        public var commonSetting: GetTimingSyntheticTaskResponseBody.Data.CommonSetting?

        public var customPeriod: GetTimingSyntheticTaskResponseBody.Data.CustomPeriod?

        public var frequency: String?

        public var monitorCategory: Int64?

        public var monitorConf: GetTimingSyntheticTaskResponseBody.Data.MonitorConf?

        public var monitors: [GetTimingSyntheticTaskResponseBody.Data.Monitors]?

        public var name: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var status: String?

        public var tags: [GetTimingSyntheticTaskResponseBody.Data.Tags]?

        public var taskId: String?

        public var taskType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commonSetting?.validate()
            try self.customPeriod?.validate()
            try self.monitorConf?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableAssertions != nil {
                var tmp : [Any] = []
                for k in self.availableAssertions! {
                    tmp.append(k.toMap())
                }
                map["AvailableAssertions"] = tmp
            }
            if self.commonSetting != nil {
                map["CommonSetting"] = self.commonSetting?.toMap()
            }
            if self.customPeriod != nil {
                map["CustomPeriod"] = self.customPeriod?.toMap()
            }
            if self.frequency != nil {
                map["Frequency"] = self.frequency!
            }
            if self.monitorCategory != nil {
                map["MonitorCategory"] = self.monitorCategory!
            }
            if self.monitorConf != nil {
                map["MonitorConf"] = self.monitorConf?.toMap()
            }
            if self.monitors != nil {
                var tmp : [Any] = []
                for k in self.monitors! {
                    tmp.append(k.toMap())
                }
                map["Monitors"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableAssertions") && dict["AvailableAssertions"] != nil {
                var tmp : [GetTimingSyntheticTaskResponseBody.Data.AvailableAssertions] = []
                for v in dict["AvailableAssertions"] as! [Any] {
                    var model = GetTimingSyntheticTaskResponseBody.Data.AvailableAssertions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableAssertions = tmp
            }
            if dict.keys.contains("CommonSetting") && dict["CommonSetting"] != nil {
                var model = GetTimingSyntheticTaskResponseBody.Data.CommonSetting()
                model.fromMap(dict["CommonSetting"] as! [String: Any])
                self.commonSetting = model
            }
            if dict.keys.contains("CustomPeriod") && dict["CustomPeriod"] != nil {
                var model = GetTimingSyntheticTaskResponseBody.Data.CustomPeriod()
                model.fromMap(dict["CustomPeriod"] as! [String: Any])
                self.customPeriod = model
            }
            if dict.keys.contains("Frequency") && dict["Frequency"] != nil {
                self.frequency = dict["Frequency"] as! String
            }
            if dict.keys.contains("MonitorCategory") && dict["MonitorCategory"] != nil {
                self.monitorCategory = dict["MonitorCategory"] as! Int64
            }
            if dict.keys.contains("MonitorConf") && dict["MonitorConf"] != nil {
                var model = GetTimingSyntheticTaskResponseBody.Data.MonitorConf()
                model.fromMap(dict["MonitorConf"] as! [String: Any])
                self.monitorConf = model
            }
            if dict.keys.contains("Monitors") && dict["Monitors"] != nil {
                var tmp : [GetTimingSyntheticTaskResponseBody.Data.Monitors] = []
                for v in dict["Monitors"] as! [Any] {
                    var model = GetTimingSyntheticTaskResponseBody.Data.Monitors()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.monitors = tmp
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [GetTimingSyntheticTaskResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetTimingSyntheticTaskResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! Int32
            }
        }
    }
    public var code: Int64?

    public var data: GetTimingSyntheticTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetTimingSyntheticTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTraceRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var regionId: String?

    public var startTime: Int64?

    public var traceID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.traceID != nil {
            map["TraceID"] = self.traceID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TraceID") && dict["TraceID"] != nil {
            self.traceID = dict["TraceID"] as! String
        }
    }
}

public class GetTraceResponseBody : Tea.TeaModel {
    public class Spans : Tea.TeaModel {
        public class LogEventList : Tea.TeaModel {
            public class TagEntryList : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var tagEntryList: [GetTraceResponseBody.Spans.LogEventList.TagEntryList]?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagEntryList != nil {
                    var tmp : [Any] = []
                    for k in self.tagEntryList! {
                        tmp.append(k.toMap())
                    }
                    map["TagEntryList"] = tmp
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagEntryList") && dict["TagEntryList"] != nil {
                    var tmp : [GetTraceResponseBody.Spans.LogEventList.TagEntryList] = []
                    for v in dict["TagEntryList"] as! [Any] {
                        var model = GetTraceResponseBody.Spans.LogEventList.TagEntryList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tagEntryList = tmp
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
            }
        }
        public class TagEntryList : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var children: [[String: Any]]?

        public var duration: Int64?

        public var haveStack: Bool?

        public var logEventList: [GetTraceResponseBody.Spans.LogEventList]?

        public var operationName: String?

        public var parentSpanId: String?

        public var resultCode: String?

        public var rpcId: String?

        public var rpcType: Int32?

        public var serviceIp: String?

        public var serviceName: String?

        public var spanId: String?

        public var tagEntryList: [GetTraceResponseBody.Spans.TagEntryList]?

        public var timestamp: Int64?

        public var traceID: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.children != nil {
                map["Children"] = self.children!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.haveStack != nil {
                map["HaveStack"] = self.haveStack!
            }
            if self.logEventList != nil {
                var tmp : [Any] = []
                for k in self.logEventList! {
                    tmp.append(k.toMap())
                }
                map["LogEventList"] = tmp
            }
            if self.operationName != nil {
                map["OperationName"] = self.operationName!
            }
            if self.parentSpanId != nil {
                map["ParentSpanId"] = self.parentSpanId!
            }
            if self.resultCode != nil {
                map["ResultCode"] = self.resultCode!
            }
            if self.rpcId != nil {
                map["RpcId"] = self.rpcId!
            }
            if self.rpcType != nil {
                map["RpcType"] = self.rpcType!
            }
            if self.serviceIp != nil {
                map["ServiceIp"] = self.serviceIp!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.spanId != nil {
                map["SpanId"] = self.spanId!
            }
            if self.tagEntryList != nil {
                var tmp : [Any] = []
                for k in self.tagEntryList! {
                    tmp.append(k.toMap())
                }
                map["TagEntryList"] = tmp
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.traceID != nil {
                map["TraceID"] = self.traceID!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Children") && dict["Children"] != nil {
                self.children = dict["Children"] as! [[String: Any]]
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("HaveStack") && dict["HaveStack"] != nil {
                self.haveStack = dict["HaveStack"] as! Bool
            }
            if dict.keys.contains("LogEventList") && dict["LogEventList"] != nil {
                var tmp : [GetTraceResponseBody.Spans.LogEventList] = []
                for v in dict["LogEventList"] as! [Any] {
                    var model = GetTraceResponseBody.Spans.LogEventList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logEventList = tmp
            }
            if dict.keys.contains("OperationName") && dict["OperationName"] != nil {
                self.operationName = dict["OperationName"] as! String
            }
            if dict.keys.contains("ParentSpanId") && dict["ParentSpanId"] != nil {
                self.parentSpanId = dict["ParentSpanId"] as! String
            }
            if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
                self.resultCode = dict["ResultCode"] as! String
            }
            if dict.keys.contains("RpcId") && dict["RpcId"] != nil {
                self.rpcId = dict["RpcId"] as! String
            }
            if dict.keys.contains("RpcType") && dict["RpcType"] != nil {
                self.rpcType = dict["RpcType"] as! Int32
            }
            if dict.keys.contains("ServiceIp") && dict["ServiceIp"] != nil {
                self.serviceIp = dict["ServiceIp"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("SpanId") && dict["SpanId"] != nil {
                self.spanId = dict["SpanId"] as! String
            }
            if dict.keys.contains("TagEntryList") && dict["TagEntryList"] != nil {
                var tmp : [GetTraceResponseBody.Spans.TagEntryList] = []
                for v in dict["TagEntryList"] as! [Any] {
                    var model = GetTraceResponseBody.Spans.TagEntryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagEntryList = tmp
            }
            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TraceID") && dict["TraceID"] != nil {
                self.traceID = dict["TraceID"] as! String
            }
        }
    }
    public var requestId: String?

    public var spans: [GetTraceResponseBody.Spans]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spans != nil {
            var tmp : [Any] = []
            for k in self.spans! {
                tmp.append(k.toMap())
            }
            map["Spans"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Spans") && dict["Spans"] != nil {
            var tmp : [GetTraceResponseBody.Spans] = []
            for v in dict["Spans"] as! [Any] {
                var model = GetTraceResponseBody.Spans()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spans = tmp
        }
    }
}

public class GetTraceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTraceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTraceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTraceAppRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pid: String?

    public var regionId: String?

    public var tags: [GetTraceAppRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [GetTraceAppRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetTraceAppRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetTraceAppResponseBody : Tea.TeaModel {
    public class TraceApp : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: Int64?

        public var appName: String?

        public var createTime: Int64?

        public var labels: [String]?

        public var pid: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var show: Bool?

        public var source: String?

        public var tags: [GetTraceAppResponseBody.TraceApp.Tags]?

        public var type: String?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.labels != nil {
                map["Labels"] = self.labels!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.show != nil {
                map["Show"] = self.show!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                self.labels = dict["Labels"] as! [String]
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Show") && dict["Show"] != nil {
                self.show = dict["Show"] as! Bool
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [GetTraceAppResponseBody.TraceApp.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetTraceAppResponseBody.TraceApp.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var requestId: String?

    public var traceApp: GetTraceAppResponseBody.TraceApp?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.traceApp?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceApp != nil {
            map["TraceApp"] = self.traceApp?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TraceApp") && dict["TraceApp"] != nil {
            var model = GetTraceAppResponseBody.TraceApp()
            model.fromMap(dict["TraceApp"] as! [String: Any])
            self.traceApp = model
        }
    }
}

public class GetTraceAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTraceAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTraceAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportAppAlertRulesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var contactGroupIds: String?

    public var isAutoStart: Bool?

    public var pids: String?

    public var regionId: String?

    public var tags: [ImportAppAlertRulesRequest.Tags]?

    public var templageAlertConfig: String?

    public var templateAlertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupIds != nil {
            map["ContactGroupIds"] = self.contactGroupIds!
        }
        if self.isAutoStart != nil {
            map["IsAutoStart"] = self.isAutoStart!
        }
        if self.pids != nil {
            map["Pids"] = self.pids!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.templageAlertConfig != nil {
            map["TemplageAlertConfig"] = self.templageAlertConfig!
        }
        if self.templateAlertId != nil {
            map["TemplateAlertId"] = self.templateAlertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupIds") && dict["ContactGroupIds"] != nil {
            self.contactGroupIds = dict["ContactGroupIds"] as! String
        }
        if dict.keys.contains("IsAutoStart") && dict["IsAutoStart"] != nil {
            self.isAutoStart = dict["IsAutoStart"] as! Bool
        }
        if dict.keys.contains("Pids") && dict["Pids"] != nil {
            self.pids = dict["Pids"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [ImportAppAlertRulesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ImportAppAlertRulesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TemplageAlertConfig") && dict["TemplageAlertConfig"] != nil {
            self.templageAlertConfig = dict["TemplageAlertConfig"] as! String
        }
        if dict.keys.contains("TemplateAlertId") && dict["TemplateAlertId"] != nil {
            self.templateAlertId = dict["TemplateAlertId"] as! String
        }
    }
}

public class ImportAppAlertRulesResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportAppAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportAppAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportAppAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitEnvironmentRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class InitEnvironmentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InitEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InitEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallAddonRequest : Tea.TeaModel {
    public var addonVersion: String?

    public var aliyunLang: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var name: String?

    public var regionId: String?

    public var releaseName: String?

    public var values: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonVersion != nil {
            map["AddonVersion"] = self.addonVersion!
        }
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseName != nil {
            map["ReleaseName"] = self.releaseName!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonVersion") && dict["AddonVersion"] != nil {
            self.addonVersion = dict["AddonVersion"] as! String
        }
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseName") && dict["ReleaseName"] != nil {
            self.releaseName = dict["ReleaseName"] as! String
        }
        if dict.keys.contains("Values") && dict["Values"] != nil {
            self.values = dict["Values"] as! String
        }
    }
}

public class InstallAddonResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Conditions : Tea.TeaModel {
            public var firstTransitionTime: String?

            public var lastTransitionTime: String?

            public var message: String?

            public var reason: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.firstTransitionTime != nil {
                    map["FirstTransitionTime"] = self.firstTransitionTime!
                }
                if self.lastTransitionTime != nil {
                    map["LastTransitionTime"] = self.lastTransitionTime!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FirstTransitionTime") && dict["FirstTransitionTime"] != nil {
                    self.firstTransitionTime = dict["FirstTransitionTime"] as! String
                }
                if dict.keys.contains("LastTransitionTime") && dict["LastTransitionTime"] != nil {
                    self.lastTransitionTime = dict["LastTransitionTime"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Reason") && dict["Reason"] != nil {
                    self.reason = dict["Reason"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var addonName: String?

        public var alertRuleCount: Int64?

        public var conditions: [InstallAddonResponseBody.Data.Conditions]?

        public var createTime: String?

        public var dashboardCount: Int64?

        public var environmentId: String?

        public var exporterCount: Int64?

        public var haveConfig: Bool?

        public var installUserId: String?

        public var language: String?

        public var regionId: String?

        public var releaseId: String?

        public var releaseName: String?

        public var scene: String?

        public var status: String?

        public var updateTime: String?

        public var userId: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addonName != nil {
                map["AddonName"] = self.addonName!
            }
            if self.alertRuleCount != nil {
                map["AlertRuleCount"] = self.alertRuleCount!
            }
            if self.conditions != nil {
                var tmp : [Any] = []
                for k in self.conditions! {
                    tmp.append(k.toMap())
                }
                map["Conditions"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dashboardCount != nil {
                map["DashboardCount"] = self.dashboardCount!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.exporterCount != nil {
                map["ExporterCount"] = self.exporterCount!
            }
            if self.haveConfig != nil {
                map["HaveConfig"] = self.haveConfig!
            }
            if self.installUserId != nil {
                map["InstallUserId"] = self.installUserId!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.releaseId != nil {
                map["ReleaseId"] = self.releaseId!
            }
            if self.releaseName != nil {
                map["ReleaseName"] = self.releaseName!
            }
            if self.scene != nil {
                map["Scene"] = self.scene!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddonName") && dict["AddonName"] != nil {
                self.addonName = dict["AddonName"] as! String
            }
            if dict.keys.contains("AlertRuleCount") && dict["AlertRuleCount"] != nil {
                self.alertRuleCount = dict["AlertRuleCount"] as! Int64
            }
            if dict.keys.contains("Conditions") && dict["Conditions"] != nil {
                var tmp : [InstallAddonResponseBody.Data.Conditions] = []
                for v in dict["Conditions"] as! [Any] {
                    var model = InstallAddonResponseBody.Data.Conditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditions = tmp
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DashboardCount") && dict["DashboardCount"] != nil {
                self.dashboardCount = dict["DashboardCount"] as! Int64
            }
            if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("ExporterCount") && dict["ExporterCount"] != nil {
                self.exporterCount = dict["ExporterCount"] as! Int64
            }
            if dict.keys.contains("HaveConfig") && dict["HaveConfig"] != nil {
                self.haveConfig = dict["HaveConfig"] as! Bool
            }
            if dict.keys.contains("InstallUserId") && dict["InstallUserId"] != nil {
                self.installUserId = dict["InstallUserId"] as! String
            }
            if dict.keys.contains("Language") && dict["Language"] != nil {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ReleaseId") && dict["ReleaseId"] != nil {
                self.releaseId = dict["ReleaseId"] as! String
            }
            if dict.keys.contains("ReleaseName") && dict["ReleaseName"] != nil {
                self.releaseName = dict["ReleaseName"] as! String
            }
            if dict.keys.contains("Scene") && dict["Scene"] != nil {
                self.scene = dict["Scene"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: InstallAddonResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = InstallAddonResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallAddonResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallAddonResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallAddonResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallCmsExporterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var cmsArgs: String?

    public var directArgs: String?

    public var enableTag: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cmsArgs != nil {
            map["CmsArgs"] = self.cmsArgs!
        }
        if self.directArgs != nil {
            map["DirectArgs"] = self.directArgs!
        }
        if self.enableTag != nil {
            map["EnableTag"] = self.enableTag!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CmsArgs") && dict["CmsArgs"] != nil {
            self.cmsArgs = dict["CmsArgs"] as! String
        }
        if dict.keys.contains("DirectArgs") && dict["DirectArgs"] != nil {
            self.directArgs = dict["DirectArgs"] as! String
        }
        if dict.keys.contains("EnableTag") && dict["EnableTag"] != nil {
            self.enableTag = dict["EnableTag"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class InstallCmsExporterResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InstallCmsExporterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallCmsExporterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallCmsExporterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallEnvironmentFeatureRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var config: String?

    public var environmentId: String?

    public var featureName: String?

    public var featureVersion: String?

    public var region: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.featureVersion != nil {
            map["FeatureVersion"] = self.featureVersion!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") && dict["FeatureName"] != nil {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("FeatureVersion") && dict["FeatureVersion"] != nil {
            self.featureVersion = dict["FeatureVersion"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class InstallEnvironmentFeatureResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallManagedPrometheusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterName: String?

    public var clusterType: String?

    public var grafanaInstanceId: String?

    public var kubeConfig: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var securityGroupId: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.grafanaInstanceId != nil {
            map["GrafanaInstanceId"] = self.grafanaInstanceId!
        }
        if self.kubeConfig != nil {
            map["KubeConfig"] = self.kubeConfig!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("GrafanaInstanceId") && dict["GrafanaInstanceId"] != nil {
            self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
        }
        if dict.keys.contains("KubeConfig") && dict["KubeConfig"] != nil {
            self.kubeConfig = dict["KubeConfig"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class InstallManagedPrometheusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallManagedPrometheusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallManagedPrometheusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallManagedPrometheusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListActivatedAlertsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var filter: String?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Filter") && dict["Filter"] != nil {
            self.filter = dict["Filter"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListActivatedAlertsResponseBody : Tea.TeaModel {
    public class Page : Tea.TeaModel {
        public class Alerts : Tea.TeaModel {
            public class DispatchRules : Tea.TeaModel {
                public var ruleId: Int32?

                public var ruleName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                        self.ruleId = dict["RuleId"] as! Int32
                    }
                    if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                        self.ruleName = dict["RuleName"] as! String
                    }
                }
            }
            public var alertId: String?

            public var alertName: String?

            public var alertType: String?

            public var count: Int32?

            public var createTime: Int64?

            public var dispatchRules: [ListActivatedAlertsResponseBody.Page.Alerts.DispatchRules]?

            public var endsAt: Int64?

            public var expandFields: [String: Any]?

            public var integrationName: String?

            public var integrationType: String?

            public var involvedObjectKind: String?

            public var involvedObjectName: String?

            public var message: String?

            public var severity: String?

            public var startsAt: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dispatchRules != nil {
                    var tmp : [Any] = []
                    for k in self.dispatchRules! {
                        tmp.append(k.toMap())
                    }
                    map["DispatchRules"] = tmp
                }
                if self.endsAt != nil {
                    map["EndsAt"] = self.endsAt!
                }
                if self.expandFields != nil {
                    map["ExpandFields"] = self.expandFields!
                }
                if self.integrationName != nil {
                    map["IntegrationName"] = self.integrationName!
                }
                if self.integrationType != nil {
                    map["IntegrationType"] = self.integrationType!
                }
                if self.involvedObjectKind != nil {
                    map["InvolvedObjectKind"] = self.involvedObjectKind!
                }
                if self.involvedObjectName != nil {
                    map["InvolvedObjectName"] = self.involvedObjectName!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.startsAt != nil {
                    map["StartsAt"] = self.startsAt!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
                    self.alertId = dict["AlertId"] as! String
                }
                if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("AlertType") && dict["AlertType"] != nil {
                    self.alertType = dict["AlertType"] as! String
                }
                if dict.keys.contains("Count") && dict["Count"] != nil {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DispatchRules") && dict["DispatchRules"] != nil {
                    var tmp : [ListActivatedAlertsResponseBody.Page.Alerts.DispatchRules] = []
                    for v in dict["DispatchRules"] as! [Any] {
                        var model = ListActivatedAlertsResponseBody.Page.Alerts.DispatchRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dispatchRules = tmp
                }
                if dict.keys.contains("EndsAt") && dict["EndsAt"] != nil {
                    self.endsAt = dict["EndsAt"] as! Int64
                }
                if dict.keys.contains("ExpandFields") && dict["ExpandFields"] != nil {
                    self.expandFields = dict["ExpandFields"] as! [String: Any]
                }
                if dict.keys.contains("IntegrationName") && dict["IntegrationName"] != nil {
                    self.integrationName = dict["IntegrationName"] as! String
                }
                if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
                    self.integrationType = dict["IntegrationType"] as! String
                }
                if dict.keys.contains("InvolvedObjectKind") && dict["InvolvedObjectKind"] != nil {
                    self.involvedObjectKind = dict["InvolvedObjectKind"] as! String
                }
                if dict.keys.contains("InvolvedObjectName") && dict["InvolvedObjectName"] != nil {
                    self.involvedObjectName = dict["InvolvedObjectName"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Severity") && dict["Severity"] != nil {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("StartsAt") && dict["StartsAt"] != nil {
                    self.startsAt = dict["StartsAt"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var alerts: [ListActivatedAlertsResponseBody.Page.Alerts]?

        public var page: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alerts != nil {
                var tmp : [Any] = []
                for k in self.alerts! {
                    tmp.append(k.toMap())
                }
                map["Alerts"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alerts") && dict["Alerts"] != nil {
                var tmp : [ListActivatedAlertsResponseBody.Page.Alerts] = []
                for v in dict["Alerts"] as! [Any] {
                    var model = ListActivatedAlertsResponseBody.Page.Alerts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alerts = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var page: ListActivatedAlertsResponseBody.Page?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.page?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["Page"] = self.page?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Page") && dict["Page"] != nil {
            var model = ListActivatedAlertsResponseBody.Page()
            model.fromMap(dict["Page"] as! [String: Any])
            self.page = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListActivatedAlertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListActivatedAlertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListActivatedAlertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAddonReleasesRequest : Tea.TeaModel {
    public var addonName: String?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonName != nil {
            map["AddonName"] = self.addonName!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonName") && dict["AddonName"] != nil {
            self.addonName = dict["AddonName"] as! String
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListAddonReleasesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Releases : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var firstTransitionTime: String?

                public var lastTransitionTime: String?

                public var message: String?

                public var reason: String?

                public var status: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.firstTransitionTime != nil {
                        map["FirstTransitionTime"] = self.firstTransitionTime!
                    }
                    if self.lastTransitionTime != nil {
                        map["LastTransitionTime"] = self.lastTransitionTime!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FirstTransitionTime") && dict["FirstTransitionTime"] != nil {
                        self.firstTransitionTime = dict["FirstTransitionTime"] as! String
                    }
                    if dict.keys.contains("LastTransitionTime") && dict["LastTransitionTime"] != nil {
                        self.lastTransitionTime = dict["LastTransitionTime"] as! String
                    }
                    if dict.keys.contains("Message") && dict["Message"] != nil {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Reason") && dict["Reason"] != nil {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var addonName: String?

            public var alertRuleCount: Int64?

            public var conditions: [ListAddonReleasesResponseBody.Data.Releases.Conditions]?

            public var createTime: String?

            public var dashboardCount: Int64?

            public var environmentId: String?

            public var exporterCount: Int64?

            public var haveConfig: Bool?

            public var installUserId: String?

            public var language: String?

            public var regionId: String?

            public var releaseId: String?

            public var releaseName: String?

            public var scene: String?

            public var status: String?

            public var updateTime: String?

            public var userId: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addonName != nil {
                    map["AddonName"] = self.addonName!
                }
                if self.alertRuleCount != nil {
                    map["AlertRuleCount"] = self.alertRuleCount!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["Conditions"] = tmp
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dashboardCount != nil {
                    map["DashboardCount"] = self.dashboardCount!
                }
                if self.environmentId != nil {
                    map["EnvironmentId"] = self.environmentId!
                }
                if self.exporterCount != nil {
                    map["ExporterCount"] = self.exporterCount!
                }
                if self.haveConfig != nil {
                    map["HaveConfig"] = self.haveConfig!
                }
                if self.installUserId != nil {
                    map["InstallUserId"] = self.installUserId!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.releaseId != nil {
                    map["ReleaseId"] = self.releaseId!
                }
                if self.releaseName != nil {
                    map["ReleaseName"] = self.releaseName!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddonName") && dict["AddonName"] != nil {
                    self.addonName = dict["AddonName"] as! String
                }
                if dict.keys.contains("AlertRuleCount") && dict["AlertRuleCount"] != nil {
                    self.alertRuleCount = dict["AlertRuleCount"] as! Int64
                }
                if dict.keys.contains("Conditions") && dict["Conditions"] != nil {
                    var tmp : [ListAddonReleasesResponseBody.Data.Releases.Conditions] = []
                    for v in dict["Conditions"] as! [Any] {
                        var model = ListAddonReleasesResponseBody.Data.Releases.Conditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.conditions = tmp
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DashboardCount") && dict["DashboardCount"] != nil {
                    self.dashboardCount = dict["DashboardCount"] as! Int64
                }
                if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                    self.environmentId = dict["EnvironmentId"] as! String
                }
                if dict.keys.contains("ExporterCount") && dict["ExporterCount"] != nil {
                    self.exporterCount = dict["ExporterCount"] as! Int64
                }
                if dict.keys.contains("HaveConfig") && dict["HaveConfig"] != nil {
                    self.haveConfig = dict["HaveConfig"] as! Bool
                }
                if dict.keys.contains("InstallUserId") && dict["InstallUserId"] != nil {
                    self.installUserId = dict["InstallUserId"] as! String
                }
                if dict.keys.contains("Language") && dict["Language"] != nil {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReleaseId") && dict["ReleaseId"] != nil {
                    self.releaseId = dict["ReleaseId"] as! String
                }
                if dict.keys.contains("ReleaseName") && dict["ReleaseName"] != nil {
                    self.releaseName = dict["ReleaseName"] as! String
                }
                if dict.keys.contains("Scene") && dict["Scene"] != nil {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var releases: [ListAddonReleasesResponseBody.Data.Releases]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.releases != nil {
                var tmp : [Any] = []
                for k in self.releases! {
                    tmp.append(k.toMap())
                }
                map["Releases"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Releases") && dict["Releases"] != nil {
                var tmp : [ListAddonReleasesResponseBody.Data.Releases] = []
                for v in dict["Releases"] as! [Any] {
                    var model = ListAddonReleasesResponseBody.Data.Releases()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.releases = tmp
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListAddonReleasesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListAddonReleasesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAddonReleasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAddonReleasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAddonReleasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlertEventsRequest : Tea.TeaModel {
    public var alertName: String?

    public var endTime: String?

    public var matchingConditions: String?

    public var page: Int64?

    public var size: Int64?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.matchingConditions != nil {
            map["MatchingConditions"] = self.matchingConditions!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("MatchingConditions") && dict["MatchingConditions"] != nil {
            self.matchingConditions = dict["MatchingConditions"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListAlertEventsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class Events : Tea.TeaModel {
            public class Alarms : Tea.TeaModel {
                public var alarmId: Int64?

                public var alarmName: String?

                public var createTime: String?

                public var state: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alarmId != nil {
                        map["AlarmId"] = self.alarmId!
                    }
                    if self.alarmName != nil {
                        map["AlarmName"] = self.alarmName!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlarmId") && dict["AlarmId"] != nil {
                        self.alarmId = dict["AlarmId"] as! Int64
                    }
                    if dict.keys.contains("AlarmName") && dict["AlarmName"] != nil {
                        self.alarmName = dict["AlarmName"] as! String
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("State") && dict["State"] != nil {
                        self.state = dict["State"] as! Int32
                    }
                }
            }
            public var alarms: [ListAlertEventsResponseBody.PageBean.Events.Alarms]?

            public var alertName: String?

            public var annotations: String?

            public var description_: String?

            public var endTime: String?

            public var generatorURL: String?

            public var handlerName: String?

            public var integrationName: String?

            public var integrationType: String?

            public var labels: String?

            public var receiveTime: String?

            public var severity: String?

            public var startTime: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarms != nil {
                    var tmp : [Any] = []
                    for k in self.alarms! {
                        tmp.append(k.toMap())
                    }
                    map["Alarms"] = tmp
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.annotations != nil {
                    map["Annotations"] = self.annotations!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.generatorURL != nil {
                    map["GeneratorURL"] = self.generatorURL!
                }
                if self.handlerName != nil {
                    map["HandlerName"] = self.handlerName!
                }
                if self.integrationName != nil {
                    map["IntegrationName"] = self.integrationName!
                }
                if self.integrationType != nil {
                    map["IntegrationType"] = self.integrationType!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.receiveTime != nil {
                    map["ReceiveTime"] = self.receiveTime!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alarms") && dict["Alarms"] != nil {
                    var tmp : [ListAlertEventsResponseBody.PageBean.Events.Alarms] = []
                    for v in dict["Alarms"] as! [Any] {
                        var model = ListAlertEventsResponseBody.PageBean.Events.Alarms()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alarms = tmp
                }
                if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                    self.annotations = dict["Annotations"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("GeneratorURL") && dict["GeneratorURL"] != nil {
                    self.generatorURL = dict["GeneratorURL"] as! String
                }
                if dict.keys.contains("HandlerName") && dict["HandlerName"] != nil {
                    self.handlerName = dict["HandlerName"] as! String
                }
                if dict.keys.contains("IntegrationName") && dict["IntegrationName"] != nil {
                    self.integrationName = dict["IntegrationName"] as! String
                }
                if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
                    self.integrationType = dict["IntegrationType"] as! String
                }
                if dict.keys.contains("Labels") && dict["Labels"] != nil {
                    self.labels = dict["Labels"] as! String
                }
                if dict.keys.contains("ReceiveTime") && dict["ReceiveTime"] != nil {
                    self.receiveTime = dict["ReceiveTime"] as! String
                }
                if dict.keys.contains("Severity") && dict["Severity"] != nil {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var events: [ListAlertEventsResponseBody.PageBean.Events]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.events != nil {
                var tmp : [Any] = []
                for k in self.events! {
                    tmp.append(k.toMap())
                }
                map["Events"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Events") && dict["Events"] != nil {
                var tmp : [ListAlertEventsResponseBody.PageBean.Events] = []
                for v in dict["Events"] as! [Any] {
                    var model = ListAlertEventsResponseBody.PageBean.Events()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.events = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListAlertEventsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = ListAlertEventsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAlertEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAlertEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlertsRequest : Tea.TeaModel {
    public var alertName: String?

    public var dispatchRuleId: Int64?

    public var endTime: String?

    public var integrationType: String?

    public var page: Int64?

    public var regionId: String?

    public var severity: String?

    public var showActivities: Bool?

    public var showEvents: Bool?

    public var size: Int64?

    public var startTime: String?

    public var state: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.dispatchRuleId != nil {
            map["DispatchRuleId"] = self.dispatchRuleId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.showActivities != nil {
            map["ShowActivities"] = self.showActivities!
        }
        if self.showEvents != nil {
            map["ShowEvents"] = self.showEvents!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("DispatchRuleId") && dict["DispatchRuleId"] != nil {
            self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Severity") && dict["Severity"] != nil {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("ShowActivities") && dict["ShowActivities"] != nil {
            self.showActivities = dict["ShowActivities"] as! Bool
        }
        if dict.keys.contains("ShowEvents") && dict["ShowEvents"] != nil {
            self.showEvents = dict["ShowEvents"] as! Bool
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! Int64
        }
    }
}

public class ListAlertsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class ListAlerts : Tea.TeaModel {
            public class Activities : Tea.TeaModel {
                public var content: String?

                public var description_: String?

                public var handlerName: String?

                public var time: String?

                public var type: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.handlerName != nil {
                        map["HandlerName"] = self.handlerName!
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("HandlerName") && dict["HandlerName"] != nil {
                        self.handlerName = dict["HandlerName"] as! String
                    }
                    if dict.keys.contains("Time") && dict["Time"] != nil {
                        self.time = dict["Time"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! Int64
                    }
                }
            }
            public class AlertEvents : Tea.TeaModel {
                public var alertName: String?

                public var annotations: String?

                public var description_: String?

                public var endTime: String?

                public var generatorURL: String?

                public var integrationName: String?

                public var integrationType: String?

                public var labels: String?

                public var receiveTime: String?

                public var severity: String?

                public var startTime: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alertName != nil {
                        map["AlertName"] = self.alertName!
                    }
                    if self.annotations != nil {
                        map["Annotations"] = self.annotations!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.generatorURL != nil {
                        map["GeneratorURL"] = self.generatorURL!
                    }
                    if self.integrationName != nil {
                        map["IntegrationName"] = self.integrationName!
                    }
                    if self.integrationType != nil {
                        map["IntegrationType"] = self.integrationType!
                    }
                    if self.labels != nil {
                        map["Labels"] = self.labels!
                    }
                    if self.receiveTime != nil {
                        map["ReceiveTime"] = self.receiveTime!
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                        self.alertName = dict["AlertName"] as! String
                    }
                    if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                        self.annotations = dict["Annotations"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("GeneratorURL") && dict["GeneratorURL"] != nil {
                        self.generatorURL = dict["GeneratorURL"] as! String
                    }
                    if dict.keys.contains("IntegrationName") && dict["IntegrationName"] != nil {
                        self.integrationName = dict["IntegrationName"] as! String
                    }
                    if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
                        self.integrationType = dict["IntegrationType"] as! String
                    }
                    if dict.keys.contains("Labels") && dict["Labels"] != nil {
                        self.labels = dict["Labels"] as! String
                    }
                    if dict.keys.contains("ReceiveTime") && dict["ReceiveTime"] != nil {
                        self.receiveTime = dict["ReceiveTime"] as! String
                    }
                    if dict.keys.contains("Severity") && dict["Severity"] != nil {
                        self.severity = dict["Severity"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("State") && dict["State"] != nil {
                        self.state = dict["State"] as! String
                    }
                }
            }
            public var activities: [ListAlertsResponseBody.PageBean.ListAlerts.Activities]?

            public var alertEvents: [ListAlertsResponseBody.PageBean.ListAlerts.AlertEvents]?

            public var alertId: Int64?

            public var alertName: String?

            public var createTime: String?

            public var dispatchRuleId: Double?

            public var dispatchRuleName: String?

            public var severity: String?

            public var solution: String?

            public var state: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activities != nil {
                    var tmp : [Any] = []
                    for k in self.activities! {
                        tmp.append(k.toMap())
                    }
                    map["Activities"] = tmp
                }
                if self.alertEvents != nil {
                    var tmp : [Any] = []
                    for k in self.alertEvents! {
                        tmp.append(k.toMap())
                    }
                    map["AlertEvents"] = tmp
                }
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dispatchRuleId != nil {
                    map["DispatchRuleId"] = self.dispatchRuleId!
                }
                if self.dispatchRuleName != nil {
                    map["DispatchRuleName"] = self.dispatchRuleName!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.solution != nil {
                    map["Solution"] = self.solution!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Activities") && dict["Activities"] != nil {
                    var tmp : [ListAlertsResponseBody.PageBean.ListAlerts.Activities] = []
                    for v in dict["Activities"] as! [Any] {
                        var model = ListAlertsResponseBody.PageBean.ListAlerts.Activities()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.activities = tmp
                }
                if dict.keys.contains("AlertEvents") && dict["AlertEvents"] != nil {
                    var tmp : [ListAlertsResponseBody.PageBean.ListAlerts.AlertEvents] = []
                    for v in dict["AlertEvents"] as! [Any] {
                        var model = ListAlertsResponseBody.PageBean.ListAlerts.AlertEvents()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alertEvents = tmp
                }
                if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
                    self.alertId = dict["AlertId"] as! Int64
                }
                if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DispatchRuleId") && dict["DispatchRuleId"] != nil {
                    self.dispatchRuleId = dict["DispatchRuleId"] as! Double
                }
                if dict.keys.contains("DispatchRuleName") && dict["DispatchRuleName"] != nil {
                    self.dispatchRuleName = dict["DispatchRuleName"] as! String
                }
                if dict.keys.contains("Severity") && dict["Severity"] != nil {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("Solution") && dict["Solution"] != nil {
                    self.solution = dict["Solution"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! Int64
                }
            }
        }
        public var listAlerts: [ListAlertsResponseBody.PageBean.ListAlerts]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.listAlerts != nil {
                var tmp : [Any] = []
                for k in self.listAlerts! {
                    tmp.append(k.toMap())
                }
                map["ListAlerts"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ListAlerts") && dict["ListAlerts"] != nil {
                var tmp : [ListAlertsResponseBody.PageBean.ListAlerts] = []
                for v in dict["ListAlerts"] as! [Any] {
                    var model = ListAlertsResponseBody.PageBean.ListAlerts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.listAlerts = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListAlertsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = ListAlertsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAlertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAlertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterFromGrafanaRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListClusterFromGrafanaResponseBody : Tea.TeaModel {
    public class PromClusterList : Tea.TeaModel {
        public var agentStatus: String?

        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: String?

        public var controllerId: String?

        public var createTime: Int64?

        public var extra: String?

        public var id: Int64?

        public var installTime: Int64?

        public var isControllerInstalled: Bool?

        public var lastHeartBeatTime: Int64?

        public var nodeNum: Int32?

        public var options: String?

        public var pluginsJsonArray: String?

        public var regionId: String?

        public var stateJson: String?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentStatus != nil {
                map["AgentStatus"] = self.agentStatus!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.controllerId != nil {
                map["ControllerId"] = self.controllerId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.installTime != nil {
                map["InstallTime"] = self.installTime!
            }
            if self.isControllerInstalled != nil {
                map["IsControllerInstalled"] = self.isControllerInstalled!
            }
            if self.lastHeartBeatTime != nil {
                map["LastHeartBeatTime"] = self.lastHeartBeatTime!
            }
            if self.nodeNum != nil {
                map["NodeNum"] = self.nodeNum!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            if self.pluginsJsonArray != nil {
                map["PluginsJsonArray"] = self.pluginsJsonArray!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.stateJson != nil {
                map["StateJson"] = self.stateJson!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentStatus") && dict["AgentStatus"] != nil {
                self.agentStatus = dict["AgentStatus"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("ControllerId") && dict["ControllerId"] != nil {
                self.controllerId = dict["ControllerId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Extra") && dict["Extra"] != nil {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstallTime") && dict["InstallTime"] != nil {
                self.installTime = dict["InstallTime"] as! Int64
            }
            if dict.keys.contains("IsControllerInstalled") && dict["IsControllerInstalled"] != nil {
                self.isControllerInstalled = dict["IsControllerInstalled"] as! Bool
            }
            if dict.keys.contains("LastHeartBeatTime") && dict["LastHeartBeatTime"] != nil {
                self.lastHeartBeatTime = dict["LastHeartBeatTime"] as! Int64
            }
            if dict.keys.contains("NodeNum") && dict["NodeNum"] != nil {
                self.nodeNum = dict["NodeNum"] as! Int32
            }
            if dict.keys.contains("Options") && dict["Options"] != nil {
                self.options = dict["Options"] as! String
            }
            if dict.keys.contains("PluginsJsonArray") && dict["PluginsJsonArray"] != nil {
                self.pluginsJsonArray = dict["PluginsJsonArray"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("StateJson") && dict["StateJson"] != nil {
                self.stateJson = dict["StateJson"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var promClusterList: [ListClusterFromGrafanaResponseBody.PromClusterList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.promClusterList != nil {
            var tmp : [Any] = []
            for k in self.promClusterList! {
                tmp.append(k.toMap())
            }
            map["PromClusterList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PromClusterList") && dict["PromClusterList"] != nil {
            var tmp : [ListClusterFromGrafanaResponseBody.PromClusterList] = []
            for v in dict["PromClusterList"] as! [Any] {
                var model = ListClusterFromGrafanaResponseBody.PromClusterList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.promClusterList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClusterFromGrafanaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterFromGrafanaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterFromGrafanaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCmsInstancesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var typeFilter: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.typeFilter != nil {
            map["TypeFilter"] = self.typeFilter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TypeFilter") && dict["TypeFilter"] != nil {
            self.typeFilter = dict["TypeFilter"] as! String
        }
    }
}

public class ListCmsInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Products : Tea.TeaModel {
            public var descr: String?

            public var id: String?

            public var instance: String?

            public var name: String?

            public var prod: String?

            public var source: String?

            public var state: String?

            public var time: String?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.descr != nil {
                    map["Descr"] = self.descr!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instance != nil {
                    map["Instance"] = self.instance!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.prod != nil {
                    map["Prod"] = self.prod!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Descr") && dict["Descr"] != nil {
                    self.descr = dict["Descr"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Instance") && dict["Instance"] != nil {
                    self.instance = dict["Instance"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Prod") && dict["Prod"] != nil {
                    self.prod = dict["Prod"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Time") && dict["Time"] != nil {
                    self.time = dict["Time"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var enableTag: Bool?

        public var products: [ListCmsInstancesResponseBody.Data.Products]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableTag != nil {
                map["EnableTag"] = self.enableTag!
            }
            if self.products != nil {
                var tmp : [Any] = []
                for k in self.products! {
                    tmp.append(k.toMap())
                }
                map["Products"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableTag") && dict["EnableTag"] != nil {
                self.enableTag = dict["EnableTag"] as! Bool
            }
            if dict.keys.contains("Products") && dict["Products"] != nil {
                var tmp : [ListCmsInstancesResponseBody.Data.Products] = []
                for v in dict["Products"] as! [Any] {
                    var model = ListCmsInstancesResponseBody.Data.Products()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.products = tmp
            }
        }
    }
    public var data: ListCmsInstancesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListCmsInstancesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCmsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCmsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCmsInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDashboardsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var dashboardName: String?

    public var language: String?

    public var product: String?

    public var recreateSwitch: Bool?

    public var regionId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.dashboardName != nil {
            map["DashboardName"] = self.dashboardName!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.recreateSwitch != nil {
            map["RecreateSwitch"] = self.recreateSwitch!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("DashboardName") && dict["DashboardName"] != nil {
            self.dashboardName = dict["DashboardName"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RecreateSwitch") && dict["RecreateSwitch"] != nil {
            self.recreateSwitch = dict["RecreateSwitch"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class ListDashboardsResponseBody : Tea.TeaModel {
    public class DashboardVos : Tea.TeaModel {
        public class I18nChild : Tea.TeaModel {
            public var dashboardType: String?

            public var exporter: String?

            public var httpUrl: String?

            public var httpsUrl: String?

            public var id: String?

            public var isArmsExporter: Bool?

            public var kind: String?

            public var language: String?

            public var name: String?

            public var needUpdate: Bool?

            public var tags: [String]?

            public var time: String?

            public var title: String?

            public var type: String?

            public var uid: String?

            public var url: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dashboardType != nil {
                    map["DashboardType"] = self.dashboardType!
                }
                if self.exporter != nil {
                    map["Exporter"] = self.exporter!
                }
                if self.httpUrl != nil {
                    map["HttpUrl"] = self.httpUrl!
                }
                if self.httpsUrl != nil {
                    map["HttpsUrl"] = self.httpsUrl!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isArmsExporter != nil {
                    map["IsArmsExporter"] = self.isArmsExporter!
                }
                if self.kind != nil {
                    map["Kind"] = self.kind!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.needUpdate != nil {
                    map["NeedUpdate"] = self.needUpdate!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.uid != nil {
                    map["Uid"] = self.uid!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DashboardType") && dict["DashboardType"] != nil {
                    self.dashboardType = dict["DashboardType"] as! String
                }
                if dict.keys.contains("Exporter") && dict["Exporter"] != nil {
                    self.exporter = dict["Exporter"] as! String
                }
                if dict.keys.contains("HttpUrl") && dict["HttpUrl"] != nil {
                    self.httpUrl = dict["HttpUrl"] as! String
                }
                if dict.keys.contains("HttpsUrl") && dict["HttpsUrl"] != nil {
                    self.httpsUrl = dict["HttpsUrl"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("IsArmsExporter") && dict["IsArmsExporter"] != nil {
                    self.isArmsExporter = dict["IsArmsExporter"] as! Bool
                }
                if dict.keys.contains("Kind") && dict["Kind"] != nil {
                    self.kind = dict["Kind"] as! String
                }
                if dict.keys.contains("Language") && dict["Language"] != nil {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NeedUpdate") && dict["NeedUpdate"] != nil {
                    self.needUpdate = dict["NeedUpdate"] as! Bool
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    self.tags = dict["Tags"] as! [String]
                }
                if dict.keys.contains("Time") && dict["Time"] != nil {
                    self.time = dict["Time"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Uid") && dict["Uid"] != nil {
                    self.uid = dict["Uid"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var dashboardType: String?

        public var exporter: String?

        public var httpUrl: String?

        public var httpsUrl: String?

        public var i18nChild: ListDashboardsResponseBody.DashboardVos.I18nChild?

        public var id: String?

        public var isArmsExporter: Bool?

        public var kind: String?

        public var language: String?

        public var name: String?

        public var needUpdate: Bool?

        public var tags: [String]?

        public var time: String?

        public var title: String?

        public var type: String?

        public var uid: String?

        public var url: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.i18nChild?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dashboardType != nil {
                map["DashboardType"] = self.dashboardType!
            }
            if self.exporter != nil {
                map["Exporter"] = self.exporter!
            }
            if self.httpUrl != nil {
                map["HttpUrl"] = self.httpUrl!
            }
            if self.httpsUrl != nil {
                map["HttpsUrl"] = self.httpsUrl!
            }
            if self.i18nChild != nil {
                map["I18nChild"] = self.i18nChild?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isArmsExporter != nil {
                map["IsArmsExporter"] = self.isArmsExporter!
            }
            if self.kind != nil {
                map["Kind"] = self.kind!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.needUpdate != nil {
                map["NeedUpdate"] = self.needUpdate!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DashboardType") && dict["DashboardType"] != nil {
                self.dashboardType = dict["DashboardType"] as! String
            }
            if dict.keys.contains("Exporter") && dict["Exporter"] != nil {
                self.exporter = dict["Exporter"] as! String
            }
            if dict.keys.contains("HttpUrl") && dict["HttpUrl"] != nil {
                self.httpUrl = dict["HttpUrl"] as! String
            }
            if dict.keys.contains("HttpsUrl") && dict["HttpsUrl"] != nil {
                self.httpsUrl = dict["HttpsUrl"] as! String
            }
            if dict.keys.contains("I18nChild") && dict["I18nChild"] != nil {
                var model = ListDashboardsResponseBody.DashboardVos.I18nChild()
                model.fromMap(dict["I18nChild"] as! [String: Any])
                self.i18nChild = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsArmsExporter") && dict["IsArmsExporter"] != nil {
                self.isArmsExporter = dict["IsArmsExporter"] as! Bool
            }
            if dict.keys.contains("Kind") && dict["Kind"] != nil {
                self.kind = dict["Kind"] as! String
            }
            if dict.keys.contains("Language") && dict["Language"] != nil {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NeedUpdate") && dict["NeedUpdate"] != nil {
                self.needUpdate = dict["NeedUpdate"] as! Bool
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! [String]
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                self.time = dict["Time"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uid") && dict["Uid"] != nil {
                self.uid = dict["Uid"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var dashboardVos: [ListDashboardsResponseBody.DashboardVos]?

    public var prometheusServiceOpened: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dashboardVos != nil {
            var tmp : [Any] = []
            for k in self.dashboardVos! {
                tmp.append(k.toMap())
            }
            map["DashboardVos"] = tmp
        }
        if self.prometheusServiceOpened != nil {
            map["PrometheusServiceOpened"] = self.prometheusServiceOpened!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DashboardVos") && dict["DashboardVos"] != nil {
            var tmp : [ListDashboardsResponseBody.DashboardVos] = []
            for v in dict["DashboardVos"] as! [Any] {
                var model = ListDashboardsResponseBody.DashboardVos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dashboardVos = tmp
        }
        if dict.keys.contains("PrometheusServiceOpened") && dict["PrometheusServiceOpened"] != nil {
            self.prometheusServiceOpened = dict["PrometheusServiceOpened"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDashboardsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDashboardsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDashboardsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDashboardsByNameRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var dashBoardName: String?

    public var dashBoardVersion: String?

    public var dataSourceType: String?

    public var groupName: String?

    public var onlyQuery: Bool?

    public var productCode: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.dashBoardName != nil {
            map["DashBoardName"] = self.dashBoardName!
        }
        if self.dashBoardVersion != nil {
            map["DashBoardVersion"] = self.dashBoardVersion!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.onlyQuery != nil {
            map["OnlyQuery"] = self.onlyQuery!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("DashBoardName") && dict["DashBoardName"] != nil {
            self.dashBoardName = dict["DashBoardName"] as! String
        }
        if dict.keys.contains("DashBoardVersion") && dict["DashBoardVersion"] != nil {
            self.dashBoardVersion = dict["DashBoardVersion"] as! String
        }
        if dict.keys.contains("DataSourceType") && dict["DataSourceType"] != nil {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("OnlyQuery") && dict["OnlyQuery"] != nil {
            self.onlyQuery = dict["OnlyQuery"] as! Bool
        }
        if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListDashboardsByNameResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDashboardsByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDashboardsByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDashboardsByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDispatchRuleRequest : Tea.TeaModel {
    public var name: String?

    public var regionId: String?

    public var system: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.system != nil {
            map["System"] = self.system!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("System") && dict["System"] != nil {
            self.system = dict["System"] as! Bool
        }
    }
}

public class ListDispatchRuleResponseBody : Tea.TeaModel {
    public class DispatchRules : Tea.TeaModel {
        public var name: String?

        public var ruleId: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! Int64
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var dispatchRules: [ListDispatchRuleResponseBody.DispatchRules]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRules != nil {
            var tmp : [Any] = []
            for k in self.dispatchRules! {
                tmp.append(k.toMap())
            }
            map["DispatchRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRules") && dict["DispatchRules"] != nil {
            var tmp : [ListDispatchRuleResponseBody.DispatchRules] = []
            for v in dict["DispatchRules"] as! [Any] {
                var model = ListDispatchRuleResponseBody.DispatchRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dispatchRules = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvCustomJobsRequest : Tea.TeaModel {
    public var encryptYaml: Bool?

    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encryptYaml != nil {
            map["EncryptYaml"] = self.encryptYaml!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EncryptYaml") && dict["EncryptYaml"] != nil {
            self.encryptYaml = dict["EncryptYaml"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListEnvCustomJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ScrapeConfigs : Tea.TeaModel {
            public var jobName: String?

            public var metricsPath: String?

            public var scrapeDiscoverys: [String]?

            public var scrapeInterval: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobName != nil {
                    map["JobName"] = self.jobName!
                }
                if self.metricsPath != nil {
                    map["MetricsPath"] = self.metricsPath!
                }
                if self.scrapeDiscoverys != nil {
                    map["ScrapeDiscoverys"] = self.scrapeDiscoverys!
                }
                if self.scrapeInterval != nil {
                    map["ScrapeInterval"] = self.scrapeInterval!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobName") && dict["JobName"] != nil {
                    self.jobName = dict["JobName"] as! String
                }
                if dict.keys.contains("MetricsPath") && dict["MetricsPath"] != nil {
                    self.metricsPath = dict["MetricsPath"] as! String
                }
                if dict.keys.contains("ScrapeDiscoverys") && dict["ScrapeDiscoverys"] != nil {
                    self.scrapeDiscoverys = dict["ScrapeDiscoverys"] as! [String]
                }
                if dict.keys.contains("ScrapeInterval") && dict["ScrapeInterval"] != nil {
                    self.scrapeInterval = dict["ScrapeInterval"] as! String
                }
            }
        }
        public var addonName: String?

        public var addonReleaseName: String?

        public var addonVersion: String?

        public var configYaml: String?

        public var creationTimestamp: String?

        public var customJobName: String?

        public var environmentId: String?

        public var regionId: String?

        public var scrapeConfigs: [ListEnvCustomJobsResponseBody.Data.ScrapeConfigs]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addonName != nil {
                map["AddonName"] = self.addonName!
            }
            if self.addonReleaseName != nil {
                map["AddonReleaseName"] = self.addonReleaseName!
            }
            if self.addonVersion != nil {
                map["AddonVersion"] = self.addonVersion!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.creationTimestamp != nil {
                map["CreationTimestamp"] = self.creationTimestamp!
            }
            if self.customJobName != nil {
                map["CustomJobName"] = self.customJobName!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.scrapeConfigs != nil {
                var tmp : [Any] = []
                for k in self.scrapeConfigs! {
                    tmp.append(k.toMap())
                }
                map["ScrapeConfigs"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddonName") && dict["AddonName"] != nil {
                self.addonName = dict["AddonName"] as! String
            }
            if dict.keys.contains("AddonReleaseName") && dict["AddonReleaseName"] != nil {
                self.addonReleaseName = dict["AddonReleaseName"] as! String
            }
            if dict.keys.contains("AddonVersion") && dict["AddonVersion"] != nil {
                self.addonVersion = dict["AddonVersion"] as! String
            }
            if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("CreationTimestamp") && dict["CreationTimestamp"] != nil {
                self.creationTimestamp = dict["CreationTimestamp"] as! String
            }
            if dict.keys.contains("CustomJobName") && dict["CustomJobName"] != nil {
                self.customJobName = dict["CustomJobName"] as! String
            }
            if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ScrapeConfigs") && dict["ScrapeConfigs"] != nil {
                var tmp : [ListEnvCustomJobsResponseBody.Data.ScrapeConfigs] = []
                for v in dict["ScrapeConfigs"] as! [Any] {
                    var model = ListEnvCustomJobsResponseBody.Data.ScrapeConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scrapeConfigs = tmp
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListEnvCustomJobsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListEnvCustomJobsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEnvCustomJobsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEnvCustomJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvCustomJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEnvCustomJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvPodMonitorsRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListEnvPodMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Endpoints : Tea.TeaModel {
            public var interval: String?

            public var matchedTargetCount: Int32?

            public var path: String?

            public var port: String?

            public var targetPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.matchedTargetCount != nil {
                    map["MatchedTargetCount"] = self.matchedTargetCount!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! String
                }
                if dict.keys.contains("MatchedTargetCount") && dict["MatchedTargetCount"] != nil {
                    self.matchedTargetCount = dict["MatchedTargetCount"] as! Int32
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("TargetPort") && dict["TargetPort"] != nil {
                    self.targetPort = dict["TargetPort"] as! Int32
                }
            }
        }
        public var addonName: String?

        public var addonReleaseName: String?

        public var addonVersion: String?

        public var configYaml: String?

        public var creationTimestamp: String?

        public var endpoints: [ListEnvPodMonitorsResponseBody.Data.Endpoints]?

        public var environmentId: String?

        public var namespace: String?

        public var podMonitorName: String?

        public var regionId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addonName != nil {
                map["AddonName"] = self.addonName!
            }
            if self.addonReleaseName != nil {
                map["AddonReleaseName"] = self.addonReleaseName!
            }
            if self.addonVersion != nil {
                map["AddonVersion"] = self.addonVersion!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.creationTimestamp != nil {
                map["CreationTimestamp"] = self.creationTimestamp!
            }
            if self.endpoints != nil {
                var tmp : [Any] = []
                for k in self.endpoints! {
                    tmp.append(k.toMap())
                }
                map["Endpoints"] = tmp
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.podMonitorName != nil {
                map["PodMonitorName"] = self.podMonitorName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddonName") && dict["AddonName"] != nil {
                self.addonName = dict["AddonName"] as! String
            }
            if dict.keys.contains("AddonReleaseName") && dict["AddonReleaseName"] != nil {
                self.addonReleaseName = dict["AddonReleaseName"] as! String
            }
            if dict.keys.contains("AddonVersion") && dict["AddonVersion"] != nil {
                self.addonVersion = dict["AddonVersion"] as! String
            }
            if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("CreationTimestamp") && dict["CreationTimestamp"] != nil {
                self.creationTimestamp = dict["CreationTimestamp"] as! String
            }
            if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
                var tmp : [ListEnvPodMonitorsResponseBody.Data.Endpoints] = []
                for v in dict["Endpoints"] as! [Any] {
                    var model = ListEnvPodMonitorsResponseBody.Data.Endpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpoints = tmp
            }
            if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PodMonitorName") && dict["PodMonitorName"] != nil {
                self.podMonitorName = dict["PodMonitorName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListEnvPodMonitorsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListEnvPodMonitorsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEnvPodMonitorsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEnvPodMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvPodMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEnvPodMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvServiceMonitorsRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListEnvServiceMonitorsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Endpoints : Tea.TeaModel {
            public var interval: String?

            public var matchedTargetCount: Int32?

            public var path: String?

            public var port: String?

            public var targetPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.matchedTargetCount != nil {
                    map["MatchedTargetCount"] = self.matchedTargetCount!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! String
                }
                if dict.keys.contains("MatchedTargetCount") && dict["MatchedTargetCount"] != nil {
                    self.matchedTargetCount = dict["MatchedTargetCount"] as! Int32
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("TargetPort") && dict["TargetPort"] != nil {
                    self.targetPort = dict["TargetPort"] as! Int32
                }
            }
        }
        public var addonName: String?

        public var addonReleaseName: String?

        public var addonVersion: String?

        public var configYaml: String?

        public var creationTimestamp: String?

        public var endpoints: [ListEnvServiceMonitorsResponseBody.Data.Endpoints]?

        public var environmentId: String?

        public var matchedServiceCount: Int32?

        public var namespace: String?

        public var regionId: String?

        public var serviceMonitorName: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addonName != nil {
                map["AddonName"] = self.addonName!
            }
            if self.addonReleaseName != nil {
                map["AddonReleaseName"] = self.addonReleaseName!
            }
            if self.addonVersion != nil {
                map["AddonVersion"] = self.addonVersion!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.creationTimestamp != nil {
                map["CreationTimestamp"] = self.creationTimestamp!
            }
            if self.endpoints != nil {
                var tmp : [Any] = []
                for k in self.endpoints! {
                    tmp.append(k.toMap())
                }
                map["Endpoints"] = tmp
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.matchedServiceCount != nil {
                map["MatchedServiceCount"] = self.matchedServiceCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.serviceMonitorName != nil {
                map["ServiceMonitorName"] = self.serviceMonitorName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddonName") && dict["AddonName"] != nil {
                self.addonName = dict["AddonName"] as! String
            }
            if dict.keys.contains("AddonReleaseName") && dict["AddonReleaseName"] != nil {
                self.addonReleaseName = dict["AddonReleaseName"] as! String
            }
            if dict.keys.contains("AddonVersion") && dict["AddonVersion"] != nil {
                self.addonVersion = dict["AddonVersion"] as! String
            }
            if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("CreationTimestamp") && dict["CreationTimestamp"] != nil {
                self.creationTimestamp = dict["CreationTimestamp"] as! String
            }
            if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
                var tmp : [ListEnvServiceMonitorsResponseBody.Data.Endpoints] = []
                for v in dict["Endpoints"] as! [Any] {
                    var model = ListEnvServiceMonitorsResponseBody.Data.Endpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpoints = tmp
            }
            if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("MatchedServiceCount") && dict["MatchedServiceCount"] != nil {
                self.matchedServiceCount = dict["MatchedServiceCount"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ServiceMonitorName") && dict["ServiceMonitorName"] != nil {
                self.serviceMonitorName = dict["ServiceMonitorName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListEnvServiceMonitorsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListEnvServiceMonitorsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEnvServiceMonitorsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEnvServiceMonitorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvServiceMonitorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEnvServiceMonitorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvironmentFeaturesRequest : Tea.TeaModel {
    public var environmentId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListEnvironmentFeaturesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var alias: String?

        public var config: [String: String]?

        public var description_: String?

        public var environmentId: String?

        public var icon: String?

        public var language: String?

        public var latestVersion: String?

        public var name: String?

        public var status: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.latestVersion != nil {
                map["LatestVersion"] = self.latestVersion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") && dict["Alias"] != nil {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! [String: String]
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                self.environmentId = dict["EnvironmentId"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("Language") && dict["Language"] != nil {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("LatestVersion") && dict["LatestVersion"] != nil {
                self.latestVersion = dict["LatestVersion"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListEnvironmentFeaturesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListEnvironmentFeaturesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEnvironmentFeaturesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEnvironmentFeaturesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvironmentFeaturesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEnvironmentFeaturesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnvironmentsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var addonName: String?

    public var environmentType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [ListEnvironmentsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonName != nil {
            map["AddonName"] = self.addonName!
        }
        if self.environmentType != nil {
            map["EnvironmentType"] = self.environmentType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonName") && dict["AddonName"] != nil {
            self.addonName = dict["AddonName"] as! String
        }
        if dict.keys.contains("EnvironmentType") && dict["EnvironmentType"] != nil {
            self.environmentType = dict["EnvironmentType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListEnvironmentsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListEnvironmentsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListEnvironmentsShrinkRequest : Tea.TeaModel {
    public var addonName: String?

    public var environmentType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tagShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonName != nil {
            map["AddonName"] = self.addonName!
        }
        if self.environmentType != nil {
            map["EnvironmentType"] = self.environmentType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tagShrink != nil {
            map["Tag"] = self.tagShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonName") && dict["AddonName"] != nil {
            self.addonName = dict["AddonName"] as! String
        }
        if dict.keys.contains("EnvironmentType") && dict["EnvironmentType"] != nil {
            self.environmentType = dict["EnvironmentType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tagShrink = dict["Tag"] as! String
        }
    }
}

public class ListEnvironmentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Environments : Tea.TeaModel {
            public class Addons : Tea.TeaModel {
                public var alias: String?

                public var description_: String?

                public var icon: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") && dict["Alias"] != nil {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Icon") && dict["Icon"] != nil {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class Features : Tea.TeaModel {
                public var alias: String?

                public var description_: String?

                public var icon: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") && dict["Alias"] != nil {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Icon") && dict["Icon"] != nil {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var addons: [ListEnvironmentsResponseBody.Data.Environments.Addons]?

            public var bindResourceId: String?

            public var bindResourceProfile: String?

            public var bindResourceType: String?

            public var bindVpcCidr: String?

            public var createTime: String?

            public var createdUserId: String?

            public var environmentId: String?

            public var environmentName: String?

            public var environmentType: String?

            public var features: [ListEnvironmentsResponseBody.Data.Environments.Features]?

            public var grafanaDatasourceUid: String?

            public var grafanaFolderTitle: String?

            public var grafanaFolderUid: String?

            public var latestReleaseCreateTime: String?

            public var prometheusId: Int64?

            public var prometheusInstanceId: String?

            public var regionId: String?

            public var releaseCount: Int32?

            public var resourceGroupId: String?

            public var tags: [ListEnvironmentsResponseBody.Data.Environments.Tags]?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addons != nil {
                    var tmp : [Any] = []
                    for k in self.addons! {
                        tmp.append(k.toMap())
                    }
                    map["Addons"] = tmp
                }
                if self.bindResourceId != nil {
                    map["BindResourceId"] = self.bindResourceId!
                }
                if self.bindResourceProfile != nil {
                    map["BindResourceProfile"] = self.bindResourceProfile!
                }
                if self.bindResourceType != nil {
                    map["BindResourceType"] = self.bindResourceType!
                }
                if self.bindVpcCidr != nil {
                    map["BindVpcCidr"] = self.bindVpcCidr!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createdUserId != nil {
                    map["CreatedUserId"] = self.createdUserId!
                }
                if self.environmentId != nil {
                    map["EnvironmentId"] = self.environmentId!
                }
                if self.environmentName != nil {
                    map["EnvironmentName"] = self.environmentName!
                }
                if self.environmentType != nil {
                    map["EnvironmentType"] = self.environmentType!
                }
                if self.features != nil {
                    var tmp : [Any] = []
                    for k in self.features! {
                        tmp.append(k.toMap())
                    }
                    map["Features"] = tmp
                }
                if self.grafanaDatasourceUid != nil {
                    map["GrafanaDatasourceUid"] = self.grafanaDatasourceUid!
                }
                if self.grafanaFolderTitle != nil {
                    map["GrafanaFolderTitle"] = self.grafanaFolderTitle!
                }
                if self.grafanaFolderUid != nil {
                    map["GrafanaFolderUid"] = self.grafanaFolderUid!
                }
                if self.latestReleaseCreateTime != nil {
                    map["LatestReleaseCreateTime"] = self.latestReleaseCreateTime!
                }
                if self.prometheusId != nil {
                    map["PrometheusId"] = self.prometheusId!
                }
                if self.prometheusInstanceId != nil {
                    map["PrometheusInstanceId"] = self.prometheusInstanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.releaseCount != nil {
                    map["ReleaseCount"] = self.releaseCount!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Addons") && dict["Addons"] != nil {
                    var tmp : [ListEnvironmentsResponseBody.Data.Environments.Addons] = []
                    for v in dict["Addons"] as! [Any] {
                        var model = ListEnvironmentsResponseBody.Data.Environments.Addons()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.addons = tmp
                }
                if dict.keys.contains("BindResourceId") && dict["BindResourceId"] != nil {
                    self.bindResourceId = dict["BindResourceId"] as! String
                }
                if dict.keys.contains("BindResourceProfile") && dict["BindResourceProfile"] != nil {
                    self.bindResourceProfile = dict["BindResourceProfile"] as! String
                }
                if dict.keys.contains("BindResourceType") && dict["BindResourceType"] != nil {
                    self.bindResourceType = dict["BindResourceType"] as! String
                }
                if dict.keys.contains("BindVpcCidr") && dict["BindVpcCidr"] != nil {
                    self.bindVpcCidr = dict["BindVpcCidr"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreatedUserId") && dict["CreatedUserId"] != nil {
                    self.createdUserId = dict["CreatedUserId"] as! String
                }
                if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
                    self.environmentId = dict["EnvironmentId"] as! String
                }
                if dict.keys.contains("EnvironmentName") && dict["EnvironmentName"] != nil {
                    self.environmentName = dict["EnvironmentName"] as! String
                }
                if dict.keys.contains("EnvironmentType") && dict["EnvironmentType"] != nil {
                    self.environmentType = dict["EnvironmentType"] as! String
                }
                if dict.keys.contains("Features") && dict["Features"] != nil {
                    var tmp : [ListEnvironmentsResponseBody.Data.Environments.Features] = []
                    for v in dict["Features"] as! [Any] {
                        var model = ListEnvironmentsResponseBody.Data.Environments.Features()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.features = tmp
                }
                if dict.keys.contains("GrafanaDatasourceUid") && dict["GrafanaDatasourceUid"] != nil {
                    self.grafanaDatasourceUid = dict["GrafanaDatasourceUid"] as! String
                }
                if dict.keys.contains("GrafanaFolderTitle") && dict["GrafanaFolderTitle"] != nil {
                    self.grafanaFolderTitle = dict["GrafanaFolderTitle"] as! String
                }
                if dict.keys.contains("GrafanaFolderUid") && dict["GrafanaFolderUid"] != nil {
                    self.grafanaFolderUid = dict["GrafanaFolderUid"] as! String
                }
                if dict.keys.contains("LatestReleaseCreateTime") && dict["LatestReleaseCreateTime"] != nil {
                    self.latestReleaseCreateTime = dict["LatestReleaseCreateTime"] as! String
                }
                if dict.keys.contains("PrometheusId") && dict["PrometheusId"] != nil {
                    self.prometheusId = dict["PrometheusId"] as! Int64
                }
                if dict.keys.contains("PrometheusInstanceId") && dict["PrometheusInstanceId"] != nil {
                    self.prometheusInstanceId = dict["PrometheusInstanceId"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReleaseCount") && dict["ReleaseCount"] != nil {
                    self.releaseCount = dict["ReleaseCount"] as! Int32
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var tmp : [ListEnvironmentsResponseBody.Data.Environments.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListEnvironmentsResponseBody.Data.Environments.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var environments: [ListEnvironmentsResponseBody.Data.Environments]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.environments != nil {
                var tmp : [Any] = []
                for k in self.environments! {
                    tmp.append(k.toMap())
                }
                map["Environments"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Environments") && dict["Environments"] != nil {
                var tmp : [ListEnvironmentsResponseBody.Data.Environments] = []
                for v in dict["Environments"] as! [Any] {
                    var model = ListEnvironmentsResponseBody.Data.Environments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.environments = tmp
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListEnvironmentsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListEnvironmentsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListEnvironmentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnvironmentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEnvironmentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEscalationPoliciesRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListEscalationPoliciesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class EscalationPolicies : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var escalationPolicies: [ListEscalationPoliciesResponseBody.PageBean.EscalationPolicies]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPolicies != nil {
                var tmp : [Any] = []
                for k in self.escalationPolicies! {
                    tmp.append(k.toMap())
                }
                map["EscalationPolicies"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EscalationPolicies") && dict["EscalationPolicies"] != nil {
                var tmp : [ListEscalationPoliciesResponseBody.PageBean.EscalationPolicies] = []
                for v in dict["EscalationPolicies"] as! [Any] {
                    var model = ListEscalationPoliciesResponseBody.PageBean.EscalationPolicies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPolicies = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListEscalationPoliciesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = ListEscalationPoliciesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEscalationPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEscalationPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEscalationPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventBridgeIntegrationsRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListEventBridgeIntegrationsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class EventBridgeIntegrations : Tea.TeaModel {
            public var description_: String?

            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var eventBridgeIntegrations: [ListEventBridgeIntegrationsResponseBody.PageBean.EventBridgeIntegrations]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventBridgeIntegrations != nil {
                var tmp : [Any] = []
                for k in self.eventBridgeIntegrations! {
                    tmp.append(k.toMap())
                }
                map["EventBridgeIntegrations"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventBridgeIntegrations") && dict["EventBridgeIntegrations"] != nil {
                var tmp : [ListEventBridgeIntegrationsResponseBody.PageBean.EventBridgeIntegrations] = []
                for v in dict["EventBridgeIntegrations"] as! [Any] {
                    var model = ListEventBridgeIntegrationsResponseBody.PageBean.EventBridgeIntegrations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventBridgeIntegrations = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListEventBridgeIntegrationsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = ListEventBridgeIntegrationsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEventBridgeIntegrationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventBridgeIntegrationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEventBridgeIntegrationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGrafanaWorkspaceRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aliyunLang: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [ListGrafanaWorkspaceRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [ListGrafanaWorkspaceRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListGrafanaWorkspaceRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListGrafanaWorkspaceShrinkRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class ListGrafanaWorkspaceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [GrafanaWorkspace]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GrafanaWorkspace] = []
            for v in dict["Data"] as! [Any] {
                var model = GrafanaWorkspace()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListGrafanaWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGrafanaWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListGrafanaWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInsightsEventsRequest : Tea.TeaModel {
    public var endTime: String?

    public var insightsTypes: String?

    public var pid: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.insightsTypes != nil {
            map["InsightsTypes"] = self.insightsTypes!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InsightsTypes") && dict["InsightsTypes"] != nil {
            self.insightsTypes = dict["InsightsTypes"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListInsightsEventsResponseBody : Tea.TeaModel {
    public class InsightsEvents : Tea.TeaModel {
        public var date: Int64?

        public var desc: String?

        public var level: String?

        public var pid: String?

        public var problemId: String?

        public var title: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.problemId != nil {
                map["ProblemId"] = self.problemId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! Int64
            }
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("ProblemId") && dict["ProblemId"] != nil {
                self.problemId = dict["ProblemId"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var insightsEvents: [ListInsightsEventsResponseBody.InsightsEvents]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.insightsEvents != nil {
            var tmp : [Any] = []
            for k in self.insightsEvents! {
                tmp.append(k.toMap())
            }
            map["InsightsEvents"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InsightsEvents") && dict["InsightsEvents"] != nil {
            var tmp : [ListInsightsEventsResponseBody.InsightsEvents] = []
            for v in dict["InsightsEvents"] as! [Any] {
                var model = ListInsightsEventsResponseBody.InsightsEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.insightsEvents = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListInsightsEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInsightsEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInsightsEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntegrationRequest : Tea.TeaModel {
    public var integrationName: String?

    public var integrationProductType: String?

    public var isDetail: Bool?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.integrationName != nil {
            map["IntegrationName"] = self.integrationName!
        }
        if self.integrationProductType != nil {
            map["IntegrationProductType"] = self.integrationProductType!
        }
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IntegrationName") && dict["IntegrationName"] != nil {
            self.integrationName = dict["IntegrationName"] as! String
        }
        if dict.keys.contains("IntegrationProductType") && dict["IntegrationProductType"] != nil {
            self.integrationProductType = dict["IntegrationProductType"] as! String
        }
        if dict.keys.contains("IsDetail") && dict["IsDetail"] != nil {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListIntegrationResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public class Integrations : Tea.TeaModel {
            public class IntegrationDetail : Tea.TeaModel {
                public var autoRecover: Bool?

                public var description_: String?

                public var duplicateKey: String?

                public var extendedFieldRedefineRules: [[String: Any]]?

                public var fieldRedefineRules: [[String: Any]]?

                public var initiativeRecoverField: String?

                public var initiativeRecoverValue: String?

                public var recoverTime: Int64?

                public var stat: [Int64]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoRecover != nil {
                        map["AutoRecover"] = self.autoRecover!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.duplicateKey != nil {
                        map["DuplicateKey"] = self.duplicateKey!
                    }
                    if self.extendedFieldRedefineRules != nil {
                        map["ExtendedFieldRedefineRules"] = self.extendedFieldRedefineRules!
                    }
                    if self.fieldRedefineRules != nil {
                        map["FieldRedefineRules"] = self.fieldRedefineRules!
                    }
                    if self.initiativeRecoverField != nil {
                        map["InitiativeRecoverField"] = self.initiativeRecoverField!
                    }
                    if self.initiativeRecoverValue != nil {
                        map["InitiativeRecoverValue"] = self.initiativeRecoverValue!
                    }
                    if self.recoverTime != nil {
                        map["RecoverTime"] = self.recoverTime!
                    }
                    if self.stat != nil {
                        map["Stat"] = self.stat!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutoRecover") && dict["AutoRecover"] != nil {
                        self.autoRecover = dict["AutoRecover"] as! Bool
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DuplicateKey") && dict["DuplicateKey"] != nil {
                        self.duplicateKey = dict["DuplicateKey"] as! String
                    }
                    if dict.keys.contains("ExtendedFieldRedefineRules") && dict["ExtendedFieldRedefineRules"] != nil {
                        self.extendedFieldRedefineRules = dict["ExtendedFieldRedefineRules"] as! [[String: Any]]
                    }
                    if dict.keys.contains("FieldRedefineRules") && dict["FieldRedefineRules"] != nil {
                        self.fieldRedefineRules = dict["FieldRedefineRules"] as! [[String: Any]]
                    }
                    if dict.keys.contains("InitiativeRecoverField") && dict["InitiativeRecoverField"] != nil {
                        self.initiativeRecoverField = dict["InitiativeRecoverField"] as! String
                    }
                    if dict.keys.contains("InitiativeRecoverValue") && dict["InitiativeRecoverValue"] != nil {
                        self.initiativeRecoverValue = dict["InitiativeRecoverValue"] as! String
                    }
                    if dict.keys.contains("RecoverTime") && dict["RecoverTime"] != nil {
                        self.recoverTime = dict["RecoverTime"] as! Int64
                    }
                    if dict.keys.contains("Stat") && dict["Stat"] != nil {
                        self.stat = dict["Stat"] as! [Int64]
                    }
                }
            }
            public var apiEndpoint: String?

            public var createTime: String?

            public var integrationDetail: ListIntegrationResponseBody.PageInfo.Integrations.IntegrationDetail?

            public var integrationId: Int64?

            public var integrationName: String?

            public var integrationProductType: String?

            public var liveness: String?

            public var shortToken: String?

            public var state: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.integrationDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiEndpoint != nil {
                    map["ApiEndpoint"] = self.apiEndpoint!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.integrationDetail != nil {
                    map["IntegrationDetail"] = self.integrationDetail?.toMap()
                }
                if self.integrationId != nil {
                    map["IntegrationId"] = self.integrationId!
                }
                if self.integrationName != nil {
                    map["IntegrationName"] = self.integrationName!
                }
                if self.integrationProductType != nil {
                    map["IntegrationProductType"] = self.integrationProductType!
                }
                if self.liveness != nil {
                    map["Liveness"] = self.liveness!
                }
                if self.shortToken != nil {
                    map["ShortToken"] = self.shortToken!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiEndpoint") && dict["ApiEndpoint"] != nil {
                    self.apiEndpoint = dict["ApiEndpoint"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("IntegrationDetail") && dict["IntegrationDetail"] != nil {
                    var model = ListIntegrationResponseBody.PageInfo.Integrations.IntegrationDetail()
                    model.fromMap(dict["IntegrationDetail"] as! [String: Any])
                    self.integrationDetail = model
                }
                if dict.keys.contains("IntegrationId") && dict["IntegrationId"] != nil {
                    self.integrationId = dict["IntegrationId"] as! Int64
                }
                if dict.keys.contains("IntegrationName") && dict["IntegrationName"] != nil {
                    self.integrationName = dict["IntegrationName"] as! String
                }
                if dict.keys.contains("IntegrationProductType") && dict["IntegrationProductType"] != nil {
                    self.integrationProductType = dict["IntegrationProductType"] as! String
                }
                if dict.keys.contains("Liveness") && dict["Liveness"] != nil {
                    self.liveness = dict["Liveness"] as! String
                }
                if dict.keys.contains("ShortToken") && dict["ShortToken"] != nil {
                    self.shortToken = dict["ShortToken"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! Bool
                }
            }
        }
        public var integrations: [ListIntegrationResponseBody.PageInfo.Integrations]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.integrations != nil {
                var tmp : [Any] = []
                for k in self.integrations! {
                    tmp.append(k.toMap())
                }
                map["Integrations"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Integrations") && dict["Integrations"] != nil {
                var tmp : [ListIntegrationResponseBody.PageInfo.Integrations] = []
                for v in dict["Integrations"] as! [Any] {
                    var model = ListIntegrationResponseBody.PageInfo.Integrations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.integrations = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageInfo: ListIntegrationResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListIntegrationResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNotificationPoliciesRequest : Tea.TeaModel {
    public var directedMode: Bool?

    public var ids: String?

    public var isDetail: Bool?

    public var name: String?

    public var page: Int64?

    public var regionId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.directedMode != nil {
            map["DirectedMode"] = self.directedMode!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DirectedMode") && dict["DirectedMode"] != nil {
            self.directedMode = dict["DirectedMode"] as! Bool
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("IsDetail") && dict["IsDetail"] != nil {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListNotificationPoliciesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class NotificationPolicies : Tea.TeaModel {
            public class GroupRule : Tea.TeaModel {
                public var groupInterval: Int64?

                public var groupWait: Int64?

                public var groupingFields: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupInterval != nil {
                        map["GroupInterval"] = self.groupInterval!
                    }
                    if self.groupWait != nil {
                        map["GroupWait"] = self.groupWait!
                    }
                    if self.groupingFields != nil {
                        map["GroupingFields"] = self.groupingFields!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GroupInterval") && dict["GroupInterval"] != nil {
                        self.groupInterval = dict["GroupInterval"] as! Int64
                    }
                    if dict.keys.contains("GroupWait") && dict["GroupWait"] != nil {
                        self.groupWait = dict["GroupWait"] as! Int64
                    }
                    if dict.keys.contains("GroupingFields") && dict["GroupingFields"] != nil {
                        self.groupingFields = dict["GroupingFields"] as! [String]
                    }
                }
            }
            public class MatchingRules : Tea.TeaModel {
                public class MatchingConditions : Tea.TeaModel {
                    public var key: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Operator") && dict["Operator"] != nil {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var matchingConditions: [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules.MatchingConditions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.matchingConditions != nil {
                        var tmp : [Any] = []
                        for k in self.matchingConditions! {
                            tmp.append(k.toMap())
                        }
                        map["MatchingConditions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MatchingConditions") && dict["MatchingConditions"] != nil {
                        var tmp : [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules.MatchingConditions] = []
                        for v in dict["MatchingConditions"] as! [Any] {
                            var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules.MatchingConditions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.matchingConditions = tmp
                    }
                }
            }
            public class NotifyRule : Tea.TeaModel {
                public class NotifyObjects : Tea.TeaModel {
                    public var notifyChannels: [String]?

                    public var notifyObjectId: Int64?

                    public var notifyObjectName: String?

                    public var notifyObjectType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.notifyChannels != nil {
                            map["NotifyChannels"] = self.notifyChannels!
                        }
                        if self.notifyObjectId != nil {
                            map["NotifyObjectId"] = self.notifyObjectId!
                        }
                        if self.notifyObjectName != nil {
                            map["NotifyObjectName"] = self.notifyObjectName!
                        }
                        if self.notifyObjectType != nil {
                            map["NotifyObjectType"] = self.notifyObjectType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NotifyChannels") && dict["NotifyChannels"] != nil {
                            self.notifyChannels = dict["NotifyChannels"] as! [String]
                        }
                        if dict.keys.contains("NotifyObjectId") && dict["NotifyObjectId"] != nil {
                            self.notifyObjectId = dict["NotifyObjectId"] as! Int64
                        }
                        if dict.keys.contains("NotifyObjectName") && dict["NotifyObjectName"] != nil {
                            self.notifyObjectName = dict["NotifyObjectName"] as! String
                        }
                        if dict.keys.contains("NotifyObjectType") && dict["NotifyObjectType"] != nil {
                            self.notifyObjectType = dict["NotifyObjectType"] as! String
                        }
                    }
                }
                public var notifyChannels: [String]?

                public var notifyEndTime: String?

                public var notifyObjects: [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule.NotifyObjects]?

                public var notifyStartTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.notifyChannels != nil {
                        map["NotifyChannels"] = self.notifyChannels!
                    }
                    if self.notifyEndTime != nil {
                        map["NotifyEndTime"] = self.notifyEndTime!
                    }
                    if self.notifyObjects != nil {
                        var tmp : [Any] = []
                        for k in self.notifyObjects! {
                            tmp.append(k.toMap())
                        }
                        map["NotifyObjects"] = tmp
                    }
                    if self.notifyStartTime != nil {
                        map["NotifyStartTime"] = self.notifyStartTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NotifyChannels") && dict["NotifyChannels"] != nil {
                        self.notifyChannels = dict["NotifyChannels"] as! [String]
                    }
                    if dict.keys.contains("NotifyEndTime") && dict["NotifyEndTime"] != nil {
                        self.notifyEndTime = dict["NotifyEndTime"] as! String
                    }
                    if dict.keys.contains("NotifyObjects") && dict["NotifyObjects"] != nil {
                        var tmp : [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule.NotifyObjects] = []
                        for v in dict["NotifyObjects"] as! [Any] {
                            var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule.NotifyObjects()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notifyObjects = tmp
                    }
                    if dict.keys.contains("NotifyStartTime") && dict["NotifyStartTime"] != nil {
                        self.notifyStartTime = dict["NotifyStartTime"] as! String
                    }
                }
            }
            public class NotifyTemplate : Tea.TeaModel {
                public var emailContent: String?

                public var emailRecoverContent: String?

                public var emailRecoverTitle: String?

                public var emailTitle: String?

                public var robotContent: String?

                public var smsContent: String?

                public var smsRecoverContent: String?

                public var ttsContent: String?

                public var ttsRecoverContent: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.emailContent != nil {
                        map["EmailContent"] = self.emailContent!
                    }
                    if self.emailRecoverContent != nil {
                        map["EmailRecoverContent"] = self.emailRecoverContent!
                    }
                    if self.emailRecoverTitle != nil {
                        map["EmailRecoverTitle"] = self.emailRecoverTitle!
                    }
                    if self.emailTitle != nil {
                        map["EmailTitle"] = self.emailTitle!
                    }
                    if self.robotContent != nil {
                        map["RobotContent"] = self.robotContent!
                    }
                    if self.smsContent != nil {
                        map["SmsContent"] = self.smsContent!
                    }
                    if self.smsRecoverContent != nil {
                        map["SmsRecoverContent"] = self.smsRecoverContent!
                    }
                    if self.ttsContent != nil {
                        map["TtsContent"] = self.ttsContent!
                    }
                    if self.ttsRecoverContent != nil {
                        map["TtsRecoverContent"] = self.ttsRecoverContent!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EmailContent") && dict["EmailContent"] != nil {
                        self.emailContent = dict["EmailContent"] as! String
                    }
                    if dict.keys.contains("EmailRecoverContent") && dict["EmailRecoverContent"] != nil {
                        self.emailRecoverContent = dict["EmailRecoverContent"] as! String
                    }
                    if dict.keys.contains("EmailRecoverTitle") && dict["EmailRecoverTitle"] != nil {
                        self.emailRecoverTitle = dict["EmailRecoverTitle"] as! String
                    }
                    if dict.keys.contains("EmailTitle") && dict["EmailTitle"] != nil {
                        self.emailTitle = dict["EmailTitle"] as! String
                    }
                    if dict.keys.contains("RobotContent") && dict["RobotContent"] != nil {
                        self.robotContent = dict["RobotContent"] as! String
                    }
                    if dict.keys.contains("SmsContent") && dict["SmsContent"] != nil {
                        self.smsContent = dict["SmsContent"] as! String
                    }
                    if dict.keys.contains("SmsRecoverContent") && dict["SmsRecoverContent"] != nil {
                        self.smsRecoverContent = dict["SmsRecoverContent"] as! String
                    }
                    if dict.keys.contains("TtsContent") && dict["TtsContent"] != nil {
                        self.ttsContent = dict["TtsContent"] as! String
                    }
                    if dict.keys.contains("TtsRecoverContent") && dict["TtsRecoverContent"] != nil {
                        self.ttsRecoverContent = dict["TtsRecoverContent"] as! String
                    }
                }
            }
            public var directedMode: Bool?

            public var escalationPolicyId: Int64?

            public var groupRule: ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.GroupRule?

            public var id: Int64?

            public var integrationId: Int64?

            public var matchingRules: [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules]?

            public var name: String?

            public var notifyRule: ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule?

            public var notifyTemplate: ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyTemplate?

            public var repeat_: Bool?

            public var repeatInterval: Int64?

            public var sendRecoverMessage: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groupRule?.validate()
                try self.notifyRule?.validate()
                try self.notifyTemplate?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.directedMode != nil {
                    map["DirectedMode"] = self.directedMode!
                }
                if self.escalationPolicyId != nil {
                    map["EscalationPolicyId"] = self.escalationPolicyId!
                }
                if self.groupRule != nil {
                    map["GroupRule"] = self.groupRule?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.integrationId != nil {
                    map["IntegrationId"] = self.integrationId!
                }
                if self.matchingRules != nil {
                    var tmp : [Any] = []
                    for k in self.matchingRules! {
                        tmp.append(k.toMap())
                    }
                    map["MatchingRules"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifyRule != nil {
                    map["NotifyRule"] = self.notifyRule?.toMap()
                }
                if self.notifyTemplate != nil {
                    map["NotifyTemplate"] = self.notifyTemplate?.toMap()
                }
                if self.repeat_ != nil {
                    map["Repeat"] = self.repeat_!
                }
                if self.repeatInterval != nil {
                    map["RepeatInterval"] = self.repeatInterval!
                }
                if self.sendRecoverMessage != nil {
                    map["SendRecoverMessage"] = self.sendRecoverMessage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DirectedMode") && dict["DirectedMode"] != nil {
                    self.directedMode = dict["DirectedMode"] as! Bool
                }
                if dict.keys.contains("EscalationPolicyId") && dict["EscalationPolicyId"] != nil {
                    self.escalationPolicyId = dict["EscalationPolicyId"] as! Int64
                }
                if dict.keys.contains("GroupRule") && dict["GroupRule"] != nil {
                    var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.GroupRule()
                    model.fromMap(dict["GroupRule"] as! [String: Any])
                    self.groupRule = model
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IntegrationId") && dict["IntegrationId"] != nil {
                    self.integrationId = dict["IntegrationId"] as! Int64
                }
                if dict.keys.contains("MatchingRules") && dict["MatchingRules"] != nil {
                    var tmp : [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules] = []
                    for v in dict["MatchingRules"] as! [Any] {
                        var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.MatchingRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.matchingRules = tmp
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NotifyRule") && dict["NotifyRule"] != nil {
                    var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyRule()
                    model.fromMap(dict["NotifyRule"] as! [String: Any])
                    self.notifyRule = model
                }
                if dict.keys.contains("NotifyTemplate") && dict["NotifyTemplate"] != nil {
                    var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies.NotifyTemplate()
                    model.fromMap(dict["NotifyTemplate"] as! [String: Any])
                    self.notifyTemplate = model
                }
                if dict.keys.contains("Repeat") && dict["Repeat"] != nil {
                    self.repeat_ = dict["Repeat"] as! Bool
                }
                if dict.keys.contains("RepeatInterval") && dict["RepeatInterval"] != nil {
                    self.repeatInterval = dict["RepeatInterval"] as! Int64
                }
                if dict.keys.contains("SendRecoverMessage") && dict["SendRecoverMessage"] != nil {
                    self.sendRecoverMessage = dict["SendRecoverMessage"] as! Bool
                }
            }
        }
        public var notificationPolicies: [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notificationPolicies != nil {
                var tmp : [Any] = []
                for k in self.notificationPolicies! {
                    tmp.append(k.toMap())
                }
                map["NotificationPolicies"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NotificationPolicies") && dict["NotificationPolicies"] != nil {
                var tmp : [ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies] = []
                for v in dict["NotificationPolicies"] as! [Any] {
                    var model = ListNotificationPoliciesResponseBody.PageBean.NotificationPolicies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationPolicies = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListNotificationPoliciesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = ListNotificationPoliciesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListNotificationPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNotificationPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListNotificationPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOnCallSchedulesRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListOnCallSchedulesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class OnCallSchedules : Tea.TeaModel {
            public var description_: String?

            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var onCallSchedules: [ListOnCallSchedulesResponseBody.PageBean.OnCallSchedules]?

        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.onCallSchedules != nil {
                var tmp : [Any] = []
                for k in self.onCallSchedules! {
                    tmp.append(k.toMap())
                }
                map["OnCallSchedules"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OnCallSchedules") && dict["OnCallSchedules"] != nil {
                var tmp : [ListOnCallSchedulesResponseBody.PageBean.OnCallSchedules] = []
                for v in dict["OnCallSchedules"] as! [Any] {
                    var model = ListOnCallSchedulesResponseBody.PageBean.OnCallSchedules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.onCallSchedules = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListOnCallSchedulesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = ListOnCallSchedulesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListOnCallSchedulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOnCallSchedulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListOnCallSchedulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusAlertRulesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clusterId: String?

    public var matchExpressions: String?

    public var name: String?

    public var regionId: String?

    public var status: Int32?

    public var tags: [ListPrometheusAlertRulesRequest.Tags]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.matchExpressions != nil {
            map["MatchExpressions"] = self.matchExpressions!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MatchExpressions") && dict["MatchExpressions"] != nil {
            self.matchExpressions = dict["MatchExpressions"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [ListPrometheusAlertRulesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListPrometheusAlertRulesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListPrometheusAlertRulesResponseBody : Tea.TeaModel {
    public class PrometheusAlertRules : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertId: Int64?

        public var alertName: String?

        public var annotations: [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Annotations]?

        public var clusterId: String?

        public var dispatchRuleId: Int64?

        public var duration: String?

        public var expression: String?

        public var labels: [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Labels]?

        public var message: String?

        public var notifyType: String?

        public var status: Int32?

        public var tags: [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Tags]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dispatchRuleId != nil {
                map["DispatchRuleId"] = self.dispatchRuleId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
                self.alertId = dict["AlertId"] as! Int64
            }
            if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                var tmp : [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("DispatchRuleId") && dict["DispatchRuleId"] != nil {
                self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") && dict["Expression"] != nil {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
                self.notifyType = dict["NotifyType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListPrometheusAlertRulesResponseBody.PrometheusAlertRules.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int64?

    public var message: String?

    public var prometheusAlertRules: [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.prometheusAlertRules != nil {
            var tmp : [Any] = []
            for k in self.prometheusAlertRules! {
                tmp.append(k.toMap())
            }
            map["PrometheusAlertRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PrometheusAlertRules") && dict["PrometheusAlertRules"] != nil {
            var tmp : [ListPrometheusAlertRulesResponseBody.PrometheusAlertRules] = []
            for v in dict["PrometheusAlertRules"] as! [Any] {
                var model = ListPrometheusAlertRulesResponseBody.PrometheusAlertRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.prometheusAlertRules = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListPrometheusAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrometheusAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusAlertTemplatesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListPrometheusAlertTemplatesResponseBody : Tea.TeaModel {
    public class PrometheusAlertTemplates : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertName: String?

        public var annotations: [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Annotations]?

        public var description_: String?

        public var duration: String?

        public var expression: String?

        public var labels: [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Labels]?

        public var type: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                var tmp : [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") && dict["Expression"] != nil {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var prometheusAlertTemplates: [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.prometheusAlertTemplates != nil {
            var tmp : [Any] = []
            for k in self.prometheusAlertTemplates! {
                tmp.append(k.toMap())
            }
            map["PrometheusAlertTemplates"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrometheusAlertTemplates") && dict["PrometheusAlertTemplates"] != nil {
            var tmp : [ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates] = []
            for v in dict["PrometheusAlertTemplates"] as! [Any] {
                var model = ListPrometheusAlertTemplatesResponseBody.PrometheusAlertTemplates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.prometheusAlertTemplates = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusAlertTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusAlertTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrometheusAlertTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusGlobalViewRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusInstanceByTagAndResourceGroupIdRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [ListPrometheusInstanceByTagAndResourceGroupIdRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListPrometheusInstanceByTagAndResourceGroupIdRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListPrometheusInstanceByTagAndResourceGroupIdRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListPrometheusInstanceByTagAndResourceGroupIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class PrometheusInstances : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                        self.tagKey = dict["TagKey"] as! String
                    }
                    if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                        self.tagValue = dict["TagValue"] as! String
                    }
                }
            }
            public var clusterId: String?

            public var clusterName: String?

            public var clusterType: String?

            public var grafanaInstanceId: String?

            public var paymentType: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var resourceType: String?

            public var securityGroupId: String?

            public var subClustersJson: String?

            public var tags: [ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances.Tags]?

            public var userId: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.grafanaInstanceId != nil {
                    map["GrafanaInstanceId"] = self.grafanaInstanceId!
                }
                if self.paymentType != nil {
                    map["PaymentType"] = self.paymentType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.subClustersJson != nil {
                    map["SubClustersJson"] = self.subClustersJson!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                    self.clusterType = dict["ClusterType"] as! String
                }
                if dict.keys.contains("GrafanaInstanceId") && dict["GrafanaInstanceId"] != nil {
                    self.grafanaInstanceId = dict["GrafanaInstanceId"] as! String
                }
                if dict.keys.contains("PaymentType") && dict["PaymentType"] != nil {
                    self.paymentType = dict["PaymentType"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("SubClustersJson") && dict["SubClustersJson"] != nil {
                    self.subClustersJson = dict["SubClustersJson"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var tmp : [ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var prometheusInstances: [ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.prometheusInstances != nil {
                var tmp : [Any] = []
                for k in self.prometheusInstances! {
                    tmp.append(k.toMap())
                }
                map["PrometheusInstances"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrometheusInstances") && dict["PrometheusInstances"] != nil {
                var tmp : [ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances] = []
                for v in dict["PrometheusInstances"] as! [Any] {
                    var model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data.PrometheusInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.prometheusInstances = tmp
            }
        }
    }
    public var code: String?

    public var data: ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusInstanceByTagAndResourceGroupIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusInstanceByTagAndResourceGroupIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusInstancesRequest : Tea.TeaModel {
    public var clusterType: String?

    public var regionId: String?

    public var showGlobalView: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showGlobalView != nil {
            map["ShowGlobalView"] = self.showGlobalView!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ShowGlobalView") && dict["ShowGlobalView"] != nil {
            self.showGlobalView = dict["ShowGlobalView"] as! Bool
        }
    }
}

public class ListPrometheusInstancesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrometheusInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var integrationType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListPrometheusIntegrationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var canDelete: Bool?

        public var canEditor: Bool?

        public var clusterId: String?

        public var containerName: String?

        public var describe: String?

        public var exporterType: String?

        public var instanceId: Int64?

        public var instanceName: String?

        public var integrationType: String?

        public var namespace: String?

        public var needUpgrade: Bool?

        public var param: String?

        public var podName: String?

        public var showDescribe: Bool?

        public var showLog: Bool?

        public var status: String?

        public var target: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canDelete != nil {
                map["CanDelete"] = self.canDelete!
            }
            if self.canEditor != nil {
                map["CanEditor"] = self.canEditor!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.containerName != nil {
                map["ContainerName"] = self.containerName!
            }
            if self.describe != nil {
                map["Describe"] = self.describe!
            }
            if self.exporterType != nil {
                map["ExporterType"] = self.exporterType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.integrationType != nil {
                map["IntegrationType"] = self.integrationType!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.needUpgrade != nil {
                map["NeedUpgrade"] = self.needUpgrade!
            }
            if self.param != nil {
                map["Param"] = self.param!
            }
            if self.podName != nil {
                map["PodName"] = self.podName!
            }
            if self.showDescribe != nil {
                map["ShowDescribe"] = self.showDescribe!
            }
            if self.showLog != nil {
                map["ShowLog"] = self.showLog!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanDelete") && dict["CanDelete"] != nil {
                self.canDelete = dict["CanDelete"] as! Bool
            }
            if dict.keys.contains("CanEditor") && dict["CanEditor"] != nil {
                self.canEditor = dict["CanEditor"] as! Bool
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ContainerName") && dict["ContainerName"] != nil {
                self.containerName = dict["ContainerName"] as! String
            }
            if dict.keys.contains("Describe") && dict["Describe"] != nil {
                self.describe = dict["Describe"] as! String
            }
            if dict.keys.contains("ExporterType") && dict["ExporterType"] != nil {
                self.exporterType = dict["ExporterType"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
                self.integrationType = dict["IntegrationType"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NeedUpgrade") && dict["NeedUpgrade"] != nil {
                self.needUpgrade = dict["NeedUpgrade"] as! Bool
            }
            if dict.keys.contains("Param") && dict["Param"] != nil {
                self.param = dict["Param"] as! String
            }
            if dict.keys.contains("PodName") && dict["PodName"] != nil {
                self.podName = dict["PodName"] as! String
            }
            if dict.keys.contains("ShowDescribe") && dict["ShowDescribe"] != nil {
                self.showDescribe = dict["ShowDescribe"] as! Bool
            }
            if dict.keys.contains("ShowLog") && dict["ShowLog"] != nil {
                self.showLog = dict["ShowLog"] as! Bool
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListPrometheusIntegrationResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListPrometheusIntegrationResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListPrometheusIntegrationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListPrometheusMonitoringResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var configYaml: String?

        public var monitoringName: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.configYaml != nil {
                map["ConfigYaml"] = self.configYaml!
            }
            if self.monitoringName != nil {
                map["MonitoringName"] = self.monitoringName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
                self.configYaml = dict["ConfigYaml"] as! String
            }
            if dict.keys.contains("MonitoringName") && dict["MonitoringName"] != nil {
                self.monitoringName = dict["MonitoringName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListPrometheusMonitoringResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListPrometheusMonitoringResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListPrometheusMonitoringResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrometheusRemoteWritesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListPrometheusRemoteWritesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var remoteWriteName: String?

        public var remoteWriteYaml: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.remoteWriteName != nil {
                map["RemoteWriteName"] = self.remoteWriteName!
            }
            if self.remoteWriteYaml != nil {
                map["RemoteWriteYaml"] = self.remoteWriteYaml!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("RemoteWriteName") && dict["RemoteWriteName"] != nil {
                self.remoteWriteName = dict["RemoteWriteName"] as! String
            }
            if dict.keys.contains("RemoteWriteYaml") && dict["RemoteWriteYaml"] != nil {
                self.remoteWriteYaml = dict["RemoteWriteYaml"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListPrometheusRemoteWritesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListPrometheusRemoteWritesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListPrometheusRemoteWritesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListPrometheusRemoteWritesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrometheusRemoteWritesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrometheusRemoteWritesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRetcodeAppsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [ListRetcodeAppsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [ListRetcodeAppsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListRetcodeAppsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListRetcodeAppsResponseBody : Tea.TeaModel {
    public class RetcodeApps : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: Int64?

        public var appName: String?

        public var nickName: String?

        public var pid: String?

        public var resourceGroupId: String?

        public var retcodeAppType: String?

        public var tags: [ListRetcodeAppsResponseBody.RetcodeApps.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.retcodeAppType != nil {
                map["RetcodeAppType"] = self.retcodeAppType!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("NickName") && dict["NickName"] != nil {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RetcodeAppType") && dict["RetcodeAppType"] != nil {
                self.retcodeAppType = dict["RetcodeAppType"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [ListRetcodeAppsResponseBody.RetcodeApps.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListRetcodeAppsResponseBody.RetcodeApps.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var requestId: String?

    public var retcodeApps: [ListRetcodeAppsResponseBody.RetcodeApps]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retcodeApps != nil {
            var tmp : [Any] = []
            for k in self.retcodeApps! {
                tmp.append(k.toMap())
            }
            map["RetcodeApps"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetcodeApps") && dict["RetcodeApps"] != nil {
            var tmp : [ListRetcodeAppsResponseBody.RetcodeApps] = []
            for v in dict["RetcodeApps"] as! [Any] {
                var model = ListRetcodeAppsResponseBody.RetcodeApps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.retcodeApps = tmp
        }
    }
}

public class ListRetcodeAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRetcodeAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRetcodeAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScenarioRequest : Tea.TeaModel {
    public var appId: String?

    public var name: String?

    public var regionId: String?

    public var scenario: String?

    public var sign: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scenario != nil {
            map["Scenario"] = self.scenario!
        }
        if self.sign != nil {
            map["Sign"] = self.sign!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Scenario") && dict["Scenario"] != nil {
            self.scenario = dict["Scenario"] as! String
        }
        if dict.keys.contains("Sign") && dict["Sign"] != nil {
            self.sign = dict["Sign"] as! String
        }
    }
}

public class ListScenarioResponseBody : Tea.TeaModel {
    public class ArmsScenarios : Tea.TeaModel {
        public var appId: String?

        public var createTime: String?

        public var extensions: String?

        public var id: Int64?

        public var name: String?

        public var regionId: String?

        public var sign: String?

        public var updateTime: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extensions != nil {
                map["Extensions"] = self.extensions!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.sign != nil {
                map["Sign"] = self.sign!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Extensions") && dict["Extensions"] != nil {
                self.extensions = dict["Extensions"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Sign") && dict["Sign"] != nil {
                self.sign = dict["Sign"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var armsScenarios: [ListScenarioResponseBody.ArmsScenarios]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.armsScenarios != nil {
            var tmp : [Any] = []
            for k in self.armsScenarios! {
                tmp.append(k.toMap())
            }
            map["ArmsScenarios"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ArmsScenarios") && dict["ArmsScenarios"] != nil {
            var tmp : [ListScenarioResponseBody.ArmsScenarios] = []
            for v in dict["ArmsScenarios"] as! [Any] {
                var model = ListScenarioResponseBody.ArmsScenarios()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.armsScenarios = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListScenarioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScenarioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListScenarioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSilencePoliciesRequest : Tea.TeaModel {
    public var isDetail: Bool?

    public var name: String?

    public var page: Int64?

    public var regionId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsDetail") && dict["IsDetail"] != nil {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int64
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class ListSilencePoliciesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class SilencePolicies : Tea.TeaModel {
            public class MatchingRules : Tea.TeaModel {
                public class MatchingConditions : Tea.TeaModel {
                    public var key: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Operator") && dict["Operator"] != nil {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var matchingConditions: [ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules.MatchingConditions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.matchingConditions != nil {
                        var tmp : [Any] = []
                        for k in self.matchingConditions! {
                            tmp.append(k.toMap())
                        }
                        map["MatchingConditions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MatchingConditions") && dict["MatchingConditions"] != nil {
                        var tmp : [ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules.MatchingConditions] = []
                        for v in dict["MatchingConditions"] as! [Any] {
                            var model = ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules.MatchingConditions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.matchingConditions = tmp
                    }
                }
            }
            public var id: Int64?

            public var matchingRules: [ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.matchingRules != nil {
                    var tmp : [Any] = []
                    for k in self.matchingRules! {
                        tmp.append(k.toMap())
                    }
                    map["MatchingRules"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MatchingRules") && dict["MatchingRules"] != nil {
                    var tmp : [ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules] = []
                    for v in dict["MatchingRules"] as! [Any] {
                        var model = ListSilencePoliciesResponseBody.PageBean.SilencePolicies.MatchingRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.matchingRules = tmp
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var page: Int64?

        public var silencePolicies: [ListSilencePoliciesResponseBody.PageBean.SilencePolicies]?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.silencePolicies != nil {
                var tmp : [Any] = []
                for k in self.silencePolicies! {
                    tmp.append(k.toMap())
                }
                map["SilencePolicies"] = tmp
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("SilencePolicies") && dict["SilencePolicies"] != nil {
                var tmp : [ListSilencePoliciesResponseBody.PageBean.SilencePolicies] = []
                for v in dict["SilencePolicies"] as! [Any] {
                    var model = ListSilencePoliciesResponseBody.PageBean.SilencePolicies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.silencePolicies = tmp
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var pageBean: ListSilencePoliciesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = ListSilencePoliciesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSilencePoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSilencePoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSilencePoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTimingSyntheticTasksRequest : Tea.TeaModel {
    public class Search : Tea.TeaModel {
        public var name: String?

        public var order: Int32?

        public var orderField: String?

        public var page: Int32?

        public var pageSize: Int32?

        public var status: String?

        public var taskIds: [String]?

        public var taskTypes: [Int32]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.order != nil {
                map["Order"] = self.order!
            }
            if self.orderField != nil {
                map["OrderField"] = self.orderField!
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.taskTypes != nil {
                map["TaskTypes"] = self.taskTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Order") && dict["Order"] != nil {
                self.order = dict["Order"] as! Int32
            }
            if dict.keys.contains("OrderField") && dict["OrderField"] != nil {
                self.orderField = dict["OrderField"] as! String
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
                self.taskIds = dict["TaskIds"] as! [String]
            }
            if dict.keys.contains("TaskTypes") && dict["TaskTypes"] != nil {
                self.taskTypes = dict["TaskTypes"] as! [Int32]
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceGroupId: String?

    public var search: ListTimingSyntheticTasksRequest.Search?

    public var tags: [ListTimingSyntheticTasksRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.search?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.search != nil {
            map["Search"] = self.search?.toMap()
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Search") && dict["Search"] != nil {
            var model = ListTimingSyntheticTasksRequest.Search()
            model.fromMap(dict["Search"] as! [String: Any])
            self.search = model
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [ListTimingSyntheticTasksRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListTimingSyntheticTasksRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListTimingSyntheticTasksShrinkRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceGroupId: String?

    public var searchShrink: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.searchShrink != nil {
            map["Search"] = self.searchShrink!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Search") && dict["Search"] != nil {
            self.searchShrink = dict["Search"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class ListTimingSyntheticTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Items : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var frequency: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var monitorCategory: Int32?

            public var monitorNum: String?

            public var name: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var status: String?

            public var tags: [ListTimingSyntheticTasksResponseBody.Data.Items.Tags]?

            public var taskId: String?

            public var taskType: Int32?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.frequency != nil {
                    map["Frequency"] = self.frequency!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.monitorCategory != nil {
                    map["MonitorCategory"] = self.monitorCategory!
                }
                if self.monitorNum != nil {
                    map["MonitorNum"] = self.monitorNum!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Frequency") && dict["Frequency"] != nil {
                    self.frequency = dict["Frequency"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("MonitorCategory") && dict["MonitorCategory"] != nil {
                    self.monitorCategory = dict["MonitorCategory"] as! Int32
                }
                if dict.keys.contains("MonitorNum") && dict["MonitorNum"] != nil {
                    self.monitorNum = dict["MonitorNum"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var tmp : [ListTimingSyntheticTasksResponseBody.Data.Items.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListTimingSyntheticTasksResponseBody.Data.Items.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                    self.taskType = dict["TaskType"] as! Int32
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var items: [ListTimingSyntheticTasksResponseBody.Data.Items]?

        public var page: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.items != nil {
                var tmp : [Any] = []
                for k in self.items! {
                    tmp.append(k.toMap())
                }
                map["Items"] = tmp
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Items") && dict["Items"] != nil {
                var tmp : [ListTimingSyntheticTasksResponseBody.Data.Items] = []
                for v in dict["Items"] as! [Any] {
                    var model = ListTimingSyntheticTasksResponseBody.Data.Items()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.items = tmp
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: Int64?

    public var data: ListTimingSyntheticTasksResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListTimingSyntheticTasksResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTimingSyntheticTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTimingSyntheticTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTimingSyntheticTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTraceAppsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appType: String?

    public var region: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [ListTraceAppsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [ListTraceAppsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListTraceAppsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListTraceAppsResponseBody : Tea.TeaModel {
    public class TraceApps : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: Int64?

        public var appName: String?

        public var clusterId: String?

        public var createTime: Int64?

        public var labels: [String]?

        public var language: String?

        public var namespace: String?

        public var pid: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var show: Bool?

        public var source: String?

        public var tags: [ListTraceAppsResponseBody.TraceApps.Tags]?

        public var type: String?

        public var updateTime: Int64?

        public var userId: String?

        public var workloadKind: String?

        public var workloadName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.labels != nil {
                map["Labels"] = self.labels!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.show != nil {
                map["Show"] = self.show!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workloadKind != nil {
                map["WorkloadKind"] = self.workloadKind!
            }
            if self.workloadName != nil {
                map["WorkloadName"] = self.workloadName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                self.labels = dict["Labels"] as! [String]
            }
            if dict.keys.contains("Language") && dict["Language"] != nil {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Show") && dict["Show"] != nil {
                self.show = dict["Show"] as! Bool
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [ListTraceAppsResponseBody.TraceApps.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListTraceAppsResponseBody.TraceApps.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WorkloadKind") && dict["WorkloadKind"] != nil {
                self.workloadKind = dict["WorkloadKind"] as! String
            }
            if dict.keys.contains("WorkloadName") && dict["WorkloadName"] != nil {
                self.workloadName = dict["WorkloadName"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceApps: [ListTraceAppsResponseBody.TraceApps]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceApps != nil {
            var tmp : [Any] = []
            for k in self.traceApps! {
                tmp.append(k.toMap())
            }
            map["TraceApps"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceApps") && dict["TraceApps"] != nil {
            var tmp : [ListTraceAppsResponseBody.TraceApps] = []
            for v in dict["TraceApps"] as! [Any] {
                var model = ListTraceAppsResponseBody.TraceApps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traceApps = tmp
        }
    }
}

public class ListTraceAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTraceAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTraceAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ManageGetRecordingRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var queryUserId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.queryUserId != nil {
            map["QueryUserId"] = self.queryUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("QueryUserId") && dict["QueryUserId"] != nil {
            self.queryUserId = dict["QueryUserId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ManageGetRecordingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ManageGetRecordingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ManageGetRecordingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ManageGetRecordingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ManageRecordingRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var queryUserId: String?

    public var regionId: String?

    public var ruleYaml: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.queryUserId != nil {
            map["QueryUserId"] = self.queryUserId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleYaml != nil {
            map["RuleYaml"] = self.ruleYaml!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("QueryUserId") && dict["QueryUserId"] != nil {
            self.queryUserId = dict["QueryUserId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RuleYaml") && dict["RuleYaml"] != nil {
            self.ruleYaml = dict["RuleYaml"] as! String
        }
    }
}

public class ManageRecordingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ManageRecordingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ManageRecordingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ManageRecordingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenArmsDefaultSLRRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class OpenArmsDefaultSLRResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenArmsDefaultSLRResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenArmsDefaultSLRResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenArmsDefaultSLRResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenArmsServiceSecondVersionRequest : Tea.TeaModel {
    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class OpenArmsServiceSecondVersionResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenArmsServiceSecondVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenArmsServiceSecondVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenArmsServiceSecondVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenVClusterRequest : Tea.TeaModel {
    public var clusterType: String?

    public var length: Int32?

    public var product: String?

    public var recreateSwitch: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.recreateSwitch != nil {
            map["RecreateSwitch"] = self.recreateSwitch!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("Product") && dict["Product"] != nil {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RecreateSwitch") && dict["RecreateSwitch"] != nil {
            self.recreateSwitch = dict["RecreateSwitch"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class OpenVClusterResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenVClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenVClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenVClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenXtraceDefaultSLRRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class OpenXtraceDefaultSLRResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenXtraceDefaultSLRResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenXtraceDefaultSLRResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenXtraceDefaultSLRResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAppMetadataRequest : Tea.TeaModel {
    public var metaIds: String?

    public var metaType: String?

    public var pid: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metaIds != nil {
            map["MetaIds"] = self.metaIds!
        }
        if self.metaType != nil {
            map["MetaType"] = self.metaType!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetaIds") && dict["MetaIds"] != nil {
            self.metaIds = dict["MetaIds"] as! String
        }
        if dict.keys.contains("MetaType") && dict["MetaType"] != nil {
            self.metaType = dict["MetaType"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class QueryAppMetadataResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String: Any]?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String: Any]
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAppMetadataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAppMetadataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAppMetadataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMetricByPageRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var customFilters: [String]?

    public var dimensions: [String]?

    public var endTime: Int64?

    public var filters: [QueryMetricByPageRequest.Filters]?

    public var intervalInSec: Int32?

    public var measures: [String]?

    public var metric: String?

    public var order: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.customFilters != nil {
            map["CustomFilters"] = self.customFilters!
        }
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.intervalInSec != nil {
            map["IntervalInSec"] = self.intervalInSec!
        }
        if self.measures != nil {
            map["Measures"] = self.measures!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("CustomFilters") && dict["CustomFilters"] != nil {
            self.customFilters = dict["CustomFilters"] as! [String]
        }
        if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
            self.dimensions = dict["Dimensions"] as! [String]
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Filters") && dict["Filters"] != nil {
            var tmp : [QueryMetricByPageRequest.Filters] = []
            for v in dict["Filters"] as! [Any] {
                var model = QueryMetricByPageRequest.Filters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filters = tmp
        }
        if dict.keys.contains("IntervalInSec") && dict["IntervalInSec"] != nil {
            self.intervalInSec = dict["IntervalInSec"] as! Int32
        }
        if dict.keys.contains("Measures") && dict["Measures"] != nil {
            self.measures = dict["Measures"] as! [String]
        }
        if dict.keys.contains("Metric") && dict["Metric"] != nil {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Order") && dict["Order"] != nil {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class QueryMetricByPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var completed: Bool?

        public var items: [[String: Any]]?

        public var page: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completed != nil {
                map["Completed"] = self.completed!
            }
            if self.items != nil {
                map["Items"] = self.items!
            }
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Completed") && dict["Completed"] != nil {
                self.completed = dict["Completed"] as! Bool
            }
            if dict.keys.contains("Items") && dict["Items"] != nil {
                self.items = dict["Items"] as! [[String: Any]]
            }
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: QueryMetricByPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryMetricByPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMetricByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMetricByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMetricByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPromInstallStatusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class QueryPromInstallStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var isControllerInstalled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isControllerInstalled != nil {
                map["isControllerInstalled"] = self.isControllerInstalled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("isControllerInstalled") && dict["isControllerInstalled"] != nil {
                self.isControllerInstalled = dict["isControllerInstalled"] as! Bool
            }
        }
    }
    public var data: QueryPromInstallStatusResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryPromInstallStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryPromInstallStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPromInstallStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryPromInstallStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryReleaseMetricRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public var createTime: Int64?

    public var metricType: String?

    public var pid: String?

    public var proxyUserId: String?

    public var releaseEndTime: Int64?

    public var releaseStartTime: Int64?

    public var service: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.proxyUserId != nil {
            map["ProxyUserId"] = self.proxyUserId!
        }
        if self.releaseEndTime != nil {
            map["ReleaseEndTime"] = self.releaseEndTime!
        }
        if self.releaseStartTime != nil {
            map["ReleaseStartTime"] = self.releaseStartTime!
        }
        if self.service != nil {
            map["Service"] = self.service!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("ProxyUserId") && dict["ProxyUserId"] != nil {
            self.proxyUserId = dict["ProxyUserId"] as! String
        }
        if dict.keys.contains("ReleaseEndTime") && dict["ReleaseEndTime"] != nil {
            self.releaseEndTime = dict["ReleaseEndTime"] as! Int64
        }
        if dict.keys.contains("ReleaseStartTime") && dict["ReleaseStartTime"] != nil {
            self.releaseStartTime = dict["ReleaseStartTime"] as! Int64
        }
        if dict.keys.contains("Service") && dict["Service"] != nil {
            self.service = dict["Service"] as! String
        }
    }
}

public class QueryReleaseMetricResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryReleaseMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryReleaseMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryReleaseMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAliClusterIdsFromPrometheusGlobalViewRequest : Tea.TeaModel {
    public var clusterIds: String?

    public var globalViewClusterId: String?

    public var groupName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") && dict["ClusterIds"] != nil {
            self.clusterIds = dict["ClusterIds"] as! String
        }
        if dict.keys.contains("GlobalViewClusterId") && dict["GlobalViewClusterId"] != nil {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") && dict["Info"] != nil {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") && dict["Msg"] != nil {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveAliClusterIdsFromPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveSourcesFromPrometheusGlobalViewRequest : Tea.TeaModel {
    public var globalViewClusterId: String?

    public var groupName: String?

    public var regionId: String?

    public var sourceNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalViewClusterId != nil {
            map["GlobalViewClusterId"] = self.globalViewClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sourceNames != nil {
            map["SourceNames"] = self.sourceNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalViewClusterId") && dict["GlobalViewClusterId"] != nil {
            self.globalViewClusterId = dict["GlobalViewClusterId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SourceNames") && dict["SourceNames"] != nil {
            self.sourceNames = dict["SourceNames"] as! String
        }
    }
}

public class RemoveSourcesFromPrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var info: String?

        public var msg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                map["Info"] = self.info!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") && dict["Info"] != nil {
                self.info = dict["Info"] as! String
            }
            if dict.keys.contains("Msg") && dict["Msg"] != nil {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: RemoveSourcesFromPrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = RemoveSourcesFromPrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveSourcesFromPrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSourcesFromPrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveSourcesFromPrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartEnvironmentFeatureRequest : Tea.TeaModel {
    public var environmentId: String?

    public var featureName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") && dict["FeatureName"] != nil {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RestartEnvironmentFeatureResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestartEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RestartEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveTraceAppConfigRequest : Tea.TeaModel {
    public class Settings : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pid: String?

    public var settings: [SaveTraceAppConfigRequest.Settings]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.settings != nil {
            var tmp : [Any] = []
            for k in self.settings! {
                tmp.append(k.toMap())
            }
            map["Settings"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("Settings") && dict["Settings"] != nil {
            var tmp : [SaveTraceAppConfigRequest.Settings] = []
            for v in dict["Settings"] as! [Any] {
                var model = SaveTraceAppConfigRequest.Settings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.settings = tmp
        }
    }
}

public class SaveTraceAppConfigResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveTraceAppConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveTraceAppConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveTraceAppConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchAlertContactRequest : Tea.TeaModel {
    public var contactIds: String?

    public var contactName: String?

    public var currentPage: String?

    public var email: String?

    public var pageSize: String?

    public var phone: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIds") && dict["ContactIds"] != nil {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("Email") && dict["Email"] != nil {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Phone") && dict["Phone"] != nil {
            self.phone = dict["Phone"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SearchAlertContactResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class Contacts : Tea.TeaModel {
            public var contactId: Int64?

            public var contactName: String?

            public var content: String?

            public var createTime: Int64?

            public var dingRobot: String?

            public var email: String?

            public var phone: String?

            public var resourceGroupId: String?

            public var systemNoc: Bool?

            public var updateTime: Int64?

            public var userId: String?

            public var webhook: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dingRobot != nil {
                    map["DingRobot"] = self.dingRobot!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.systemNoc != nil {
                    map["SystemNoc"] = self.systemNoc!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.webhook != nil {
                    map["Webhook"] = self.webhook!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                    self.contactId = dict["ContactId"] as! Int64
                }
                if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DingRobot") && dict["DingRobot"] != nil {
                    self.dingRobot = dict["DingRobot"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Phone") && dict["Phone"] != nil {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SystemNoc") && dict["SystemNoc"] != nil {
                    self.systemNoc = dict["SystemNoc"] as! Bool
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Webhook") && dict["Webhook"] != nil {
                    self.webhook = dict["Webhook"] as! String
                }
            }
        }
        public var contacts: [SearchAlertContactResponseBody.PageBean.Contacts]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contacts != nil {
                var tmp : [Any] = []
                for k in self.contacts! {
                    tmp.append(k.toMap())
                }
                map["Contacts"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Contacts") && dict["Contacts"] != nil {
                var tmp : [SearchAlertContactResponseBody.PageBean.Contacts] = []
                for v in dict["Contacts"] as! [Any] {
                    var model = SearchAlertContactResponseBody.PageBean.Contacts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contacts = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageBean: SearchAlertContactResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = SearchAlertContactResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchAlertContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchAlertContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchAlertContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchAlertContactGroupRequest : Tea.TeaModel {
    public var contactGroupIds: String?

    public var contactGroupName: String?

    public var contactId: Int64?

    public var contactName: String?

    public var isDetail: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupIds != nil {
            map["ContactGroupIds"] = self.contactGroupIds!
        }
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.isDetail != nil {
            map["IsDetail"] = self.isDetail!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupIds") && dict["ContactGroupIds"] != nil {
            self.contactGroupIds = dict["ContactGroupIds"] as! String
        }
        if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("IsDetail") && dict["IsDetail"] != nil {
            self.isDetail = dict["IsDetail"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SearchAlertContactGroupResponseBody : Tea.TeaModel {
    public class ContactGroups : Tea.TeaModel {
        public class Contacts : Tea.TeaModel {
            public var contactId: Int64?

            public var contactName: String?

            public var createTime: Int64?

            public var dingRobot: String?

            public var email: String?

            public var phone: String?

            public var systemNoc: Bool?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dingRobot != nil {
                    map["DingRobot"] = self.dingRobot!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.systemNoc != nil {
                    map["SystemNoc"] = self.systemNoc!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                    self.contactId = dict["ContactId"] as! Int64
                }
                if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DingRobot") && dict["DingRobot"] != nil {
                    self.dingRobot = dict["DingRobot"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Phone") && dict["Phone"] != nil {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("SystemNoc") && dict["SystemNoc"] != nil {
                    self.systemNoc = dict["SystemNoc"] as! Bool
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var contactGroupId: Int64?

        public var contactGroupName: String?

        public var contacts: [SearchAlertContactGroupResponseBody.ContactGroups.Contacts]?

        public var createTime: Int64?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactGroupId != nil {
                map["ContactGroupId"] = self.contactGroupId!
            }
            if self.contactGroupName != nil {
                map["ContactGroupName"] = self.contactGroupName!
            }
            if self.contacts != nil {
                var tmp : [Any] = []
                for k in self.contacts! {
                    tmp.append(k.toMap())
                }
                map["Contacts"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactGroupId") && dict["ContactGroupId"] != nil {
                self.contactGroupId = dict["ContactGroupId"] as! Int64
            }
            if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
                self.contactGroupName = dict["ContactGroupName"] as! String
            }
            if dict.keys.contains("Contacts") && dict["Contacts"] != nil {
                var tmp : [SearchAlertContactGroupResponseBody.ContactGroups.Contacts] = []
                for v in dict["Contacts"] as! [Any] {
                    var model = SearchAlertContactGroupResponseBody.ContactGroups.Contacts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contacts = tmp
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var contactGroups: [SearchAlertContactGroupResponseBody.ContactGroups]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroups != nil {
            var tmp : [Any] = []
            for k in self.contactGroups! {
                tmp.append(k.toMap())
            }
            map["ContactGroups"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroups") && dict["ContactGroups"] != nil {
            var tmp : [SearchAlertContactGroupResponseBody.ContactGroups] = []
            for v in dict["ContactGroups"] as! [Any] {
                var model = SearchAlertContactGroupResponseBody.ContactGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contactGroups = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchAlertContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchAlertContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchAlertContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchAlertHistoriesRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var alertType: Int32?

    public var currentPage: Int32?

    public var endTime: Int64?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("AlertType") && dict["AlertType"] != nil {
            self.alertType = dict["AlertType"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class SearchAlertHistoriesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlarmHistories : Tea.TeaModel {
            public var alarmContent: String?

            public var alarmResponseCode: Int32?

            public var alarmSources: String?

            public var alarmTime: Int64?

            public var alarmType: Int32?

            public var emails: String?

            public var id: Int64?

            public var phones: String?

            public var strategyId: String?

            public var target: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmContent != nil {
                    map["AlarmContent"] = self.alarmContent!
                }
                if self.alarmResponseCode != nil {
                    map["AlarmResponseCode"] = self.alarmResponseCode!
                }
                if self.alarmSources != nil {
                    map["AlarmSources"] = self.alarmSources!
                }
                if self.alarmTime != nil {
                    map["AlarmTime"] = self.alarmTime!
                }
                if self.alarmType != nil {
                    map["AlarmType"] = self.alarmType!
                }
                if self.emails != nil {
                    map["Emails"] = self.emails!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.phones != nil {
                    map["Phones"] = self.phones!
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.target != nil {
                    map["Target"] = self.target!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmContent") && dict["AlarmContent"] != nil {
                    self.alarmContent = dict["AlarmContent"] as! String
                }
                if dict.keys.contains("AlarmResponseCode") && dict["AlarmResponseCode"] != nil {
                    self.alarmResponseCode = dict["AlarmResponseCode"] as! Int32
                }
                if dict.keys.contains("AlarmSources") && dict["AlarmSources"] != nil {
                    self.alarmSources = dict["AlarmSources"] as! String
                }
                if dict.keys.contains("AlarmTime") && dict["AlarmTime"] != nil {
                    self.alarmTime = dict["AlarmTime"] as! Int64
                }
                if dict.keys.contains("AlarmType") && dict["AlarmType"] != nil {
                    self.alarmType = dict["AlarmType"] as! Int32
                }
                if dict.keys.contains("Emails") && dict["Emails"] != nil {
                    self.emails = dict["Emails"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Phones") && dict["Phones"] != nil {
                    self.phones = dict["Phones"] as! String
                }
                if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("Target") && dict["Target"] != nil {
                    self.target = dict["Target"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var alarmHistories: [SearchAlertHistoriesResponseBody.PageBean.AlarmHistories]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmHistories != nil {
                var tmp : [Any] = []
                for k in self.alarmHistories! {
                    tmp.append(k.toMap())
                }
                map["AlarmHistories"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmHistories") && dict["AlarmHistories"] != nil {
                var tmp : [SearchAlertHistoriesResponseBody.PageBean.AlarmHistories] = []
                for v in dict["AlarmHistories"] as! [Any] {
                    var model = SearchAlertHistoriesResponseBody.PageBean.AlarmHistories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alarmHistories = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageBean: SearchAlertHistoriesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = SearchAlertHistoriesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchAlertHistoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchAlertHistoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchAlertHistoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchAlertRulesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertRuleId: String?

    public var appType: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var pid: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var systemRegionId: String?

    public var tags: [SearchAlertRulesRequest.Tags]?

    public var title: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertRuleId != nil {
            map["AlertRuleId"] = self.alertRuleId!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.systemRegionId != nil {
            map["SystemRegionId"] = self.systemRegionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertRuleId") && dict["AlertRuleId"] != nil {
            self.alertRuleId = dict["AlertRuleId"] as! String
        }
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SystemRegionId") && dict["SystemRegionId"] != nil {
            self.systemRegionId = dict["SystemRegionId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [SearchAlertRulesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchAlertRulesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class SearchAlertRulesResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class AlertRules : Tea.TeaModel {
            public class AlarmContext : Tea.TeaModel {
                public var alarmContentSubTitle: String?

                public var alarmContentTemplate: String?

                public var content: String?

                public var subTitle: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alarmContentSubTitle != nil {
                        map["AlarmContentSubTitle"] = self.alarmContentSubTitle!
                    }
                    if self.alarmContentTemplate != nil {
                        map["AlarmContentTemplate"] = self.alarmContentTemplate!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.subTitle != nil {
                        map["SubTitle"] = self.subTitle!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlarmContentSubTitle") && dict["AlarmContentSubTitle"] != nil {
                        self.alarmContentSubTitle = dict["AlarmContentSubTitle"] as! String
                    }
                    if dict.keys.contains("AlarmContentTemplate") && dict["AlarmContentTemplate"] != nil {
                        self.alarmContentTemplate = dict["AlarmContentTemplate"] as! String
                    }
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("SubTitle") && dict["SubTitle"] != nil {
                        self.subTitle = dict["SubTitle"] as! String
                    }
                }
            }
            public class AlertRule : Tea.TeaModel {
                public class Rules : Tea.TeaModel {
                    public var aggregates: String?

                    public var alias: String?

                    public var measure: String?

                    public var NValue: Int32?

                    public var operator_: String?

                    public var value: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.aggregates != nil {
                            map["Aggregates"] = self.aggregates!
                        }
                        if self.alias != nil {
                            map["Alias"] = self.alias!
                        }
                        if self.measure != nil {
                            map["Measure"] = self.measure!
                        }
                        if self.NValue != nil {
                            map["NValue"] = self.NValue!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Aggregates") && dict["Aggregates"] != nil {
                            self.aggregates = dict["Aggregates"] as! String
                        }
                        if dict.keys.contains("Alias") && dict["Alias"] != nil {
                            self.alias = dict["Alias"] as! String
                        }
                        if dict.keys.contains("Measure") && dict["Measure"] != nil {
                            self.measure = dict["Measure"] as! String
                        }
                        if dict.keys.contains("NValue") && dict["NValue"] != nil {
                            self.NValue = dict["NValue"] as! Int32
                        }
                        if dict.keys.contains("Operator") && dict["Operator"] != nil {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! Double
                        }
                    }
                }
                public var operator_: String?

                public var rules: [SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule.Rules]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.rules != nil {
                        var tmp : [Any] = []
                        for k in self.rules! {
                            tmp.append(k.toMap())
                        }
                        map["Rules"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Operator") && dict["Operator"] != nil {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Rules") && dict["Rules"] != nil {
                        var tmp : [SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule.Rules] = []
                        for v in dict["Rules"] as! [Any] {
                            var model = SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule.Rules()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.rules = tmp
                    }
                }
            }
            public class MetricParam : Tea.TeaModel {
                public class Dimensions : Tea.TeaModel {
                    public var key: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var appGroupId: String?

                public var appId: String?

                public var dimensions: [SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam.Dimensions]?

                public var pid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appGroupId != nil {
                        map["AppGroupId"] = self.appGroupId!
                    }
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.dimensions != nil {
                        var tmp : [Any] = []
                        for k in self.dimensions! {
                            tmp.append(k.toMap())
                        }
                        map["Dimensions"] = tmp
                    }
                    if self.pid != nil {
                        map["Pid"] = self.pid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppGroupId") && dict["AppGroupId"] != nil {
                        self.appGroupId = dict["AppGroupId"] as! String
                    }
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("Dimensions") && dict["Dimensions"] != nil {
                        var tmp : [SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam.Dimensions] = []
                        for v in dict["Dimensions"] as! [Any] {
                            var model = SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam.Dimensions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dimensions = tmp
                    }
                    if dict.keys.contains("Pid") && dict["Pid"] != nil {
                        self.pid = dict["Pid"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Notice : Tea.TeaModel {
                public var endTime: Int64?

                public var noticeEndTime: Int64?

                public var noticeStartTime: Int64?

                public var startTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.noticeEndTime != nil {
                        map["NoticeEndTime"] = self.noticeEndTime!
                    }
                    if self.noticeStartTime != nil {
                        map["NoticeStartTime"] = self.noticeStartTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                        self.endTime = dict["EndTime"] as! Int64
                    }
                    if dict.keys.contains("NoticeEndTime") && dict["NoticeEndTime"] != nil {
                        self.noticeEndTime = dict["NoticeEndTime"] as! Int64
                    }
                    if dict.keys.contains("NoticeStartTime") && dict["NoticeStartTime"] != nil {
                        self.noticeStartTime = dict["NoticeStartTime"] as! Int64
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                }
            }
            public var alarmContext: SearchAlertRulesResponseBody.PageBean.AlertRules.AlarmContext?

            public var alertLevel: String?

            public var alertRule: SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule?

            public var alertTitle: String?

            public var alertType: Int32?

            public var alertVersion: Int32?

            public var alertWays: [String]?

            public var config: String?

            public var contactGroupIdList: String?

            public var contactGroupIds: String?

            public var createTime: Int64?

            public var hostByAlertManager: Bool?

            public var id: Int64?

            public var metricParam: SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam?

            public var notice: SearchAlertRulesResponseBody.PageBean.AlertRules.Notice?

            public var regionId: String?

            public var resourceGroupId: String?

            public var status: String?

            public var taskId: Int64?

            public var taskStatus: String?

            public var title: String?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.alarmContext?.validate()
                try self.alertRule?.validate()
                try self.metricParam?.validate()
                try self.notice?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmContext != nil {
                    map["AlarmContext"] = self.alarmContext?.toMap()
                }
                if self.alertLevel != nil {
                    map["AlertLevel"] = self.alertLevel!
                }
                if self.alertRule != nil {
                    map["AlertRule"] = self.alertRule?.toMap()
                }
                if self.alertTitle != nil {
                    map["AlertTitle"] = self.alertTitle!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.alertVersion != nil {
                    map["AlertVersion"] = self.alertVersion!
                }
                if self.alertWays != nil {
                    map["AlertWays"] = self.alertWays!
                }
                if self.config != nil {
                    map["Config"] = self.config!
                }
                if self.contactGroupIdList != nil {
                    map["ContactGroupIdList"] = self.contactGroupIdList!
                }
                if self.contactGroupIds != nil {
                    map["ContactGroupIds"] = self.contactGroupIds!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.hostByAlertManager != nil {
                    map["HostByAlertManager"] = self.hostByAlertManager!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.metricParam != nil {
                    map["MetricParam"] = self.metricParam?.toMap()
                }
                if self.notice != nil {
                    map["Notice"] = self.notice?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmContext") && dict["AlarmContext"] != nil {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules.AlarmContext()
                    model.fromMap(dict["AlarmContext"] as! [String: Any])
                    self.alarmContext = model
                }
                if dict.keys.contains("AlertLevel") && dict["AlertLevel"] != nil {
                    self.alertLevel = dict["AlertLevel"] as! String
                }
                if dict.keys.contains("AlertRule") && dict["AlertRule"] != nil {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules.AlertRule()
                    model.fromMap(dict["AlertRule"] as! [String: Any])
                    self.alertRule = model
                }
                if dict.keys.contains("AlertTitle") && dict["AlertTitle"] != nil {
                    self.alertTitle = dict["AlertTitle"] as! String
                }
                if dict.keys.contains("AlertType") && dict["AlertType"] != nil {
                    self.alertType = dict["AlertType"] as! Int32
                }
                if dict.keys.contains("AlertVersion") && dict["AlertVersion"] != nil {
                    self.alertVersion = dict["AlertVersion"] as! Int32
                }
                if dict.keys.contains("AlertWays") && dict["AlertWays"] != nil {
                    self.alertWays = dict["AlertWays"] as! [String]
                }
                if dict.keys.contains("Config") && dict["Config"] != nil {
                    self.config = dict["Config"] as! String
                }
                if dict.keys.contains("ContactGroupIdList") && dict["ContactGroupIdList"] != nil {
                    self.contactGroupIdList = dict["ContactGroupIdList"] as! String
                }
                if dict.keys.contains("ContactGroupIds") && dict["ContactGroupIds"] != nil {
                    self.contactGroupIds = dict["ContactGroupIds"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("HostByAlertManager") && dict["HostByAlertManager"] != nil {
                    self.hostByAlertManager = dict["HostByAlertManager"] as! Bool
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MetricParam") && dict["MetricParam"] != nil {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules.MetricParam()
                    model.fromMap(dict["MetricParam"] as! [String: Any])
                    self.metricParam = model
                }
                if dict.keys.contains("Notice") && dict["Notice"] != nil {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules.Notice()
                    model.fromMap(dict["Notice"] as! [String: Any])
                    self.notice = model
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! Int64
                }
                if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                    self.taskStatus = dict["TaskStatus"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var alertRules: [SearchAlertRulesResponseBody.PageBean.AlertRules]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertRules != nil {
                var tmp : [Any] = []
                for k in self.alertRules! {
                    tmp.append(k.toMap())
                }
                map["AlertRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertRules") && dict["AlertRules"] != nil {
                var tmp : [SearchAlertRulesResponseBody.PageBean.AlertRules] = []
                for v in dict["AlertRules"] as! [Any] {
                    var model = SearchAlertRulesResponseBody.PageBean.AlertRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertRules = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageBean: SearchAlertRulesResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = SearchAlertRulesResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEventsRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var alertType: Int32?

    public var appType: String?

    public var currentPage: Int32?

    public var endTime: Int64?

    public var isTrigger: Int32?

    public var pageSize: Int32?

    public var pid: String?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.alertType != nil {
            map["AlertType"] = self.alertType!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.isTrigger != nil {
            map["IsTrigger"] = self.isTrigger!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("AlertType") && dict["AlertType"] != nil {
            self.alertType = dict["AlertType"] as! Int32
        }
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("IsTrigger") && dict["IsTrigger"] != nil {
            self.isTrigger = dict["IsTrigger"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class SearchEventsResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class Event : Tea.TeaModel {
            public var alertId: Int64?

            public var alertName: String?

            public var alertRule: String?

            public var alertType: Int32?

            public var eventLevel: String?

            public var eventTime: Int64?

            public var id: Int64?

            public var links: [String]?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertId != nil {
                    map["AlertId"] = self.alertId!
                }
                if self.alertName != nil {
                    map["AlertName"] = self.alertName!
                }
                if self.alertRule != nil {
                    map["AlertRule"] = self.alertRule!
                }
                if self.alertType != nil {
                    map["AlertType"] = self.alertType!
                }
                if self.eventLevel != nil {
                    map["EventLevel"] = self.eventLevel!
                }
                if self.eventTime != nil {
                    map["EventTime"] = self.eventTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.links != nil {
                    map["Links"] = self.links!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
                    self.alertId = dict["AlertId"] as! Int64
                }
                if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                    self.alertName = dict["AlertName"] as! String
                }
                if dict.keys.contains("AlertRule") && dict["AlertRule"] != nil {
                    self.alertRule = dict["AlertRule"] as! String
                }
                if dict.keys.contains("AlertType") && dict["AlertType"] != nil {
                    self.alertType = dict["AlertType"] as! Int32
                }
                if dict.keys.contains("EventLevel") && dict["EventLevel"] != nil {
                    self.eventLevel = dict["EventLevel"] as! String
                }
                if dict.keys.contains("EventTime") && dict["EventTime"] != nil {
                    self.eventTime = dict["EventTime"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Links") && dict["Links"] != nil {
                    self.links = dict["Links"] as! [String]
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var event: [SearchEventsResponseBody.PageBean.Event]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.event != nil {
                var tmp : [Any] = []
                for k in self.event! {
                    tmp.append(k.toMap())
                }
                map["Event"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Event") && dict["Event"] != nil {
                var tmp : [SearchEventsResponseBody.PageBean.Event] = []
                for v in dict["Event"] as! [Any] {
                    var model = SearchEventsResponseBody.PageBean.Event()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.event = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var isTrigger: Int32?

    public var pageBean: SearchEventsResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isTrigger != nil {
            map["IsTrigger"] = self.isTrigger!
        }
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsTrigger") && dict["IsTrigger"] != nil {
            self.isTrigger = dict["IsTrigger"] as! Int32
        }
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = SearchEventsResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchRetcodeAppByPageRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var retcodeAppId: String?

    public var retcodeAppName: String?

    public var tags: [SearchRetcodeAppByPageRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.retcodeAppId != nil {
            map["RetcodeAppId"] = self.retcodeAppId!
        }
        if self.retcodeAppName != nil {
            map["RetcodeAppName"] = self.retcodeAppName!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RetcodeAppId") && dict["RetcodeAppId"] != nil {
            self.retcodeAppId = dict["RetcodeAppId"] as! String
        }
        if dict.keys.contains("RetcodeAppName") && dict["RetcodeAppName"] != nil {
            self.retcodeAppName = dict["RetcodeAppName"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [SearchRetcodeAppByPageRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchRetcodeAppByPageRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class SearchRetcodeAppByPageResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class RetcodeApps : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var appId: Int64?

            public var appName: String?

            public var createTime: Int64?

            public var nickName: String?

            public var pid: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var retcodeAppType: String?

            public var tags: [SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps.Tags]?

            public var type: String?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.retcodeAppType != nil {
                    map["RetcodeAppType"] = self.retcodeAppType!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("NickName") && dict["NickName"] != nil {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("Pid") && dict["Pid"] != nil {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RetcodeAppType") && dict["RetcodeAppType"] != nil {
                    self.retcodeAppType = dict["RetcodeAppType"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var tmp : [SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var retcodeApps: [SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.retcodeApps != nil {
                var tmp : [Any] = []
                for k in self.retcodeApps! {
                    tmp.append(k.toMap())
                }
                map["RetcodeApps"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("RetcodeApps") && dict["RetcodeApps"] != nil {
                var tmp : [SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps] = []
                for v in dict["RetcodeApps"] as! [Any] {
                    var model = SearchRetcodeAppByPageResponseBody.PageBean.RetcodeApps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.retcodeApps = tmp
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageBean: SearchRetcodeAppByPageResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = SearchRetcodeAppByPageResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchRetcodeAppByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchRetcodeAppByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchRetcodeAppByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTraceAppByNameRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var tags: [SearchTraceAppByNameRequest.Tags]?

    public var traceAppName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.traceAppName != nil {
            map["TraceAppName"] = self.traceAppName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [SearchTraceAppByNameRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchTraceAppByNameRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TraceAppName") && dict["TraceAppName"] != nil {
            self.traceAppName = dict["TraceAppName"] as! String
        }
    }
}

public class SearchTraceAppByNameResponseBody : Tea.TeaModel {
    public class TraceApps : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var appId: Int64?

        public var appName: String?

        public var createTime: Int64?

        public var labels: [String]?

        public var pid: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var show: Bool?

        public var tags: [SearchTraceAppByNameResponseBody.TraceApps.Tags]?

        public var type: String?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.labels != nil {
                map["Labels"] = self.labels!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.show != nil {
                map["Show"] = self.show!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! Int64
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                self.labels = dict["Labels"] as! [String]
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Show") && dict["Show"] != nil {
                self.show = dict["Show"] as! Bool
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [SearchTraceAppByNameResponseBody.TraceApps.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = SearchTraceAppByNameResponseBody.TraceApps.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var requestId: String?

    public var traceApps: [SearchTraceAppByNameResponseBody.TraceApps]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceApps != nil {
            var tmp : [Any] = []
            for k in self.traceApps! {
                tmp.append(k.toMap())
            }
            map["TraceApps"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TraceApps") && dict["TraceApps"] != nil {
            var tmp : [SearchTraceAppByNameResponseBody.TraceApps] = []
            for v in dict["TraceApps"] as! [Any] {
                var model = SearchTraceAppByNameResponseBody.TraceApps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traceApps = tmp
        }
    }
}

public class SearchTraceAppByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTraceAppByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchTraceAppByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTraceAppByPageRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [SearchTraceAppByPageRequest.Tags]?

    public var traceAppName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.traceAppName != nil {
            map["TraceAppName"] = self.traceAppName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [SearchTraceAppByPageRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchTraceAppByPageRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TraceAppName") && dict["TraceAppName"] != nil {
            self.traceAppName = dict["TraceAppName"] as! String
        }
    }
}

public class SearchTraceAppByPageResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class TraceApps : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var appId: Int64?

            public var appName: String?

            public var createTime: Int64?

            public var labels: [String]?

            public var pid: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var show: Bool?

            public var tags: [SearchTraceAppByPageResponseBody.PageBean.TraceApps.Tags]?

            public var type: String?

            public var updateTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.show != nil {
                    map["Show"] = self.show!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Labels") && dict["Labels"] != nil {
                    self.labels = dict["Labels"] as! [String]
                }
                if dict.keys.contains("Pid") && dict["Pid"] != nil {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Show") && dict["Show"] != nil {
                    self.show = dict["Show"] as! Bool
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var tmp : [SearchTraceAppByPageResponseBody.PageBean.TraceApps.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = SearchTraceAppByPageResponseBody.PageBean.TraceApps.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public var traceApps: [SearchTraceAppByPageResponseBody.PageBean.TraceApps]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.traceApps != nil {
                var tmp : [Any] = []
                for k in self.traceApps! {
                    tmp.append(k.toMap())
                }
                map["TraceApps"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TraceApps") && dict["TraceApps"] != nil {
                var tmp : [SearchTraceAppByPageResponseBody.PageBean.TraceApps] = []
                for v in dict["TraceApps"] as! [Any] {
                    var model = SearchTraceAppByPageResponseBody.PageBean.TraceApps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.traceApps = tmp
            }
        }
    }
    public var pageBean: SearchTraceAppByPageResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = SearchTraceAppByPageResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchTraceAppByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTraceAppByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchTraceAppByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTracesRequest : Tea.TeaModel {
    public class ExclusionFilters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var exclusionFilters: [SearchTracesRequest.ExclusionFilters]?

    public var minDuration: Int64?

    public var operationName: String?

    public var pid: String?

    public var regionId: String?

    public var reverse: Bool?

    public var serviceIp: String?

    public var serviceName: String?

    public var startTime: Int64?

    public var tag: [SearchTracesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.exclusionFilters != nil {
            var tmp : [Any] = []
            for k in self.exclusionFilters! {
                tmp.append(k.toMap())
            }
            map["ExclusionFilters"] = tmp
        }
        if self.minDuration != nil {
            map["MinDuration"] = self.minDuration!
        }
        if self.operationName != nil {
            map["OperationName"] = self.operationName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.serviceIp != nil {
            map["ServiceIp"] = self.serviceIp!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExclusionFilters") && dict["ExclusionFilters"] != nil {
            var tmp : [SearchTracesRequest.ExclusionFilters] = []
            for v in dict["ExclusionFilters"] as! [Any] {
                var model = SearchTracesRequest.ExclusionFilters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.exclusionFilters = tmp
        }
        if dict.keys.contains("MinDuration") && dict["MinDuration"] != nil {
            self.minDuration = dict["MinDuration"] as! Int64
        }
        if dict.keys.contains("OperationName") && dict["OperationName"] != nil {
            self.operationName = dict["OperationName"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reverse") && dict["Reverse"] != nil {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("ServiceIp") && dict["ServiceIp"] != nil {
            self.serviceIp = dict["ServiceIp"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [SearchTracesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = SearchTracesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class SearchTracesResponseBody : Tea.TeaModel {
    public class TraceInfos : Tea.TeaModel {
        public var duration: Int64?

        public var operationName: String?

        public var serviceIp: String?

        public var serviceName: String?

        public var timestamp: Int64?

        public var traceID: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.operationName != nil {
                map["OperationName"] = self.operationName!
            }
            if self.serviceIp != nil {
                map["ServiceIp"] = self.serviceIp!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.traceID != nil {
                map["TraceID"] = self.traceID!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("OperationName") && dict["OperationName"] != nil {
                self.operationName = dict["OperationName"] as! String
            }
            if dict.keys.contains("ServiceIp") && dict["ServiceIp"] != nil {
                self.serviceIp = dict["ServiceIp"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TraceID") && dict["TraceID"] != nil {
                self.traceID = dict["TraceID"] as! String
            }
        }
    }
    public var requestId: String?

    public var traceInfos: [SearchTracesResponseBody.TraceInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceInfos != nil {
            var tmp : [Any] = []
            for k in self.traceInfos! {
                tmp.append(k.toMap())
            }
            map["TraceInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TraceInfos") && dict["TraceInfos"] != nil {
            var tmp : [SearchTracesResponseBody.TraceInfos] = []
            for v in dict["TraceInfos"] as! [Any] {
                var model = SearchTracesResponseBody.TraceInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traceInfos = tmp
        }
    }
}

public class SearchTracesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTracesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchTracesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTracesByPageRequest : Tea.TeaModel {
    public class ExclusionFilters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var exclusionFilters: [SearchTracesByPageRequest.ExclusionFilters]?

    public var isError: Bool?

    public var minDuration: Int64?

    public var operationName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pid: String?

    public var regionId: String?

    public var reverse: Bool?

    public var serviceIp: String?

    public var serviceName: String?

    public var startTime: Int64?

    public var tags: [SearchTracesByPageRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.exclusionFilters != nil {
            var tmp : [Any] = []
            for k in self.exclusionFilters! {
                tmp.append(k.toMap())
            }
            map["ExclusionFilters"] = tmp
        }
        if self.isError != nil {
            map["IsError"] = self.isError!
        }
        if self.minDuration != nil {
            map["MinDuration"] = self.minDuration!
        }
        if self.operationName != nil {
            map["OperationName"] = self.operationName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.serviceIp != nil {
            map["ServiceIp"] = self.serviceIp!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ExclusionFilters") && dict["ExclusionFilters"] != nil {
            var tmp : [SearchTracesByPageRequest.ExclusionFilters] = []
            for v in dict["ExclusionFilters"] as! [Any] {
                var model = SearchTracesByPageRequest.ExclusionFilters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.exclusionFilters = tmp
        }
        if dict.keys.contains("IsError") && dict["IsError"] != nil {
            self.isError = dict["IsError"] as! Bool
        }
        if dict.keys.contains("MinDuration") && dict["MinDuration"] != nil {
            self.minDuration = dict["MinDuration"] as! Int64
        }
        if dict.keys.contains("OperationName") && dict["OperationName"] != nil {
            self.operationName = dict["OperationName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reverse") && dict["Reverse"] != nil {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("ServiceIp") && dict["ServiceIp"] != nil {
            self.serviceIp = dict["ServiceIp"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [SearchTracesByPageRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = SearchTracesByPageRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class SearchTracesByPageResponseBody : Tea.TeaModel {
    public class PageBean : Tea.TeaModel {
        public class TraceInfos : Tea.TeaModel {
            public var duration: Int64?

            public var operationName: String?

            public var serviceIp: String?

            public var serviceName: String?

            public var timestamp: Int64?

            public var traceID: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.operationName != nil {
                    map["OperationName"] = self.operationName!
                }
                if self.serviceIp != nil {
                    map["ServiceIp"] = self.serviceIp!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.traceID != nil {
                    map["TraceID"] = self.traceID!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("OperationName") && dict["OperationName"] != nil {
                    self.operationName = dict["OperationName"] as! String
                }
                if dict.keys.contains("ServiceIp") && dict["ServiceIp"] != nil {
                    self.serviceIp = dict["ServiceIp"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("TraceID") && dict["TraceID"] != nil {
                    self.traceID = dict["TraceID"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var total: Int32?

        public var traceInfos: [SearchTracesByPageResponseBody.PageBean.TraceInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            if self.traceInfos != nil {
                var tmp : [Any] = []
                for k in self.traceInfos! {
                    tmp.append(k.toMap())
                }
                map["TraceInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
            if dict.keys.contains("TraceInfos") && dict["TraceInfos"] != nil {
                var tmp : [SearchTracesByPageResponseBody.PageBean.TraceInfos] = []
                for v in dict["TraceInfos"] as! [Any] {
                    var model = SearchTracesByPageResponseBody.PageBean.TraceInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.traceInfos = tmp
            }
        }
    }
    public var pageBean: SearchTracesByPageResponseBody.PageBean?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageBean?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageBean != nil {
            map["PageBean"] = self.pageBean?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageBean") && dict["PageBean"] != nil {
            var model = SearchTracesByPageResponseBody.PageBean()
            model.fromMap(dict["PageBean"] as! [String: Any])
            self.pageBean = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchTracesByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTracesByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchTracesByPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendTTSVerifyLinkRequest : Tea.TeaModel {
    public var contactId: Int64?

    public var phone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("Phone") && dict["Phone"] != nil {
            self.phone = dict["Phone"] as! String
        }
    }
}

public class SendTTSVerifyLinkResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendTTSVerifyLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendTTSVerifyLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SendTTSVerifyLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetRetcodeShareStatusRequest : Tea.TeaModel {
    public var appName: String?

    public var pid: String?

    public var status: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Bool
        }
    }
}

public class SetRetcodeShareStatusResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetRetcodeShareStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetRetcodeShareStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetRetcodeShareStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartAlertRequest : Tea.TeaModel {
    public var alertId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class StartAlertResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartTimingSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIds = dict["TaskIds"] as! [String]
        }
    }
}

public class StartTimingSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIdsShrink != nil {
            map["TaskIds"] = self.taskIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIdsShrink = dict["TaskIds"] as! String
        }
    }
}

public class StartTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopAlertRequest : Tea.TeaModel {
    public var alertId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class StopAlertResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopTimingSyntheticTaskRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIds = dict["TaskIds"] as! [String]
        }
    }
}

public class StopTimingSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var regionId: String?

    public var taskIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskIdsShrink != nil {
            map["TaskIds"] = self.taskIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIdsShrink = dict["TaskIds"] as! String
        }
    }
}

public class StopTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchSyntheticTaskStatusRequest : Tea.TeaModel {
    public var switchStatus: Int64?

    public var taskIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.switchStatus != nil {
            map["SwitchStatus"] = self.switchStatus!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SwitchStatus") && dict["SwitchStatus"] != nil {
            self.switchStatus = dict["SwitchStatus"] as! Int64
        }
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIds = dict["TaskIds"] as! [Int64]
        }
    }
}

public class SwitchSyntheticTaskStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! String
        }
    }
}

public class SwitchSyntheticTaskStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchSyntheticTaskStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SwitchSyntheticTaskStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncRecordingRulesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var targetClusters: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.targetClusters != nil {
            map["TargetClusters"] = self.targetClusters!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TargetClusters") && dict["TargetClusters"] != nil {
            self.targetClusters = dict["TargetClusters"] as! String
        }
    }
}

public class SyncRecordingRulesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SyncRecordingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncRecordingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SyncRecordingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallManagedPrometheusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class UninstallManagedPrometheusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UninstallManagedPrometheusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallManagedPrometheusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UninstallManagedPrometheusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallPromClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UninstallPromClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UninstallPromClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallPromClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UninstallPromClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var all: Bool?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public var tags: [UntagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") && dict["All"] != nil {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
            self.tagKey = dict["TagKey"] as! [String]
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [UntagResourcesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = UntagResourcesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAlertContactRequest : Tea.TeaModel {
    public var contactId: Int64?

    public var contactName: String?

    public var dingRobotWebhookUrl: String?

    public var email: String?

    public var phoneNum: String?

    public var regionId: String?

    public var systemNoc: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.dingRobotWebhookUrl != nil {
            map["DingRobotWebhookUrl"] = self.dingRobotWebhookUrl!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.phoneNum != nil {
            map["PhoneNum"] = self.phoneNum!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.systemNoc != nil {
            map["SystemNoc"] = self.systemNoc!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("DingRobotWebhookUrl") && dict["DingRobotWebhookUrl"] != nil {
            self.dingRobotWebhookUrl = dict["DingRobotWebhookUrl"] as! String
        }
        if dict.keys.contains("Email") && dict["Email"] != nil {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("PhoneNum") && dict["PhoneNum"] != nil {
            self.phoneNum = dict["PhoneNum"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SystemNoc") && dict["SystemNoc"] != nil {
            self.systemNoc = dict["SystemNoc"] as! Bool
        }
    }
}

public class UpdateAlertContactResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAlertContactResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAlertContactResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAlertContactResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAlertContactGroupRequest : Tea.TeaModel {
    public var contactGroupId: Int64?

    public var contactGroupName: String?

    public var contactIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactGroupId != nil {
            map["ContactGroupId"] = self.contactGroupId!
        }
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactGroupId") && dict["ContactGroupId"] != nil {
            self.contactGroupId = dict["ContactGroupId"] as! Int64
        }
        if dict.keys.contains("ContactGroupName") && dict["ContactGroupName"] != nil {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactIds") && dict["ContactIds"] != nil {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateAlertContactGroupResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAlertContactGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAlertContactGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAlertContactGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAlertRuleRequest : Tea.TeaModel {
    public var alertId: Int64?

    public var contactGroupIds: String?

    public var isAutoStart: Bool?

    public var regionId: String?

    public var templageAlertConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.contactGroupIds != nil {
            map["ContactGroupIds"] = self.contactGroupIds!
        }
        if self.isAutoStart != nil {
            map["IsAutoStart"] = self.isAutoStart!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templageAlertConfig != nil {
            map["TemplageAlertConfig"] = self.templageAlertConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("ContactGroupIds") && dict["ContactGroupIds"] != nil {
            self.contactGroupIds = dict["ContactGroupIds"] as! String
        }
        if dict.keys.contains("IsAutoStart") && dict["IsAutoStart"] != nil {
            self.isAutoStart = dict["IsAutoStart"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TemplageAlertConfig") && dict["TemplageAlertConfig"] != nil {
            self.templageAlertConfig = dict["TemplageAlertConfig"] as! String
        }
    }
}

public class UpdateAlertRuleResponseBody : Tea.TeaModel {
    public var alertId: Int64?

    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDispatchRuleRequest : Tea.TeaModel {
    public var dispatchRule: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dispatchRule != nil {
            map["DispatchRule"] = self.dispatchRule!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DispatchRule") && dict["DispatchRule"] != nil {
            self.dispatchRule = dict["DispatchRule"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateDispatchRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDispatchRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDispatchRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateDispatchRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEnvCustomJobRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var customJobName: String?

    public var environmentId: String?

    public var regionId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.customJobName != nil {
            map["CustomJobName"] = self.customJobName!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("CustomJobName") && dict["CustomJobName"] != nil {
            self.customJobName = dict["CustomJobName"] as! String
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateEnvCustomJobResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEnvCustomJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEnvCustomJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEnvCustomJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEnvPodMonitorRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var namespace: String?

    public var podMonitorName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.podMonitorName != nil {
            map["PodMonitorName"] = self.podMonitorName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PodMonitorName") && dict["PodMonitorName"] != nil {
            self.podMonitorName = dict["PodMonitorName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateEnvPodMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var matchedMsg: String?

        public var matchedTargetCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchedMsg != nil {
                map["MatchedMsg"] = self.matchedMsg!
            }
            if self.matchedTargetCount != nil {
                map["MatchedTargetCount"] = self.matchedTargetCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchedMsg") && dict["MatchedMsg"] != nil {
                self.matchedMsg = dict["MatchedMsg"] as! String
            }
            if dict.keys.contains("MatchedTargetCount") && dict["MatchedTargetCount"] != nil {
                self.matchedTargetCount = dict["MatchedTargetCount"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: UpdateEnvPodMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateEnvPodMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEnvPodMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEnvPodMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEnvPodMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEnvServiceMonitorRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var configYaml: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var namespace: String?

    public var regionId: String?

    public var serviceMonitorName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serviceMonitorName != nil {
            map["ServiceMonitorName"] = self.serviceMonitorName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ServiceMonitorName") && dict["ServiceMonitorName"] != nil {
            self.serviceMonitorName = dict["ServiceMonitorName"] as! String
        }
    }
}

public class UpdateEnvServiceMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var matchedMsg: String?

        public var matchedTargetCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchedMsg != nil {
                map["MatchedMsg"] = self.matchedMsg!
            }
            if self.matchedTargetCount != nil {
                map["MatchedTargetCount"] = self.matchedTargetCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchedMsg") && dict["MatchedMsg"] != nil {
                self.matchedMsg = dict["MatchedMsg"] as! String
            }
            if dict.keys.contains("MatchedTargetCount") && dict["MatchedTargetCount"] != nil {
                self.matchedTargetCount = dict["MatchedTargetCount"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: UpdateEnvServiceMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateEnvServiceMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEnvServiceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEnvServiceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEnvServiceMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEnvironmentRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var environmentId: String?

    public var environmentName: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.environmentName != nil {
            map["EnvironmentName"] = self.environmentName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("EnvironmentName") && dict["EnvironmentName"] != nil {
            self.environmentName = dict["EnvironmentName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateEnvironmentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEnvironmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEnvironmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEnvironmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIntegrationRequest : Tea.TeaModel {
    public var autoRecover: Bool?

    public var description_: String?

    public var duplicateKey: String?

    public var extendedFieldRedefineRules: String?

    public var fieldRedefineRules: String?

    public var initiativeRecoverField: String?

    public var initiativeRecoverValue: String?

    public var integrationId: Int64?

    public var integrationName: String?

    public var integrationProductType: String?

    public var liveness: String?

    public var recoverTime: Int64?

    public var stat: String?

    public var state: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRecover != nil {
            map["AutoRecover"] = self.autoRecover!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duplicateKey != nil {
            map["DuplicateKey"] = self.duplicateKey!
        }
        if self.extendedFieldRedefineRules != nil {
            map["ExtendedFieldRedefineRules"] = self.extendedFieldRedefineRules!
        }
        if self.fieldRedefineRules != nil {
            map["FieldRedefineRules"] = self.fieldRedefineRules!
        }
        if self.initiativeRecoverField != nil {
            map["InitiativeRecoverField"] = self.initiativeRecoverField!
        }
        if self.initiativeRecoverValue != nil {
            map["InitiativeRecoverValue"] = self.initiativeRecoverValue!
        }
        if self.integrationId != nil {
            map["IntegrationId"] = self.integrationId!
        }
        if self.integrationName != nil {
            map["IntegrationName"] = self.integrationName!
        }
        if self.integrationProductType != nil {
            map["IntegrationProductType"] = self.integrationProductType!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.recoverTime != nil {
            map["RecoverTime"] = self.recoverTime!
        }
        if self.stat != nil {
            map["Stat"] = self.stat!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRecover") && dict["AutoRecover"] != nil {
            self.autoRecover = dict["AutoRecover"] as! Bool
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DuplicateKey") && dict["DuplicateKey"] != nil {
            self.duplicateKey = dict["DuplicateKey"] as! String
        }
        if dict.keys.contains("ExtendedFieldRedefineRules") && dict["ExtendedFieldRedefineRules"] != nil {
            self.extendedFieldRedefineRules = dict["ExtendedFieldRedefineRules"] as! String
        }
        if dict.keys.contains("FieldRedefineRules") && dict["FieldRedefineRules"] != nil {
            self.fieldRedefineRules = dict["FieldRedefineRules"] as! String
        }
        if dict.keys.contains("InitiativeRecoverField") && dict["InitiativeRecoverField"] != nil {
            self.initiativeRecoverField = dict["InitiativeRecoverField"] as! String
        }
        if dict.keys.contains("InitiativeRecoverValue") && dict["InitiativeRecoverValue"] != nil {
            self.initiativeRecoverValue = dict["InitiativeRecoverValue"] as! String
        }
        if dict.keys.contains("IntegrationId") && dict["IntegrationId"] != nil {
            self.integrationId = dict["IntegrationId"] as! Int64
        }
        if dict.keys.contains("IntegrationName") && dict["IntegrationName"] != nil {
            self.integrationName = dict["IntegrationName"] as! String
        }
        if dict.keys.contains("IntegrationProductType") && dict["IntegrationProductType"] != nil {
            self.integrationProductType = dict["IntegrationProductType"] as! String
        }
        if dict.keys.contains("Liveness") && dict["Liveness"] != nil {
            self.liveness = dict["Liveness"] as! String
        }
        if dict.keys.contains("RecoverTime") && dict["RecoverTime"] != nil {
            self.recoverTime = dict["RecoverTime"] as! Int64
        }
        if dict.keys.contains("Stat") && dict["Stat"] != nil {
            self.stat = dict["Stat"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! Bool
        }
    }
}

public class UpdateIntegrationResponseBody : Tea.TeaModel {
    public class Integration : Tea.TeaModel {
        public var apiEndpoint: String?

        public var autoRecover: Bool?

        public var description_: String?

        public var duplicateKey: String?

        public var extendedFieldRedefineRules: [[String: Any]]?

        public var fieldRedefineRules: [[String: Any]]?

        public var initiativeRecoverField: String?

        public var initiativeRecoverValue: String?

        public var integrationId: Int64?

        public var integrationName: String?

        public var integrationProductType: String?

        public var liveness: String?

        public var recoverTime: Int64?

        public var shortToken: String?

        public var stat: [Int64]?

        public var state: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiEndpoint != nil {
                map["ApiEndpoint"] = self.apiEndpoint!
            }
            if self.autoRecover != nil {
                map["AutoRecover"] = self.autoRecover!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duplicateKey != nil {
                map["DuplicateKey"] = self.duplicateKey!
            }
            if self.extendedFieldRedefineRules != nil {
                map["ExtendedFieldRedefineRules"] = self.extendedFieldRedefineRules!
            }
            if self.fieldRedefineRules != nil {
                map["FieldRedefineRules"] = self.fieldRedefineRules!
            }
            if self.initiativeRecoverField != nil {
                map["InitiativeRecoverField"] = self.initiativeRecoverField!
            }
            if self.initiativeRecoverValue != nil {
                map["InitiativeRecoverValue"] = self.initiativeRecoverValue!
            }
            if self.integrationId != nil {
                map["IntegrationId"] = self.integrationId!
            }
            if self.integrationName != nil {
                map["IntegrationName"] = self.integrationName!
            }
            if self.integrationProductType != nil {
                map["IntegrationProductType"] = self.integrationProductType!
            }
            if self.liveness != nil {
                map["Liveness"] = self.liveness!
            }
            if self.recoverTime != nil {
                map["RecoverTime"] = self.recoverTime!
            }
            if self.shortToken != nil {
                map["ShortToken"] = self.shortToken!
            }
            if self.stat != nil {
                map["Stat"] = self.stat!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiEndpoint") && dict["ApiEndpoint"] != nil {
                self.apiEndpoint = dict["ApiEndpoint"] as! String
            }
            if dict.keys.contains("AutoRecover") && dict["AutoRecover"] != nil {
                self.autoRecover = dict["AutoRecover"] as! Bool
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DuplicateKey") && dict["DuplicateKey"] != nil {
                self.duplicateKey = dict["DuplicateKey"] as! String
            }
            if dict.keys.contains("ExtendedFieldRedefineRules") && dict["ExtendedFieldRedefineRules"] != nil {
                self.extendedFieldRedefineRules = dict["ExtendedFieldRedefineRules"] as! [[String: Any]]
            }
            if dict.keys.contains("FieldRedefineRules") && dict["FieldRedefineRules"] != nil {
                self.fieldRedefineRules = dict["FieldRedefineRules"] as! [[String: Any]]
            }
            if dict.keys.contains("InitiativeRecoverField") && dict["InitiativeRecoverField"] != nil {
                self.initiativeRecoverField = dict["InitiativeRecoverField"] as! String
            }
            if dict.keys.contains("InitiativeRecoverValue") && dict["InitiativeRecoverValue"] != nil {
                self.initiativeRecoverValue = dict["InitiativeRecoverValue"] as! String
            }
            if dict.keys.contains("IntegrationId") && dict["IntegrationId"] != nil {
                self.integrationId = dict["IntegrationId"] as! Int64
            }
            if dict.keys.contains("IntegrationName") && dict["IntegrationName"] != nil {
                self.integrationName = dict["IntegrationName"] as! String
            }
            if dict.keys.contains("IntegrationProductType") && dict["IntegrationProductType"] != nil {
                self.integrationProductType = dict["IntegrationProductType"] as! String
            }
            if dict.keys.contains("Liveness") && dict["Liveness"] != nil {
                self.liveness = dict["Liveness"] as! String
            }
            if dict.keys.contains("RecoverTime") && dict["RecoverTime"] != nil {
                self.recoverTime = dict["RecoverTime"] as! Int64
            }
            if dict.keys.contains("ShortToken") && dict["ShortToken"] != nil {
                self.shortToken = dict["ShortToken"] as! String
            }
            if dict.keys.contains("Stat") && dict["Stat"] != nil {
                self.stat = dict["Stat"] as! [Int64]
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! Bool
            }
        }
    }
    public var integration: UpdateIntegrationResponseBody.Integration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.integration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.integration != nil {
            map["Integration"] = self.integration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Integration") && dict["Integration"] != nil {
            var model = UpdateIntegrationResponseBody.Integration()
            model.fromMap(dict["Integration"] as! [String: Any])
            self.integration = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusAlertRuleRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var alertId: Int64?

    public var alertName: String?

    public var annotations: String?

    public var clusterId: String?

    public var dispatchRuleId: Int64?

    public var duration: String?

    public var expression: String?

    public var labels: String?

    public var message: String?

    public var notifyType: String?

    public var regionId: String?

    public var tags: [UpdatePrometheusAlertRuleRequest.Tags]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertId != nil {
            map["AlertId"] = self.alertId!
        }
        if self.alertName != nil {
            map["AlertName"] = self.alertName!
        }
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dispatchRuleId != nil {
            map["DispatchRuleId"] = self.dispatchRuleId!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.expression != nil {
            map["Expression"] = self.expression!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
            self.alertId = dict["AlertId"] as! Int64
        }
        if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
            self.alertName = dict["AlertName"] as! String
        }
        if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DispatchRuleId") && dict["DispatchRuleId"] != nil {
            self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("Expression") && dict["Expression"] != nil {
            self.expression = dict["Expression"] as! String
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [UpdatePrometheusAlertRuleRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = UpdatePrometheusAlertRuleRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdatePrometheusAlertRuleResponseBody : Tea.TeaModel {
    public class PrometheusAlertRule : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var alertId: Int64?

        public var alertName: String?

        public var annotations: [UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations]?

        public var clusterId: String?

        public var dispatchRuleId: Int64?

        public var duration: String?

        public var expression: String?

        public var labels: [UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels]?

        public var message: String?

        public var notifyType: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["AlertId"] = self.alertId!
            }
            if self.alertName != nil {
                map["AlertName"] = self.alertName!
            }
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["Annotations"] = tmp
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.dispatchRuleId != nil {
                map["DispatchRuleId"] = self.dispatchRuleId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.expression != nil {
                map["Expression"] = self.expression!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertId") && dict["AlertId"] != nil {
                self.alertId = dict["AlertId"] as! Int64
            }
            if dict.keys.contains("AlertName") && dict["AlertName"] != nil {
                self.alertName = dict["AlertName"] as! String
            }
            if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                var tmp : [UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations] = []
                for v in dict["Annotations"] as! [Any] {
                    var model = UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("DispatchRuleId") && dict["DispatchRuleId"] != nil {
                self.dispatchRuleId = dict["DispatchRuleId"] as! Int64
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("Expression") && dict["Expression"] != nil {
                self.expression = dict["Expression"] as! String
            }
            if dict.keys.contains("Labels") && dict["Labels"] != nil {
                var tmp : [UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
                self.notifyType = dict["NotifyType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int64?

    public var message: String?

    public var prometheusAlertRule: UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prometheusAlertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.prometheusAlertRule != nil {
            map["PrometheusAlertRule"] = self.prometheusAlertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PrometheusAlertRule") && dict["PrometheusAlertRule"] != nil {
            var model = UpdatePrometheusAlertRuleResponseBody.PrometheusAlertRule()
            model.fromMap(dict["PrometheusAlertRule"] as! [String: Any])
            self.prometheusAlertRule = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePrometheusAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdatePrometheusAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusGlobalViewRequest : Tea.TeaModel {
    public var allSubClustersSuccess: Bool?

    public var clusterId: String?

    public var groupName: String?

    public var mostRegionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subClustersJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allSubClustersSuccess != nil {
            map["AllSubClustersSuccess"] = self.allSubClustersSuccess!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.mostRegionId != nil {
            map["MostRegionId"] = self.mostRegionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subClustersJson != nil {
            map["SubClustersJson"] = self.subClustersJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllSubClustersSuccess") && dict["AllSubClustersSuccess"] != nil {
            self.allSubClustersSuccess = dict["AllSubClustersSuccess"] as! Bool
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("MostRegionId") && dict["MostRegionId"] != nil {
            self.mostRegionId = dict["MostRegionId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubClustersJson") && dict["SubClustersJson"] != nil {
            self.subClustersJson = dict["SubClustersJson"] as! String
        }
    }
}

public class UpdatePrometheusGlobalViewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FailedInstances : Tea.TeaModel {
            public var clusterId: String?

            public var sourceName: String?

            public var sourceType: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.sourceName != nil {
                    map["SourceName"] = self.sourceName!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("SourceName") && dict["SourceName"] != nil {
                    self.sourceName = dict["SourceName"] as! String
                }
                if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var failedInstances: [UpdatePrometheusGlobalViewResponseBody.Data.FailedInstances]?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedInstances != nil {
                var tmp : [Any] = []
                for k in self.failedInstances! {
                    tmp.append(k.toMap())
                }
                map["FailedInstances"] = tmp
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedInstances") && dict["FailedInstances"] != nil {
                var tmp : [UpdatePrometheusGlobalViewResponseBody.Data.FailedInstances] = []
                for v in dict["FailedInstances"] as! [Any] {
                    var model = UpdatePrometheusGlobalViewResponseBody.Data.FailedInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.failedInstances = tmp
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: UpdatePrometheusGlobalViewResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdatePrometheusGlobalViewResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePrometheusGlobalViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusGlobalViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdatePrometheusGlobalViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusIntegrationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceId: Int64?

    public var integrationType: String?

    public var param: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.integrationType != nil {
            map["IntegrationType"] = self.integrationType!
        }
        if self.param != nil {
            map["Param"] = self.param!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("IntegrationType") && dict["IntegrationType"] != nil {
            self.integrationType = dict["IntegrationType"] as! String
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.param = dict["Param"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdatePrometheusIntegrationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: Int64?

        public var instanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: UpdatePrometheusIntegrationResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdatePrometheusIntegrationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePrometheusIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdatePrometheusIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusMonitoringRequest : Tea.TeaModel {
    public var clusterId: String?

    public var configYaml: String?

    public var monitoringName: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configYaml != nil {
            map["ConfigYaml"] = self.configYaml!
        }
        if self.monitoringName != nil {
            map["MonitoringName"] = self.monitoringName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigYaml") && dict["ConfigYaml"] != nil {
            self.configYaml = dict["ConfigYaml"] as! String
        }
        if dict.keys.contains("MonitoringName") && dict["MonitoringName"] != nil {
            self.monitoringName = dict["MonitoringName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdatePrometheusMonitoringResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePrometheusMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdatePrometheusMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusMonitoringStatusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var monitoringName: String?

    public var regionId: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.monitoringName != nil {
            map["MonitoringName"] = self.monitoringName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MonitoringName") && dict["MonitoringName"] != nil {
            self.monitoringName = dict["MonitoringName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdatePrometheusMonitoringStatusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePrometheusMonitoringStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusMonitoringStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdatePrometheusMonitoringStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrometheusRemoteWriteRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var remoteWriteName: String?

    public var remoteWriteYaml: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteWriteName != nil {
            map["RemoteWriteName"] = self.remoteWriteName!
        }
        if self.remoteWriteYaml != nil {
            map["RemoteWriteYaml"] = self.remoteWriteYaml!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteWriteName") && dict["RemoteWriteName"] != nil {
            self.remoteWriteName = dict["RemoteWriteName"] as! String
        }
        if dict.keys.contains("RemoteWriteYaml") && dict["RemoteWriteYaml"] != nil {
            self.remoteWriteYaml = dict["RemoteWriteYaml"] as! String
        }
    }
}

public class UpdatePrometheusRemoteWriteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePrometheusRemoteWriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrometheusRemoteWriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdatePrometheusRemoteWriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTimingSyntheticTaskRequest : Tea.TeaModel {
    public class AvailableAssertions : Tea.TeaModel {
        public var expect: String?

        public var operator_: String?

        public var target: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expect != nil {
                map["Expect"] = self.expect!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Expect") && dict["Expect"] != nil {
                self.expect = dict["Expect"] as! String
            }
            if dict.keys.contains("Operator") && dict["Operator"] != nil {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class CommonSetting : Tea.TeaModel {
        public class CustomHost : Tea.TeaModel {
            public class Hosts : Tea.TeaModel {
                public var domain: String?

                public var ipType: Int32?

                public var ips: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.domain != nil {
                        map["Domain"] = self.domain!
                    }
                    if self.ipType != nil {
                        map["IpType"] = self.ipType!
                    }
                    if self.ips != nil {
                        map["Ips"] = self.ips!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Domain") && dict["Domain"] != nil {
                        self.domain = dict["Domain"] as! String
                    }
                    if dict.keys.contains("IpType") && dict["IpType"] != nil {
                        self.ipType = dict["IpType"] as! Int32
                    }
                    if dict.keys.contains("Ips") && dict["Ips"] != nil {
                        self.ips = dict["Ips"] as! [String]
                    }
                }
            }
            public var hosts: [UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts]?

            public var selectType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hosts != nil {
                    var tmp : [Any] = []
                    for k in self.hosts! {
                        tmp.append(k.toMap())
                    }
                    map["Hosts"] = tmp
                }
                if self.selectType != nil {
                    map["SelectType"] = self.selectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Hosts") && dict["Hosts"] != nil {
                    var tmp : [UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts] = []
                    for v in dict["Hosts"] as! [Any] {
                        var model = UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost.Hosts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.hosts = tmp
                }
                if dict.keys.contains("SelectType") && dict["SelectType"] != nil {
                    self.selectType = dict["SelectType"] as! Int32
                }
            }
        }
        public var customHost: UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost?

        public var ipType: Int32?

        public var isOpenTrace: Bool?

        public var monitorSamples: Int32?

        public var traceClientType: Int32?

        public var xtraceRegion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customHost?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customHost != nil {
                map["CustomHost"] = self.customHost?.toMap()
            }
            if self.ipType != nil {
                map["IpType"] = self.ipType!
            }
            if self.isOpenTrace != nil {
                map["IsOpenTrace"] = self.isOpenTrace!
            }
            if self.monitorSamples != nil {
                map["MonitorSamples"] = self.monitorSamples!
            }
            if self.traceClientType != nil {
                map["TraceClientType"] = self.traceClientType!
            }
            if self.xtraceRegion != nil {
                map["XtraceRegion"] = self.xtraceRegion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomHost") && dict["CustomHost"] != nil {
                var model = UpdateTimingSyntheticTaskRequest.CommonSetting.CustomHost()
                model.fromMap(dict["CustomHost"] as! [String: Any])
                self.customHost = model
            }
            if dict.keys.contains("IpType") && dict["IpType"] != nil {
                self.ipType = dict["IpType"] as! Int32
            }
            if dict.keys.contains("IsOpenTrace") && dict["IsOpenTrace"] != nil {
                self.isOpenTrace = dict["IsOpenTrace"] as! Bool
            }
            if dict.keys.contains("MonitorSamples") && dict["MonitorSamples"] != nil {
                self.monitorSamples = dict["MonitorSamples"] as! Int32
            }
            if dict.keys.contains("TraceClientType") && dict["TraceClientType"] != nil {
                self.traceClientType = dict["TraceClientType"] as! Int32
            }
            if dict.keys.contains("XtraceRegion") && dict["XtraceRegion"] != nil {
                self.xtraceRegion = dict["XtraceRegion"] as! String
            }
        }
    }
    public class CustomPeriod : Tea.TeaModel {
        public var endHour: Int32?

        public var startHour: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endHour != nil {
                map["EndHour"] = self.endHour!
            }
            if self.startHour != nil {
                map["StartHour"] = self.startHour!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndHour") && dict["EndHour"] != nil {
                self.endHour = dict["EndHour"] as! Int32
            }
            if dict.keys.contains("StartHour") && dict["StartHour"] != nil {
                self.startHour = dict["StartHour"] as! Int32
            }
        }
    }
    public class MonitorConf : Tea.TeaModel {
        public class ApiHTTP : Tea.TeaModel {
            public class RequestBody : Tea.TeaModel {
                public var content: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var connectTimeout: Int64?

            public var method: String?

            public var requestBody: UpdateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP.RequestBody?

            public var requestHeaders: [String: String]?

            public var targetUrl: String?

            public var timeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.requestBody?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectTimeout != nil {
                    map["ConnectTimeout"] = self.connectTimeout!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.requestBody != nil {
                    map["RequestBody"] = self.requestBody?.toMap()
                }
                if self.requestHeaders != nil {
                    map["RequestHeaders"] = self.requestHeaders!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectTimeout") && dict["ConnectTimeout"] != nil {
                    self.connectTimeout = dict["ConnectTimeout"] as! Int64
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("RequestBody") && dict["RequestBody"] != nil {
                    var model = UpdateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP.RequestBody()
                    model.fromMap(dict["RequestBody"] as! [String: Any])
                    self.requestBody = model
                }
                if dict.keys.contains("RequestHeaders") && dict["RequestHeaders"] != nil {
                    self.requestHeaders = dict["RequestHeaders"] as! [String: String]
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! Int64
                }
            }
        }
        public class FileDownload : Tea.TeaModel {
            public var connectionTimeout: Int64?

            public var customHeaderContent: [String: String]?

            public var downloadKernel: Int32?

            public var ignoreCertificateAuthError: Int32?

            public var ignoreCertificateCanceledError: Int32?

            public var ignoreCertificateOutOfDateError: Int32?

            public var ignoreCertificateStatusError: Int32?

            public var ignoreCertificateUntrustworthyError: Int32?

            public var ignoreCertificateUsingError: Int32?

            public var ignoreInvalidHostError: Int32?

            public var monitorTimeout: Int64?

            public var quickProtocol: Int32?

            public var redirection: Int32?

            public var targetUrl: String?

            public var transmissionSize: Int64?

            public var validateKeywords: String?

            public var verifyWay: Int32?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectionTimeout != nil {
                    map["ConnectionTimeout"] = self.connectionTimeout!
                }
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.downloadKernel != nil {
                    map["DownloadKernel"] = self.downloadKernel!
                }
                if self.ignoreCertificateAuthError != nil {
                    map["IgnoreCertificateAuthError"] = self.ignoreCertificateAuthError!
                }
                if self.ignoreCertificateCanceledError != nil {
                    map["IgnoreCertificateCanceledError"] = self.ignoreCertificateCanceledError!
                }
                if self.ignoreCertificateOutOfDateError != nil {
                    map["IgnoreCertificateOutOfDateError"] = self.ignoreCertificateOutOfDateError!
                }
                if self.ignoreCertificateStatusError != nil {
                    map["IgnoreCertificateStatusError"] = self.ignoreCertificateStatusError!
                }
                if self.ignoreCertificateUntrustworthyError != nil {
                    map["IgnoreCertificateUntrustworthyError"] = self.ignoreCertificateUntrustworthyError!
                }
                if self.ignoreCertificateUsingError != nil {
                    map["IgnoreCertificateUsingError"] = self.ignoreCertificateUsingError!
                }
                if self.ignoreInvalidHostError != nil {
                    map["IgnoreInvalidHostError"] = self.ignoreInvalidHostError!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.quickProtocol != nil {
                    map["QuickProtocol"] = self.quickProtocol!
                }
                if self.redirection != nil {
                    map["Redirection"] = self.redirection!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.transmissionSize != nil {
                    map["TransmissionSize"] = self.transmissionSize!
                }
                if self.validateKeywords != nil {
                    map["ValidateKeywords"] = self.validateKeywords!
                }
                if self.verifyWay != nil {
                    map["VerifyWay"] = self.verifyWay!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectionTimeout") && dict["ConnectionTimeout"] != nil {
                    self.connectionTimeout = dict["ConnectionTimeout"] as! Int64
                }
                if dict.keys.contains("CustomHeaderContent") && dict["CustomHeaderContent"] != nil {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("DownloadKernel") && dict["DownloadKernel"] != nil {
                    self.downloadKernel = dict["DownloadKernel"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateAuthError") && dict["IgnoreCertificateAuthError"] != nil {
                    self.ignoreCertificateAuthError = dict["IgnoreCertificateAuthError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateCanceledError") && dict["IgnoreCertificateCanceledError"] != nil {
                    self.ignoreCertificateCanceledError = dict["IgnoreCertificateCanceledError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateOutOfDateError") && dict["IgnoreCertificateOutOfDateError"] != nil {
                    self.ignoreCertificateOutOfDateError = dict["IgnoreCertificateOutOfDateError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateStatusError") && dict["IgnoreCertificateStatusError"] != nil {
                    self.ignoreCertificateStatusError = dict["IgnoreCertificateStatusError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateUntrustworthyError") && dict["IgnoreCertificateUntrustworthyError"] != nil {
                    self.ignoreCertificateUntrustworthyError = dict["IgnoreCertificateUntrustworthyError"] as! Int32
                }
                if dict.keys.contains("IgnoreCertificateUsingError") && dict["IgnoreCertificateUsingError"] != nil {
                    self.ignoreCertificateUsingError = dict["IgnoreCertificateUsingError"] as! Int32
                }
                if dict.keys.contains("IgnoreInvalidHostError") && dict["IgnoreInvalidHostError"] != nil {
                    self.ignoreInvalidHostError = dict["IgnoreInvalidHostError"] as! Int32
                }
                if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("QuickProtocol") && dict["QuickProtocol"] != nil {
                    self.quickProtocol = dict["QuickProtocol"] as! Int32
                }
                if dict.keys.contains("Redirection") && dict["Redirection"] != nil {
                    self.redirection = dict["Redirection"] as! Int32
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("TransmissionSize") && dict["TransmissionSize"] != nil {
                    self.transmissionSize = dict["TransmissionSize"] as! Int64
                }
                if dict.keys.contains("ValidateKeywords") && dict["ValidateKeywords"] != nil {
                    self.validateKeywords = dict["ValidateKeywords"] as! String
                }
                if dict.keys.contains("VerifyWay") && dict["VerifyWay"] != nil {
                    self.verifyWay = dict["VerifyWay"] as! Int32
                }
                if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class NetDNS : Tea.TeaModel {
            public var dig: Int32?

            public var dnsServerIpType: Int32?

            public var nsServer: String?

            public var queryMethod: Int32?

            public var targetUrl: String?

            public var timeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dig != nil {
                    map["Dig"] = self.dig!
                }
                if self.dnsServerIpType != nil {
                    map["DnsServerIpType"] = self.dnsServerIpType!
                }
                if self.nsServer != nil {
                    map["NsServer"] = self.nsServer!
                }
                if self.queryMethod != nil {
                    map["QueryMethod"] = self.queryMethod!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dig") && dict["Dig"] != nil {
                    self.dig = dict["Dig"] as! Int32
                }
                if dict.keys.contains("DnsServerIpType") && dict["DnsServerIpType"] != nil {
                    self.dnsServerIpType = dict["DnsServerIpType"] as! Int32
                }
                if dict.keys.contains("NsServer") && dict["NsServer"] != nil {
                    self.nsServer = dict["NsServer"] as! String
                }
                if dict.keys.contains("QueryMethod") && dict["QueryMethod"] != nil {
                    self.queryMethod = dict["QueryMethod"] as! Int32
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! Int64
                }
            }
        }
        public class NetICMP : Tea.TeaModel {
            public var interval: Int64?

            public var packageNum: Int32?

            public var packageSize: Int32?

            public var splitPackage: Bool?

            public var targetUrl: String?

            public var timeout: Int64?

            public var tracertEnable: Bool?

            public var tracertNumMax: Int32?

            public var tracertTimeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.packageNum != nil {
                    map["PackageNum"] = self.packageNum!
                }
                if self.packageSize != nil {
                    map["PackageSize"] = self.packageSize!
                }
                if self.splitPackage != nil {
                    map["SplitPackage"] = self.splitPackage!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.tracertEnable != nil {
                    map["TracertEnable"] = self.tracertEnable!
                }
                if self.tracertNumMax != nil {
                    map["TracertNumMax"] = self.tracertNumMax!
                }
                if self.tracertTimeout != nil {
                    map["TracertTimeout"] = self.tracertTimeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("PackageNum") && dict["PackageNum"] != nil {
                    self.packageNum = dict["PackageNum"] as! Int32
                }
                if dict.keys.contains("PackageSize") && dict["PackageSize"] != nil {
                    self.packageSize = dict["PackageSize"] as! Int32
                }
                if dict.keys.contains("SplitPackage") && dict["SplitPackage"] != nil {
                    self.splitPackage = dict["SplitPackage"] as! Bool
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("TracertEnable") && dict["TracertEnable"] != nil {
                    self.tracertEnable = dict["TracertEnable"] as! Bool
                }
                if dict.keys.contains("TracertNumMax") && dict["TracertNumMax"] != nil {
                    self.tracertNumMax = dict["TracertNumMax"] as! Int32
                }
                if dict.keys.contains("TracertTimeout") && dict["TracertTimeout"] != nil {
                    self.tracertTimeout = dict["TracertTimeout"] as! Int64
                }
            }
        }
        public class NetTCP : Tea.TeaModel {
            public var connectTimes: Int32?

            public var interval: Int64?

            public var targetUrl: String?

            public var timeout: Int64?

            public var tracertEnable: Bool?

            public var tracertNumMax: Int32?

            public var tracertTimeout: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectTimes != nil {
                    map["ConnectTimes"] = self.connectTimes!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.tracertEnable != nil {
                    map["TracertEnable"] = self.tracertEnable!
                }
                if self.tracertNumMax != nil {
                    map["TracertNumMax"] = self.tracertNumMax!
                }
                if self.tracertTimeout != nil {
                    map["TracertTimeout"] = self.tracertTimeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConnectTimes") && dict["ConnectTimes"] != nil {
                    self.connectTimes = dict["ConnectTimes"] as! Int32
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("TracertEnable") && dict["TracertEnable"] != nil {
                    self.tracertEnable = dict["TracertEnable"] as! Bool
                }
                if dict.keys.contains("TracertNumMax") && dict["TracertNumMax"] != nil {
                    self.tracertNumMax = dict["TracertNumMax"] as! Int32
                }
                if dict.keys.contains("TracertTimeout") && dict["TracertTimeout"] != nil {
                    self.tracertTimeout = dict["TracertTimeout"] as! Int64
                }
            }
        }
        public class Stream : Tea.TeaModel {
            public var customHeaderContent: [String: String]?

            public var playerType: Int32?

            public var streamAddressType: Int32?

            public var streamMonitorTimeout: Int32?

            public var streamType: Int32?

            public var targetUrl: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.playerType != nil {
                    map["PlayerType"] = self.playerType!
                }
                if self.streamAddressType != nil {
                    map["StreamAddressType"] = self.streamAddressType!
                }
                if self.streamMonitorTimeout != nil {
                    map["StreamMonitorTimeout"] = self.streamMonitorTimeout!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.whiteList != nil {
                    map["WhiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomHeaderContent") && dict["CustomHeaderContent"] != nil {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("PlayerType") && dict["PlayerType"] != nil {
                    self.playerType = dict["PlayerType"] as! Int32
                }
                if dict.keys.contains("StreamAddressType") && dict["StreamAddressType"] != nil {
                    self.streamAddressType = dict["StreamAddressType"] as! Int32
                }
                if dict.keys.contains("StreamMonitorTimeout") && dict["StreamMonitorTimeout"] != nil {
                    self.streamMonitorTimeout = dict["StreamMonitorTimeout"] as! Int32
                }
                if dict.keys.contains("StreamType") && dict["StreamType"] != nil {
                    self.streamType = dict["StreamType"] as! Int32
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                    self.whiteList = dict["WhiteList"] as! String
                }
            }
        }
        public class Website : Tea.TeaModel {
            public var automaticScrolling: Int32?

            public var customHeader: Int32?

            public var customHeaderContent: [String: String]?

            public var DNSHijackWhitelist: String?

            public var disableCache: Int32?

            public var disableCompression: Int32?

            public var elementBlacklist: String?

            public var filterInvalidIP: Int32?

            public var flowHijackJumpTimes: Int32?

            public var flowHijackLogo: String?

            public var ignoreCertificateError: Int32?

            public var monitorTimeout: Int64?

            public var pageTamper: String?

            public var redirection: Int32?

            public var slowElementThreshold: Int64?

            public var targetUrl: String?

            public var verifyStringBlacklist: String?

            public var verifyStringWhitelist: String?

            public var waitCompletionTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.automaticScrolling != nil {
                    map["AutomaticScrolling"] = self.automaticScrolling!
                }
                if self.customHeader != nil {
                    map["CustomHeader"] = self.customHeader!
                }
                if self.customHeaderContent != nil {
                    map["CustomHeaderContent"] = self.customHeaderContent!
                }
                if self.DNSHijackWhitelist != nil {
                    map["DNSHijackWhitelist"] = self.DNSHijackWhitelist!
                }
                if self.disableCache != nil {
                    map["DisableCache"] = self.disableCache!
                }
                if self.disableCompression != nil {
                    map["DisableCompression"] = self.disableCompression!
                }
                if self.elementBlacklist != nil {
                    map["ElementBlacklist"] = self.elementBlacklist!
                }
                if self.filterInvalidIP != nil {
                    map["FilterInvalidIP"] = self.filterInvalidIP!
                }
                if self.flowHijackJumpTimes != nil {
                    map["FlowHijackJumpTimes"] = self.flowHijackJumpTimes!
                }
                if self.flowHijackLogo != nil {
                    map["FlowHijackLogo"] = self.flowHijackLogo!
                }
                if self.ignoreCertificateError != nil {
                    map["IgnoreCertificateError"] = self.ignoreCertificateError!
                }
                if self.monitorTimeout != nil {
                    map["MonitorTimeout"] = self.monitorTimeout!
                }
                if self.pageTamper != nil {
                    map["PageTamper"] = self.pageTamper!
                }
                if self.redirection != nil {
                    map["Redirection"] = self.redirection!
                }
                if self.slowElementThreshold != nil {
                    map["SlowElementThreshold"] = self.slowElementThreshold!
                }
                if self.targetUrl != nil {
                    map["TargetUrl"] = self.targetUrl!
                }
                if self.verifyStringBlacklist != nil {
                    map["VerifyStringBlacklist"] = self.verifyStringBlacklist!
                }
                if self.verifyStringWhitelist != nil {
                    map["VerifyStringWhitelist"] = self.verifyStringWhitelist!
                }
                if self.waitCompletionTime != nil {
                    map["WaitCompletionTime"] = self.waitCompletionTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutomaticScrolling") && dict["AutomaticScrolling"] != nil {
                    self.automaticScrolling = dict["AutomaticScrolling"] as! Int32
                }
                if dict.keys.contains("CustomHeader") && dict["CustomHeader"] != nil {
                    self.customHeader = dict["CustomHeader"] as! Int32
                }
                if dict.keys.contains("CustomHeaderContent") && dict["CustomHeaderContent"] != nil {
                    self.customHeaderContent = dict["CustomHeaderContent"] as! [String: String]
                }
                if dict.keys.contains("DNSHijackWhitelist") && dict["DNSHijackWhitelist"] != nil {
                    self.DNSHijackWhitelist = dict["DNSHijackWhitelist"] as! String
                }
                if dict.keys.contains("DisableCache") && dict["DisableCache"] != nil {
                    self.disableCache = dict["DisableCache"] as! Int32
                }
                if dict.keys.contains("DisableCompression") && dict["DisableCompression"] != nil {
                    self.disableCompression = dict["DisableCompression"] as! Int32
                }
                if dict.keys.contains("ElementBlacklist") && dict["ElementBlacklist"] != nil {
                    self.elementBlacklist = dict["ElementBlacklist"] as! String
                }
                if dict.keys.contains("FilterInvalidIP") && dict["FilterInvalidIP"] != nil {
                    self.filterInvalidIP = dict["FilterInvalidIP"] as! Int32
                }
                if dict.keys.contains("FlowHijackJumpTimes") && dict["FlowHijackJumpTimes"] != nil {
                    self.flowHijackJumpTimes = dict["FlowHijackJumpTimes"] as! Int32
                }
                if dict.keys.contains("FlowHijackLogo") && dict["FlowHijackLogo"] != nil {
                    self.flowHijackLogo = dict["FlowHijackLogo"] as! String
                }
                if dict.keys.contains("IgnoreCertificateError") && dict["IgnoreCertificateError"] != nil {
                    self.ignoreCertificateError = dict["IgnoreCertificateError"] as! Int32
                }
                if dict.keys.contains("MonitorTimeout") && dict["MonitorTimeout"] != nil {
                    self.monitorTimeout = dict["MonitorTimeout"] as! Int64
                }
                if dict.keys.contains("PageTamper") && dict["PageTamper"] != nil {
                    self.pageTamper = dict["PageTamper"] as! String
                }
                if dict.keys.contains("Redirection") && dict["Redirection"] != nil {
                    self.redirection = dict["Redirection"] as! Int32
                }
                if dict.keys.contains("SlowElementThreshold") && dict["SlowElementThreshold"] != nil {
                    self.slowElementThreshold = dict["SlowElementThreshold"] as! Int64
                }
                if dict.keys.contains("TargetUrl") && dict["TargetUrl"] != nil {
                    self.targetUrl = dict["TargetUrl"] as! String
                }
                if dict.keys.contains("VerifyStringBlacklist") && dict["VerifyStringBlacklist"] != nil {
                    self.verifyStringBlacklist = dict["VerifyStringBlacklist"] as! String
                }
                if dict.keys.contains("VerifyStringWhitelist") && dict["VerifyStringWhitelist"] != nil {
                    self.verifyStringWhitelist = dict["VerifyStringWhitelist"] as! String
                }
                if dict.keys.contains("WaitCompletionTime") && dict["WaitCompletionTime"] != nil {
                    self.waitCompletionTime = dict["WaitCompletionTime"] as! Int64
                }
            }
        }
        public var apiHTTP: UpdateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP?

        public var fileDownload: UpdateTimingSyntheticTaskRequest.MonitorConf.FileDownload?

        public var netDNS: UpdateTimingSyntheticTaskRequest.MonitorConf.NetDNS?

        public var netICMP: UpdateTimingSyntheticTaskRequest.MonitorConf.NetICMP?

        public var netTCP: UpdateTimingSyntheticTaskRequest.MonitorConf.NetTCP?

        public var stream: UpdateTimingSyntheticTaskRequest.MonitorConf.Stream?

        public var website: UpdateTimingSyntheticTaskRequest.MonitorConf.Website?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.apiHTTP?.validate()
            try self.fileDownload?.validate()
            try self.netDNS?.validate()
            try self.netICMP?.validate()
            try self.netTCP?.validate()
            try self.stream?.validate()
            try self.website?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiHTTP != nil {
                map["ApiHTTP"] = self.apiHTTP?.toMap()
            }
            if self.fileDownload != nil {
                map["FileDownload"] = self.fileDownload?.toMap()
            }
            if self.netDNS != nil {
                map["NetDNS"] = self.netDNS?.toMap()
            }
            if self.netICMP != nil {
                map["NetICMP"] = self.netICMP?.toMap()
            }
            if self.netTCP != nil {
                map["NetTCP"] = self.netTCP?.toMap()
            }
            if self.stream != nil {
                map["Stream"] = self.stream?.toMap()
            }
            if self.website != nil {
                map["Website"] = self.website?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiHTTP") && dict["ApiHTTP"] != nil {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.ApiHTTP()
                model.fromMap(dict["ApiHTTP"] as! [String: Any])
                self.apiHTTP = model
            }
            if dict.keys.contains("FileDownload") && dict["FileDownload"] != nil {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.FileDownload()
                model.fromMap(dict["FileDownload"] as! [String: Any])
                self.fileDownload = model
            }
            if dict.keys.contains("NetDNS") && dict["NetDNS"] != nil {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.NetDNS()
                model.fromMap(dict["NetDNS"] as! [String: Any])
                self.netDNS = model
            }
            if dict.keys.contains("NetICMP") && dict["NetICMP"] != nil {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.NetICMP()
                model.fromMap(dict["NetICMP"] as! [String: Any])
                self.netICMP = model
            }
            if dict.keys.contains("NetTCP") && dict["NetTCP"] != nil {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.NetTCP()
                model.fromMap(dict["NetTCP"] as! [String: Any])
                self.netTCP = model
            }
            if dict.keys.contains("Stream") && dict["Stream"] != nil {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.Stream()
                model.fromMap(dict["Stream"] as! [String: Any])
                self.stream = model
            }
            if dict.keys.contains("Website") && dict["Website"] != nil {
                var model = UpdateTimingSyntheticTaskRequest.MonitorConf.Website()
                model.fromMap(dict["Website"] as! [String: Any])
                self.website = model
            }
        }
    }
    public class Monitors : Tea.TeaModel {
        public var cityCode: String?

        public var clientType: Int32?

        public var operatorCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.operatorCode != nil {
                map["OperatorCode"] = self.operatorCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") && dict["CityCode"] != nil {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("ClientType") && dict["ClientType"] != nil {
                self.clientType = dict["ClientType"] as! Int32
            }
            if dict.keys.contains("OperatorCode") && dict["OperatorCode"] != nil {
                self.operatorCode = dict["OperatorCode"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var availableAssertions: [UpdateTimingSyntheticTaskRequest.AvailableAssertions]?

    public var commonSetting: UpdateTimingSyntheticTaskRequest.CommonSetting?

    public var customPeriod: UpdateTimingSyntheticTaskRequest.CustomPeriod?

    public var frequency: String?

    public var monitorCategory: Int32?

    public var monitorConf: UpdateTimingSyntheticTaskRequest.MonitorConf?

    public var monitors: [UpdateTimingSyntheticTaskRequest.Monitors]?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [UpdateTimingSyntheticTaskRequest.Tags]?

    public var taskId: String?

    public var taskType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonSetting?.validate()
        try self.customPeriod?.validate()
        try self.monitorConf?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAssertions != nil {
            var tmp : [Any] = []
            for k in self.availableAssertions! {
                tmp.append(k.toMap())
            }
            map["AvailableAssertions"] = tmp
        }
        if self.commonSetting != nil {
            map["CommonSetting"] = self.commonSetting?.toMap()
        }
        if self.customPeriod != nil {
            map["CustomPeriod"] = self.customPeriod?.toMap()
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.monitorCategory != nil {
            map["MonitorCategory"] = self.monitorCategory!
        }
        if self.monitorConf != nil {
            map["MonitorConf"] = self.monitorConf?.toMap()
        }
        if self.monitors != nil {
            var tmp : [Any] = []
            for k in self.monitors! {
                tmp.append(k.toMap())
            }
            map["Monitors"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAssertions") && dict["AvailableAssertions"] != nil {
            var tmp : [UpdateTimingSyntheticTaskRequest.AvailableAssertions] = []
            for v in dict["AvailableAssertions"] as! [Any] {
                var model = UpdateTimingSyntheticTaskRequest.AvailableAssertions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.availableAssertions = tmp
        }
        if dict.keys.contains("CommonSetting") && dict["CommonSetting"] != nil {
            var model = UpdateTimingSyntheticTaskRequest.CommonSetting()
            model.fromMap(dict["CommonSetting"] as! [String: Any])
            self.commonSetting = model
        }
        if dict.keys.contains("CustomPeriod") && dict["CustomPeriod"] != nil {
            var model = UpdateTimingSyntheticTaskRequest.CustomPeriod()
            model.fromMap(dict["CustomPeriod"] as! [String: Any])
            self.customPeriod = model
        }
        if dict.keys.contains("Frequency") && dict["Frequency"] != nil {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("MonitorCategory") && dict["MonitorCategory"] != nil {
            self.monitorCategory = dict["MonitorCategory"] as! Int32
        }
        if dict.keys.contains("MonitorConf") && dict["MonitorConf"] != nil {
            var model = UpdateTimingSyntheticTaskRequest.MonitorConf()
            model.fromMap(dict["MonitorConf"] as! [String: Any])
            self.monitorConf = model
        }
        if dict.keys.contains("Monitors") && dict["Monitors"] != nil {
            var tmp : [UpdateTimingSyntheticTaskRequest.Monitors] = []
            for v in dict["Monitors"] as! [Any] {
                var model = UpdateTimingSyntheticTaskRequest.Monitors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.monitors = tmp
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [UpdateTimingSyntheticTaskRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = UpdateTimingSyntheticTaskRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! Int32
        }
    }
}

public class UpdateTimingSyntheticTaskShrinkRequest : Tea.TeaModel {
    public var availableAssertionsShrink: String?

    public var commonSettingShrink: String?

    public var customPeriodShrink: String?

    public var frequency: String?

    public var monitorCategory: Int32?

    public var monitorConfShrink: String?

    public var monitorsShrink: String?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tagsShrink: String?

    public var taskId: String?

    public var taskType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAssertionsShrink != nil {
            map["AvailableAssertions"] = self.availableAssertionsShrink!
        }
        if self.commonSettingShrink != nil {
            map["CommonSetting"] = self.commonSettingShrink!
        }
        if self.customPeriodShrink != nil {
            map["CustomPeriod"] = self.customPeriodShrink!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.monitorCategory != nil {
            map["MonitorCategory"] = self.monitorCategory!
        }
        if self.monitorConfShrink != nil {
            map["MonitorConf"] = self.monitorConfShrink!
        }
        if self.monitorsShrink != nil {
            map["Monitors"] = self.monitorsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAssertions") && dict["AvailableAssertions"] != nil {
            self.availableAssertionsShrink = dict["AvailableAssertions"] as! String
        }
        if dict.keys.contains("CommonSetting") && dict["CommonSetting"] != nil {
            self.commonSettingShrink = dict["CommonSetting"] as! String
        }
        if dict.keys.contains("CustomPeriod") && dict["CustomPeriod"] != nil {
            self.customPeriodShrink = dict["CustomPeriod"] as! String
        }
        if dict.keys.contains("Frequency") && dict["Frequency"] != nil {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("MonitorCategory") && dict["MonitorCategory"] != nil {
            self.monitorCategory = dict["MonitorCategory"] as! Int32
        }
        if dict.keys.contains("MonitorConf") && dict["MonitorConf"] != nil {
            self.monitorConfShrink = dict["MonitorConf"] as! String
        }
        if dict.keys.contains("Monitors") && dict["Monitors"] != nil {
            self.monitorsShrink = dict["Monitors"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tagsShrink = dict["Tags"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! Int32
        }
    }
}

public class UpdateTimingSyntheticTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: UpdateTimingSyntheticTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateTimingSyntheticTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateTimingSyntheticTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTimingSyntheticTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTimingSyntheticTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWebhookRequest : Tea.TeaModel {
    public var body: String?

    public var contactId: Int64?

    public var contactName: String?

    public var httpHeaders: String?

    public var httpParams: String?

    public var method: String?

    public var recoverBody: String?

    public var regionId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["Body"] = self.body!
        }
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.httpHeaders != nil {
            map["HttpHeaders"] = self.httpHeaders!
        }
        if self.httpParams != nil {
            map["HttpParams"] = self.httpParams!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.recoverBody != nil {
            map["RecoverBody"] = self.recoverBody!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Body") && dict["Body"] != nil {
            self.body = dict["Body"] as! String
        }
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! Int64
        }
        if dict.keys.contains("ContactName") && dict["ContactName"] != nil {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("HttpHeaders") && dict["HttpHeaders"] != nil {
            self.httpHeaders = dict["HttpHeaders"] as! String
        }
        if dict.keys.contains("HttpParams") && dict["HttpParams"] != nil {
            self.httpParams = dict["HttpParams"] as! String
        }
        if dict.keys.contains("Method") && dict["Method"] != nil {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("RecoverBody") && dict["RecoverBody"] != nil {
            self.recoverBody = dict["RecoverBody"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class UpdateWebhookResponseBody : Tea.TeaModel {
    public var isSuccess: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isSuccess != nil {
            map["IsSuccess"] = self.isSuccess!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsSuccess") && dict["IsSuccess"] != nil {
            self.isSuccess = dict["IsSuccess"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeAddonReleaseRequest : Tea.TeaModel {
    public var addonVersion: String?

    public var dryRun: Bool?

    public var environmentId: String?

    public var regionId: String?

    public var releaseName: String?

    public var values: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addonVersion != nil {
            map["AddonVersion"] = self.addonVersion!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseName != nil {
            map["ReleaseName"] = self.releaseName!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddonVersion") && dict["AddonVersion"] != nil {
            self.addonVersion = dict["AddonVersion"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseName") && dict["ReleaseName"] != nil {
            self.releaseName = dict["ReleaseName"] as! String
        }
        if dict.keys.contains("Values") && dict["Values"] != nil {
            self.values = dict["Values"] as! String
        }
    }
}

public class UpgradeAddonReleaseResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeAddonReleaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeAddonReleaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpgradeAddonReleaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeEnvironmentFeatureRequest : Tea.TeaModel {
    public var aliyunLang: String?

    public var environmentId: String?

    public var featureName: String?

    public var featureVersion: String?

    public var regionId: String?

    public var values: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunLang != nil {
            map["AliyunLang"] = self.aliyunLang!
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.featureName != nil {
            map["FeatureName"] = self.featureName!
        }
        if self.featureVersion != nil {
            map["FeatureVersion"] = self.featureVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunLang") && dict["AliyunLang"] != nil {
            self.aliyunLang = dict["AliyunLang"] as! String
        }
        if dict.keys.contains("EnvironmentId") && dict["EnvironmentId"] != nil {
            self.environmentId = dict["EnvironmentId"] as! String
        }
        if dict.keys.contains("FeatureName") && dict["FeatureName"] != nil {
            self.featureName = dict["FeatureName"] as! String
        }
        if dict.keys.contains("FeatureVersion") && dict["FeatureVersion"] != nil {
            self.featureVersion = dict["FeatureVersion"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Values") && dict["Values"] != nil {
            self.values = dict["Values"] as! String
        }
    }
}

public class UpgradeEnvironmentFeatureResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String: String]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String: String]
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeEnvironmentFeatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeEnvironmentFeatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpgradeEnvironmentFeatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadRequest : Tea.TeaModel {
    public var edition: String?

    public var file: String?

    public var fileName: String?

    public var pid: String?

    public var regionId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.edition != nil {
            map["Edition"] = self.edition!
        }
        if self.file != nil {
            map["File"] = self.file!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Edition") && dict["Edition"] != nil {
            self.edition = dict["Edition"] as! String
        }
        if dict.keys.contains("File") && dict["File"] != nil {
            self.file = dict["File"] as! String
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class UploadResponseBody : Tea.TeaModel {
    public class UploadResult : Tea.TeaModel {
        public var fid: String?

        public var fileName: String?

        public var uploadTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fid != nil {
                map["Fid"] = self.fid!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.uploadTime != nil {
                map["UploadTime"] = self.uploadTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Fid") && dict["Fid"] != nil {
                self.fid = dict["Fid"] as! String
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("UploadTime") && dict["UploadTime"] != nil {
                self.uploadTime = dict["UploadTime"] as! String
            }
        }
    }
    public var requestId: String?

    public var uploadResult: UploadResponseBody.UploadResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadResult != nil {
            map["UploadResult"] = self.uploadResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadResult") && dict["UploadResult"] != nil {
            var model = UploadResponseBody.UploadResult()
            model.fromMap(dict["UploadResult"] as! [String: Any])
            self.uploadResult = model
        }
    }
}

public class UploadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
