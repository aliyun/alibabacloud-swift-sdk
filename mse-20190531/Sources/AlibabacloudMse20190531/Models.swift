import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class GatewayDomain : Tea.TeaModel {
    public var certIdentifier: String?

    public var gatewayId: Int64?

    public var gatewayName: String?

    public var gatewayUniqueId: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var id: Int64?

    public var mustHttps: String?

    public var name: String?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayName != nil {
            map["GatewayName"] = self.gatewayName!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mustHttps != nil {
            map["MustHttps"] = self.mustHttps!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertIdentifier") && dict["CertIdentifier"] != nil {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayName") && dict["GatewayName"] != nil {
            self.gatewayName = dict["GatewayName"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MustHttps") && dict["MustHttps"] != nil {
            self.mustHttps = dict["MustHttps"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class GatewayOption : Tea.TeaModel {
    public class LogConfigDetails : Tea.TeaModel {
        public var logEnabled: Bool?

        public var logStoreName: String?

        public var projectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logEnabled != nil {
                map["LogEnabled"] = self.logEnabled!
            }
            if self.logStoreName != nil {
                map["LogStoreName"] = self.logStoreName!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogEnabled") && dict["LogEnabled"] != nil {
                self.logEnabled = dict["LogEnabled"] as! Bool
            }
            if dict.keys.contains("LogStoreName") && dict["LogStoreName"] != nil {
                self.logStoreName = dict["LogStoreName"] as! String
            }
            if dict.keys.contains("ProjectName") && dict["ProjectName"] != nil {
                self.projectName = dict["ProjectName"] as! String
            }
        }
    }
    public class TraceDetails : Tea.TeaModel {
        public var sample: Int64?

        public var serviceId: Int64?

        public var servicePort: String?

        public var traceEnabled: Bool?

        public var traceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sample != nil {
                map["Sample"] = self.sample!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.traceEnabled != nil {
                map["TraceEnabled"] = self.traceEnabled!
            }
            if self.traceType != nil {
                map["TraceType"] = self.traceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Sample") && dict["Sample"] != nil {
                self.sample = dict["Sample"] as! Int64
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                self.servicePort = dict["ServicePort"] as! String
            }
            if dict.keys.contains("TraceEnabled") && dict["TraceEnabled"] != nil {
                self.traceEnabled = dict["TraceEnabled"] as! Bool
            }
            if dict.keys.contains("TraceType") && dict["TraceType"] != nil {
                self.traceType = dict["TraceType"] as! String
            }
        }
    }
    public var disableHttp2Alpn: Bool?

    public var enableHardwareAcceleration: Bool?

    public var enableWaf: Bool?

    public var logConfigDetails: GatewayOption.LogConfigDetails?

    public var traceDetails: GatewayOption.TraceDetails?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logConfigDetails?.validate()
        try self.traceDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disableHttp2Alpn != nil {
            map["DisableHttp2Alpn"] = self.disableHttp2Alpn!
        }
        if self.enableHardwareAcceleration != nil {
            map["EnableHardwareAcceleration"] = self.enableHardwareAcceleration!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.logConfigDetails != nil {
            map["LogConfigDetails"] = self.logConfigDetails?.toMap()
        }
        if self.traceDetails != nil {
            map["TraceDetails"] = self.traceDetails?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DisableHttp2Alpn") && dict["DisableHttp2Alpn"] != nil {
            self.disableHttp2Alpn = dict["DisableHttp2Alpn"] as! Bool
        }
        if dict.keys.contains("EnableHardwareAcceleration") && dict["EnableHardwareAcceleration"] != nil {
            self.enableHardwareAcceleration = dict["EnableHardwareAcceleration"] as! Bool
        }
        if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("LogConfigDetails") && dict["LogConfigDetails"] != nil {
            var model = GatewayOption.LogConfigDetails()
            model.fromMap(dict["LogConfigDetails"] as! [String: Any])
            self.logConfigDetails = model
        }
        if dict.keys.contains("TraceDetails") && dict["TraceDetails"] != nil {
            var model = GatewayOption.TraceDetails()
            model.fromMap(dict["TraceDetails"] as! [String: Any])
            self.traceDetails = model
        }
    }
}

public class GatewayService : Tea.TeaModel {
    public var gatewayTrafficPolicy: TrafficPolicy?

    public var gatewayUniqueId: String?

    public var groupName: String?

    public var id: Int64?

    public var metaInfo: String?

    public var name: String?

    public var namespace: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewayTrafficPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gatewayTrafficPolicy != nil {
            map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.metaInfo != nil {
            map["MetaInfo"] = self.metaInfo!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GatewayTrafficPolicy") && dict["GatewayTrafficPolicy"] != nil {
            var model = TrafficPolicy()
            model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
            self.gatewayTrafficPolicy = model
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MetaInfo") && dict["MetaInfo"] != nil {
            self.metaInfo = dict["MetaInfo"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class TrafficPolicy : Tea.TeaModel {
    public class LoadBalancerSettings : Tea.TeaModel {
        public class ConsistentHashLBConfig : Tea.TeaModel {
            public class HttpCookie : Tea.TeaModel {
                public var name: String?

                public var path: String?

                public var TTL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.TTL != nil {
                        map["TTL"] = self.TTL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("TTL") && dict["TTL"] != nil {
                        self.TTL = dict["TTL"] as! String
                    }
                }
            }
            public var consistentHashLBType: String?

            public var httpCookie: TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie?

            public var parameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.httpCookie?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consistentHashLBType != nil {
                    map["ConsistentHashLBType"] = self.consistentHashLBType!
                }
                if self.httpCookie != nil {
                    map["HttpCookie"] = self.httpCookie?.toMap()
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsistentHashLBType") && dict["ConsistentHashLBType"] != nil {
                    self.consistentHashLBType = dict["ConsistentHashLBType"] as! String
                }
                if dict.keys.contains("HttpCookie") && dict["HttpCookie"] != nil {
                    var model = TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie()
                    model.fromMap(dict["HttpCookie"] as! [String: Any])
                    self.httpCookie = model
                }
                if dict.keys.contains("ParameterName") && dict["ParameterName"] != nil {
                    self.parameterName = dict["ParameterName"] as! String
                }
            }
        }
        public var consistentHashLBConfig: TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig?

        public var loadbalancerType: String?

        public var warmupDuration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.consistentHashLBConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consistentHashLBConfig != nil {
                map["ConsistentHashLBConfig"] = self.consistentHashLBConfig?.toMap()
            }
            if self.loadbalancerType != nil {
                map["LoadbalancerType"] = self.loadbalancerType!
            }
            if self.warmupDuration != nil {
                map["WarmupDuration"] = self.warmupDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsistentHashLBConfig") && dict["ConsistentHashLBConfig"] != nil {
                var model = TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig()
                model.fromMap(dict["ConsistentHashLBConfig"] as! [String: Any])
                self.consistentHashLBConfig = model
            }
            if dict.keys.contains("LoadbalancerType") && dict["LoadbalancerType"] != nil {
                self.loadbalancerType = dict["LoadbalancerType"] as! String
            }
            if dict.keys.contains("WarmupDuration") && dict["WarmupDuration"] != nil {
                self.warmupDuration = dict["WarmupDuration"] as! Int64
            }
        }
    }
    public class TlsSetting : Tea.TeaModel {
        public var caCertContent: String?

        public var certId: String?

        public var sni: String?

        public var tlsMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caCertContent != nil {
                map["CaCertContent"] = self.caCertContent!
            }
            if self.certId != nil {
                map["CertId"] = self.certId!
            }
            if self.sni != nil {
                map["Sni"] = self.sni!
            }
            if self.tlsMode != nil {
                map["TlsMode"] = self.tlsMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaCertContent") && dict["CaCertContent"] != nil {
                self.caCertContent = dict["CaCertContent"] as! String
            }
            if dict.keys.contains("CertId") && dict["CertId"] != nil {
                self.certId = dict["CertId"] as! String
            }
            if dict.keys.contains("Sni") && dict["Sni"] != nil {
                self.sni = dict["Sni"] as! String
            }
            if dict.keys.contains("TlsMode") && dict["TlsMode"] != nil {
                self.tlsMode = dict["TlsMode"] as! String
            }
        }
    }
    public var loadBalancerSettings: TrafficPolicy.LoadBalancerSettings?

    public var tlsSetting: TrafficPolicy.TlsSetting?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.loadBalancerSettings?.validate()
        try self.tlsSetting?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerSettings != nil {
            map["LoadBalancerSettings"] = self.loadBalancerSettings?.toMap()
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerSettings") && dict["LoadBalancerSettings"] != nil {
            var model = TrafficPolicy.LoadBalancerSettings()
            model.fromMap(dict["LoadBalancerSettings"] as! [String: Any])
            self.loadBalancerSettings = model
        }
        if dict.keys.contains("TlsSetting") && dict["TlsSetting"] != nil {
            var model = TrafficPolicy.TlsSetting()
            model.fromMap(dict["TlsSetting"] as! [String: Any])
            self.tlsSetting = model
        }
    }
}

public class RulesValue : Tea.TeaModel {
    public class Rules : Tea.TeaModel {
        public class Springcloud : Tea.TeaModel {
            public class RestItems : Tea.TeaModel {
                public var datum: String?

                public var operator_: String?

                public var nameList: [String]?

                public var cond: String?

                public var divisor: Int32?

                public var remainder: Int32?

                public var rate: Int32?

                public var type: String?

                public var name: String?

                public var value: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("datum") && dict["datum"] != nil {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("operator") && dict["operator"] != nil {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("nameList") && dict["nameList"] != nil {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("cond") && dict["cond"] != nil {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("divisor") && dict["divisor"] != nil {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("remainder") && dict["remainder"] != nil {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("rate") && dict["rate"] != nil {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("type") && dict["type"] != nil {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("value") && dict["value"] != nil {
                        self.value = dict["value"] as! Any
                    }
                }
            }
            public var condition: String?

            public var restItems: [RulesValue.Rules.Springcloud.RestItems]?

            public var triggerPolicy: String?

            public var enable: Bool?

            public var appId: String?

            public var priority: Int32?

            public var tags: [String]?

            public var paths: [String]?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.restItems != nil {
                    var tmp : [Any] = []
                    for k in self.restItems! {
                        tmp.append(k.toMap())
                    }
                    map["restItems"] = tmp
                }
                if self.triggerPolicy != nil {
                    map["triggerPolicy"] = self.triggerPolicy!
                }
                if self.enable != nil {
                    map["enable"] = self.enable!
                }
                if self.appId != nil {
                    map["appId"] = self.appId!
                }
                if self.priority != nil {
                    map["priority"] = self.priority!
                }
                if self.tags != nil {
                    map["tags"] = self.tags!
                }
                if self.paths != nil {
                    map["paths"] = self.paths!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") && dict["condition"] != nil {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("restItems") && dict["restItems"] != nil {
                    var tmp : [RulesValue.Rules.Springcloud.RestItems] = []
                    for v in dict["restItems"] as! [Any] {
                        var model = RulesValue.Rules.Springcloud.RestItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restItems = tmp
                }
                if dict.keys.contains("triggerPolicy") && dict["triggerPolicy"] != nil {
                    self.triggerPolicy = dict["triggerPolicy"] as! String
                }
                if dict.keys.contains("enable") && dict["enable"] != nil {
                    self.enable = dict["enable"] as! Bool
                }
                if dict.keys.contains("appId") && dict["appId"] != nil {
                    self.appId = dict["appId"] as! String
                }
                if dict.keys.contains("priority") && dict["priority"] != nil {
                    self.priority = dict["priority"] as! Int32
                }
                if dict.keys.contains("tags") && dict["tags"] != nil {
                    self.tags = dict["tags"] as! [String]
                }
                if dict.keys.contains("paths") && dict["paths"] != nil {
                    self.paths = dict["paths"] as! [String]
                }
                if dict.keys.contains("path") && dict["path"] != nil {
                    self.path = dict["path"] as! String
                }
            }
        }
        public class Dubbo : Tea.TeaModel {
            public class ArgumentItems : Tea.TeaModel {
                public var operator_: String?

                public var nameList: [String]?

                public var datum: String?

                public var cond: String?

                public var divisor: Int32?

                public var remainder: Int32?

                public var rate: Int32?

                public var index: Int32?

                public var expr: String?

                public var value: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.index != nil {
                        map["index"] = self.index!
                    }
                    if self.expr != nil {
                        map["expr"] = self.expr!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("operator") && dict["operator"] != nil {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("nameList") && dict["nameList"] != nil {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("datum") && dict["datum"] != nil {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("cond") && dict["cond"] != nil {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("divisor") && dict["divisor"] != nil {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("remainder") && dict["remainder"] != nil {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("rate") && dict["rate"] != nil {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("index") && dict["index"] != nil {
                        self.index = dict["index"] as! Int32
                    }
                    if dict.keys.contains("expr") && dict["expr"] != nil {
                        self.expr = dict["expr"] as! String
                    }
                    if dict.keys.contains("value") && dict["value"] != nil {
                        self.value = dict["value"] as! Any
                    }
                }
            }
            public var appId: String?

            public var tags: [String]?

            public var triggerPolicy: String?

            public var serviceName: String?

            public var group: String?

            public var version: String?

            public var methodName: String?

            public var paramTypes: [String]?

            public var condition: String?

            public var argumentItems: [RulesValue.Rules.Dubbo.ArgumentItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["appId"] = self.appId!
                }
                if self.tags != nil {
                    map["tags"] = self.tags!
                }
                if self.triggerPolicy != nil {
                    map["triggerPolicy"] = self.triggerPolicy!
                }
                if self.serviceName != nil {
                    map["serviceName"] = self.serviceName!
                }
                if self.group != nil {
                    map["group"] = self.group!
                }
                if self.version != nil {
                    map["version"] = self.version!
                }
                if self.methodName != nil {
                    map["methodName"] = self.methodName!
                }
                if self.paramTypes != nil {
                    map["paramTypes"] = self.paramTypes!
                }
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.argumentItems != nil {
                    var tmp : [Any] = []
                    for k in self.argumentItems! {
                        tmp.append(k.toMap())
                    }
                    map["argumentItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("appId") && dict["appId"] != nil {
                    self.appId = dict["appId"] as! String
                }
                if dict.keys.contains("tags") && dict["tags"] != nil {
                    self.tags = dict["tags"] as! [String]
                }
                if dict.keys.contains("triggerPolicy") && dict["triggerPolicy"] != nil {
                    self.triggerPolicy = dict["triggerPolicy"] as! String
                }
                if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                    self.serviceName = dict["serviceName"] as! String
                }
                if dict.keys.contains("group") && dict["group"] != nil {
                    self.group = dict["group"] as! String
                }
                if dict.keys.contains("version") && dict["version"] != nil {
                    self.version = dict["version"] as! String
                }
                if dict.keys.contains("methodName") && dict["methodName"] != nil {
                    self.methodName = dict["methodName"] as! String
                }
                if dict.keys.contains("paramTypes") && dict["paramTypes"] != nil {
                    self.paramTypes = dict["paramTypes"] as! [String]
                }
                if dict.keys.contains("condition") && dict["condition"] != nil {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("argumentItems") && dict["argumentItems"] != nil {
                    var tmp : [RulesValue.Rules.Dubbo.ArgumentItems] = []
                    for v in dict["argumentItems"] as! [Any] {
                        var model = RulesValue.Rules.Dubbo.ArgumentItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.argumentItems = tmp
                }
            }
        }
        public var springcloud: [RulesValue.Rules.Springcloud]?

        public var dubbo: [RulesValue.Rules.Dubbo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.springcloud != nil {
                var tmp : [Any] = []
                for k in self.springcloud! {
                    tmp.append(k.toMap())
                }
                map["springcloud"] = tmp
            }
            if self.dubbo != nil {
                var tmp : [Any] = []
                for k in self.dubbo! {
                    tmp.append(k.toMap())
                }
                map["dubbo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("springcloud") && dict["springcloud"] != nil {
                var tmp : [RulesValue.Rules.Springcloud] = []
                for v in dict["springcloud"] as! [Any] {
                    var model = RulesValue.Rules.Springcloud()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.springcloud = tmp
            }
            if dict.keys.contains("dubbo") && dict["dubbo"] != nil {
                var tmp : [RulesValue.Rules.Dubbo] = []
                for v in dict["dubbo"] as! [Any] {
                    var model = RulesValue.Rules.Dubbo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dubbo = tmp
            }
        }
    }
    public var status: Int32?

    public var rate: Int32?

    public var enable: Bool?

    public var tag: String?

    public var name: String?

    public var id: Int64?

    public var instanceNum: Int32?

    public var rules: RulesValue.Rules?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.rules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.rate != nil {
            map["Rate"] = self.rate!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceNum != nil {
            map["InstanceNum"] = self.instanceNum!
        }
        if self.rules != nil {
            map["Rules"] = self.rules?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Rate") && dict["Rate"] != nil {
            self.rate = dict["Rate"] as! Int32
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("InstanceNum") && dict["InstanceNum"] != nil {
            self.instanceNum = dict["InstanceNum"] as! Int32
        }
        if dict.keys.contains("Rules") && dict["Rules"] != nil {
            var model = RulesValue.Rules()
            model.fromMap(dict["Rules"] as! [String: Any])
            self.rules = model
        }
    }
}

public class DataValue : Tea.TeaModel {
    public var userId: String?

    public var regionId: String?

    public var namespace: String?

    public var appName: String?

    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class AddAuthPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var authRule: String?

    public var authType: Int32?

    public var enable: String?

    public var k8sNamespace: String?

    public var name: String?

    public var namespace: String?

    public var protocol_: String?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authRule != nil {
            map["AuthRule"] = self.authRule!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.k8sNamespace != nil {
            map["K8sNamespace"] = self.k8sNamespace!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AuthRule") && dict["AuthRule"] != nil {
            self.authRule = dict["AuthRule"] as! String
        }
        if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
            self.authType = dict["AuthType"] as! Int32
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! String
        }
        if dict.keys.contains("K8sNamespace") && dict["K8sNamespace"] != nil {
            self.k8sNamespace = dict["K8sNamespace"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class AddAuthPolicyResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAuthPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAuthPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddAuthPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAuthResourceRequest : Tea.TeaModel {
    public class AuthResourceHeaderList : Tea.TeaModel {
        public var headerKey: String?

        public var headerMethod: String?

        public var headerValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerKey != nil {
                map["HeaderKey"] = self.headerKey!
            }
            if self.headerMethod != nil {
                map["HeaderMethod"] = self.headerMethod!
            }
            if self.headerValue != nil {
                map["HeaderValue"] = self.headerValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HeaderKey") && dict["HeaderKey"] != nil {
                self.headerKey = dict["HeaderKey"] as! String
            }
            if dict.keys.contains("HeaderMethod") && dict["HeaderMethod"] != nil {
                self.headerMethod = dict["HeaderMethod"] as! String
            }
            if dict.keys.contains("HeaderValue") && dict["HeaderValue"] != nil {
                self.headerValue = dict["HeaderValue"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var authId: Int64?

    public var authResourceHeaderList: [AddAuthResourceRequest.AuthResourceHeaderList]?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public var ignoreCase: Bool?

    public var matchType: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authId != nil {
            map["AuthId"] = self.authId!
        }
        if self.authResourceHeaderList != nil {
            var tmp : [Any] = []
            for k in self.authResourceHeaderList! {
                tmp.append(k.toMap())
            }
            map["AuthResourceHeaderList"] = tmp
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.ignoreCase != nil {
            map["IgnoreCase"] = self.ignoreCase!
        }
        if self.matchType != nil {
            map["MatchType"] = self.matchType!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthId") && dict["AuthId"] != nil {
            self.authId = dict["AuthId"] as! Int64
        }
        if dict.keys.contains("AuthResourceHeaderList") && dict["AuthResourceHeaderList"] != nil {
            var tmp : [AddAuthResourceRequest.AuthResourceHeaderList] = []
            for v in dict["AuthResourceHeaderList"] as! [Any] {
                var model = AddAuthResourceRequest.AuthResourceHeaderList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authResourceHeaderList = tmp
        }
        if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IgnoreCase") && dict["IgnoreCase"] != nil {
            self.ignoreCase = dict["IgnoreCase"] as! Bool
        }
        if dict.keys.contains("MatchType") && dict["MatchType"] != nil {
            self.matchType = dict["MatchType"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
    }
}

public class AddAuthResourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var authId: Int64?

    public var authResourceHeaderListShrink: String?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public var ignoreCase: Bool?

    public var matchType: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authId != nil {
            map["AuthId"] = self.authId!
        }
        if self.authResourceHeaderListShrink != nil {
            map["AuthResourceHeaderList"] = self.authResourceHeaderListShrink!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.ignoreCase != nil {
            map["IgnoreCase"] = self.ignoreCase!
        }
        if self.matchType != nil {
            map["MatchType"] = self.matchType!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthId") && dict["AuthId"] != nil {
            self.authId = dict["AuthId"] as! Int64
        }
        if dict.keys.contains("AuthResourceHeaderList") && dict["AuthResourceHeaderList"] != nil {
            self.authResourceHeaderListShrink = dict["AuthResourceHeaderList"] as! String
        }
        if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IgnoreCase") && dict["IgnoreCase"] != nil {
            self.ignoreCase = dict["IgnoreCase"] as! Bool
        }
        if dict.keys.contains("MatchType") && dict["MatchType"] != nil {
            self.matchType = dict["MatchType"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
    }
}

public class AddAuthResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAuthResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAuthResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddAuthResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddBlackWhiteListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var content: String?

    public var gatewayUniqueId: String?

    public var isWhite: Bool?

    public var name: String?

    public var note: String?

    public var resourceIdJsonList: String?

    public var resourceType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.resourceIdJsonList != nil {
            map["ResourceIdJsonList"] = self.resourceIdJsonList!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsWhite") && dict["IsWhite"] != nil {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("ResourceIdJsonList") && dict["ResourceIdJsonList"] != nil {
            self.resourceIdJsonList = dict["ResourceIdJsonList"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddBlackWhiteListResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class ZoneInfo : Tea.TeaModel {
        public var vSwitchId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var chargeType: String?

    public var enableHardwareAcceleration: Bool?

    public var enableSls: Bool?

    public var enableXtrace: Bool?

    public var enterpriseSecurityGroup: Bool?

    public var internetSlbSpec: String?

    public var mserVersion: String?

    public var name: String?

    public var nlbNetworkType: String?

    public var region: String?

    public var replica: Int32?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var slbSpec: String?

    public var spec: String?

    public var tag: [AddGatewayRequest.Tag]?

    public var vSwitchId: String?

    public var vSwitchId2: String?

    public var vpc: String?

    public var xtraceRatio: String?

    public var zoneInfo: [AddGatewayRequest.ZoneInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.enableHardwareAcceleration != nil {
            map["EnableHardwareAcceleration"] = self.enableHardwareAcceleration!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.enableXtrace != nil {
            map["EnableXtrace"] = self.enableXtrace!
        }
        if self.enterpriseSecurityGroup != nil {
            map["EnterpriseSecurityGroup"] = self.enterpriseSecurityGroup!
        }
        if self.internetSlbSpec != nil {
            map["InternetSlbSpec"] = self.internetSlbSpec!
        }
        if self.mserVersion != nil {
            map["MserVersion"] = self.mserVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nlbNetworkType != nil {
            map["NlbNetworkType"] = self.nlbNetworkType!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.replica != nil {
            map["Replica"] = self.replica!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slbSpec != nil {
            map["SlbSpec"] = self.slbSpec!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchId2 != nil {
            map["VSwitchId2"] = self.vSwitchId2!
        }
        if self.vpc != nil {
            map["Vpc"] = self.vpc!
        }
        if self.xtraceRatio != nil {
            map["XtraceRatio"] = self.xtraceRatio!
        }
        if self.zoneInfo != nil {
            var tmp : [Any] = []
            for k in self.zoneInfo! {
                tmp.append(k.toMap())
            }
            map["ZoneInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("EnableHardwareAcceleration") && dict["EnableHardwareAcceleration"] != nil {
            self.enableHardwareAcceleration = dict["EnableHardwareAcceleration"] as! Bool
        }
        if dict.keys.contains("EnableSls") && dict["EnableSls"] != nil {
            self.enableSls = dict["EnableSls"] as! Bool
        }
        if dict.keys.contains("EnableXtrace") && dict["EnableXtrace"] != nil {
            self.enableXtrace = dict["EnableXtrace"] as! Bool
        }
        if dict.keys.contains("EnterpriseSecurityGroup") && dict["EnterpriseSecurityGroup"] != nil {
            self.enterpriseSecurityGroup = dict["EnterpriseSecurityGroup"] as! Bool
        }
        if dict.keys.contains("InternetSlbSpec") && dict["InternetSlbSpec"] != nil {
            self.internetSlbSpec = dict["InternetSlbSpec"] as! String
        }
        if dict.keys.contains("MserVersion") && dict["MserVersion"] != nil {
            self.mserVersion = dict["MserVersion"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NlbNetworkType") && dict["NlbNetworkType"] != nil {
            self.nlbNetworkType = dict["NlbNetworkType"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Replica") && dict["Replica"] != nil {
            self.replica = dict["Replica"] as! Int32
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlbSpec") && dict["SlbSpec"] != nil {
            self.slbSpec = dict["SlbSpec"] as! String
        }
        if dict.keys.contains("Spec") && dict["Spec"] != nil {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [AddGatewayRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AddGatewayRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchId2") && dict["VSwitchId2"] != nil {
            self.vSwitchId2 = dict["VSwitchId2"] as! String
        }
        if dict.keys.contains("Vpc") && dict["Vpc"] != nil {
            self.vpc = dict["Vpc"] as! String
        }
        if dict.keys.contains("XtraceRatio") && dict["XtraceRatio"] != nil {
            self.xtraceRatio = dict["XtraceRatio"] as! String
        }
        if dict.keys.contains("ZoneInfo") && dict["ZoneInfo"] != nil {
            var tmp : [AddGatewayRequest.ZoneInfo] = []
            for v in dict["ZoneInfo"] as! [Any] {
                var model = AddGatewayRequest.ZoneInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.zoneInfo = tmp
        }
    }
}

public class AddGatewayShrinkRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var chargeType: String?

    public var enableHardwareAcceleration: Bool?

    public var enableSls: Bool?

    public var enableXtrace: Bool?

    public var enterpriseSecurityGroup: Bool?

    public var internetSlbSpec: String?

    public var mserVersion: String?

    public var name: String?

    public var nlbNetworkType: String?

    public var region: String?

    public var replica: Int32?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var slbSpec: String?

    public var spec: String?

    public var tag: [AddGatewayShrinkRequest.Tag]?

    public var vSwitchId: String?

    public var vSwitchId2: String?

    public var vpc: String?

    public var xtraceRatio: String?

    public var zoneInfoShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.enableHardwareAcceleration != nil {
            map["EnableHardwareAcceleration"] = self.enableHardwareAcceleration!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.enableXtrace != nil {
            map["EnableXtrace"] = self.enableXtrace!
        }
        if self.enterpriseSecurityGroup != nil {
            map["EnterpriseSecurityGroup"] = self.enterpriseSecurityGroup!
        }
        if self.internetSlbSpec != nil {
            map["InternetSlbSpec"] = self.internetSlbSpec!
        }
        if self.mserVersion != nil {
            map["MserVersion"] = self.mserVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nlbNetworkType != nil {
            map["NlbNetworkType"] = self.nlbNetworkType!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.replica != nil {
            map["Replica"] = self.replica!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slbSpec != nil {
            map["SlbSpec"] = self.slbSpec!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchId2 != nil {
            map["VSwitchId2"] = self.vSwitchId2!
        }
        if self.vpc != nil {
            map["Vpc"] = self.vpc!
        }
        if self.xtraceRatio != nil {
            map["XtraceRatio"] = self.xtraceRatio!
        }
        if self.zoneInfoShrink != nil {
            map["ZoneInfo"] = self.zoneInfoShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("EnableHardwareAcceleration") && dict["EnableHardwareAcceleration"] != nil {
            self.enableHardwareAcceleration = dict["EnableHardwareAcceleration"] as! Bool
        }
        if dict.keys.contains("EnableSls") && dict["EnableSls"] != nil {
            self.enableSls = dict["EnableSls"] as! Bool
        }
        if dict.keys.contains("EnableXtrace") && dict["EnableXtrace"] != nil {
            self.enableXtrace = dict["EnableXtrace"] as! Bool
        }
        if dict.keys.contains("EnterpriseSecurityGroup") && dict["EnterpriseSecurityGroup"] != nil {
            self.enterpriseSecurityGroup = dict["EnterpriseSecurityGroup"] as! Bool
        }
        if dict.keys.contains("InternetSlbSpec") && dict["InternetSlbSpec"] != nil {
            self.internetSlbSpec = dict["InternetSlbSpec"] as! String
        }
        if dict.keys.contains("MserVersion") && dict["MserVersion"] != nil {
            self.mserVersion = dict["MserVersion"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NlbNetworkType") && dict["NlbNetworkType"] != nil {
            self.nlbNetworkType = dict["NlbNetworkType"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Replica") && dict["Replica"] != nil {
            self.replica = dict["Replica"] as! Int32
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlbSpec") && dict["SlbSpec"] != nil {
            self.slbSpec = dict["SlbSpec"] as! String
        }
        if dict.keys.contains("Spec") && dict["Spec"] != nil {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [AddGatewayShrinkRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AddGatewayShrinkRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchId2") && dict["VSwitchId2"] != nil {
            self.vSwitchId2 = dict["VSwitchId2"] as! String
        }
        if dict.keys.contains("Vpc") && dict["Vpc"] != nil {
            self.vpc = dict["Vpc"] as! String
        }
        if dict.keys.contains("XtraceRatio") && dict["XtraceRatio"] != nil {
            self.xtraceRatio = dict["XtraceRatio"] as! String
        }
        if dict.keys.contains("ZoneInfo") && dict["ZoneInfo"] != nil {
            self.zoneInfoShrink = dict["ZoneInfo"] as! String
        }
    }
}

public class AddGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gatewayUniqueId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AddGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AddGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayAuthConsumerRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var encodeType: String?

    public var gatewayUniqueId: String?

    public var jwks: String?

    public var keyName: String?

    public var keyValue: String?

    public var name: String?

    public var tokenName: String?

    public var tokenPass: Bool?

    public var tokenPosition: String?

    public var tokenPrefix: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.encodeType != nil {
            map["EncodeType"] = self.encodeType!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.jwks != nil {
            map["Jwks"] = self.jwks!
        }
        if self.keyName != nil {
            map["KeyName"] = self.keyName!
        }
        if self.keyValue != nil {
            map["KeyValue"] = self.keyValue!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tokenName != nil {
            map["TokenName"] = self.tokenName!
        }
        if self.tokenPass != nil {
            map["TokenPass"] = self.tokenPass!
        }
        if self.tokenPosition != nil {
            map["TokenPosition"] = self.tokenPosition!
        }
        if self.tokenPrefix != nil {
            map["TokenPrefix"] = self.tokenPrefix!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EncodeType") && dict["EncodeType"] != nil {
            self.encodeType = dict["EncodeType"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Jwks") && dict["Jwks"] != nil {
            self.jwks = dict["Jwks"] as! String
        }
        if dict.keys.contains("KeyName") && dict["KeyName"] != nil {
            self.keyName = dict["KeyName"] as! String
        }
        if dict.keys.contains("KeyValue") && dict["KeyValue"] != nil {
            self.keyValue = dict["KeyValue"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TokenName") && dict["TokenName"] != nil {
            self.tokenName = dict["TokenName"] as! String
        }
        if dict.keys.contains("TokenPass") && dict["TokenPass"] != nil {
            self.tokenPass = dict["TokenPass"] as! Bool
        }
        if dict.keys.contains("TokenPosition") && dict["TokenPosition"] != nil {
            self.tokenPosition = dict["TokenPosition"] as! String
        }
        if dict.keys.contains("TokenPrefix") && dict["TokenPrefix"] != nil {
            self.tokenPrefix = dict["TokenPrefix"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddGatewayAuthConsumerResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayAuthConsumerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayAuthConsumerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddGatewayAuthConsumerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var gatewayUniqueId: String?

    public var http2: String?

    public var mustHttps: Bool?

    public var name: String?

    public var protocol_: String?

    public var tlsMax: String?

    public var tlsMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.http2 != nil {
            map["Http2"] = self.http2!
        }
        if self.mustHttps != nil {
            map["MustHttps"] = self.mustHttps!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.tlsMax != nil {
            map["TlsMax"] = self.tlsMax!
        }
        if self.tlsMin != nil {
            map["TlsMin"] = self.tlsMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") && dict["CertIdentifier"] != nil {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Http2") && dict["Http2"] != nil {
            self.http2 = dict["Http2"] as! String
        }
        if dict.keys.contains("MustHttps") && dict["MustHttps"] != nil {
            self.mustHttps = dict["MustHttps"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TlsMax") && dict["TlsMax"] != nil {
            self.tlsMax = dict["TlsMax"] as! String
        }
        if dict.keys.contains("TlsMin") && dict["TlsMin"] != nil {
            self.tlsMin = dict["TlsMin"] as! String
        }
    }
}

public class AddGatewayDomainResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayRouteRequest : Tea.TeaModel {
    public class DirectResponseJSON : Tea.TeaModel {
        public var body: String?

        public var code: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.body != nil {
                map["Body"] = self.body!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Body") && dict["Body"] != nil {
                self.body = dict["Body"] as! String
            }
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! Int64
            }
        }
    }
    public class FallbackServices : Tea.TeaModel {
        public var agreementType: String?

        public var groupName: String?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") && dict["AgreementType"] != nil {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") && dict["Percent"] != nil {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public class Predicates : Tea.TeaModel {
        public class HeaderPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class PathPredicates : Tea.TeaModel {
            public var ignoreCase: Bool?

            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ignoreCase != nil {
                    map["IgnoreCase"] = self.ignoreCase!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IgnoreCase") && dict["IgnoreCase"] != nil {
                    self.ignoreCase = dict["IgnoreCase"] as! Bool
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class QueryPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var headerPredicates: [AddGatewayRouteRequest.Predicates.HeaderPredicates]?

        public var methodPredicates: [String]?

        public var pathPredicates: AddGatewayRouteRequest.Predicates.PathPredicates?

        public var queryPredicates: [AddGatewayRouteRequest.Predicates.QueryPredicates]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pathPredicates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerPredicates != nil {
                var tmp : [Any] = []
                for k in self.headerPredicates! {
                    tmp.append(k.toMap())
                }
                map["HeaderPredicates"] = tmp
            }
            if self.methodPredicates != nil {
                map["MethodPredicates"] = self.methodPredicates!
            }
            if self.pathPredicates != nil {
                map["PathPredicates"] = self.pathPredicates?.toMap()
            }
            if self.queryPredicates != nil {
                var tmp : [Any] = []
                for k in self.queryPredicates! {
                    tmp.append(k.toMap())
                }
                map["QueryPredicates"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HeaderPredicates") && dict["HeaderPredicates"] != nil {
                var tmp : [AddGatewayRouteRequest.Predicates.HeaderPredicates] = []
                for v in dict["HeaderPredicates"] as! [Any] {
                    var model = AddGatewayRouteRequest.Predicates.HeaderPredicates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.headerPredicates = tmp
            }
            if dict.keys.contains("MethodPredicates") && dict["MethodPredicates"] != nil {
                self.methodPredicates = dict["MethodPredicates"] as! [String]
            }
            if dict.keys.contains("PathPredicates") && dict["PathPredicates"] != nil {
                var model = AddGatewayRouteRequest.Predicates.PathPredicates()
                model.fromMap(dict["PathPredicates"] as! [String: Any])
                self.pathPredicates = model
            }
            if dict.keys.contains("QueryPredicates") && dict["QueryPredicates"] != nil {
                var tmp : [AddGatewayRouteRequest.Predicates.QueryPredicates] = []
                for v in dict["QueryPredicates"] as! [Any] {
                    var model = AddGatewayRouteRequest.Predicates.QueryPredicates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.queryPredicates = tmp
            }
        }
    }
    public class RedirectJSON : Tea.TeaModel {
        public var code: Int32?

        public var host: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! Int32
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class Services : Tea.TeaModel {
        public class HttpDubboTranscoder : Tea.TeaModel {
            public class MothedMapList : Tea.TeaModel {
                public class ParamMapsList : Tea.TeaModel {
                    public var extractKey: String?

                    public var extractKeySpec: String?

                    public var mappingType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extractKey != nil {
                            map["ExtractKey"] = self.extractKey!
                        }
                        if self.extractKeySpec != nil {
                            map["ExtractKeySpec"] = self.extractKeySpec!
                        }
                        if self.mappingType != nil {
                            map["MappingType"] = self.mappingType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtractKey") && dict["ExtractKey"] != nil {
                            self.extractKey = dict["ExtractKey"] as! String
                        }
                        if dict.keys.contains("ExtractKeySpec") && dict["ExtractKeySpec"] != nil {
                            self.extractKeySpec = dict["ExtractKeySpec"] as! String
                        }
                        if dict.keys.contains("MappingType") && dict["MappingType"] != nil {
                            self.mappingType = dict["MappingType"] as! String
                        }
                    }
                }
                public var dubboMothedName: String?

                public var httpMothed: String?

                public var mothedpath: String?

                public var paramMapsList: [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                public var passThroughAllHeaders: String?

                public var passThroughList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dubboMothedName != nil {
                        map["DubboMothedName"] = self.dubboMothedName!
                    }
                    if self.httpMothed != nil {
                        map["HttpMothed"] = self.httpMothed!
                    }
                    if self.mothedpath != nil {
                        map["Mothedpath"] = self.mothedpath!
                    }
                    if self.paramMapsList != nil {
                        var tmp : [Any] = []
                        for k in self.paramMapsList! {
                            tmp.append(k.toMap())
                        }
                        map["ParamMapsList"] = tmp
                    }
                    if self.passThroughAllHeaders != nil {
                        map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                    }
                    if self.passThroughList != nil {
                        map["PassThroughList"] = self.passThroughList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DubboMothedName") && dict["DubboMothedName"] != nil {
                        self.dubboMothedName = dict["DubboMothedName"] as! String
                    }
                    if dict.keys.contains("HttpMothed") && dict["HttpMothed"] != nil {
                        self.httpMothed = dict["HttpMothed"] as! String
                    }
                    if dict.keys.contains("Mothedpath") && dict["Mothedpath"] != nil {
                        self.mothedpath = dict["Mothedpath"] as! String
                    }
                    if dict.keys.contains("ParamMapsList") && dict["ParamMapsList"] != nil {
                        var tmp : [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList] = []
                        for v in dict["ParamMapsList"] as! [Any] {
                            var model = AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.paramMapsList = tmp
                    }
                    if dict.keys.contains("PassThroughAllHeaders") && dict["PassThroughAllHeaders"] != nil {
                        self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                    }
                    if dict.keys.contains("PassThroughList") && dict["PassThroughList"] != nil {
                        self.passThroughList = dict["PassThroughList"] as! [String]
                    }
                }
            }
            public var dubboServiceGroup: String?

            public var dubboServiceName: String?

            public var dubboServiceVersion: String?

            public var mothedMapList: [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dubboServiceGroup != nil {
                    map["DubboServiceGroup"] = self.dubboServiceGroup!
                }
                if self.dubboServiceName != nil {
                    map["DubboServiceName"] = self.dubboServiceName!
                }
                if self.dubboServiceVersion != nil {
                    map["DubboServiceVersion"] = self.dubboServiceVersion!
                }
                if self.mothedMapList != nil {
                    var tmp : [Any] = []
                    for k in self.mothedMapList! {
                        tmp.append(k.toMap())
                    }
                    map["MothedMapList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DubboServiceGroup") && dict["DubboServiceGroup"] != nil {
                    self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                }
                if dict.keys.contains("DubboServiceName") && dict["DubboServiceName"] != nil {
                    self.dubboServiceName = dict["DubboServiceName"] as! String
                }
                if dict.keys.contains("DubboServiceVersion") && dict["DubboServiceVersion"] != nil {
                    self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                }
                if dict.keys.contains("MothedMapList") && dict["MothedMapList"] != nil {
                    var tmp : [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList] = []
                    for v in dict["MothedMapList"] as! [Any] {
                        var model = AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.mothedMapList = tmp
                }
            }
        }
        public var agreementType: String?

        public var groupName: String?

        public var httpDubboTranscoder: AddGatewayRouteRequest.Services.HttpDubboTranscoder?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.httpDubboTranscoder?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.httpDubboTranscoder != nil {
                map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") && dict["AgreementType"] != nil {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HttpDubboTranscoder") && dict["HttpDubboTranscoder"] != nil {
                var model = AddGatewayRouteRequest.Services.HttpDubboTranscoder()
                model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                self.httpDubboTranscoder = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") && dict["Percent"] != nil {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var description_: String?

    public var destinationType: String?

    public var directResponseJSON: AddGatewayRouteRequest.DirectResponseJSON?

    public var domainId: Int64?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServices: [AddGatewayRouteRequest.FallbackServices]?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var name: String?

    public var policies: String?

    public var predicates: AddGatewayRouteRequest.Predicates?

    public var redirectJSON: AddGatewayRouteRequest.RedirectJSON?

    public var routeOrder: Int32?

    public var routeType: String?

    public var services: [AddGatewayRouteRequest.Services]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.directResponseJSON?.validate()
        try self.predicates?.validate()
        try self.redirectJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSON != nil {
            map["DirectResponseJSON"] = self.directResponseJSON?.toMap()
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServices != nil {
            var tmp : [Any] = []
            for k in self.fallbackServices! {
                tmp.append(k.toMap())
            }
            map["FallbackServices"] = tmp
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policies != nil {
            map["Policies"] = self.policies!
        }
        if self.predicates != nil {
            map["Predicates"] = self.predicates?.toMap()
        }
        if self.redirectJSON != nil {
            map["RedirectJSON"] = self.redirectJSON?.toMap()
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.routeType != nil {
            map["RouteType"] = self.routeType!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationType") && dict["DestinationType"] != nil {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") && dict["DirectResponseJSON"] != nil {
            var model = AddGatewayRouteRequest.DirectResponseJSON()
            model.fromMap(dict["DirectResponseJSON"] as! [String: Any])
            self.directResponseJSON = model
        }
        if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("DomainIdListJSON") && dict["DomainIdListJSON"] != nil {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") && dict["Fallback"] != nil {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") && dict["FallbackServices"] != nil {
            var tmp : [AddGatewayRouteRequest.FallbackServices] = []
            for v in dict["FallbackServices"] as! [Any] {
                var model = AddGatewayRouteRequest.FallbackServices()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fallbackServices = tmp
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Policies") && dict["Policies"] != nil {
            self.policies = dict["Policies"] as! String
        }
        if dict.keys.contains("Predicates") && dict["Predicates"] != nil {
            var model = AddGatewayRouteRequest.Predicates()
            model.fromMap(dict["Predicates"] as! [String: Any])
            self.predicates = model
        }
        if dict.keys.contains("RedirectJSON") && dict["RedirectJSON"] != nil {
            var model = AddGatewayRouteRequest.RedirectJSON()
            model.fromMap(dict["RedirectJSON"] as! [String: Any])
            self.redirectJSON = model
        }
        if dict.keys.contains("RouteOrder") && dict["RouteOrder"] != nil {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("RouteType") && dict["RouteType"] != nil {
            self.routeType = dict["RouteType"] as! String
        }
        if dict.keys.contains("Services") && dict["Services"] != nil {
            var tmp : [AddGatewayRouteRequest.Services] = []
            for v in dict["Services"] as! [Any] {
                var model = AddGatewayRouteRequest.Services()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.services = tmp
        }
    }
}

public class AddGatewayRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var destinationType: String?

    public var directResponseJSONShrink: String?

    public var domainId: Int64?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServicesShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var name: String?

    public var policies: String?

    public var predicatesShrink: String?

    public var redirectJSONShrink: String?

    public var routeOrder: Int32?

    public var routeType: String?

    public var servicesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSONShrink != nil {
            map["DirectResponseJSON"] = self.directResponseJSONShrink!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServicesShrink != nil {
            map["FallbackServices"] = self.fallbackServicesShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policies != nil {
            map["Policies"] = self.policies!
        }
        if self.predicatesShrink != nil {
            map["Predicates"] = self.predicatesShrink!
        }
        if self.redirectJSONShrink != nil {
            map["RedirectJSON"] = self.redirectJSONShrink!
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.routeType != nil {
            map["RouteType"] = self.routeType!
        }
        if self.servicesShrink != nil {
            map["Services"] = self.servicesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationType") && dict["DestinationType"] != nil {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") && dict["DirectResponseJSON"] != nil {
            self.directResponseJSONShrink = dict["DirectResponseJSON"] as! String
        }
        if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("DomainIdListJSON") && dict["DomainIdListJSON"] != nil {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") && dict["Fallback"] != nil {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") && dict["FallbackServices"] != nil {
            self.fallbackServicesShrink = dict["FallbackServices"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Policies") && dict["Policies"] != nil {
            self.policies = dict["Policies"] as! String
        }
        if dict.keys.contains("Predicates") && dict["Predicates"] != nil {
            self.predicatesShrink = dict["Predicates"] as! String
        }
        if dict.keys.contains("RedirectJSON") && dict["RedirectJSON"] != nil {
            self.redirectJSONShrink = dict["RedirectJSON"] as! String
        }
        if dict.keys.contains("RouteOrder") && dict["RouteOrder"] != nil {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("RouteType") && dict["RouteType"] != nil {
            self.routeType = dict["RouteType"] as! String
        }
        if dict.keys.contains("Services") && dict["Services"] != nil {
            self.servicesShrink = dict["Services"] as! String
        }
    }
}

public class AddGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayServiceVersionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! Int64
        }
        if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class AddGatewayServiceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayServiceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayServiceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddGatewayServiceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewaySlbRequest : Tea.TeaModel {
    public class VServiceList : Tea.TeaModel {
        public var port: Int32?

        public var protocol_: String?

        public var VServerGroupId: String?

        public var VServerGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.VServerGroupId != nil {
                map["VServerGroupId"] = self.VServerGroupId!
            }
            if self.VServerGroupName != nil {
                map["VServerGroupName"] = self.VServerGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                self.VServerGroupId = dict["VServerGroupId"] as! String
            }
            if dict.keys.contains("VServerGroupName") && dict["VServerGroupName"] != nil {
                self.VServerGroupName = dict["VServerGroupName"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var httpPort: Int32?

    public var httpsPort: Int32?

    public var httpsVServerGroupId: String?

    public var serviceWeight: Int32?

    public var slbId: String?

    public var type: String?

    public var VServerGroupId: String?

    public var VServiceList: [AddGatewaySlbRequest.VServiceList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.httpPort != nil {
            map["HttpPort"] = self.httpPort!
        }
        if self.httpsPort != nil {
            map["HttpsPort"] = self.httpsPort!
        }
        if self.httpsVServerGroupId != nil {
            map["HttpsVServerGroupId"] = self.httpsVServerGroupId!
        }
        if self.serviceWeight != nil {
            map["ServiceWeight"] = self.serviceWeight!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.VServerGroupId != nil {
            map["VServerGroupId"] = self.VServerGroupId!
        }
        if self.VServiceList != nil {
            var tmp : [Any] = []
            for k in self.VServiceList! {
                tmp.append(k.toMap())
            }
            map["VServiceList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HttpPort") && dict["HttpPort"] != nil {
            self.httpPort = dict["HttpPort"] as! Int32
        }
        if dict.keys.contains("HttpsPort") && dict["HttpsPort"] != nil {
            self.httpsPort = dict["HttpsPort"] as! Int32
        }
        if dict.keys.contains("HttpsVServerGroupId") && dict["HttpsVServerGroupId"] != nil {
            self.httpsVServerGroupId = dict["HttpsVServerGroupId"] as! String
        }
        if dict.keys.contains("ServiceWeight") && dict["ServiceWeight"] != nil {
            self.serviceWeight = dict["ServiceWeight"] as! Int32
        }
        if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
            self.slbId = dict["SlbId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
            self.VServerGroupId = dict["VServerGroupId"] as! String
        }
        if dict.keys.contains("VServiceList") && dict["VServiceList"] != nil {
            var tmp : [AddGatewaySlbRequest.VServiceList] = []
            for v in dict["VServiceList"] as! [Any] {
                var model = AddGatewaySlbRequest.VServiceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.VServiceList = tmp
        }
    }
}

public class AddGatewaySlbShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var httpPort: Int32?

    public var httpsPort: Int32?

    public var httpsVServerGroupId: String?

    public var serviceWeight: Int32?

    public var slbId: String?

    public var type: String?

    public var VServerGroupId: String?

    public var VServiceListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.httpPort != nil {
            map["HttpPort"] = self.httpPort!
        }
        if self.httpsPort != nil {
            map["HttpsPort"] = self.httpsPort!
        }
        if self.httpsVServerGroupId != nil {
            map["HttpsVServerGroupId"] = self.httpsVServerGroupId!
        }
        if self.serviceWeight != nil {
            map["ServiceWeight"] = self.serviceWeight!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.VServerGroupId != nil {
            map["VServerGroupId"] = self.VServerGroupId!
        }
        if self.VServiceListShrink != nil {
            map["VServiceList"] = self.VServiceListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HttpPort") && dict["HttpPort"] != nil {
            self.httpPort = dict["HttpPort"] as! Int32
        }
        if dict.keys.contains("HttpsPort") && dict["HttpsPort"] != nil {
            self.httpsPort = dict["HttpsPort"] as! Int32
        }
        if dict.keys.contains("HttpsVServerGroupId") && dict["HttpsVServerGroupId"] != nil {
            self.httpsVServerGroupId = dict["HttpsVServerGroupId"] as! String
        }
        if dict.keys.contains("ServiceWeight") && dict["ServiceWeight"] != nil {
            self.serviceWeight = dict["ServiceWeight"] as! Int32
        }
        if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
            self.slbId = dict["SlbId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
            self.VServerGroupId = dict["VServerGroupId"] as! String
        }
        if dict.keys.contains("VServiceList") && dict["VServiceList"] != nil {
            self.VServiceListShrink = dict["VServiceList"] as! String
        }
    }
}

public class AddGatewaySlbResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMigrationTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var originInstanceAddress: String?

    public var originInstanceName: String?

    public var originInstanceNamespace: String?

    public var projectDesc: String?

    public var requestPars: String?

    public var targetClusterName: String?

    public var targetClusterUrl: String?

    public var targetInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.originInstanceAddress != nil {
            map["OriginInstanceAddress"] = self.originInstanceAddress!
        }
        if self.originInstanceName != nil {
            map["OriginInstanceName"] = self.originInstanceName!
        }
        if self.originInstanceNamespace != nil {
            map["OriginInstanceNamespace"] = self.originInstanceNamespace!
        }
        if self.projectDesc != nil {
            map["ProjectDesc"] = self.projectDesc!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.targetClusterName != nil {
            map["TargetClusterName"] = self.targetClusterName!
        }
        if self.targetClusterUrl != nil {
            map["TargetClusterUrl"] = self.targetClusterUrl!
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("OriginInstanceAddress") && dict["OriginInstanceAddress"] != nil {
            self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
        }
        if dict.keys.contains("OriginInstanceName") && dict["OriginInstanceName"] != nil {
            self.originInstanceName = dict["OriginInstanceName"] as! String
        }
        if dict.keys.contains("OriginInstanceNamespace") && dict["OriginInstanceNamespace"] != nil {
            self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
        }
        if dict.keys.contains("ProjectDesc") && dict["ProjectDesc"] != nil {
            self.projectDesc = dict["ProjectDesc"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("TargetClusterName") && dict["TargetClusterName"] != nil {
            self.targetClusterName = dict["TargetClusterName"] as! String
        }
        if dict.keys.contains("TargetClusterUrl") && dict["TargetClusterUrl"] != nil {
            self.targetClusterUrl = dict["TargetClusterUrl"] as! String
        }
        if dict.keys.contains("TargetInstanceId") && dict["TargetInstanceId"] != nil {
            self.targetInstanceId = dict["TargetInstanceId"] as! String
        }
    }
}

public class AddMigrationTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterType: String?

        public var id: String?

        public var originInstanceAddress: String?

        public var originInstanceName: String?

        public var originInstanceNamespace: String?

        public var projectDesc: String?

        public var targetClusterName: String?

        public var targetClusterUrl: String?

        public var targetInstanceId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.originInstanceAddress != nil {
                map["OriginInstanceAddress"] = self.originInstanceAddress!
            }
            if self.originInstanceName != nil {
                map["OriginInstanceName"] = self.originInstanceName!
            }
            if self.originInstanceNamespace != nil {
                map["OriginInstanceNamespace"] = self.originInstanceNamespace!
            }
            if self.projectDesc != nil {
                map["ProjectDesc"] = self.projectDesc!
            }
            if self.targetClusterName != nil {
                map["TargetClusterName"] = self.targetClusterName!
            }
            if self.targetClusterUrl != nil {
                map["TargetClusterUrl"] = self.targetClusterUrl!
            }
            if self.targetInstanceId != nil {
                map["TargetInstanceId"] = self.targetInstanceId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("OriginInstanceAddress") && dict["OriginInstanceAddress"] != nil {
                self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
            }
            if dict.keys.contains("OriginInstanceName") && dict["OriginInstanceName"] != nil {
                self.originInstanceName = dict["OriginInstanceName"] as! String
            }
            if dict.keys.contains("OriginInstanceNamespace") && dict["OriginInstanceNamespace"] != nil {
                self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
            }
            if dict.keys.contains("ProjectDesc") && dict["ProjectDesc"] != nil {
                self.projectDesc = dict["ProjectDesc"] as! String
            }
            if dict.keys.contains("TargetClusterName") && dict["TargetClusterName"] != nil {
                self.targetClusterName = dict["TargetClusterName"] as! String
            }
            if dict.keys.contains("TargetClusterUrl") && dict["TargetClusterUrl"] != nil {
                self.targetClusterUrl = dict["TargetClusterUrl"] as! String
            }
            if dict.keys.contains("TargetInstanceId") && dict["TargetInstanceId"] != nil {
                self.targetInstanceId = dict["TargetInstanceId"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var data: AddMigrationTaskResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AddMigrationTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddMigrationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMigrationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddMigrationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMockRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerAppIds: String?

    public var dubboMockItems: String?

    public var enable: Bool?

    public var extraJson: String?

    public var mockType: Int64?

    public var name: String?

    public var providerAppId: String?

    public var providerAppName: String?

    public var region: String?

    public var scMockItems: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerAppIds != nil {
            map["ConsumerAppIds"] = self.consumerAppIds!
        }
        if self.dubboMockItems != nil {
            map["DubboMockItems"] = self.dubboMockItems!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.extraJson != nil {
            map["ExtraJson"] = self.extraJson!
        }
        if self.mockType != nil {
            map["MockType"] = self.mockType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.providerAppId != nil {
            map["ProviderAppId"] = self.providerAppId!
        }
        if self.providerAppName != nil {
            map["ProviderAppName"] = self.providerAppName!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.scMockItems != nil {
            map["ScMockItems"] = self.scMockItems!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerAppIds") && dict["ConsumerAppIds"] != nil {
            self.consumerAppIds = dict["ConsumerAppIds"] as! String
        }
        if dict.keys.contains("DubboMockItems") && dict["DubboMockItems"] != nil {
            self.dubboMockItems = dict["DubboMockItems"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("ExtraJson") && dict["ExtraJson"] != nil {
            self.extraJson = dict["ExtraJson"] as! String
        }
        if dict.keys.contains("MockType") && dict["MockType"] != nil {
            self.mockType = dict["MockType"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProviderAppId") && dict["ProviderAppId"] != nil {
            self.providerAppId = dict["ProviderAppId"] as! String
        }
        if dict.keys.contains("ProviderAppName") && dict["ProviderAppName"] != nil {
            self.providerAppName = dict["ProviderAppName"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ScMockItems") && dict["ScMockItems"] != nil {
            self.scMockItems = dict["ScMockItems"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class AddMockRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountId: String?

        public var consumerAppId: String?

        public var consumerAppName: String?

        public var enable: Bool?

        public var extraJson: String?

        public var id: Int64?

        public var mockType: Int64?

        public var name: String?

        public var namespaceId: String?

        public var providerAppId: String?

        public var providerAppName: String?

        public var region: String?

        public var scMockItemJson: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.consumerAppId != nil {
                map["ConsumerAppId"] = self.consumerAppId!
            }
            if self.consumerAppName != nil {
                map["ConsumerAppName"] = self.consumerAppName!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.extraJson != nil {
                map["ExtraJson"] = self.extraJson!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mockType != nil {
                map["MockType"] = self.mockType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.providerAppId != nil {
                map["ProviderAppId"] = self.providerAppId!
            }
            if self.providerAppName != nil {
                map["ProviderAppName"] = self.providerAppName!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.scMockItemJson != nil {
                map["ScMockItemJson"] = self.scMockItemJson!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("ConsumerAppId") && dict["ConsumerAppId"] != nil {
                self.consumerAppId = dict["ConsumerAppId"] as! String
            }
            if dict.keys.contains("ConsumerAppName") && dict["ConsumerAppName"] != nil {
                self.consumerAppName = dict["ConsumerAppName"] as! String
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("ExtraJson") && dict["ExtraJson"] != nil {
                self.extraJson = dict["ExtraJson"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MockType") && dict["MockType"] != nil {
                self.mockType = dict["MockType"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("ProviderAppId") && dict["ProviderAppId"] != nil {
                self.providerAppId = dict["ProviderAppId"] as! String
            }
            if dict.keys.contains("ProviderAppName") && dict["ProviderAppName"] != nil {
                self.providerAppName = dict["ProviderAppName"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("ScMockItemJson") && dict["ScMockItemJson"] != nil {
                self.scMockItemJson = dict["ScMockItemJson"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AddMockRuleResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AddMockRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddMockRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMockRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddMockRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSSLCertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") && dict["CertIdentifier"] != nil {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class AddSSLCertResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddSSLCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSSLCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddSSLCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSecurityGroupRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var gatewayUniqueId: String?

    public var portRange: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class AddSecurityGroupRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddSecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddServiceSourceRequest : Tea.TeaModel {
    public class IngressOptionsRequest : Tea.TeaModel {
        public var enableIngress: Bool?

        public var enableStatus: Bool?

        public var ingressClass: String?

        public var watchNamespace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableIngress != nil {
                map["EnableIngress"] = self.enableIngress!
            }
            if self.enableStatus != nil {
                map["EnableStatus"] = self.enableStatus!
            }
            if self.ingressClass != nil {
                map["IngressClass"] = self.ingressClass!
            }
            if self.watchNamespace != nil {
                map["WatchNamespace"] = self.watchNamespace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableIngress") && dict["EnableIngress"] != nil {
                self.enableIngress = dict["EnableIngress"] as! Bool
            }
            if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                self.enableStatus = dict["EnableStatus"] as! Bool
            }
            if dict.keys.contains("IngressClass") && dict["IngressClass"] != nil {
                self.ingressClass = dict["IngressClass"] as! String
            }
            if dict.keys.contains("WatchNamespace") && dict["WatchNamespace"] != nil {
                self.watchNamespace = dict["WatchNamespace"] as! String
            }
        }
    }
    public class ToAuthorizeSecurityGroups : Tea.TeaModel {
        public var description_: String?

        public var portRange: String?

        public var securityGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayUniqueId: String?

    public var groupList: [String]?

    public var ingressOptionsRequest: AddServiceSourceRequest.IngressOptionsRequest?

    public var name: String?

    public var pathList: [String]?

    public var source: String?

    public var toAuthorizeSecurityGroups: [AddServiceSourceRequest.ToAuthorizeSecurityGroups]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ingressOptionsRequest?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.groupList != nil {
            map["GroupList"] = self.groupList!
        }
        if self.ingressOptionsRequest != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequest?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pathList != nil {
            map["PathList"] = self.pathList!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.toAuthorizeSecurityGroups != nil {
            var tmp : [Any] = []
            for k in self.toAuthorizeSecurityGroups! {
                tmp.append(k.toMap())
            }
            map["ToAuthorizeSecurityGroups"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GroupList") && dict["GroupList"] != nil {
            self.groupList = dict["GroupList"] as! [String]
        }
        if dict.keys.contains("IngressOptionsRequest") && dict["IngressOptionsRequest"] != nil {
            var model = AddServiceSourceRequest.IngressOptionsRequest()
            model.fromMap(dict["IngressOptionsRequest"] as! [String: Any])
            self.ingressOptionsRequest = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PathList") && dict["PathList"] != nil {
            self.pathList = dict["PathList"] as! [String]
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("ToAuthorizeSecurityGroups") && dict["ToAuthorizeSecurityGroups"] != nil {
            var tmp : [AddServiceSourceRequest.ToAuthorizeSecurityGroups] = []
            for v in dict["ToAuthorizeSecurityGroups"] as! [Any] {
                var model = AddServiceSourceRequest.ToAuthorizeSecurityGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.toAuthorizeSecurityGroups = tmp
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddServiceSourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayUniqueId: String?

    public var groupListShrink: String?

    public var ingressOptionsRequestShrink: String?

    public var name: String?

    public var pathListShrink: String?

    public var source: String?

    public var toAuthorizeSecurityGroupsShrink: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.groupListShrink != nil {
            map["GroupList"] = self.groupListShrink!
        }
        if self.ingressOptionsRequestShrink != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequestShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pathListShrink != nil {
            map["PathList"] = self.pathListShrink!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.toAuthorizeSecurityGroupsShrink != nil {
            map["ToAuthorizeSecurityGroups"] = self.toAuthorizeSecurityGroupsShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GroupList") && dict["GroupList"] != nil {
            self.groupListShrink = dict["GroupList"] as! String
        }
        if dict.keys.contains("IngressOptionsRequest") && dict["IngressOptionsRequest"] != nil {
            self.ingressOptionsRequestShrink = dict["IngressOptionsRequest"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PathList") && dict["PathList"] != nil {
            self.pathListShrink = dict["PathList"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("ToAuthorizeSecurityGroups") && dict["ToAuthorizeSecurityGroups"] != nil {
            self.toAuthorizeSecurityGroupsShrink = dict["ToAuthorizeSecurityGroups"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddServiceSourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyGatewayRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
            self.routeId = dict["RouteId"] as! String
        }
    }
}

public class ApplyGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApplyGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApplyGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyTagPoliciesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var namespace: String?

    public var namespaceId: String?

    public var region: String?

    public var rules: [String: RulesValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rules != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.rules! {
                tmp[k] = v.toMap()
            }
            map["Rules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Rules") && dict["Rules"] != nil {
            var tmp : [String: RulesValue] = [:]
            for (k, v) in dict["Rules"] as! [String: Any] {
                if v != nil {
                    var model = RulesValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.rules = tmp
        }
    }
}

public class ApplyTagPoliciesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var namespace: String?

    public var namespaceId: String?

    public var region: String?

    public var rulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rulesShrink != nil {
            map["Rules"] = self.rulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Rules") && dict["Rules"] != nil {
            self.rulesShrink = dict["Rules"] as! String
        }
    }
}

public class ApplyTagPoliciesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var carryData: Bool?

        public var enable: Bool?

        public var id: Int64?

        public var instanceNum: Int32?

        public var name: String?

        public var rate: Int32?

        public var remove: Bool?

        public var rules: String?

        public var status: Int32?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.carryData != nil {
                map["CarryData"] = self.carryData!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceNum != nil {
                map["InstanceNum"] = self.instanceNum!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.rate != nil {
                map["Rate"] = self.rate!
            }
            if self.remove != nil {
                map["Remove"] = self.remove!
            }
            if self.rules != nil {
                map["Rules"] = self.rules!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CarryData") && dict["CarryData"] != nil {
                self.carryData = dict["CarryData"] as! Bool
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceNum") && dict["InstanceNum"] != nil {
                self.instanceNum = dict["InstanceNum"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Rate") && dict["Rate"] != nil {
                self.rate = dict["Rate"] as! Int32
            }
            if dict.keys.contains("Remove") && dict["Remove"] != nil {
                self.remove = dict["Remove"] as! Bool
            }
            if dict.keys.contains("Rules") && dict["Rules"] != nil {
                self.rules = dict["Rules"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
        }
    }
    public var data: [ApplyTagPoliciesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ApplyTagPoliciesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ApplyTagPoliciesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApplyTagPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyTagPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ApplyTagPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloneNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ids: String?

    public var instanceId: String?

    public var originNamespaceId: String?

    public var policy: String?

    public var targetNamespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.originNamespaceId != nil {
            map["OriginNamespaceId"] = self.originNamespaceId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.targetNamespaceId != nil {
            map["TargetNamespaceId"] = self.targetNamespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OriginNamespaceId") && dict["OriginNamespaceId"] != nil {
            self.originNamespaceId = dict["OriginNamespaceId"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("TargetNamespaceId") && dict["TargetNamespaceId"] != nil {
            self.targetNamespaceId = dict["TargetNamespaceId"] as! String
        }
    }
}

public class CloneNacosConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FailData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") && dict["DataId"] != nil {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") && dict["Group"] != nil {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public class SkipData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") && dict["DataId"] != nil {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") && dict["Group"] != nil {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public var failData: [CloneNacosConfigResponseBody.Data.FailData]?

        public var skipCount: Int32?

        public var skipData: [CloneNacosConfigResponseBody.Data.SkipData]?

        public var succCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failData != nil {
                var tmp : [Any] = []
                for k in self.failData! {
                    tmp.append(k.toMap())
                }
                map["FailData"] = tmp
            }
            if self.skipCount != nil {
                map["SkipCount"] = self.skipCount!
            }
            if self.skipData != nil {
                var tmp : [Any] = []
                for k in self.skipData! {
                    tmp.append(k.toMap())
                }
                map["SkipData"] = tmp
            }
            if self.succCount != nil {
                map["SuccCount"] = self.succCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailData") && dict["FailData"] != nil {
                var tmp : [CloneNacosConfigResponseBody.Data.FailData] = []
                for v in dict["FailData"] as! [Any] {
                    var model = CloneNacosConfigResponseBody.Data.FailData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.failData = tmp
            }
            if dict.keys.contains("SkipCount") && dict["SkipCount"] != nil {
                self.skipCount = dict["SkipCount"] as! Int32
            }
            if dict.keys.contains("SkipData") && dict["SkipData"] != nil {
                var tmp : [CloneNacosConfigResponseBody.Data.SkipData] = []
                for v in dict["SkipData"] as! [Any] {
                    var model = CloneNacosConfigResponseBody.Data.SkipData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skipData = tmp
            }
            if dict.keys.contains("SuccCount") && dict["SuccCount"] != nil {
                self.succCount = dict["SuccCount"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: CloneNacosConfigResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CloneNacosConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CloneNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CloneNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApplicationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var language: String?

    public var namespace: String?

    public var region: String?

    public var sentinelEnable: String?

    public var source: String?

    public var switchEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sentinelEnable != nil {
            map["SentinelEnable"] = self.sentinelEnable!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.switchEnable != nil {
            map["SwitchEnable"] = self.switchEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SentinelEnable") && dict["SentinelEnable"] != nil {
            self.sentinelEnable = dict["SentinelEnable"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SwitchEnable") && dict["SwitchEnable"] != nil {
            self.switchEnable = dict["SwitchEnable"] as! String
        }
    }
}

public class CreateApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var createTime: Int64?

        public var extraInfo: String?

        public var language: String?

        public var licenseKey: String?

        public var namespace: String?

        public var regionId: String?

        public var source: String?

        public var status: Int32?

        public var updateTime: Int64?

        public var userId: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.licenseKey != nil {
                map["LicenseKey"] = self.licenseKey!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                self.extraInfo = dict["ExtraInfo"] as! String
            }
            if dict.keys.contains("Language") && dict["Language"] != nil {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("LicenseKey") && dict["LicenseKey"] != nil {
                self.licenseKey = dict["LicenseKey"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateApplicationResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCircuitBreakerRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var halfOpenBaseAmountPerStep: Int32?

    public var halfOpenRecoveryStepNum: Int32?

    public var maxAllowedRtMs: Int32?

    public var minRequestAmount: Int32?

    public var namespace: String?

    public var regionId: String?

    public var resource: String?

    public var resourceType: Int32?

    public var retryTimeoutMs: Int32?

    public var statIntervalMs: Int32?

    public var strategy: Int32?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.halfOpenBaseAmountPerStep != nil {
            map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
        }
        if self.halfOpenRecoveryStepNum != nil {
            map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
        }
        if self.maxAllowedRtMs != nil {
            map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
        }
        if self.minRequestAmount != nil {
            map["MinRequestAmount"] = self.minRequestAmount!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.retryTimeoutMs != nil {
            map["RetryTimeoutMs"] = self.retryTimeoutMs!
        }
        if self.statIntervalMs != nil {
            map["StatIntervalMs"] = self.statIntervalMs!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("HalfOpenBaseAmountPerStep") && dict["HalfOpenBaseAmountPerStep"] != nil {
            self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
        }
        if dict.keys.contains("HalfOpenRecoveryStepNum") && dict["HalfOpenRecoveryStepNum"] != nil {
            self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
        }
        if dict.keys.contains("MaxAllowedRtMs") && dict["MaxAllowedRtMs"] != nil {
            self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
        }
        if dict.keys.contains("MinRequestAmount") && dict["MinRequestAmount"] != nil {
            self.minRequestAmount = dict["MinRequestAmount"] as! Int32
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! Int32
        }
        if dict.keys.contains("RetryTimeoutMs") && dict["RetryTimeoutMs"] != nil {
            self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
        }
        if dict.keys.contains("StatIntervalMs") && dict["StatIntervalMs"] != nil {
            self.statIntervalMs = dict["StatIntervalMs"] as! Int32
        }
        if dict.keys.contains("Strategy") && dict["Strategy"] != nil {
            self.strategy = dict["Strategy"] as! Int32
        }
        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class CreateCircuitBreakerRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var enable: Bool?

        public var halfOpenBaseAmountPerStep: Int32?

        public var halfOpenRecoveryStepNum: Int32?

        public var id: Int64?

        public var maxAllowedRtMs: Int32?

        public var minRequestAmount: Int32?

        public var namespace: String?

        public var regionId: String?

        public var resource: String?

        public var retryTimeoutMs: Int32?

        public var statIntervalMs: Int32?

        public var strategy: Int32?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.halfOpenBaseAmountPerStep != nil {
                map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
            }
            if self.halfOpenRecoveryStepNum != nil {
                map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxAllowedRtMs != nil {
                map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
            }
            if self.minRequestAmount != nil {
                map["MinRequestAmount"] = self.minRequestAmount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.retryTimeoutMs != nil {
                map["RetryTimeoutMs"] = self.retryTimeoutMs!
            }
            if self.statIntervalMs != nil {
                map["StatIntervalMs"] = self.statIntervalMs!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("HalfOpenBaseAmountPerStep") && dict["HalfOpenBaseAmountPerStep"] != nil {
                self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
            }
            if dict.keys.contains("HalfOpenRecoveryStepNum") && dict["HalfOpenRecoveryStepNum"] != nil {
                self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MaxAllowedRtMs") && dict["MaxAllowedRtMs"] != nil {
                self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
            }
            if dict.keys.contains("MinRequestAmount") && dict["MinRequestAmount"] != nil {
                self.minRequestAmount = dict["MinRequestAmount"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("RetryTimeoutMs") && dict["RetryTimeoutMs"] != nil {
                self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
            }
            if dict.keys.contains("StatIntervalMs") && dict["StatIntervalMs"] != nil {
                self.statIntervalMs = dict["StatIntervalMs"] as! Int32
            }
            if dict.keys.contains("Strategy") && dict["Strategy"] != nil {
                self.strategy = dict["Strategy"] as! Int32
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: CreateCircuitBreakerRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateCircuitBreakerRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCircuitBreakerRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCircuitBreakerRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCircuitBreakerRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClusterRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var chargeType: String?

    public var clusterSpecification: String?

    public var clusterType: String?

    public var clusterVersion: String?

    public var connectionType: String?

    public var diskType: String?

    public var eipEnabled: Bool?

    public var instanceCount: Int32?

    public var instanceName: String?

    public var mseVersion: String?

    public var netType: String?

    public var privateSlbSpecification: String?

    public var pubNetworkFlow: String?

    public var pubSlbSpecification: String?

    public var region: String?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var securityGroupType: String?

    public var tag: [CreateClusterRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clusterSpecification != nil {
            map["ClusterSpecification"] = self.clusterSpecification!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.clusterVersion != nil {
            map["ClusterVersion"] = self.clusterVersion!
        }
        if self.connectionType != nil {
            map["ConnectionType"] = self.connectionType!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.eipEnabled != nil {
            map["EipEnabled"] = self.eipEnabled!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.privateSlbSpecification != nil {
            map["PrivateSlbSpecification"] = self.privateSlbSpecification!
        }
        if self.pubNetworkFlow != nil {
            map["PubNetworkFlow"] = self.pubNetworkFlow!
        }
        if self.pubSlbSpecification != nil {
            map["PubSlbSpecification"] = self.pubSlbSpecification!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupType != nil {
            map["SecurityGroupType"] = self.securityGroupType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClusterSpecification") && dict["ClusterSpecification"] != nil {
            self.clusterSpecification = dict["ClusterSpecification"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("ClusterVersion") && dict["ClusterVersion"] != nil {
            self.clusterVersion = dict["ClusterVersion"] as! String
        }
        if dict.keys.contains("ConnectionType") && dict["ConnectionType"] != nil {
            self.connectionType = dict["ConnectionType"] as! String
        }
        if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
            self.diskType = dict["DiskType"] as! String
        }
        if dict.keys.contains("EipEnabled") && dict["EipEnabled"] != nil {
            self.eipEnabled = dict["EipEnabled"] as! Bool
        }
        if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
            self.instanceCount = dict["InstanceCount"] as! Int32
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("NetType") && dict["NetType"] != nil {
            self.netType = dict["NetType"] as! String
        }
        if dict.keys.contains("PrivateSlbSpecification") && dict["PrivateSlbSpecification"] != nil {
            self.privateSlbSpecification = dict["PrivateSlbSpecification"] as! String
        }
        if dict.keys.contains("PubNetworkFlow") && dict["PubNetworkFlow"] != nil {
            self.pubNetworkFlow = dict["PubNetworkFlow"] as! String
        }
        if dict.keys.contains("PubSlbSpecification") && dict["PubSlbSpecification"] != nil {
            self.pubSlbSpecification = dict["PubSlbSpecification"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupType") && dict["SecurityGroupType"] != nil {
            self.securityGroupType = dict["SecurityGroupType"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateClusterRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateClusterRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var instanceId: String?

    public var message: String?

    public var orderId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEngineNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var desc: String?

    public var id: String?

    public var instanceId: String?

    public var name: String?

    public var serviceCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.serviceCount != nil {
            map["ServiceCount"] = self.serviceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServiceCount") && dict["ServiceCount"] != nil {
            self.serviceCount = dict["ServiceCount"] as! Int32
        }
    }
}

public class CreateEngineNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configCount: Int32?

        public var namespace: String?

        public var namespaceDesc: String?

        public var namespaceShowName: String?

        public var quota: Int32?

        public var serviceCount: Int32?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configCount != nil {
                map["ConfigCount"] = self.configCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceDesc != nil {
                map["NamespaceDesc"] = self.namespaceDesc!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.serviceCount != nil {
                map["ServiceCount"] = self.serviceCount!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigCount") && dict["ConfigCount"] != nil {
                self.configCount = dict["ConfigCount"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceDesc") && dict["NamespaceDesc"] != nil {
                self.namespaceDesc = dict["NamespaceDesc"] as! String
            }
            if dict.keys.contains("NamespaceShowName") && dict["NamespaceShowName"] != nil {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Quota") && dict["Quota"] != nil {
                self.quota = dict["Quota"] as! Int32
            }
            if dict.keys.contains("ServiceCount") && dict["ServiceCount"] != nil {
                self.serviceCount = dict["ServiceCount"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var clusterId: String?

    public var data: CreateEngineNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateEngineNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateEngineNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEngineNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEngineNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var controlBehavior: Int32?

    public var enable: Bool?

    public var maxQueueingTimeMs: Int32?

    public var namespace: String?

    public var regionId: String?

    public var resource: String?

    public var resourceType: Int32?

    public var threshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.controlBehavior != nil {
            map["ControlBehavior"] = self.controlBehavior!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.maxQueueingTimeMs != nil {
            map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ControlBehavior") && dict["ControlBehavior"] != nil {
            self.controlBehavior = dict["ControlBehavior"] as! Int32
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("MaxQueueingTimeMs") && dict["MaxQueueingTimeMs"] != nil {
            self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! Int32
        }
        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
            self.threshold = dict["Threshold"] as! Int32
        }
    }
}

public class CreateFlowRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var controlBehavior: Int32?

        public var enable: Bool?

        public var id: Int64?

        public var maxQueueingTimeMs: Int32?

        public var namespace: String?

        public var regionId: String?

        public var resource: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.controlBehavior != nil {
                map["ControlBehavior"] = self.controlBehavior!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxQueueingTimeMs != nil {
                map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ControlBehavior") && dict["ControlBehavior"] != nil {
                self.controlBehavior = dict["ControlBehavior"] as! Int32
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MaxQueueingTimeMs") && dict["MaxQueueingTimeMs"] != nil {
                self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: CreateFlowRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateFlowRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateFlowRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFlowRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMseServiceApplicationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var extraInfo: String?

    public var language: String?

    public var mseVersion: String?

    public var region: String?

    public var sentinelEnable: String?

    public var source: String?

    public var switchEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extraInfo != nil {
            map["ExtraInfo"] = self.extraInfo!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sentinelEnable != nil {
            map["SentinelEnable"] = self.sentinelEnable!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.switchEnable != nil {
            map["SwitchEnable"] = self.switchEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
            self.extraInfo = dict["ExtraInfo"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SentinelEnable") && dict["SentinelEnable"] != nil {
            self.sentinelEnable = dict["SentinelEnable"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SwitchEnable") && dict["SwitchEnable"] != nil {
            self.switchEnable = dict["SwitchEnable"] as! String
        }
    }
}

public class CreateMseServiceApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var createTime: Int64?

        public var extraInfo: String?

        public var language: String?

        public var licenseKey: String?

        public var regionId: String?

        public var source: String?

        public var status: Int32?

        public var updateTime: Int64?

        public var userId: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.licenseKey != nil {
                map["LicenseKey"] = self.licenseKey!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                self.extraInfo = dict["ExtraInfo"] as! String
            }
            if dict.keys.contains("Language") && dict["Language"] != nil {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("LicenseKey") && dict["LicenseKey"] != nil {
                self.licenseKey = dict["LicenseKey"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var data: CreateMseServiceApplicationResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateMseServiceApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateMseServiceApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMseServiceApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMseServiceApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var betaIps: String?

    public var content: String?

    public var dataId: String?

    public var desc: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var tags: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.betaIps != nil {
            map["BetaIps"] = self.betaIps!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BetaIps") && dict["BetaIps"] != nil {
            self.betaIps = dict["BetaIps"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateNacosConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNacosInstanceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterName: String?

    public var enabled: Bool?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var ip: String?

    public var metadata: String?

    public var namespaceId: String?

    public var port: Int32?

    public var serviceName: String?

    public var weight: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.metadata != nil {
            map["Metadata"] = self.metadata!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Enabled") && dict["Enabled"] != nil {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Ephemeral") && dict["Ephemeral"] != nil {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Metadata") && dict["Metadata"] != nil {
            self.metadata = dict["Metadata"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Weight") && dict["Weight"] != nil {
            self.weight = dict["Weight"] as! String
        }
    }
}

public class CreateNacosInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNacosInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNacosInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateNacosInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNacosServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var protectThreshold: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.protectThreshold != nil {
            map["ProtectThreshold"] = self.protectThreshold!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Ephemeral") && dict["Ephemeral"] != nil {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ProtectThreshold") && dict["ProtectThreshold"] != nil {
            self.protectThreshold = dict["ProtectThreshold"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class CreateNacosServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNacosServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNacosServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateNacosServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateSwimmingLaneRequest : Tea.TeaModel {
    public class EntryRules : Tea.TeaModel {
        public class RestItems : Tea.TeaModel {
            public var cond: String?

            public var datum: String?

            public var divisor: Int32?

            public var name: String?

            public var nameList: [String]?

            public var operator_: String?

            public var rate: Int32?

            public var remainder: Int32?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cond != nil {
                    map["Cond"] = self.cond!
                }
                if self.datum != nil {
                    map["Datum"] = self.datum!
                }
                if self.divisor != nil {
                    map["Divisor"] = self.divisor!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameList != nil {
                    map["NameList"] = self.nameList!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.remainder != nil {
                    map["Remainder"] = self.remainder!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cond") && dict["Cond"] != nil {
                    self.cond = dict["Cond"] as! String
                }
                if dict.keys.contains("Datum") && dict["Datum"] != nil {
                    self.datum = dict["Datum"] as! String
                }
                if dict.keys.contains("Divisor") && dict["Divisor"] != nil {
                    self.divisor = dict["Divisor"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameList") && dict["NameList"] != nil {
                    self.nameList = dict["NameList"] as! [String]
                }
                if dict.keys.contains("Operator") && dict["Operator"] != nil {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Rate") && dict["Rate"] != nil {
                    self.rate = dict["Rate"] as! Int32
                }
                if dict.keys.contains("Remainder") && dict["Remainder"] != nil {
                    self.remainder = dict["Remainder"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var condition: String?

        public var paths: [String]?

        public var priority: Int32?

        public var restItems: [CreateOrUpdateSwimmingLaneRequest.EntryRules.RestItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.paths != nil {
                map["Paths"] = self.paths!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.restItems != nil {
                var tmp : [Any] = []
                for k in self.restItems! {
                    tmp.append(k.toMap())
                }
                map["RestItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") && dict["Condition"] != nil {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Paths") && dict["Paths"] != nil {
                self.paths = dict["Paths"] as! [String]
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RestItems") && dict["RestItems"] != nil {
                var tmp : [CreateOrUpdateSwimmingLaneRequest.EntryRules.RestItems] = []
                for v in dict["RestItems"] as! [Any] {
                    var model = CreateOrUpdateSwimmingLaneRequest.EntryRules.RestItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.restItems = tmp
            }
        }
    }
    public class GatewaySwimmingLaneRouteJson : Tea.TeaModel {
        public class Conditions : Tea.TeaModel {
            public var cond: String?

            public var name: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cond != nil {
                    map["Cond"] = self.cond!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cond") && dict["Cond"] != nil {
                    self.cond = dict["Cond"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var conditions: [CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson.Conditions]?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var routeIdList: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditions != nil {
                var tmp : [Any] = []
                for k in self.conditions! {
                    tmp.append(k.toMap())
                }
                map["Conditions"] = tmp
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.routeIdList != nil {
                map["RouteIdList"] = self.routeIdList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Conditions") && dict["Conditions"] != nil {
                var tmp : [CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson.Conditions] = []
                for v in dict["Conditions"] as! [Any] {
                    var model = CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson.Conditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditions = tmp
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("RouteIdList") && dict["RouteIdList"] != nil {
                self.routeIdList = dict["RouteIdList"] as! [Int64]
            }
        }
    }
    public var acceptLanguage: String?

    public var enable: Bool?

    public var enableRules: Bool?

    public var entryRule: String?

    public var entryRules: [CreateOrUpdateSwimmingLaneRequest.EntryRules]?

    public var gatewaySwimmingLaneRouteJson: CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson?

    public var groupId: Int64?

    public var id: Int64?

    public var name: String?

    public var namespace: String?

    public var regionId: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewaySwimmingLaneRouteJson?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.enableRules != nil {
            map["EnableRules"] = self.enableRules!
        }
        if self.entryRule != nil {
            map["EntryRule"] = self.entryRule!
        }
        if self.entryRules != nil {
            var tmp : [Any] = []
            for k in self.entryRules! {
                tmp.append(k.toMap())
            }
            map["EntryRules"] = tmp
        }
        if self.gatewaySwimmingLaneRouteJson != nil {
            map["GatewaySwimmingLaneRouteJson"] = self.gatewaySwimmingLaneRouteJson?.toMap()
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("EnableRules") && dict["EnableRules"] != nil {
            self.enableRules = dict["EnableRules"] as! Bool
        }
        if dict.keys.contains("EntryRule") && dict["EntryRule"] != nil {
            self.entryRule = dict["EntryRule"] as! String
        }
        if dict.keys.contains("EntryRules") && dict["EntryRules"] != nil {
            var tmp : [CreateOrUpdateSwimmingLaneRequest.EntryRules] = []
            for v in dict["EntryRules"] as! [Any] {
                var model = CreateOrUpdateSwimmingLaneRequest.EntryRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.entryRules = tmp
        }
        if dict.keys.contains("GatewaySwimmingLaneRouteJson") && dict["GatewaySwimmingLaneRouteJson"] != nil {
            var model = CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson()
            model.fromMap(dict["GatewaySwimmingLaneRouteJson"] as! [String: Any])
            self.gatewaySwimmingLaneRouteJson = model
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class CreateOrUpdateSwimmingLaneShrinkRequest : Tea.TeaModel {
    public class EntryRules : Tea.TeaModel {
        public class RestItems : Tea.TeaModel {
            public var cond: String?

            public var datum: String?

            public var divisor: Int32?

            public var name: String?

            public var nameList: [String]?

            public var operator_: String?

            public var rate: Int32?

            public var remainder: Int32?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cond != nil {
                    map["Cond"] = self.cond!
                }
                if self.datum != nil {
                    map["Datum"] = self.datum!
                }
                if self.divisor != nil {
                    map["Divisor"] = self.divisor!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameList != nil {
                    map["NameList"] = self.nameList!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.remainder != nil {
                    map["Remainder"] = self.remainder!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cond") && dict["Cond"] != nil {
                    self.cond = dict["Cond"] as! String
                }
                if dict.keys.contains("Datum") && dict["Datum"] != nil {
                    self.datum = dict["Datum"] as! String
                }
                if dict.keys.contains("Divisor") && dict["Divisor"] != nil {
                    self.divisor = dict["Divisor"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameList") && dict["NameList"] != nil {
                    self.nameList = dict["NameList"] as! [String]
                }
                if dict.keys.contains("Operator") && dict["Operator"] != nil {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Rate") && dict["Rate"] != nil {
                    self.rate = dict["Rate"] as! Int32
                }
                if dict.keys.contains("Remainder") && dict["Remainder"] != nil {
                    self.remainder = dict["Remainder"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var condition: String?

        public var paths: [String]?

        public var priority: Int32?

        public var restItems: [CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules.RestItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.paths != nil {
                map["Paths"] = self.paths!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.restItems != nil {
                var tmp : [Any] = []
                for k in self.restItems! {
                    tmp.append(k.toMap())
                }
                map["RestItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") && dict["Condition"] != nil {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Paths") && dict["Paths"] != nil {
                self.paths = dict["Paths"] as! [String]
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RestItems") && dict["RestItems"] != nil {
                var tmp : [CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules.RestItems] = []
                for v in dict["RestItems"] as! [Any] {
                    var model = CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules.RestItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.restItems = tmp
            }
        }
    }
    public var acceptLanguage: String?

    public var enable: Bool?

    public var enableRules: Bool?

    public var entryRule: String?

    public var entryRules: [CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules]?

    public var gatewaySwimmingLaneRouteJsonShrink: String?

    public var groupId: Int64?

    public var id: Int64?

    public var name: String?

    public var namespace: String?

    public var regionId: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.enableRules != nil {
            map["EnableRules"] = self.enableRules!
        }
        if self.entryRule != nil {
            map["EntryRule"] = self.entryRule!
        }
        if self.entryRules != nil {
            var tmp : [Any] = []
            for k in self.entryRules! {
                tmp.append(k.toMap())
            }
            map["EntryRules"] = tmp
        }
        if self.gatewaySwimmingLaneRouteJsonShrink != nil {
            map["GatewaySwimmingLaneRouteJson"] = self.gatewaySwimmingLaneRouteJsonShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("EnableRules") && dict["EnableRules"] != nil {
            self.enableRules = dict["EnableRules"] as! Bool
        }
        if dict.keys.contains("EntryRule") && dict["EntryRule"] != nil {
            self.entryRule = dict["EntryRule"] as! String
        }
        if dict.keys.contains("EntryRules") && dict["EntryRules"] != nil {
            var tmp : [CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules] = []
            for v in dict["EntryRules"] as! [Any] {
                var model = CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.entryRules = tmp
        }
        if dict.keys.contains("GatewaySwimmingLaneRouteJson") && dict["GatewaySwimmingLaneRouteJson"] != nil {
            self.gatewaySwimmingLaneRouteJsonShrink = dict["GatewaySwimmingLaneRouteJson"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class CreateOrUpdateSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EntryRules : Tea.TeaModel {
            public class RestItems : Tea.TeaModel {
                public var cond: String?

                public var datum: String?

                public var divisor: Int32?

                public var name: String?

                public var nameList: [String]?

                public var operator_: String?

                public var rate: Int32?

                public var remainder: Int32?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cond") && dict["cond"] != nil {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("datum") && dict["datum"] != nil {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("divisor") && dict["divisor"] != nil {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("nameList") && dict["nameList"] != nil {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("operator") && dict["operator"] != nil {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("rate") && dict["rate"] != nil {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("remainder") && dict["remainder"] != nil {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("type") && dict["type"] != nil {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("value") && dict["value"] != nil {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var condition: String?

            public var path: String?

            public var paths: [String]?

            public var restItems: [CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules.RestItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.paths != nil {
                    map["paths"] = self.paths!
                }
                if self.restItems != nil {
                    var tmp : [Any] = []
                    for k in self.restItems! {
                        tmp.append(k.toMap())
                    }
                    map["restItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") && dict["condition"] != nil {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("path") && dict["path"] != nil {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("paths") && dict["paths"] != nil {
                    self.paths = dict["paths"] as! [String]
                }
                if dict.keys.contains("restItems") && dict["restItems"] != nil {
                    var tmp : [CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules.RestItems] = []
                    for v in dict["restItems"] as! [Any] {
                        var model = CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules.RestItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restItems = tmp
                }
            }
        }
        public var enable: Bool?

        public var enableRules: Bool?

        public var entryRule: String?

        public var entryRules: [CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules]?

        public var gatewaySwimmingLaneRouteJson: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var regionId: String?

        public var status: Int32?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.enableRules != nil {
                map["enableRules"] = self.enableRules!
            }
            if self.entryRule != nil {
                map["entryRule"] = self.entryRule!
            }
            if self.entryRules != nil {
                var tmp : [Any] = []
                for k in self.entryRules! {
                    tmp.append(k.toMap())
                }
                map["entryRules"] = tmp
            }
            if self.gatewaySwimmingLaneRouteJson != nil {
                map["gatewaySwimmingLaneRouteJson"] = self.gatewaySwimmingLaneRouteJson!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.groupId != nil {
                map["groupId"] = self.groupId!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tag != nil {
                map["tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("enable") && dict["enable"] != nil {
                self.enable = dict["enable"] as! Bool
            }
            if dict.keys.contains("enableRules") && dict["enableRules"] != nil {
                self.enableRules = dict["enableRules"] as! Bool
            }
            if dict.keys.contains("entryRule") && dict["entryRule"] != nil {
                self.entryRule = dict["entryRule"] as! String
            }
            if dict.keys.contains("entryRules") && dict["entryRules"] != nil {
                var tmp : [CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules] = []
                for v in dict["entryRules"] as! [Any] {
                    var model = CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entryRules = tmp
            }
            if dict.keys.contains("gatewaySwimmingLaneRouteJson") && dict["gatewaySwimmingLaneRouteJson"] != nil {
                self.gatewaySwimmingLaneRouteJson = dict["gatewaySwimmingLaneRouteJson"] as! String
            }
            if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") && dict["gmtModified"] != nil {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("groupId") && dict["groupId"] != nil {
                self.groupId = dict["groupId"] as! Int64
            }
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") && dict["name"] != nil {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("regionId") && dict["regionId"] != nil {
                self.regionId = dict["regionId"] as! String
            }
            if dict.keys.contains("status") && dict["status"] != nil {
                self.status = dict["status"] as! Int32
            }
            if dict.keys.contains("tag") && dict["tag"] != nil {
                self.tag = dict["tag"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateOrUpdateSwimmingLaneResponseBody.Data?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateOrUpdateSwimmingLaneResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrUpdateSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appIds: String?

    public var dbGrayEnable: Bool?

    public var entryApp: String?

    public var id: Int64?

    public var messageQueueFilterSide: String?

    public var messageQueueGrayEnable: Bool?

    public var name: String?

    public var namespace: String?

    public var recordCanaryDetail: Bool?

    public var region: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.dbGrayEnable != nil {
            map["DbGrayEnable"] = self.dbGrayEnable!
        }
        if self.entryApp != nil {
            map["EntryApp"] = self.entryApp!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.messageQueueFilterSide != nil {
            map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
        }
        if self.messageQueueGrayEnable != nil {
            map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.recordCanaryDetail != nil {
            map["RecordCanaryDetail"] = self.recordCanaryDetail!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("DbGrayEnable") && dict["DbGrayEnable"] != nil {
            self.dbGrayEnable = dict["DbGrayEnable"] as! Bool
        }
        if dict.keys.contains("EntryApp") && dict["EntryApp"] != nil {
            self.entryApp = dict["EntryApp"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MessageQueueFilterSide") && dict["MessageQueueFilterSide"] != nil {
            self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
        }
        if dict.keys.contains("MessageQueueGrayEnable") && dict["MessageQueueGrayEnable"] != nil {
            self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RecordCanaryDetail") && dict["RecordCanaryDetail"] != nil {
            self.recordCanaryDetail = dict["RecordCanaryDetail"] as! Bool
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appIds: String?

        public var dbGrayEnable: String?

        public var entryApp: String?

        public var id: Int64?

        public var messageQueueFilterSide: String?

        public var messageQueueGrayEnable: Bool?

        public var name: String?

        public var namespace: String?

        public var recordCanaryDetail: Bool?

        public var region: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appIds != nil {
                map["AppIds"] = self.appIds!
            }
            if self.dbGrayEnable != nil {
                map["DbGrayEnable"] = self.dbGrayEnable!
            }
            if self.entryApp != nil {
                map["EntryApp"] = self.entryApp!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.messageQueueFilterSide != nil {
                map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
            }
            if self.messageQueueGrayEnable != nil {
                map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.recordCanaryDetail != nil {
                map["RecordCanaryDetail"] = self.recordCanaryDetail!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
                self.appIds = dict["AppIds"] as! String
            }
            if dict.keys.contains("DbGrayEnable") && dict["DbGrayEnable"] != nil {
                self.dbGrayEnable = dict["DbGrayEnable"] as! String
            }
            if dict.keys.contains("EntryApp") && dict["EntryApp"] != nil {
                self.entryApp = dict["EntryApp"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MessageQueueFilterSide") && dict["MessageQueueFilterSide"] != nil {
                self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
            }
            if dict.keys.contains("MessageQueueGrayEnable") && dict["MessageQueueGrayEnable"] != nil {
                self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RecordCanaryDetail") && dict["RecordCanaryDetail"] != nil {
                self.recordCanaryDetail = dict["RecordCanaryDetail"] as! Bool
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var data: CreateOrUpdateSwimmingLaneGroupResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateOrUpdateSwimmingLaneGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateZnodeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var data: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
    }
}

public class CreateZnodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") && dict["Dir"] != nil {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: CreateZnodeResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateZnodeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateZnodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateZnodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateZnodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAuthResourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteAuthResourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var authId: Int64?

        public var domainId: Int64?

        public var domainName: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var isWhite: Bool?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authId != nil {
                map["AuthId"] = self.authId!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isWhite != nil {
                map["IsWhite"] = self.isWhite!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthId") && dict["AuthId"] != nil {
                self.authId = dict["AuthId"] as! Int64
            }
            if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsWhite") && dict["IsWhite"] != nil {
                self.isWhite = dict["IsWhite"] as! Bool
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteAuthResourceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DeleteAuthResourceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAuthResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAuthResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAuthResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCircuitBreakerRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var ids: [Int64]?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! [Int64]
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteCircuitBreakerRulesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var idsShrink: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.idsShrink = dict["Ids"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteCircuitBreakerRulesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [Int64]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [Int64]
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCircuitBreakerRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCircuitBreakerRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCircuitBreakerRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEngineNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var id: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteEngineNamespaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEngineNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEngineNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEngineNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var ids: [Int64]?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! [Int64]
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteFlowRulesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var idsShrink: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.idsShrink = dict["Ids"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteFlowRulesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [Int64]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [Int64]
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteFlowRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFlowRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var deleteSlb: Bool?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.deleteSlb != nil {
            map["DeleteSlb"] = self.deleteSlb!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DeleteSlb") && dict["DeleteSlb"] != nil {
            self.deleteSlb = dict["DeleteSlb"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class DeleteGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var name: String?

        public var primaryUser: String?

        public var region: String?

        public var replica: Int32?

        public var securityGroup: String?

        public var spec: String?

        public var status: Int32?

        public var vpc: String?

        public var vswitch: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.replica != nil {
                map["Replica"] = self.replica!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PrimaryUser") && dict["PrimaryUser"] != nil {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Replica") && dict["Replica"] != nil {
                self.replica = dict["Replica"] as! Int32
            }
            if dict.keys.contains("SecurityGroup") && dict["SecurityGroup"] != nil {
                self.securityGroup = dict["SecurityGroup"] as! String
            }
            if dict.keys.contains("Spec") && dict["Spec"] != nil {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Vpc") && dict["Vpc"] != nil {
                self.vpc = dict["Vpc"] as! String
            }
            if dict.keys.contains("Vswitch") && dict["Vswitch"] != nil {
                self.vswitch = dict["Vswitch"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DeleteGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayAuthConsumerRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteGatewayAuthConsumerResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayAuthConsumerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayAuthConsumerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGatewayAuthConsumerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayAuthConsumerResourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var idList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.idList != nil {
            map["IdList"] = self.idList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") && dict["ConsumerId"] != nil {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IdList") && dict["IdList"] != nil {
            self.idList = dict["IdList"] as! String
        }
    }
}

public class DeleteGatewayAuthConsumerResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayAuthConsumerResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayAuthConsumerResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGatewayAuthConsumerResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
    }
}

public class DeleteGatewayDomainResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var certIdentifier: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var mustHttps: Bool?

        public var name: String?

        public var protocol_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mustHttps != nil {
                map["MustHttps"] = self.mustHttps!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertIdentifier") && dict["CertIdentifier"] != nil {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MustHttps") && dict["MustHttps"] != nil {
                self.mustHttps = dict["MustHttps"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                self.protocol_ = dict["Protocol"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayDomainResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DeleteGatewayDomainResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
            self.routeId = dict["RouteId"] as! String
        }
    }
}

public class DeleteGatewayRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var defaultServiceId: Int64?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var name: String?

        public var predicates: String?

        public var routeOrder: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.predicates != nil {
                map["Predicates"] = self.predicates!
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultServiceId") && dict["DefaultServiceId"] != nil {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Predicates") && dict["Predicates"] != nil {
                self.predicates = dict["Predicates"] as! String
            }
            if dict.keys.contains("RouteOrder") && dict["RouteOrder"] != nil {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayRouteResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DeleteGatewayRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var serviceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
    }
}

public class DeleteGatewayServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupName: String?

        public var id: Int64?

        public var ips: [String]?

        public var metaInfo: String?

        public var name: String?

        public var namespace: String?

        public var serviceNameInRegistry: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.metaInfo != nil {
                map["MetaInfo"] = self.metaInfo!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.serviceNameInRegistry != nil {
                map["ServiceNameInRegistry"] = self.serviceNameInRegistry!
            }
            if self.sourceId != nil {
                map["SourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Ips") && dict["Ips"] != nil {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("MetaInfo") && dict["MetaInfo"] != nil {
                self.metaInfo = dict["MetaInfo"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServiceNameInRegistry") && dict["ServiceNameInRegistry"] != nil {
                self.serviceNameInRegistry = dict["ServiceNameInRegistry"] as! String
            }
            if dict.keys.contains("SourceId") && dict["SourceId"] != nil {
                self.sourceId = dict["SourceId"] as! Int64
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayServiceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DeleteGatewayServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGatewayServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayServiceVersionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! Int64
        }
        if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class DeleteGatewayServiceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayServiceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayServiceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGatewayServiceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var deleteSlb: Bool?

    public var gatewayUniqueId: String?

    public var id: String?

    public var slbId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.deleteSlb != nil {
            map["DeleteSlb"] = self.deleteSlb!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DeleteSlb") && dict["DeleteSlb"] != nil {
            self.deleteSlb = dict["DeleteSlb"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
            self.slbId = dict["SlbId"] as! String
        }
    }
}

public class DeleteGatewaySlbResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMigrationTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var id: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class DeleteMigrationTaskResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMigrationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMigrationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMigrationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var beta: Bool?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.beta != nil {
            map["Beta"] = self.beta!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Beta") && dict["Beta"] != nil {
            self.beta = dict["Beta"] as! Bool
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class DeleteNacosConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ids: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class DeleteNacosConfigsResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNacosConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosInstanceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterName: String?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var ip: String?

    public var namespaceId: String?

    public var port: Int32?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Ephemeral") && dict["Ephemeral"] != nil {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class DeleteNacosInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNacosInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class DeleteNacosServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNacosServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var name: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
    }
}

public class DeleteNamespaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSecurityGroupRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var cascadingDelete: Bool?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.cascadingDelete != nil {
            map["CascadingDelete"] = self.cascadingDelete!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CascadingDelete") && dict["CascadingDelete"] != nil {
            self.cascadingDelete = dict["CascadingDelete"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteSecurityGroupRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var description_: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ipProtocol: String?

        public var portRange: String?

        public var securityGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteSecurityGroupRuleResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DeleteSecurityGroupRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteServiceSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var sourceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("SourceId") && dict["SourceId"] != nil {
            self.sourceId = dict["SourceId"] as! Int64
        }
    }
}

public class DeleteServiceSourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSwimmingLaneRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var laneId: Int64?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("LaneId") && dict["LaneId"] != nil {
            self.laneId = dict["LaneId"] as! Int64
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteSwimmingLaneResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSwimmingLaneGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteZnodeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var path: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class DeleteZnodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") && dict["Dir"] != nil {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: DeleteZnodeResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DeleteZnodeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteZnodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteZnodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteZnodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var dataId: String?

    public var dataIds: String?

    public var group: String?

    public var ids: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.dataIds != nil {
            map["DataIds"] = self.dataIds!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("DataIds") && dict["DataIds"] != nil {
            self.dataIds = dict["DataIds"] as! String
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class ExportNacosConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: ExportNacosConfigResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ExportNacosConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExportNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportZookeeperDataRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var exportType: String?

    public var instanceId: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.exportType != nil {
            map["ExportType"] = self.exportType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ExportType") && dict["ExportType"] != nil {
            self.exportType = dict["ExportType"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ExportZookeeperDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var contentMap: [String: Any]?

        public var createTime: Int64?

        public var exportType: String?

        public var extend: String?

        public var id: Int32?

        public var instanceId: String?

        public var kubeoneTaskIds: String?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentMap != nil {
                map["ContentMap"] = self.contentMap!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.exportType != nil {
                map["ExportType"] = self.exportType!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.kubeoneTaskIds != nil {
                map["KubeoneTaskIds"] = self.kubeoneTaskIds!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentMap") && dict["ContentMap"] != nil {
                self.contentMap = dict["ContentMap"] as! [String: Any]
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExportType") && dict["ExportType"] != nil {
                self.exportType = dict["ExportType"] as! String
            }
            if dict.keys.contains("Extend") && dict["Extend"] != nil {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("KubeoneTaskIds") && dict["KubeoneTaskIds"] != nil {
                self.kubeoneTaskIds = dict["KubeoneTaskIds"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var data: ExportZookeeperDataResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ExportZookeeperDataResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExportZookeeperDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportZookeeperDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportZookeeperDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FetchLosslessRuleListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class FetchLosslessRuleListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Results : Tea.TeaModel {
            public var aligned: Bool?

            public var appId: String?

            public var appName: String?

            public var count: Int32?

            public var delayTime: Int32?

            public var enable: Bool?

            public var funcType: Int32?

            public var lossLessDetail: Bool?

            public var notice: Bool?

            public var related: Bool?

            public var warmupTime: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aligned != nil {
                    map["Aligned"] = self.aligned!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.delayTime != nil {
                    map["DelayTime"] = self.delayTime!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.funcType != nil {
                    map["FuncType"] = self.funcType!
                }
                if self.lossLessDetail != nil {
                    map["LossLessDetail"] = self.lossLessDetail!
                }
                if self.notice != nil {
                    map["Notice"] = self.notice!
                }
                if self.related != nil {
                    map["Related"] = self.related!
                }
                if self.warmupTime != nil {
                    map["WarmupTime"] = self.warmupTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Aligned") && dict["Aligned"] != nil {
                    self.aligned = dict["Aligned"] as! Bool
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Count") && dict["Count"] != nil {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("DelayTime") && dict["DelayTime"] != nil {
                    self.delayTime = dict["DelayTime"] as! Int32
                }
                if dict.keys.contains("Enable") && dict["Enable"] != nil {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("FuncType") && dict["FuncType"] != nil {
                    self.funcType = dict["FuncType"] as! Int32
                }
                if dict.keys.contains("LossLessDetail") && dict["LossLessDetail"] != nil {
                    self.lossLessDetail = dict["LossLessDetail"] as! Bool
                }
                if dict.keys.contains("Notice") && dict["Notice"] != nil {
                    self.notice = dict["Notice"] as! Bool
                }
                if dict.keys.contains("Related") && dict["Related"] != nil {
                    self.related = dict["Related"] as! Bool
                }
                if dict.keys.contains("WarmupTime") && dict["WarmupTime"] != nil {
                    self.warmupTime = dict["WarmupTime"] as! Int32
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var results: [FetchLosslessRuleListResponseBody.Data.Results]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.results != nil {
                var tmp : [Any] = []
                for k in self.results! {
                    tmp.append(k.toMap())
                }
                map["Results"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Results") && dict["Results"] != nil {
                var tmp : [FetchLosslessRuleListResponseBody.Data.Results] = []
                for v in dict["Results"] as! [Any] {
                    var model = FetchLosslessRuleListResponseBody.Data.Results()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.results = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: FetchLosslessRuleListResponseBody.Data?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = FetchLosslessRuleListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class FetchLosslessRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FetchLosslessRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = FetchLosslessRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppMessageQueueRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
    }
}

public class GetAppMessageQueueRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var enable: Bool?

        public var filterSide: String?

        public var region: String?

        public var tags: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.filterSide != nil {
                map["FilterSide"] = self.filterSide!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("FilterSide") && dict["FilterSide"] != nil {
                self.filterSide = dict["FilterSide"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! [String]
            }
        }
    }
    public var code: Int32?

    public var data: GetAppMessageQueueRouteResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetAppMessageQueueRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAppMessageQueueRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppMessageQueueRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAppMessageQueueRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApplicationInstanceListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class GetApplicationInstanceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var tag: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") && dict["Tag"] != nil {
                        self.tag = dict["Tag"] as! String
                    }
                }
            }
            public var ip: String?

            public var port: String?

            public var tags: [GetApplicationInstanceListResponseBody.Data.Result.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var tmp : [GetApplicationInstanceListResponseBody.Data.Result.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = GetApplicationInstanceListResponseBody.Data.Result.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GetApplicationInstanceListResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [GetApplicationInstanceListResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetApplicationInstanceListResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: GetApplicationInstanceListResponseBody.Data?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetApplicationInstanceListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
    }
}

public class GetApplicationInstanceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationInstanceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetApplicationInstanceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApplicationListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var language: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var sentinelEnable: Bool?

    public var source: String?

    public var switchEnable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sentinelEnable != nil {
            map["SentinelEnable"] = self.sentinelEnable!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.switchEnable != nil {
            map["SwitchEnable"] = self.switchEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SentinelEnable") && dict["SentinelEnable"] != nil {
            self.sentinelEnable = dict["SentinelEnable"] as! Bool
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SwitchEnable") && dict["SwitchEnable"] != nil {
            self.switchEnable = dict["SwitchEnable"] as! Bool
        }
    }
}

public class GetApplicationListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var extraInfo: String?

            public var instancesNumber: Int32?

            public var language: String?

            public var namespace: String?

            public var regionId: String?

            public var source: String?

            public var status: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.instancesNumber != nil {
                    map["InstancesNumber"] = self.instancesNumber!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                    self.extraInfo = dict["ExtraInfo"] as! String
                }
                if dict.keys.contains("InstancesNumber") && dict["InstancesNumber"] != nil {
                    self.instancesNumber = dict["InstancesNumber"] as! Int32
                }
                if dict.keys.contains("Language") && dict["Language"] != nil {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GetApplicationListResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [GetApplicationListResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetApplicationListResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: GetApplicationListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetApplicationListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetApplicationListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetApplicationListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBlackWhiteListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var isWhite: Bool?

    public var resourceType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsWhite") && dict["IsWhite"] != nil {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetBlackWhiteListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var content: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var isWhite: Bool?

        public var resourceId: Int64?

        public var resourceType: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isWhite != nil {
                map["IsWhite"] = self.isWhite!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsWhite") && dict["IsWhite"] != nil {
                self.isWhite = dict["IsWhite"] as! Bool
            }
            if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                self.resourceId = dict["ResourceId"] as! Int64
            }
            if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetBlackWhiteListResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetBlackWhiteListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEngineNamepaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var id: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetEngineNamepaceResponseBody : Tea.TeaModel {
    public var configCount: String?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var namespace: String?

    public var namespaceDesc: String?

    public var namespaceShowName: String?

    public var quota: String?

    public var requestId: String?

    public var success: Bool?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configCount != nil {
            map["ConfigCount"] = self.configCount!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.namespaceDesc != nil {
            map["NamespaceDesc"] = self.namespaceDesc!
        }
        if self.namespaceShowName != nil {
            map["NamespaceShowName"] = self.namespaceShowName!
        }
        if self.quota != nil {
            map["Quota"] = self.quota!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigCount") && dict["ConfigCount"] != nil {
            self.configCount = dict["ConfigCount"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NamespaceDesc") && dict["NamespaceDesc"] != nil {
            self.namespaceDesc = dict["NamespaceDesc"] as! String
        }
        if dict.keys.contains("NamespaceShowName") && dict["NamespaceShowName"] != nil {
            self.namespaceShowName = dict["NamespaceShowName"] as! String
        }
        if dict.keys.contains("Quota") && dict["Quota"] != nil {
            self.quota = dict["Quota"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetEngineNamepaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEngineNamepaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEngineNamepaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class GetGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ElasticPolicy : Tea.TeaModel {
            public class TimePolicyList : Tea.TeaModel {
                public var desiredReplica: Int32?

                public var endTime: String?

                public var startTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desiredReplica != nil {
                        map["DesiredReplica"] = self.desiredReplica!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DesiredReplica") && dict["DesiredReplica"] != nil {
                        self.desiredReplica = dict["DesiredReplica"] as! Int32
                    }
                    if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                }
            }
            public var elasticType: String?

            public var maxReplica: Int32?

            public var timePolicyList: [GetGatewayResponseBody.Data.ElasticPolicy.TimePolicyList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.elasticType != nil {
                    map["ElasticType"] = self.elasticType!
                }
                if self.maxReplica != nil {
                    map["MaxReplica"] = self.maxReplica!
                }
                if self.timePolicyList != nil {
                    var tmp : [Any] = []
                    for k in self.timePolicyList! {
                        tmp.append(k.toMap())
                    }
                    map["TimePolicyList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ElasticType") && dict["ElasticType"] != nil {
                    self.elasticType = dict["ElasticType"] as! String
                }
                if dict.keys.contains("MaxReplica") && dict["MaxReplica"] != nil {
                    self.maxReplica = dict["MaxReplica"] as! Int32
                }
                if dict.keys.contains("TimePolicyList") && dict["TimePolicyList"] != nil {
                    var tmp : [GetGatewayResponseBody.Data.ElasticPolicy.TimePolicyList] = []
                    for v in dict["TimePolicyList"] as! [Any] {
                        var model = GetGatewayResponseBody.Data.ElasticPolicy.TimePolicyList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.timePolicyList = tmp
                }
            }
        }
        public class LogConfigDetails : Tea.TeaModel {
            public var logEnabled: Bool?

            public var logStoreName: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logEnabled != nil {
                    map["LogEnabled"] = self.logEnabled!
                }
                if self.logStoreName != nil {
                    map["LogStoreName"] = self.logStoreName!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LogEnabled") && dict["LogEnabled"] != nil {
                    self.logEnabled = dict["LogEnabled"] as! Bool
                }
                if dict.keys.contains("LogStoreName") && dict["LogStoreName"] != nil {
                    self.logStoreName = dict["LogStoreName"] as! String
                }
                if dict.keys.contains("ProjectName") && dict["ProjectName"] != nil {
                    self.projectName = dict["ProjectName"] as! String
                }
            }
        }
        public class XtraceDetails : Tea.TeaModel {
            public var sample: Int32?

            public var traceOn: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sample != nil {
                    map["Sample"] = self.sample!
                }
                if self.traceOn != nil {
                    map["TraceOn"] = self.traceOn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Sample") && dict["Sample"] != nil {
                    self.sample = dict["Sample"] as! Int32
                }
                if dict.keys.contains("TraceOn") && dict["TraceOn"] != nil {
                    self.traceOn = dict["TraceOn"] as! Bool
                }
            }
        }
        public var chargeType: String?

        public var elastic: Bool?

        public var elasticPolicy: GetGatewayResponseBody.Data.ElasticPolicy?

        public var elasticReplica: Int32?

        public var elasticType: String?

        public var endDate: String?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var instanceId: String?

        public var logConfigDetails: GetGatewayResponseBody.Data.LogConfigDetails?

        public var mseTag: String?

        public var name: String?

        public var primaryUser: String?

        public var region: String?

        public var replica: Int32?

        public var resourceGroupId: String?

        public var securityGroup: String?

        public var spec: String?

        public var status: Int32?

        public var statusDesc: String?

        public var totalReplica: Int32?

        public var vpc: String?

        public var vswitch: String?

        public var vswitch2: String?

        public var xtraceDetails: GetGatewayResponseBody.Data.XtraceDetails?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.elasticPolicy?.validate()
            try self.logConfigDetails?.validate()
            try self.xtraceDetails?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.elastic != nil {
                map["Elastic"] = self.elastic!
            }
            if self.elasticPolicy != nil {
                map["ElasticPolicy"] = self.elasticPolicy?.toMap()
            }
            if self.elasticReplica != nil {
                map["ElasticReplica"] = self.elasticReplica!
            }
            if self.elasticType != nil {
                map["ElasticType"] = self.elasticType!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logConfigDetails != nil {
                map["LogConfigDetails"] = self.logConfigDetails?.toMap()
            }
            if self.mseTag != nil {
                map["MseTag"] = self.mseTag!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.replica != nil {
                map["Replica"] = self.replica!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.totalReplica != nil {
                map["TotalReplica"] = self.totalReplica!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            if self.vswitch2 != nil {
                map["Vswitch2"] = self.vswitch2!
            }
            if self.xtraceDetails != nil {
                map["XtraceDetails"] = self.xtraceDetails?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("Elastic") && dict["Elastic"] != nil {
                self.elastic = dict["Elastic"] as! Bool
            }
            if dict.keys.contains("ElasticPolicy") && dict["ElasticPolicy"] != nil {
                var model = GetGatewayResponseBody.Data.ElasticPolicy()
                model.fromMap(dict["ElasticPolicy"] as! [String: Any])
                self.elasticPolicy = model
            }
            if dict.keys.contains("ElasticReplica") && dict["ElasticReplica"] != nil {
                self.elasticReplica = dict["ElasticReplica"] as! Int32
            }
            if dict.keys.contains("ElasticType") && dict["ElasticType"] != nil {
                self.elasticType = dict["ElasticType"] as! String
            }
            if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LogConfigDetails") && dict["LogConfigDetails"] != nil {
                var model = GetGatewayResponseBody.Data.LogConfigDetails()
                model.fromMap(dict["LogConfigDetails"] as! [String: Any])
                self.logConfigDetails = model
            }
            if dict.keys.contains("MseTag") && dict["MseTag"] != nil {
                self.mseTag = dict["MseTag"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PrimaryUser") && dict["PrimaryUser"] != nil {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Replica") && dict["Replica"] != nil {
                self.replica = dict["Replica"] as! Int32
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroup") && dict["SecurityGroup"] != nil {
                self.securityGroup = dict["SecurityGroup"] as! String
            }
            if dict.keys.contains("Spec") && dict["Spec"] != nil {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("TotalReplica") && dict["TotalReplica"] != nil {
                self.totalReplica = dict["TotalReplica"] as! Int32
            }
            if dict.keys.contains("Vpc") && dict["Vpc"] != nil {
                self.vpc = dict["Vpc"] as! String
            }
            if dict.keys.contains("Vswitch") && dict["Vswitch"] != nil {
                self.vswitch = dict["Vswitch"] as! String
            }
            if dict.keys.contains("Vswitch2") && dict["Vswitch2"] != nil {
                self.vswitch2 = dict["Vswitch2"] as! String
            }
            if dict.keys.contains("XtraceDetails") && dict["XtraceDetails"] != nil {
                var model = GetGatewayResponseBody.Data.XtraceDetails()
                model.fromMap(dict["XtraceDetails"] as! [String: Any])
                self.xtraceDetails = model
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayAuthConsumerDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetGatewayAuthConsumerDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ResourceList : Tea.TeaModel {
            public var consumerId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var resourceStatus: Bool?

            public var routeId: Int64?

            public var routeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumerId != nil {
                    map["ConsumerId"] = self.consumerId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.resourceStatus != nil {
                    map["ResourceStatus"] = self.resourceStatus!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumerId") && dict["ConsumerId"] != nil {
                    self.consumerId = dict["ConsumerId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ResourceStatus") && dict["ResourceStatus"] != nil {
                    self.resourceStatus = dict["ResourceStatus"] as! Bool
                }
                if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") && dict["RouteName"] != nil {
                    self.routeName = dict["RouteName"] as! String
                }
            }
        }
        public var consumerStatus: Bool?

        public var description_: String?

        public var encodeType: String?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var jwks: String?

        public var keyName: String?

        public var keyValue: String?

        public var name: String?

        public var primaryUser: String?

        public var resourceList: [GetGatewayAuthConsumerDetailResponseBody.Data.ResourceList]?

        public var tokenName: String?

        public var tokenPass: Bool?

        public var tokenPosition: String?

        public var tokenPrefix: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumerStatus != nil {
                map["ConsumerStatus"] = self.consumerStatus!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.encodeType != nil {
                map["EncodeType"] = self.encodeType!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.jwks != nil {
                map["Jwks"] = self.jwks!
            }
            if self.keyName != nil {
                map["KeyName"] = self.keyName!
            }
            if self.keyValue != nil {
                map["KeyValue"] = self.keyValue!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.resourceList != nil {
                var tmp : [Any] = []
                for k in self.resourceList! {
                    tmp.append(k.toMap())
                }
                map["ResourceList"] = tmp
            }
            if self.tokenName != nil {
                map["TokenName"] = self.tokenName!
            }
            if self.tokenPass != nil {
                map["TokenPass"] = self.tokenPass!
            }
            if self.tokenPosition != nil {
                map["TokenPosition"] = self.tokenPosition!
            }
            if self.tokenPrefix != nil {
                map["TokenPrefix"] = self.tokenPrefix!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumerStatus") && dict["ConsumerStatus"] != nil {
                self.consumerStatus = dict["ConsumerStatus"] as! Bool
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EncodeType") && dict["EncodeType"] != nil {
                self.encodeType = dict["EncodeType"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Jwks") && dict["Jwks"] != nil {
                self.jwks = dict["Jwks"] as! String
            }
            if dict.keys.contains("KeyName") && dict["KeyName"] != nil {
                self.keyName = dict["KeyName"] as! String
            }
            if dict.keys.contains("KeyValue") && dict["KeyValue"] != nil {
                self.keyValue = dict["KeyValue"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PrimaryUser") && dict["PrimaryUser"] != nil {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("ResourceList") && dict["ResourceList"] != nil {
                var tmp : [GetGatewayAuthConsumerDetailResponseBody.Data.ResourceList] = []
                for v in dict["ResourceList"] as! [Any] {
                    var model = GetGatewayAuthConsumerDetailResponseBody.Data.ResourceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resourceList = tmp
            }
            if dict.keys.contains("TokenName") && dict["TokenName"] != nil {
                self.tokenName = dict["TokenName"] as! String
            }
            if dict.keys.contains("TokenPass") && dict["TokenPass"] != nil {
                self.tokenPass = dict["TokenPass"] as! Bool
            }
            if dict.keys.contains("TokenPosition") && dict["TokenPosition"] != nil {
                self.tokenPosition = dict["TokenPosition"] as! String
            }
            if dict.keys.contains("TokenPrefix") && dict["TokenPrefix"] != nil {
                self.tokenPrefix = dict["TokenPrefix"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayAuthConsumerDetailResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetGatewayAuthConsumerDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayAuthConsumerDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayAuthConsumerDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetGatewayAuthConsumerDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayDomainDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
    }
}

public class GetGatewayDomainDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var afterDate: Int64?

        public var algorithm: String?

        public var beforeDate: Int64?

        public var certIdentifier: String?

        public var certName: String?

        public var commonName: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtAfter: String?

        public var gmtBefore: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var http2: String?

        public var id: Int64?

        public var issuer: String?

        public var mustHttps: Bool?

        public var name: String?

        public var protocol_: String?

        public var sans: String?

        public var tlsMax: String?

        public var tlsMin: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.afterDate != nil {
                map["AfterDate"] = self.afterDate!
            }
            if self.algorithm != nil {
                map["Algorithm"] = self.algorithm!
            }
            if self.beforeDate != nil {
                map["BeforeDate"] = self.beforeDate!
            }
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.commonName != nil {
                map["CommonName"] = self.commonName!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtAfter != nil {
                map["GmtAfter"] = self.gmtAfter!
            }
            if self.gmtBefore != nil {
                map["GmtBefore"] = self.gmtBefore!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.http2 != nil {
                map["Http2"] = self.http2!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.issuer != nil {
                map["Issuer"] = self.issuer!
            }
            if self.mustHttps != nil {
                map["MustHttps"] = self.mustHttps!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sans != nil {
                map["Sans"] = self.sans!
            }
            if self.tlsMax != nil {
                map["TlsMax"] = self.tlsMax!
            }
            if self.tlsMin != nil {
                map["TlsMin"] = self.tlsMin!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AfterDate") && dict["AfterDate"] != nil {
                self.afterDate = dict["AfterDate"] as! Int64
            }
            if dict.keys.contains("Algorithm") && dict["Algorithm"] != nil {
                self.algorithm = dict["Algorithm"] as! String
            }
            if dict.keys.contains("BeforeDate") && dict["BeforeDate"] != nil {
                self.beforeDate = dict["BeforeDate"] as! Int64
            }
            if dict.keys.contains("CertIdentifier") && dict["CertIdentifier"] != nil {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("CertName") && dict["CertName"] != nil {
                self.certName = dict["CertName"] as! String
            }
            if dict.keys.contains("CommonName") && dict["CommonName"] != nil {
                self.commonName = dict["CommonName"] as! String
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtAfter") && dict["GmtAfter"] != nil {
                self.gmtAfter = dict["GmtAfter"] as! String
            }
            if dict.keys.contains("GmtBefore") && dict["GmtBefore"] != nil {
                self.gmtBefore = dict["GmtBefore"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Http2") && dict["Http2"] != nil {
                self.http2 = dict["Http2"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Issuer") && dict["Issuer"] != nil {
                self.issuer = dict["Issuer"] as! String
            }
            if dict.keys.contains("MustHttps") && dict["MustHttps"] != nil {
                self.mustHttps = dict["MustHttps"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("Sans") && dict["Sans"] != nil {
                self.sans = dict["Sans"] as! String
            }
            if dict.keys.contains("TlsMax") && dict["TlsMax"] != nil {
                self.tlsMax = dict["TlsMax"] as! String
            }
            if dict.keys.contains("TlsMin") && dict["TlsMin"] != nil {
                self.tlsMin = dict["TlsMin"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayDomainDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetGatewayDomainDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayDomainDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayDomainDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetGatewayDomainDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayOptionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class GetGatewayOptionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GatewayOption?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GatewayOption()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayOptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayOptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetGatewayOptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayRouteDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
            self.routeId = dict["RouteId"] as! Int64
        }
    }
}

public class GetGatewayRouteDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Cors : Tea.TeaModel {
            public var allowCredentials: Bool?

            public var allowHeaders: String?

            public var allowMethods: String?

            public var allowOrigins: String?

            public var exposeHeaders: String?

            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowCredentials != nil {
                    map["AllowCredentials"] = self.allowCredentials!
                }
                if self.allowHeaders != nil {
                    map["AllowHeaders"] = self.allowHeaders!
                }
                if self.allowMethods != nil {
                    map["AllowMethods"] = self.allowMethods!
                }
                if self.allowOrigins != nil {
                    map["AllowOrigins"] = self.allowOrigins!
                }
                if self.exposeHeaders != nil {
                    map["ExposeHeaders"] = self.exposeHeaders!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowCredentials") && dict["AllowCredentials"] != nil {
                    self.allowCredentials = dict["AllowCredentials"] as! Bool
                }
                if dict.keys.contains("AllowHeaders") && dict["AllowHeaders"] != nil {
                    self.allowHeaders = dict["AllowHeaders"] as! String
                }
                if dict.keys.contains("AllowMethods") && dict["AllowMethods"] != nil {
                    self.allowMethods = dict["AllowMethods"] as! String
                }
                if dict.keys.contains("AllowOrigins") && dict["AllowOrigins"] != nil {
                    self.allowOrigins = dict["AllowOrigins"] as! String
                }
                if dict.keys.contains("ExposeHeaders") && dict["ExposeHeaders"] != nil {
                    self.exposeHeaders = dict["ExposeHeaders"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") && dict["TimeUnit"] != nil {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") && dict["UnitNum"] != nil {
                    self.unitNum = dict["UnitNum"] as! Int64
                }
            }
        }
        public class DirectResponse : Tea.TeaModel {
            public var body: String?

            public var code: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") && dict["Body"] != nil {
                    self.body = dict["Body"] as! String
                }
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! Int32
                }
            }
        }
        public class FallbackServices : Tea.TeaModel {
            public var agreementType: String?

            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var percent: Int32?

            public var serviceId: Int64?

            public var serviceName: String?

            public var servicePort: Int32?

            public var sourceType: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agreementType != nil {
                    map["AgreementType"] = self.agreementType!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgreementType") && dict["AgreementType"] != nil {
                    self.agreementType = dict["AgreementType"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Percent") && dict["Percent"] != nil {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                    self.servicePort = dict["ServicePort"] as! Int32
                }
                if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class FlowMirror : Tea.TeaModel {
            public var percentage: Int32?

            public var port: Int32?

            public var status: String?

            public var targetServiceId: Int64?

            public var targetServiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.targetServiceId != nil {
                    map["TargetServiceId"] = self.targetServiceId!
                }
                if self.targetServiceName != nil {
                    map["TargetServiceName"] = self.targetServiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Percentage") && dict["Percentage"] != nil {
                    self.percentage = dict["Percentage"] as! Int32
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TargetServiceId") && dict["TargetServiceId"] != nil {
                    self.targetServiceId = dict["TargetServiceId"] as! Int64
                }
                if dict.keys.contains("TargetServiceName") && dict["TargetServiceName"] != nil {
                    self.targetServiceName = dict["TargetServiceName"] as! String
                }
            }
        }
        public class HTTPRewrite : Tea.TeaModel {
            public var host: String?

            public var path: String?

            public var pathType: String?

            public var pattern: String?

            public var status: String?

            public var substitution: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.pathType != nil {
                    map["PathType"] = self.pathType!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.substitution != nil {
                    map["Substitution"] = self.substitution!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("PathType") && dict["PathType"] != nil {
                    self.pathType = dict["PathType"] as! String
                }
                if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                    self.pattern = dict["Pattern"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Substitution") && dict["Substitution"] != nil {
                    self.substitution = dict["Substitution"] as! String
                }
            }
        }
        public class HeaderOp : Tea.TeaModel {
            public class HeaderOpItems : Tea.TeaModel {
                public var directionType: String?

                public var key: String?

                public var opType: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.directionType != nil {
                        map["DirectionType"] = self.directionType!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.opType != nil {
                        map["OpType"] = self.opType!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DirectionType") && dict["DirectionType"] != nil {
                        self.directionType = dict["DirectionType"] as! String
                    }
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("OpType") && dict["OpType"] != nil {
                        self.opType = dict["OpType"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerOpItems: [GetGatewayRouteDetailResponseBody.Data.HeaderOp.HeaderOpItems]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerOpItems != nil {
                    var tmp : [Any] = []
                    for k in self.headerOpItems! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderOpItems"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderOpItems") && dict["HeaderOpItems"] != nil {
                    var tmp : [GetGatewayRouteDetailResponseBody.Data.HeaderOp.HeaderOpItems] = []
                    for v in dict["HeaderOpItems"] as! [Any] {
                        var model = GetGatewayRouteDetailResponseBody.Data.HeaderOp.HeaderOpItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerOpItems = tmp
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Redirect : Tea.TeaModel {
            public var code: Int32?

            public var host: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! Int32
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public class Retry : Tea.TeaModel {
            public var attempts: Int32?

            public var httpCodes: [String]?

            public var retryOn: [String]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attempts != nil {
                    map["Attempts"] = self.attempts!
                }
                if self.httpCodes != nil {
                    map["HttpCodes"] = self.httpCodes!
                }
                if self.retryOn != nil {
                    map["RetryOn"] = self.retryOn!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attempts") && dict["Attempts"] != nil {
                    self.attempts = dict["Attempts"] as! Int32
                }
                if dict.keys.contains("HttpCodes") && dict["HttpCodes"] != nil {
                    self.httpCodes = dict["HttpCodes"] as! [String]
                }
                if dict.keys.contains("RetryOn") && dict["RetryOn"] != nil {
                    self.retryOn = dict["RetryOn"] as! [String]
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RoutePredicates : Tea.TeaModel {
            public class HeaderPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class PathPredicates : Tea.TeaModel {
                public var ignoreCase: Bool?

                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ignoreCase != nil {
                        map["IgnoreCase"] = self.ignoreCase!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IgnoreCase") && dict["IgnoreCase"] != nil {
                        self.ignoreCase = dict["IgnoreCase"] as! Bool
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class QueryPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerPredicates: [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.HeaderPredicates]?

            public var methodPredicates: [String]?

            public var pathPredicates: GetGatewayRouteDetailResponseBody.Data.RoutePredicates.PathPredicates?

            public var queryPredicates: [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.QueryPredicates]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pathPredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.headerPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderPredicates"] = tmp
                }
                if self.methodPredicates != nil {
                    map["MethodPredicates"] = self.methodPredicates!
                }
                if self.pathPredicates != nil {
                    map["PathPredicates"] = self.pathPredicates?.toMap()
                }
                if self.queryPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.queryPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["QueryPredicates"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderPredicates") && dict["HeaderPredicates"] != nil {
                    var tmp : [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.HeaderPredicates] = []
                    for v in dict["HeaderPredicates"] as! [Any] {
                        var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates.HeaderPredicates()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerPredicates = tmp
                }
                if dict.keys.contains("MethodPredicates") && dict["MethodPredicates"] != nil {
                    self.methodPredicates = dict["MethodPredicates"] as! [String]
                }
                if dict.keys.contains("PathPredicates") && dict["PathPredicates"] != nil {
                    var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates.PathPredicates()
                    model.fromMap(dict["PathPredicates"] as! [String: Any])
                    self.pathPredicates = model
                }
                if dict.keys.contains("QueryPredicates") && dict["QueryPredicates"] != nil {
                    var tmp : [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.QueryPredicates] = []
                    for v in dict["QueryPredicates"] as! [Any] {
                        var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates.QueryPredicates()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.queryPredicates = tmp
                }
            }
        }
        public class RouteServices : Tea.TeaModel {
            public class HttpDubboTranscoder : Tea.TeaModel {
                public class MothedMapList : Tea.TeaModel {
                    public class ParamMapsList : Tea.TeaModel {
                        public var extractKey: String?

                        public var extractKeySpec: String?

                        public var mappingType: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extractKey != nil {
                                map["ExtractKey"] = self.extractKey!
                            }
                            if self.extractKeySpec != nil {
                                map["ExtractKeySpec"] = self.extractKeySpec!
                            }
                            if self.mappingType != nil {
                                map["MappingType"] = self.mappingType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtractKey") && dict["ExtractKey"] != nil {
                                self.extractKey = dict["ExtractKey"] as! String
                            }
                            if dict.keys.contains("ExtractKeySpec") && dict["ExtractKeySpec"] != nil {
                                self.extractKeySpec = dict["ExtractKeySpec"] as! String
                            }
                            if dict.keys.contains("MappingType") && dict["MappingType"] != nil {
                                self.mappingType = dict["MappingType"] as! String
                            }
                        }
                    }
                    public var dubboMothedName: String?

                    public var httpMothed: String?

                    public var mothedpath: String?

                    public var paramMapsList: [GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                    public var passThroughAllHeaders: String?

                    public var passThroughList: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dubboMothedName != nil {
                            map["DubboMothedName"] = self.dubboMothedName!
                        }
                        if self.httpMothed != nil {
                            map["HttpMothed"] = self.httpMothed!
                        }
                        if self.mothedpath != nil {
                            map["Mothedpath"] = self.mothedpath!
                        }
                        if self.paramMapsList != nil {
                            var tmp : [Any] = []
                            for k in self.paramMapsList! {
                                tmp.append(k.toMap())
                            }
                            map["ParamMapsList"] = tmp
                        }
                        if self.passThroughAllHeaders != nil {
                            map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                        }
                        if self.passThroughList != nil {
                            map["PassThroughList"] = self.passThroughList!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DubboMothedName") && dict["DubboMothedName"] != nil {
                            self.dubboMothedName = dict["DubboMothedName"] as! String
                        }
                        if dict.keys.contains("HttpMothed") && dict["HttpMothed"] != nil {
                            self.httpMothed = dict["HttpMothed"] as! String
                        }
                        if dict.keys.contains("Mothedpath") && dict["Mothedpath"] != nil {
                            self.mothedpath = dict["Mothedpath"] as! String
                        }
                        if dict.keys.contains("ParamMapsList") && dict["ParamMapsList"] != nil {
                            var tmp : [GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList] = []
                            for v in dict["ParamMapsList"] as! [Any] {
                                var model = GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.paramMapsList = tmp
                        }
                        if dict.keys.contains("PassThroughAllHeaders") && dict["PassThroughAllHeaders"] != nil {
                            self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                        }
                        if dict.keys.contains("PassThroughList") && dict["PassThroughList"] != nil {
                            self.passThroughList = dict["PassThroughList"] as! [String]
                        }
                    }
                }
                public var dubboServiceGroup: String?

                public var dubboServiceName: String?

                public var dubboServiceVersion: String?

                public var mothedMapList: [GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dubboServiceGroup != nil {
                        map["DubboServiceGroup"] = self.dubboServiceGroup!
                    }
                    if self.dubboServiceName != nil {
                        map["DubboServiceName"] = self.dubboServiceName!
                    }
                    if self.dubboServiceVersion != nil {
                        map["DubboServiceVersion"] = self.dubboServiceVersion!
                    }
                    if self.mothedMapList != nil {
                        var tmp : [Any] = []
                        for k in self.mothedMapList! {
                            tmp.append(k.toMap())
                        }
                        map["MothedMapList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DubboServiceGroup") && dict["DubboServiceGroup"] != nil {
                        self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                    }
                    if dict.keys.contains("DubboServiceName") && dict["DubboServiceName"] != nil {
                        self.dubboServiceName = dict["DubboServiceName"] as! String
                    }
                    if dict.keys.contains("DubboServiceVersion") && dict["DubboServiceVersion"] != nil {
                        self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                    }
                    if dict.keys.contains("MothedMapList") && dict["MothedMapList"] != nil {
                        var tmp : [GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList] = []
                        for v in dict["MothedMapList"] as! [Any] {
                            var model = GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.mothedMapList = tmp
                    }
                }
            }
            public var agreementType: String?

            public var groupName: String?

            public var healthStatus: String?

            public var httpDubboTranscoder: GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder?

            public var name: String?

            public var namespace: String?

            public var percent: Int32?

            public var serviceId: Int64?

            public var serviceName: String?

            public var servicePort: Int32?

            public var sourceType: String?

            public var unhealthyEndpoints: [String]?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.httpDubboTranscoder?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agreementType != nil {
                    map["AgreementType"] = self.agreementType!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.httpDubboTranscoder != nil {
                    map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.unhealthyEndpoints != nil {
                    map["UnhealthyEndpoints"] = self.unhealthyEndpoints!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgreementType") && dict["AgreementType"] != nil {
                    self.agreementType = dict["AgreementType"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("HttpDubboTranscoder") && dict["HttpDubboTranscoder"] != nil {
                    var model = GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder()
                    model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                    self.httpDubboTranscoder = model
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Percent") && dict["Percent"] != nil {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                    self.servicePort = dict["ServicePort"] as! Int32
                }
                if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("UnhealthyEndpoints") && dict["UnhealthyEndpoints"] != nil {
                    self.unhealthyEndpoints = dict["UnhealthyEndpoints"] as! [String]
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Timeout : Tea.TeaModel {
            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") && dict["TimeUnit"] != nil {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") && dict["UnitNum"] != nil {
                    self.unitNum = dict["UnitNum"] as! Int32
                }
            }
        }
        public var ahasStatus: Int32?

        public var cors: GetGatewayRouteDetailResponseBody.Data.Cors?

        public var defaultServiceId: Int64?

        public var defaultServiceName: String?

        public var description_: String?

        public var destinationType: String?

        public var directResponse: GetGatewayRouteDetailResponseBody.Data.DirectResponse?

        public var domainId: Int64?

        public var domainIdList: [Int64]?

        public var domainName: String?

        public var domainNameList: [String]?

        public var enableWaf: Bool?

        public var fallback: Bool?

        public var fallbackServices: [GetGatewayRouteDetailResponseBody.Data.FallbackServices]?

        public var flowMirror: GetGatewayRouteDetailResponseBody.Data.FlowMirror?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var HTTPRewrite: GetGatewayRouteDetailResponseBody.Data.HTTPRewrite?

        public var headerOp: GetGatewayRouteDetailResponseBody.Data.HeaderOp?

        public var id: Int64?

        public var name: String?

        public var policies: String?

        public var predicates: String?

        public var redirect: GetGatewayRouteDetailResponseBody.Data.Redirect?

        public var retry: GetGatewayRouteDetailResponseBody.Data.Retry?

        public var routeOrder: Int32?

        public var routePredicates: GetGatewayRouteDetailResponseBody.Data.RoutePredicates?

        public var routeServices: [GetGatewayRouteDetailResponseBody.Data.RouteServices]?

        public var services: String?

        public var status: Int32?

        public var timeout: GetGatewayRouteDetailResponseBody.Data.Timeout?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cors?.validate()
            try self.directResponse?.validate()
            try self.flowMirror?.validate()
            try self.HTTPRewrite?.validate()
            try self.headerOp?.validate()
            try self.redirect?.validate()
            try self.retry?.validate()
            try self.routePredicates?.validate()
            try self.timeout?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ahasStatus != nil {
                map["AhasStatus"] = self.ahasStatus!
            }
            if self.cors != nil {
                map["Cors"] = self.cors?.toMap()
            }
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.defaultServiceName != nil {
                map["DefaultServiceName"] = self.defaultServiceName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationType != nil {
                map["DestinationType"] = self.destinationType!
            }
            if self.directResponse != nil {
                map["DirectResponse"] = self.directResponse?.toMap()
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainIdList != nil {
                map["DomainIdList"] = self.domainIdList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameList != nil {
                map["DomainNameList"] = self.domainNameList!
            }
            if self.enableWaf != nil {
                map["EnableWaf"] = self.enableWaf!
            }
            if self.fallback != nil {
                map["Fallback"] = self.fallback!
            }
            if self.fallbackServices != nil {
                var tmp : [Any] = []
                for k in self.fallbackServices! {
                    tmp.append(k.toMap())
                }
                map["FallbackServices"] = tmp
            }
            if self.flowMirror != nil {
                map["FlowMirror"] = self.flowMirror?.toMap()
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.HTTPRewrite != nil {
                map["HTTPRewrite"] = self.HTTPRewrite?.toMap()
            }
            if self.headerOp != nil {
                map["HeaderOp"] = self.headerOp?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.policies != nil {
                map["Policies"] = self.policies!
            }
            if self.predicates != nil {
                map["Predicates"] = self.predicates!
            }
            if self.redirect != nil {
                map["Redirect"] = self.redirect?.toMap()
            }
            if self.retry != nil {
                map["Retry"] = self.retry?.toMap()
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.routePredicates != nil {
                map["RoutePredicates"] = self.routePredicates?.toMap()
            }
            if self.routeServices != nil {
                var tmp : [Any] = []
                for k in self.routeServices! {
                    tmp.append(k.toMap())
                }
                map["RouteServices"] = tmp
            }
            if self.services != nil {
                map["Services"] = self.services!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AhasStatus") && dict["AhasStatus"] != nil {
                self.ahasStatus = dict["AhasStatus"] as! Int32
            }
            if dict.keys.contains("Cors") && dict["Cors"] != nil {
                var model = GetGatewayRouteDetailResponseBody.Data.Cors()
                model.fromMap(dict["Cors"] as! [String: Any])
                self.cors = model
            }
            if dict.keys.contains("DefaultServiceId") && dict["DefaultServiceId"] != nil {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("DefaultServiceName") && dict["DefaultServiceName"] != nil {
                self.defaultServiceName = dict["DefaultServiceName"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationType") && dict["DestinationType"] != nil {
                self.destinationType = dict["DestinationType"] as! String
            }
            if dict.keys.contains("DirectResponse") && dict["DirectResponse"] != nil {
                var model = GetGatewayRouteDetailResponseBody.Data.DirectResponse()
                model.fromMap(dict["DirectResponse"] as! [String: Any])
                self.directResponse = model
            }
            if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainIdList") && dict["DomainIdList"] != nil {
                self.domainIdList = dict["DomainIdList"] as! [Int64]
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainNameList") && dict["DomainNameList"] != nil {
                self.domainNameList = dict["DomainNameList"] as! [String]
            }
            if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
                self.enableWaf = dict["EnableWaf"] as! Bool
            }
            if dict.keys.contains("Fallback") && dict["Fallback"] != nil {
                self.fallback = dict["Fallback"] as! Bool
            }
            if dict.keys.contains("FallbackServices") && dict["FallbackServices"] != nil {
                var tmp : [GetGatewayRouteDetailResponseBody.Data.FallbackServices] = []
                for v in dict["FallbackServices"] as! [Any] {
                    var model = GetGatewayRouteDetailResponseBody.Data.FallbackServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fallbackServices = tmp
            }
            if dict.keys.contains("FlowMirror") && dict["FlowMirror"] != nil {
                var model = GetGatewayRouteDetailResponseBody.Data.FlowMirror()
                model.fromMap(dict["FlowMirror"] as! [String: Any])
                self.flowMirror = model
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("HTTPRewrite") && dict["HTTPRewrite"] != nil {
                var model = GetGatewayRouteDetailResponseBody.Data.HTTPRewrite()
                model.fromMap(dict["HTTPRewrite"] as! [String: Any])
                self.HTTPRewrite = model
            }
            if dict.keys.contains("HeaderOp") && dict["HeaderOp"] != nil {
                var model = GetGatewayRouteDetailResponseBody.Data.HeaderOp()
                model.fromMap(dict["HeaderOp"] as! [String: Any])
                self.headerOp = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Policies") && dict["Policies"] != nil {
                self.policies = dict["Policies"] as! String
            }
            if dict.keys.contains("Predicates") && dict["Predicates"] != nil {
                self.predicates = dict["Predicates"] as! String
            }
            if dict.keys.contains("Redirect") && dict["Redirect"] != nil {
                var model = GetGatewayRouteDetailResponseBody.Data.Redirect()
                model.fromMap(dict["Redirect"] as! [String: Any])
                self.redirect = model
            }
            if dict.keys.contains("Retry") && dict["Retry"] != nil {
                var model = GetGatewayRouteDetailResponseBody.Data.Retry()
                model.fromMap(dict["Retry"] as! [String: Any])
                self.retry = model
            }
            if dict.keys.contains("RouteOrder") && dict["RouteOrder"] != nil {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("RoutePredicates") && dict["RoutePredicates"] != nil {
                var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates()
                model.fromMap(dict["RoutePredicates"] as! [String: Any])
                self.routePredicates = model
            }
            if dict.keys.contains("RouteServices") && dict["RouteServices"] != nil {
                var tmp : [GetGatewayRouteDetailResponseBody.Data.RouteServices] = []
                for v in dict["RouteServices"] as! [Any] {
                    var model = GetGatewayRouteDetailResponseBody.Data.RouteServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routeServices = tmp
            }
            if dict.keys.contains("Services") && dict["Services"] != nil {
                self.services = dict["Services"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                var model = GetGatewayRouteDetailResponseBody.Data.Timeout()
                model.fromMap(dict["Timeout"] as! [String: Any])
                self.timeout = model
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayRouteDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetGatewayRouteDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayRouteDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayRouteDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetGatewayRouteDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayServiceDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! Int64
        }
    }
}

public class GetGatewayServiceDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class LabelDetails : Tea.TeaModel {
            public var key: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Values") && dict["Values"] != nil {
                    self.values = dict["Values"] as! [String]
                }
            }
        }
        public class PortTrafficPolicyList : Tea.TeaModel {
            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var serviceId: Int64?

            public var servicePort: Int32?

            public var trafficPolicy: TrafficPolicy?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.trafficPolicy?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.trafficPolicy != nil {
                    map["TrafficPolicy"] = self.trafficPolicy?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                    self.servicePort = dict["ServicePort"] as! Int32
                }
                if dict.keys.contains("TrafficPolicy") && dict["TrafficPolicy"] != nil {
                    var model = TrafficPolicy()
                    model.fromMap(dict["TrafficPolicy"] as! [String: Any])
                    self.trafficPolicy = model
                }
            }
        }
        public class VersionDetails : Tea.TeaModel {
            public class ServiceVersion : Tea.TeaModel {
                public class Labels : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var labels: [GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion.Labels]?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.labels != nil {
                        var tmp : [Any] = []
                        for k in self.labels! {
                            tmp.append(k.toMap())
                        }
                        map["Labels"] = tmp
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Labels") && dict["Labels"] != nil {
                        var tmp : [GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion.Labels] = []
                        for v in dict["Labels"] as! [Any] {
                            var model = GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion.Labels()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.labels = tmp
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var endpointNum: Int32?

            public var endpointNumPercent: String?

            public var serviceVersion: GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.serviceVersion?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpointNum != nil {
                    map["EndpointNum"] = self.endpointNum!
                }
                if self.endpointNumPercent != nil {
                    map["EndpointNumPercent"] = self.endpointNumPercent!
                }
                if self.serviceVersion != nil {
                    map["ServiceVersion"] = self.serviceVersion?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndpointNum") && dict["EndpointNum"] != nil {
                    self.endpointNum = dict["EndpointNum"] as! Int32
                }
                if dict.keys.contains("EndpointNumPercent") && dict["EndpointNumPercent"] != nil {
                    self.endpointNumPercent = dict["EndpointNumPercent"] as! String
                }
                if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
                    var model = GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion()
                    model.fromMap(dict["ServiceVersion"] as! [String: Any])
                    self.serviceVersion = model
                }
            }
        }
        public class Versions : Tea.TeaModel {
            public var label: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var gatewayId: Int64?

        public var gatewayTrafficPolicy: TrafficPolicy?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupName: String?

        public var healthCheck: String?

        public var healthStatus: String?

        public var id: Int64?

        public var ips: [String]?

        public var labelDetails: [GetGatewayServiceDetailResponseBody.Data.LabelDetails]?

        public var metaInfo: String?

        public var name: String?

        public var namespace: String?

        public var portTrafficPolicyList: [GetGatewayServiceDetailResponseBody.Data.PortTrafficPolicyList]?

        public var ports: [Int32]?

        public var serviceNameInRegistry: String?

        public var serviceProtocol: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public var versionDetails: [GetGatewayServiceDetailResponseBody.Data.VersionDetails]?

        public var versions: [GetGatewayServiceDetailResponseBody.Data.Versions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.gatewayTrafficPolicy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayTrafficPolicy != nil {
                map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.healthCheck != nil {
                map["HealthCheck"] = self.healthCheck!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.labelDetails != nil {
                var tmp : [Any] = []
                for k in self.labelDetails! {
                    tmp.append(k.toMap())
                }
                map["LabelDetails"] = tmp
            }
            if self.metaInfo != nil {
                map["MetaInfo"] = self.metaInfo!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.portTrafficPolicyList != nil {
                var tmp : [Any] = []
                for k in self.portTrafficPolicyList! {
                    tmp.append(k.toMap())
                }
                map["PortTrafficPolicyList"] = tmp
            }
            if self.ports != nil {
                map["Ports"] = self.ports!
            }
            if self.serviceNameInRegistry != nil {
                map["ServiceNameInRegistry"] = self.serviceNameInRegistry!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.sourceId != nil {
                map["SourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.versionDetails != nil {
                var tmp : [Any] = []
                for k in self.versionDetails! {
                    tmp.append(k.toMap())
                }
                map["VersionDetails"] = tmp
            }
            if self.versions != nil {
                var tmp : [Any] = []
                for k in self.versions! {
                    tmp.append(k.toMap())
                }
                map["Versions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayTrafficPolicy") && dict["GatewayTrafficPolicy"] != nil {
                var model = TrafficPolicy()
                model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
                self.gatewayTrafficPolicy = model
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
                self.healthCheck = dict["HealthCheck"] as! String
            }
            if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Ips") && dict["Ips"] != nil {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("LabelDetails") && dict["LabelDetails"] != nil {
                var tmp : [GetGatewayServiceDetailResponseBody.Data.LabelDetails] = []
                for v in dict["LabelDetails"] as! [Any] {
                    var model = GetGatewayServiceDetailResponseBody.Data.LabelDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labelDetails = tmp
            }
            if dict.keys.contains("MetaInfo") && dict["MetaInfo"] != nil {
                self.metaInfo = dict["MetaInfo"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PortTrafficPolicyList") && dict["PortTrafficPolicyList"] != nil {
                var tmp : [GetGatewayServiceDetailResponseBody.Data.PortTrafficPolicyList] = []
                for v in dict["PortTrafficPolicyList"] as! [Any] {
                    var model = GetGatewayServiceDetailResponseBody.Data.PortTrafficPolicyList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portTrafficPolicyList = tmp
            }
            if dict.keys.contains("Ports") && dict["Ports"] != nil {
                self.ports = dict["Ports"] as! [Int32]
            }
            if dict.keys.contains("ServiceNameInRegistry") && dict["ServiceNameInRegistry"] != nil {
                self.serviceNameInRegistry = dict["ServiceNameInRegistry"] as! String
            }
            if dict.keys.contains("ServiceProtocol") && dict["ServiceProtocol"] != nil {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("SourceId") && dict["SourceId"] != nil {
                self.sourceId = dict["SourceId"] as! Int64
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("VersionDetails") && dict["VersionDetails"] != nil {
                var tmp : [GetGatewayServiceDetailResponseBody.Data.VersionDetails] = []
                for v in dict["VersionDetails"] as! [Any] {
                    var model = GetGatewayServiceDetailResponseBody.Data.VersionDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.versionDetails = tmp
            }
            if dict.keys.contains("Versions") && dict["Versions"] != nil {
                var tmp : [GetGatewayServiceDetailResponseBody.Data.Versions] = []
                for v in dict["Versions"] as! [Any] {
                    var model = GetGatewayServiceDetailResponseBody.Data.Versions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.versions = tmp
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayServiceDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetGatewayServiceDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayServiceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayServiceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetGatewayServiceDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGovernanceKubernetesClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetGovernanceKubernetesClusterResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Namespaces : Tea.TeaModel {
            public var mseNamespace: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mseNamespace != nil {
                    map["MseNamespace"] = self.mseNamespace!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MseNamespace") && dict["MseNamespace"] != nil {
                    self.mseNamespace = dict["MseNamespace"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var clusterId: String?

        public var clusterName: String?

        public var k8sVersion: String?

        public var namespaceInfos: String?

        public var namespaces: [GetGovernanceKubernetesClusterResponseBody.Data.Namespaces]?

        public var pilotStartTime: String?

        public var region: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.k8sVersion != nil {
                map["K8sVersion"] = self.k8sVersion!
            }
            if self.namespaceInfos != nil {
                map["NamespaceInfos"] = self.namespaceInfos!
            }
            if self.namespaces != nil {
                var tmp : [Any] = []
                for k in self.namespaces! {
                    tmp.append(k.toMap())
                }
                map["Namespaces"] = tmp
            }
            if self.pilotStartTime != nil {
                map["PilotStartTime"] = self.pilotStartTime!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("K8sVersion") && dict["K8sVersion"] != nil {
                self.k8sVersion = dict["K8sVersion"] as! String
            }
            if dict.keys.contains("NamespaceInfos") && dict["NamespaceInfos"] != nil {
                self.namespaceInfos = dict["NamespaceInfos"] as! String
            }
            if dict.keys.contains("Namespaces") && dict["Namespaces"] != nil {
                var tmp : [GetGovernanceKubernetesClusterResponseBody.Data.Namespaces] = []
                for v in dict["Namespaces"] as! [Any] {
                    var model = GetGovernanceKubernetesClusterResponseBody.Data.Namespaces()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.namespaces = tmp
            }
            if dict.keys.contains("PilotStartTime") && dict["PilotStartTime"] != nil {
                self.pilotStartTime = dict["PilotStartTime"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var data: GetGovernanceKubernetesClusterResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetGovernanceKubernetesClusterResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGovernanceKubernetesClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGovernanceKubernetesClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetGovernanceKubernetesClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class GetImageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var currentVersionFullShowName: String?

        public var maxVersionChangelogUrl: String?

        public var maxVersionCode: String?

        public var maxVersionFullShowName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentVersionFullShowName != nil {
                map["CurrentVersionFullShowName"] = self.currentVersionFullShowName!
            }
            if self.maxVersionChangelogUrl != nil {
                map["MaxVersionChangelogUrl"] = self.maxVersionChangelogUrl!
            }
            if self.maxVersionCode != nil {
                map["MaxVersionCode"] = self.maxVersionCode!
            }
            if self.maxVersionFullShowName != nil {
                map["MaxVersionFullShowName"] = self.maxVersionFullShowName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentVersionFullShowName") && dict["CurrentVersionFullShowName"] != nil {
                self.currentVersionFullShowName = dict["CurrentVersionFullShowName"] as! String
            }
            if dict.keys.contains("MaxVersionChangelogUrl") && dict["MaxVersionChangelogUrl"] != nil {
                self.maxVersionChangelogUrl = dict["MaxVersionChangelogUrl"] as! String
            }
            if dict.keys.contains("MaxVersionCode") && dict["MaxVersionCode"] != nil {
                self.maxVersionCode = dict["MaxVersionCode"] as! String
            }
            if dict.keys.contains("MaxVersionFullShowName") && dict["MaxVersionFullShowName"] != nil {
                self.maxVersionFullShowName = dict["MaxVersionFullShowName"] as! String
            }
        }
    }
    public var data: GetImageResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetImageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImportFileUrlRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var contentType: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class GetImportFileUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetImportFileUrlResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetImportFileUrlResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetImportFileUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImportFileUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetImportFileUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetKubernetesSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var isAll: Bool?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isAll != nil {
            map["IsAll"] = self.isAll!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsAll") && dict["IsAll"] != nil {
            self.isAll = dict["IsAll"] as! Bool
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class GetKubernetesSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cluster: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cluster != nil {
                map["Cluster"] = self.cluster!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cluster") && dict["Cluster"] != nil {
                self.cluster = dict["Cluster"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetKubernetesSourceResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetKubernetesSourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetKubernetesSourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetKubernetesSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetKubernetesSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetKubernetesSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLosslessRuleByAppRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetLosslessRuleByAppResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aligned: Bool?

        public var appId: String?

        public var appName: String?

        public var count: Int32?

        public var delayTime: Int32?

        public var enable: Bool?

        public var funcType: Int32?

        public var lossLessDetail: Bool?

        public var notice: Bool?

        public var related: Bool?

        public var warmupTime: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aligned != nil {
                map["Aligned"] = self.aligned!
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.delayTime != nil {
                map["DelayTime"] = self.delayTime!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.funcType != nil {
                map["FuncType"] = self.funcType!
            }
            if self.lossLessDetail != nil {
                map["LossLessDetail"] = self.lossLessDetail!
            }
            if self.notice != nil {
                map["Notice"] = self.notice!
            }
            if self.related != nil {
                map["Related"] = self.related!
            }
            if self.warmupTime != nil {
                map["WarmupTime"] = self.warmupTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Aligned") && dict["Aligned"] != nil {
                self.aligned = dict["Aligned"] as! Bool
            }
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("DelayTime") && dict["DelayTime"] != nil {
                self.delayTime = dict["DelayTime"] as! Int32
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("FuncType") && dict["FuncType"] != nil {
                self.funcType = dict["FuncType"] as! Int32
            }
            if dict.keys.contains("LossLessDetail") && dict["LossLessDetail"] != nil {
                self.lossLessDetail = dict["LossLessDetail"] as! Bool
            }
            if dict.keys.contains("Notice") && dict["Notice"] != nil {
                self.notice = dict["Notice"] as! Bool
            }
            if dict.keys.contains("Related") && dict["Related"] != nil {
                self.related = dict["Related"] as! Bool
            }
            if dict.keys.contains("WarmupTime") && dict["WarmupTime"] != nil {
                self.warmupTime = dict["WarmupTime"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GetLosslessRuleByAppResponseBody.Data?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetLosslessRuleByAppResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetLosslessRuleByAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLosslessRuleByAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLosslessRuleByAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMseFeatureSwitchRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class GetMseFeatureSwitchResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [String: Any]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! [String: Any]
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMseFeatureSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMseFeatureSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMseFeatureSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMseSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetMseSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var address: String?

        public var clusterId: String?

        public var instanceId: String?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetMseSourceResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetMseSourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetMseSourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMseSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMseSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMseSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var beta: Bool?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.beta != nil {
            map["Beta"] = self.beta!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Beta") && dict["Beta"] != nil {
            self.beta = dict["Beta"] as! Bool
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class GetNacosConfigResponseBody : Tea.TeaModel {
    public class Configuration : Tea.TeaModel {
        public var appName: String?

        public var betaIps: String?

        public var content: String?

        public var dataId: String?

        public var desc: String?

        public var encryptedDataKey: String?

        public var group: String?

        public var md5: String?

        public var tags: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.betaIps != nil {
                map["BetaIps"] = self.betaIps!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.encryptedDataKey != nil {
                map["EncryptedDataKey"] = self.encryptedDataKey!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("BetaIps") && dict["BetaIps"] != nil {
                self.betaIps = dict["BetaIps"] as! String
            }
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("DataId") && dict["DataId"] != nil {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("EncryptedDataKey") && dict["EncryptedDataKey"] != nil {
                self.encryptedDataKey = dict["EncryptedDataKey"] as! String
            }
            if dict.keys.contains("Group") && dict["Group"] != nil {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Md5") && dict["Md5"] != nil {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var configuration: GetNacosConfigResponseBody.Configuration?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configuration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configuration != nil {
            map["Configuration"] = self.configuration?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configuration") && dict["Configuration"] != nil {
            var model = GetNacosConfigResponseBody.Configuration()
            model.fromMap(dict["Configuration"] as! [String: Any])
            self.configuration = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNacosHistoryConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var nid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nid != nil {
            map["Nid"] = self.nid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Nid") && dict["Nid"] != nil {
            self.nid = dict["Nid"] as! String
        }
    }
}

public class GetNacosHistoryConfigResponseBody : Tea.TeaModel {
    public class Configuration : Tea.TeaModel {
        public var appName: String?

        public var content: String?

        public var dataId: String?

        public var encryptedDataKey: String?

        public var group: String?

        public var md5: String?

        public var opType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.encryptedDataKey != nil {
                map["EncryptedDataKey"] = self.encryptedDataKey!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("DataId") && dict["DataId"] != nil {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("EncryptedDataKey") && dict["EncryptedDataKey"] != nil {
                self.encryptedDataKey = dict["EncryptedDataKey"] as! String
            }
            if dict.keys.contains("Group") && dict["Group"] != nil {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Md5") && dict["Md5"] != nil {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("OpType") && dict["OpType"] != nil {
                self.opType = dict["OpType"] as! String
            }
        }
    }
    public var configuration: GetNacosHistoryConfigResponseBody.Configuration?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configuration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configuration != nil {
            map["Configuration"] = self.configuration?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configuration") && dict["Configuration"] != nil {
            var model = GetNacosHistoryConfigResponseBody.Configuration()
            model.fromMap(dict["Configuration"] as! [String: Any])
            self.configuration = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNacosHistoryConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNacosHistoryConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNacosHistoryConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOverviewRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var period: Int32?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
    }
}

public class GetOverviewResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetOverviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOverviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOverviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPluginConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var pluginId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
            self.pluginId = dict["PluginId"] as! Int64
        }
    }
}

public class GetPluginConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class GatewayConfigList : Tea.TeaModel {
            public var config: String?

            public var configLevel: Int32?

            public var enable: Bool?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var pluginId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.config != nil {
                    map["Config"] = self.config!
                }
                if self.configLevel != nil {
                    map["ConfigLevel"] = self.configLevel!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.pluginId != nil {
                    map["PluginId"] = self.pluginId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Config") && dict["Config"] != nil {
                    self.config = dict["Config"] as! String
                }
                if dict.keys.contains("ConfigLevel") && dict["ConfigLevel"] != nil {
                    self.configLevel = dict["ConfigLevel"] as! Int32
                }
                if dict.keys.contains("Enable") && dict["Enable"] != nil {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
                    self.pluginId = dict["PluginId"] as! Int64
                }
            }
        }
        public var category: Int32?

        public var configCheck: String?

        public var gatewayConfigList: [GetPluginConfigResponseBody.Data.GatewayConfigList]?

        public var id: Int64?

        public var imageName: String?

        public var mode: Int32?

        public var name: String?

        public var phase: Int32?

        public var primaryUser: String?

        public var priority: Int32?

        public var publishState: Int32?

        public var readme: String?

        public var readmeEn: String?

        public var status: String?

        public var summary: String?

        public var type: Int32?

        public var version: String?

        public var versionJson: String?

        public var wasmLang: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configCheck != nil {
                map["ConfigCheck"] = self.configCheck!
            }
            if self.gatewayConfigList != nil {
                var tmp : [Any] = []
                for k in self.gatewayConfigList! {
                    tmp.append(k.toMap())
                }
                map["GatewayConfigList"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.readme != nil {
                map["Readme"] = self.readme!
            }
            if self.readmeEn != nil {
                map["ReadmeEn"] = self.readmeEn!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.versionJson != nil {
                map["VersionJson"] = self.versionJson!
            }
            if self.wasmLang != nil {
                map["WasmLang"] = self.wasmLang!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! Int32
            }
            if dict.keys.contains("ConfigCheck") && dict["ConfigCheck"] != nil {
                self.configCheck = dict["ConfigCheck"] as! String
            }
            if dict.keys.contains("GatewayConfigList") && dict["GatewayConfigList"] != nil {
                var tmp : [GetPluginConfigResponseBody.Data.GatewayConfigList] = []
                for v in dict["GatewayConfigList"] as! [Any] {
                    var model = GetPluginConfigResponseBody.Data.GatewayConfigList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.gatewayConfigList = tmp
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("Mode") && dict["Mode"] != nil {
                self.mode = dict["Mode"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Phase") && dict["Phase"] != nil {
                self.phase = dict["Phase"] as! Int32
            }
            if dict.keys.contains("PrimaryUser") && dict["PrimaryUser"] != nil {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("PublishState") && dict["PublishState"] != nil {
                self.publishState = dict["PublishState"] as! Int32
            }
            if dict.keys.contains("Readme") && dict["Readme"] != nil {
                self.readme = dict["Readme"] as! String
            }
            if dict.keys.contains("ReadmeEn") && dict["ReadmeEn"] != nil {
                self.readmeEn = dict["ReadmeEn"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") && dict["Summary"] != nil {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("VersionJson") && dict["VersionJson"] != nil {
                self.versionJson = dict["VersionJson"] as! String
            }
            if dict.keys.contains("WasmLang") && dict["WasmLang"] != nil {
                self.wasmLang = dict["WasmLang"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GetPluginConfigResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetPluginConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPluginConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPluginConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPluginConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPluginsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var category: Int32?

    public var enableOnly: Bool?

    public var gatewayUniqueId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.enableOnly != nil {
            map["EnableOnly"] = self.enableOnly!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! Int32
        }
        if dict.keys.contains("EnableOnly") && dict["EnableOnly"] != nil {
            self.enableOnly = dict["EnableOnly"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class GetPluginsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var category: Int32?

        public var configCheck: String?

        public var id: Int64?

        public var maxVersion: String?

        public var mode: Int32?

        public var name: String?

        public var newVersionPublishingFlag: Bool?

        public var phase: Int32?

        public var primaryUser: String?

        public var priority: Int32?

        public var publishState: Int32?

        public var status: String?

        public var summary: String?

        public var version: String?

        public var wasmFile: String?

        public var wasmLang: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configCheck != nil {
                map["ConfigCheck"] = self.configCheck!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxVersion != nil {
                map["MaxVersion"] = self.maxVersion!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.newVersionPublishingFlag != nil {
                map["NewVersionPublishingFlag"] = self.newVersionPublishingFlag!
            }
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.wasmFile != nil {
                map["WasmFile"] = self.wasmFile!
            }
            if self.wasmLang != nil {
                map["WasmLang"] = self.wasmLang!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! Int32
            }
            if dict.keys.contains("ConfigCheck") && dict["ConfigCheck"] != nil {
                self.configCheck = dict["ConfigCheck"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MaxVersion") && dict["MaxVersion"] != nil {
                self.maxVersion = dict["MaxVersion"] as! String
            }
            if dict.keys.contains("Mode") && dict["Mode"] != nil {
                self.mode = dict["Mode"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NewVersionPublishingFlag") && dict["NewVersionPublishingFlag"] != nil {
                self.newVersionPublishingFlag = dict["NewVersionPublishingFlag"] as! Bool
            }
            if dict.keys.contains("Phase") && dict["Phase"] != nil {
                self.phase = dict["Phase"] as! Int32
            }
            if dict.keys.contains("PrimaryUser") && dict["PrimaryUser"] != nil {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("PublishState") && dict["PublishState"] != nil {
                self.publishState = dict["PublishState"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") && dict["Summary"] != nil {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("WasmFile") && dict["WasmFile"] != nil {
                self.wasmFile = dict["WasmFile"] as! String
            }
            if dict.keys.contains("WasmLang") && dict["WasmLang"] != nil {
                self.wasmLang = dict["WasmLang"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: [GetPluginsResponseBody.Data]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetPluginsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetPluginsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPluginsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var ip: String?

    public var region: String?

    public var serviceName: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class GetServiceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Methods : Tea.TeaModel {
            public var methodController: String?

            public var name: String?

            public var parameterTypes: [String]?

            public var paths: [String]?

            public var requestMethods: [String]?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MethodController") && dict["MethodController"] != nil {
                    self.methodController = dict["MethodController"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParameterTypes") && dict["ParameterTypes"] != nil {
                    self.parameterTypes = dict["ParameterTypes"] as! [String]
                }
                if dict.keys.contains("Paths") && dict["Paths"] != nil {
                    self.paths = dict["Paths"] as! [String]
                }
                if dict.keys.contains("RequestMethods") && dict["RequestMethods"] != nil {
                    self.requestMethods = dict["RequestMethods"] as! [String]
                }
                if dict.keys.contains("ReturnType") && dict["ReturnType"] != nil {
                    self.returnType = dict["ReturnType"] as! String
                }
            }
        }
        public var dubboApplicationName: String?

        public var edasAppName: String?

        public var group: String?

        public var metadata: [String: Any]?

        public var methods: [GetServiceListResponseBody.Data.Methods]?

        public var registryType: String?

        public var serviceName: String?

        public var serviceType: String?

        public var springApplicationName: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dubboApplicationName != nil {
                map["DubboApplicationName"] = self.dubboApplicationName!
            }
            if self.edasAppName != nil {
                map["EdasAppName"] = self.edasAppName!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.methods != nil {
                var tmp : [Any] = []
                for k in self.methods! {
                    tmp.append(k.toMap())
                }
                map["Methods"] = tmp
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.springApplicationName != nil {
                map["SpringApplicationName"] = self.springApplicationName!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DubboApplicationName") && dict["DubboApplicationName"] != nil {
                self.dubboApplicationName = dict["DubboApplicationName"] as! String
            }
            if dict.keys.contains("EdasAppName") && dict["EdasAppName"] != nil {
                self.edasAppName = dict["EdasAppName"] as! String
            }
            if dict.keys.contains("Group") && dict["Group"] != nil {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Metadata") && dict["Metadata"] != nil {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Methods") && dict["Methods"] != nil {
                var tmp : [GetServiceListResponseBody.Data.Methods] = []
                for v in dict["Methods"] as! [Any] {
                    var model = GetServiceListResponseBody.Data.Methods()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.methods = tmp
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("SpringApplicationName") && dict["SpringApplicationName"] != nil {
                self.springApplicationName = dict["SpringApplicationName"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetServiceListResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetServiceListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetServiceListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceListPageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var ip: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var serviceName: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class GetServiceListPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var gmtModifyTime: String?

            public var group: String?

            public var instanceNum: Int32?

            public var serviceName: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.gmtModifyTime != nil {
                    map["GmtModifyTime"] = self.gmtModifyTime!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                if self.instanceNum != nil {
                    map["InstanceNum"] = self.instanceNum!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("GmtModifyTime") && dict["GmtModifyTime"] != nil {
                    self.gmtModifyTime = dict["GmtModifyTime"] as! String
                }
                if dict.keys.contains("Group") && dict["Group"] != nil {
                    self.group = dict["Group"] as! String
                }
                if dict.keys.contains("InstanceNum") && dict["InstanceNum"] != nil {
                    self.instanceNum = dict["InstanceNum"] as! Int32
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var pageNumber: String?

        public var pageSize: String?

        public var result: [GetServiceListPageResponseBody.Data.Result]?

        public var totalSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [GetServiceListPageResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetServiceListPageResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! String
            }
        }
    }
    public var data: GetServiceListPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetServiceListPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceListPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceListPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceListenersRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var hasIpCount: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.hasIpCount != nil {
            map["HasIpCount"] = self.hasIpCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HasIpCount") && dict["HasIpCount"] != nil {
            self.hasIpCount = dict["HasIpCount"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class GetServiceListenersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var addr: String?

        public var agent: String?

        public var app: String?

        public var cluster: String?

        public var IP: String?

        public var namespaceId: String?

        public var port: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                map["Addr"] = self.addr!
            }
            if self.agent != nil {
                map["Agent"] = self.agent!
            }
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.cluster != nil {
                map["Cluster"] = self.cluster!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") && dict["Addr"] != nil {
                self.addr = dict["Addr"] as! String
            }
            if dict.keys.contains("Agent") && dict["Agent"] != nil {
                self.agent = dict["Agent"] as! String
            }
            if dict.keys.contains("App") && dict["App"] != nil {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("Cluster") && dict["Cluster"] != nil {
                self.cluster = dict["Cluster"] as! String
            }
            if dict.keys.contains("IP") && dict["IP"] != nil {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public var data: [GetServiceListenersResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetServiceListenersResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetServiceListenersResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class GetServiceListenersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListenersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceListenersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceMethodPageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var ip: String?

    public var methodController: String?

    public var name: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var path: String?

    public var region: String?

    public var serviceGroup: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.methodController != nil {
            map["MethodController"] = self.methodController!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.serviceGroup != nil {
            map["ServiceGroup"] = self.serviceGroup!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("MethodController") && dict["MethodController"] != nil {
            self.methodController = dict["MethodController"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ServiceGroup") && dict["ServiceGroup"] != nil {
            self.serviceGroup = dict["ServiceGroup"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
            self.serviceType = dict["ServiceType"] as! String
        }
        if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class GetServiceMethodPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class ParameterDefinitions : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var methodController: String?

            public var name: String?

            public var nameDetail: String?

            public var parameterDefinitions: [GetServiceMethodPageResponseBody.Data.Result.ParameterDefinitions]?

            public var parameterDetails: [String]?

            public var parameterTypes: [String]?

            public var paths: [String]?

            public var requestMethods: [String]?

            public var returnDetails: String?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameDetail != nil {
                    map["NameDetail"] = self.nameDetail!
                }
                if self.parameterDefinitions != nil {
                    var tmp : [Any] = []
                    for k in self.parameterDefinitions! {
                        tmp.append(k.toMap())
                    }
                    map["ParameterDefinitions"] = tmp
                }
                if self.parameterDetails != nil {
                    map["ParameterDetails"] = self.parameterDetails!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnDetails != nil {
                    map["ReturnDetails"] = self.returnDetails!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MethodController") && dict["MethodController"] != nil {
                    self.methodController = dict["MethodController"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameDetail") && dict["NameDetail"] != nil {
                    self.nameDetail = dict["NameDetail"] as! String
                }
                if dict.keys.contains("ParameterDefinitions") && dict["ParameterDefinitions"] != nil {
                    var tmp : [GetServiceMethodPageResponseBody.Data.Result.ParameterDefinitions] = []
                    for v in dict["ParameterDefinitions"] as! [Any] {
                        var model = GetServiceMethodPageResponseBody.Data.Result.ParameterDefinitions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.parameterDefinitions = tmp
                }
                if dict.keys.contains("ParameterDetails") && dict["ParameterDetails"] != nil {
                    self.parameterDetails = dict["ParameterDetails"] as! [String]
                }
                if dict.keys.contains("ParameterTypes") && dict["ParameterTypes"] != nil {
                    self.parameterTypes = dict["ParameterTypes"] as! [String]
                }
                if dict.keys.contains("Paths") && dict["Paths"] != nil {
                    self.paths = dict["Paths"] as! [String]
                }
                if dict.keys.contains("RequestMethods") && dict["RequestMethods"] != nil {
                    self.requestMethods = dict["RequestMethods"] as! [String]
                }
                if dict.keys.contains("ReturnDetails") && dict["ReturnDetails"] != nil {
                    self.returnDetails = dict["ReturnDetails"] as! String
                }
                if dict.keys.contains("ReturnType") && dict["ReturnType"] != nil {
                    self.returnType = dict["ReturnType"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GetServiceMethodPageResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [GetServiceMethodPageResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetServiceMethodPageResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: GetServiceMethodPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetServiceMethodPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceMethodPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceMethodPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceMethodPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTagsBySwimmingLaneGroupIdRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class GetTagsBySwimmingLaneGroupIdResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTagsBySwimmingLaneGroupIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTagsBySwimmingLaneGroupIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTagsBySwimmingLaneGroupIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetZookeeperDataImportUrlRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var contentType: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetZookeeperDataImportUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var maxSize: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaxSize") && dict["MaxSize"] != nil {
                self.maxSize = dict["MaxSize"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetZookeeperDataImportUrlResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetZookeeperDataImportUrlResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetZookeeperDataImportUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetZookeeperDataImportUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetZookeeperDataImportUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var fileUrl: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var policy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! String
        }
    }
}

public class ImportNacosConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FailData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") && dict["DataId"] != nil {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") && dict["Group"] != nil {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public class SkipData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") && dict["DataId"] != nil {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") && dict["Group"] != nil {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public var failData: [ImportNacosConfigResponseBody.Data.FailData]?

        public var skipCount: Int32?

        public var skipData: [ImportNacosConfigResponseBody.Data.SkipData]?

        public var succCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failData != nil {
                var tmp : [Any] = []
                for k in self.failData! {
                    tmp.append(k.toMap())
                }
                map["FailData"] = tmp
            }
            if self.skipCount != nil {
                map["SkipCount"] = self.skipCount!
            }
            if self.skipData != nil {
                var tmp : [Any] = []
                for k in self.skipData! {
                    tmp.append(k.toMap())
                }
                map["SkipData"] = tmp
            }
            if self.succCount != nil {
                map["SuccCount"] = self.succCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailData") && dict["FailData"] != nil {
                var tmp : [ImportNacosConfigResponseBody.Data.FailData] = []
                for v in dict["FailData"] as! [Any] {
                    var model = ImportNacosConfigResponseBody.Data.FailData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.failData = tmp
            }
            if dict.keys.contains("SkipCount") && dict["SkipCount"] != nil {
                self.skipCount = dict["SkipCount"] as! Int32
            }
            if dict.keys.contains("SkipData") && dict["SkipData"] != nil {
                var tmp : [ImportNacosConfigResponseBody.Data.SkipData] = []
                for v in dict["SkipData"] as! [Any] {
                    var model = ImportNacosConfigResponseBody.Data.SkipData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skipData = tmp
            }
            if dict.keys.contains("SuccCount") && dict["SuccCount"] != nil {
                self.succCount = dict["SuccCount"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ImportNacosConfigResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ImportNacosConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportServicesRequest : Tea.TeaModel {
    public class ServiceList : Tea.TeaModel {
        public var groupName: String?

        public var ips: [String]?

        public var name: String?

        public var namespace: String?

        public var servicePort: Int64?

        public var serviceProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Ips") && dict["Ips"] != nil {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                self.servicePort = dict["ServicePort"] as! Int64
            }
            if dict.keys.contains("ServiceProtocol") && dict["ServiceProtocol"] != nil {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var fcAlias: String?

    public var fcServiceName: String?

    public var fcVersion: String?

    public var gatewayUniqueId: String?

    public var serviceList: [ImportServicesRequest.ServiceList]?

    public var sourceType: String?

    public var tlsSetting: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.fcAlias != nil {
            map["FcAlias"] = self.fcAlias!
        }
        if self.fcServiceName != nil {
            map["FcServiceName"] = self.fcServiceName!
        }
        if self.fcVersion != nil {
            map["FcVersion"] = self.fcVersion!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceList != nil {
            var tmp : [Any] = []
            for k in self.serviceList! {
                tmp.append(k.toMap())
            }
            map["ServiceList"] = tmp
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FcAlias") && dict["FcAlias"] != nil {
            self.fcAlias = dict["FcAlias"] as! String
        }
        if dict.keys.contains("FcServiceName") && dict["FcServiceName"] != nil {
            self.fcServiceName = dict["FcServiceName"] as! String
        }
        if dict.keys.contains("FcVersion") && dict["FcVersion"] != nil {
            self.fcVersion = dict["FcVersion"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceList") && dict["ServiceList"] != nil {
            var tmp : [ImportServicesRequest.ServiceList] = []
            for v in dict["ServiceList"] as! [Any] {
                var model = ImportServicesRequest.ServiceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceList = tmp
        }
        if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("TlsSetting") && dict["TlsSetting"] != nil {
            self.tlsSetting = dict["TlsSetting"] as! String
        }
    }
}

public class ImportServicesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var fcAlias: String?

    public var fcServiceName: String?

    public var fcVersion: String?

    public var gatewayUniqueId: String?

    public var serviceListShrink: String?

    public var sourceType: String?

    public var tlsSetting: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.fcAlias != nil {
            map["FcAlias"] = self.fcAlias!
        }
        if self.fcServiceName != nil {
            map["FcServiceName"] = self.fcServiceName!
        }
        if self.fcVersion != nil {
            map["FcVersion"] = self.fcVersion!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceListShrink != nil {
            map["ServiceList"] = self.serviceListShrink!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FcAlias") && dict["FcAlias"] != nil {
            self.fcAlias = dict["FcAlias"] as! String
        }
        if dict.keys.contains("FcServiceName") && dict["FcServiceName"] != nil {
            self.fcServiceName = dict["FcServiceName"] as! String
        }
        if dict.keys.contains("FcVersion") && dict["FcVersion"] != nil {
            self.fcVersion = dict["FcVersion"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceList") && dict["ServiceList"] != nil {
            self.serviceListShrink = dict["ServiceList"] as! String
        }
        if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("TlsSetting") && dict["TlsSetting"] != nil {
            self.tlsSetting = dict["TlsSetting"] as! String
        }
    }
}

public class ImportServicesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportZookeeperDataRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var fileName: String?

    public var fileUrl: String?

    public var instanceId: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ImportZookeeperDataResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportZookeeperDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportZookeeperDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportZookeeperDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAnsInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListAnsInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var app: String?

        public var clusterName: String?

        public var datumKey: String?

        public var defaultKey: String?

        public var enabled: Bool?

        public var ephemeral: Bool?

        public var failCount: Int32?

        public var healthy: Bool?

        public var instanceHeartBeatInterval: Int32?

        public var instanceHeartBeatTimeOut: Int32?

        public var instanceId: String?

        public var ip: String?

        public var ipDeleteTimeout: Int32?

        public var lastBeat: Int64?

        public var marked: Bool?

        public var metadata: [String: Any]?

        public var okCount: Int32?

        public var port: Int32?

        public var serviceName: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.datumKey != nil {
                map["DatumKey"] = self.datumKey!
            }
            if self.defaultKey != nil {
                map["DefaultKey"] = self.defaultKey!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.ephemeral != nil {
                map["Ephemeral"] = self.ephemeral!
            }
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.healthy != nil {
                map["Healthy"] = self.healthy!
            }
            if self.instanceHeartBeatInterval != nil {
                map["InstanceHeartBeatInterval"] = self.instanceHeartBeatInterval!
            }
            if self.instanceHeartBeatTimeOut != nil {
                map["InstanceHeartBeatTimeOut"] = self.instanceHeartBeatTimeOut!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.ipDeleteTimeout != nil {
                map["IpDeleteTimeout"] = self.ipDeleteTimeout!
            }
            if self.lastBeat != nil {
                map["LastBeat"] = self.lastBeat!
            }
            if self.marked != nil {
                map["Marked"] = self.marked!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.okCount != nil {
                map["OkCount"] = self.okCount!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") && dict["App"] != nil {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("DatumKey") && dict["DatumKey"] != nil {
                self.datumKey = dict["DatumKey"] as! String
            }
            if dict.keys.contains("DefaultKey") && dict["DefaultKey"] != nil {
                self.defaultKey = dict["DefaultKey"] as! String
            }
            if dict.keys.contains("Enabled") && dict["Enabled"] != nil {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("Ephemeral") && dict["Ephemeral"] != nil {
                self.ephemeral = dict["Ephemeral"] as! Bool
            }
            if dict.keys.contains("FailCount") && dict["FailCount"] != nil {
                self.failCount = dict["FailCount"] as! Int32
            }
            if dict.keys.contains("Healthy") && dict["Healthy"] != nil {
                self.healthy = dict["Healthy"] as! Bool
            }
            if dict.keys.contains("InstanceHeartBeatInterval") && dict["InstanceHeartBeatInterval"] != nil {
                self.instanceHeartBeatInterval = dict["InstanceHeartBeatInterval"] as! Int32
            }
            if dict.keys.contains("InstanceHeartBeatTimeOut") && dict["InstanceHeartBeatTimeOut"] != nil {
                self.instanceHeartBeatTimeOut = dict["InstanceHeartBeatTimeOut"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("IpDeleteTimeout") && dict["IpDeleteTimeout"] != nil {
                self.ipDeleteTimeout = dict["IpDeleteTimeout"] as! Int32
            }
            if dict.keys.contains("LastBeat") && dict["LastBeat"] != nil {
                self.lastBeat = dict["LastBeat"] as! Int64
            }
            if dict.keys.contains("Marked") && dict["Marked"] != nil {
                self.marked = dict["Marked"] as! Bool
            }
            if dict.keys.contains("Metadata") && dict["Metadata"] != nil {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("OkCount") && dict["OkCount"] != nil {
                self.okCount = dict["OkCount"] as! Int32
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var data: [ListAnsInstancesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListAnsInstancesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAnsInstancesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAnsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAnsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAnsInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAnsServiceClustersRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListAnsServiceClustersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AppDetail : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var checkInternal: Int32?

            public var checkPath: String?

            public var checkTimeout: Int32?

            public var checkType: String?

            public var healthyCheckTimes: Int32?

            public var port: Int32?

            public var unhealthyCheckTimes: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.checkInternal != nil {
                    map["CheckInternal"] = self.checkInternal!
                }
                if self.checkPath != nil {
                    map["CheckPath"] = self.checkPath!
                }
                if self.checkTimeout != nil {
                    map["CheckTimeout"] = self.checkTimeout!
                }
                if self.checkType != nil {
                    map["CheckType"] = self.checkType!
                }
                if self.healthyCheckTimes != nil {
                    map["HealthyCheckTimes"] = self.healthyCheckTimes!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.unhealthyCheckTimes != nil {
                    map["UnhealthyCheckTimes"] = self.unhealthyCheckTimes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CheckInternal") && dict["CheckInternal"] != nil {
                    self.checkInternal = dict["CheckInternal"] as! Int32
                }
                if dict.keys.contains("CheckPath") && dict["CheckPath"] != nil {
                    self.checkPath = dict["CheckPath"] as! String
                }
                if dict.keys.contains("CheckTimeout") && dict["CheckTimeout"] != nil {
                    self.checkTimeout = dict["CheckTimeout"] as! Int32
                }
                if dict.keys.contains("CheckType") && dict["CheckType"] != nil {
                    self.checkType = dict["CheckType"] as! String
                }
                if dict.keys.contains("HealthyCheckTimes") && dict["HealthyCheckTimes"] != nil {
                    self.healthyCheckTimes = dict["HealthyCheckTimes"] as! Int32
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("UnhealthyCheckTimes") && dict["UnhealthyCheckTimes"] != nil {
                    self.unhealthyCheckTimes = dict["UnhealthyCheckTimes"] as! Int32
                }
            }
        }
        public class Clusters : Tea.TeaModel {
            public var defaultCheckPort: Int32?

            public var defaultPort: Int32?

            public var healthCheckerType: String?

            public var metadata: [String: Any]?

            public var name: String?

            public var serviceName: String?

            public var useIPPort4Check: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.defaultCheckPort != nil {
                    map["DefaultCheckPort"] = self.defaultCheckPort!
                }
                if self.defaultPort != nil {
                    map["DefaultPort"] = self.defaultPort!
                }
                if self.healthCheckerType != nil {
                    map["HealthCheckerType"] = self.healthCheckerType!
                }
                if self.metadata != nil {
                    map["Metadata"] = self.metadata!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.useIPPort4Check != nil {
                    map["UseIPPort4Check"] = self.useIPPort4Check!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DefaultCheckPort") && dict["DefaultCheckPort"] != nil {
                    self.defaultCheckPort = dict["DefaultCheckPort"] as! Int32
                }
                if dict.keys.contains("DefaultPort") && dict["DefaultPort"] != nil {
                    self.defaultPort = dict["DefaultPort"] as! Int32
                }
                if dict.keys.contains("HealthCheckerType") && dict["HealthCheckerType"] != nil {
                    self.healthCheckerType = dict["HealthCheckerType"] as! String
                }
                if dict.keys.contains("Metadata") && dict["Metadata"] != nil {
                    self.metadata = dict["Metadata"] as! [String: Any]
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("UseIPPort4Check") && dict["UseIPPort4Check"] != nil {
                    self.useIPPort4Check = dict["UseIPPort4Check"] as! Bool
                }
            }
        }
        public var appDetail: ListAnsServiceClustersResponseBody.Data.AppDetail?

        public var clusters: [ListAnsServiceClustersResponseBody.Data.Clusters]?

        public var ephemeral: Bool?

        public var groupName: String?

        public var metadata: [String: Any]?

        public var name: String?

        public var protectThreshold: Double?

        public var selectorType: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.appDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appDetail != nil {
                map["AppDetail"] = self.appDetail?.toMap()
            }
            if self.clusters != nil {
                var tmp : [Any] = []
                for k in self.clusters! {
                    tmp.append(k.toMap())
                }
                map["Clusters"] = tmp
            }
            if self.ephemeral != nil {
                map["Ephemeral"] = self.ephemeral!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protectThreshold != nil {
                map["ProtectThreshold"] = self.protectThreshold!
            }
            if self.selectorType != nil {
                map["SelectorType"] = self.selectorType!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppDetail") && dict["AppDetail"] != nil {
                var model = ListAnsServiceClustersResponseBody.Data.AppDetail()
                model.fromMap(dict["AppDetail"] as! [String: Any])
                self.appDetail = model
            }
            if dict.keys.contains("Clusters") && dict["Clusters"] != nil {
                var tmp : [ListAnsServiceClustersResponseBody.Data.Clusters] = []
                for v in dict["Clusters"] as! [Any] {
                    var model = ListAnsServiceClustersResponseBody.Data.Clusters()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusters = tmp
            }
            if dict.keys.contains("Ephemeral") && dict["Ephemeral"] != nil {
                self.ephemeral = dict["Ephemeral"] as! Bool
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Metadata") && dict["Metadata"] != nil {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProtectThreshold") && dict["ProtectThreshold"] != nil {
                self.protectThreshold = dict["ProtectThreshold"] as! Double
            }
            if dict.keys.contains("SelectorType") && dict["SelectorType"] != nil {
                self.selectorType = dict["SelectorType"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var data: ListAnsServiceClustersResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListAnsServiceClustersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAnsServiceClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAnsServiceClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAnsServiceClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAnsServicesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var hasIpCount: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.hasIpCount != nil {
            map["HasIpCount"] = self.hasIpCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HasIpCount") && dict["HasIpCount"] != nil {
            self.hasIpCount = dict["HasIpCount"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListAnsServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterCount: Int32?

        public var groupName: String?

        public var healthyInstanceCount: Int32?

        public var ipCount: Int32?

        public var name: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterCount != nil {
                map["ClusterCount"] = self.clusterCount!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.healthyInstanceCount != nil {
                map["HealthyInstanceCount"] = self.healthyInstanceCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterCount") && dict["ClusterCount"] != nil {
                self.clusterCount = dict["ClusterCount"] as! Int32
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HealthyInstanceCount") && dict["HealthyInstanceCount"] != nil {
                self.healthyInstanceCount = dict["HealthyInstanceCount"] as! Int32
            }
            if dict.keys.contains("IpCount") && dict["IpCount"] != nil {
                self.ipCount = dict["IpCount"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var data: [ListAnsServicesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListAnsServicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAnsServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAnsServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAnsServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAnsServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppBySwimmingLaneGroupTagRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class ListAppBySwimmingLaneGroupTagResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAppBySwimmingLaneGroupTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppBySwimmingLaneGroupTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAppBySwimmingLaneGroupTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppBySwimmingLaneGroupTagsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public var tags: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! [String]
        }
    }
}

public class ListAppBySwimmingLaneGroupTagsShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class ListAppBySwimmingLaneGroupTagsResponseBody : Tea.TeaModel {
    public var data: [String: [DataValue]]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.data! {
                var l1 : [Any] = []
                for k1 in v {
                    l1.append(k1.toMap())
                }
                tmp[k] = l1
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [String: [DataValue]] = [:]
            for (k, v) in dict["Data"] as! [String: Any] {
                var l1 : [DataValue] = []
                for v1 in v as! [Any] {
                    var model = DataValue()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp[k] = l1
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAppBySwimmingLaneGroupTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppBySwimmingLaneGroupTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAppBySwimmingLaneGroupTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationsWithTagRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class ListApplicationsWithTagRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class RouteRules : Tea.TeaModel {
                public class Rules : Tea.TeaModel {
                    public class Dubbo : Tea.TeaModel {
                        public class ArgumentItems : Tea.TeaModel {
                            public var cond: String?

                            public var datum: String?

                            public var divisor: Int32?

                            public var expr: String?

                            public var index: Int32?

                            public var nameList: [String]?

                            public var operator_: String?

                            public var rate: Int32?

                            public var remainder: Int32?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.cond != nil {
                                    map["cond"] = self.cond!
                                }
                                if self.datum != nil {
                                    map["datum"] = self.datum!
                                }
                                if self.divisor != nil {
                                    map["divisor"] = self.divisor!
                                }
                                if self.expr != nil {
                                    map["expr"] = self.expr!
                                }
                                if self.index != nil {
                                    map["index"] = self.index!
                                }
                                if self.nameList != nil {
                                    map["nameList"] = self.nameList!
                                }
                                if self.operator_ != nil {
                                    map["operator"] = self.operator_!
                                }
                                if self.rate != nil {
                                    map["rate"] = self.rate!
                                }
                                if self.remainder != nil {
                                    map["remainder"] = self.remainder!
                                }
                                if self.value != nil {
                                    map["value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("cond") && dict["cond"] != nil {
                                    self.cond = dict["cond"] as! String
                                }
                                if dict.keys.contains("datum") && dict["datum"] != nil {
                                    self.datum = dict["datum"] as! String
                                }
                                if dict.keys.contains("divisor") && dict["divisor"] != nil {
                                    self.divisor = dict["divisor"] as! Int32
                                }
                                if dict.keys.contains("expr") && dict["expr"] != nil {
                                    self.expr = dict["expr"] as! String
                                }
                                if dict.keys.contains("index") && dict["index"] != nil {
                                    self.index = dict["index"] as! Int32
                                }
                                if dict.keys.contains("nameList") && dict["nameList"] != nil {
                                    self.nameList = dict["nameList"] as! [String]
                                }
                                if dict.keys.contains("operator") && dict["operator"] != nil {
                                    self.operator_ = dict["operator"] as! String
                                }
                                if dict.keys.contains("rate") && dict["rate"] != nil {
                                    self.rate = dict["rate"] as! Int32
                                }
                                if dict.keys.contains("remainder") && dict["remainder"] != nil {
                                    self.remainder = dict["remainder"] as! Int32
                                }
                                if dict.keys.contains("value") && dict["value"] != nil {
                                    self.value = dict["value"] as! String
                                }
                            }
                        }
                        public var appId: String?

                        public var argumentItems: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo.ArgumentItems]?

                        public var condition: String?

                        public var group: String?

                        public var methodName: String?

                        public var paramTypes: [String]?

                        public var serviceName: String?

                        public var tags: [String]?

                        public var triggerPolicy: String?

                        public var version: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.appId != nil {
                                map["appId"] = self.appId!
                            }
                            if self.argumentItems != nil {
                                var tmp : [Any] = []
                                for k in self.argumentItems! {
                                    tmp.append(k.toMap())
                                }
                                map["argumentItems"] = tmp
                            }
                            if self.condition != nil {
                                map["condition"] = self.condition!
                            }
                            if self.group != nil {
                                map["group"] = self.group!
                            }
                            if self.methodName != nil {
                                map["methodName"] = self.methodName!
                            }
                            if self.paramTypes != nil {
                                map["paramTypes"] = self.paramTypes!
                            }
                            if self.serviceName != nil {
                                map["serviceName"] = self.serviceName!
                            }
                            if self.tags != nil {
                                map["tags"] = self.tags!
                            }
                            if self.triggerPolicy != nil {
                                map["triggerPolicy"] = self.triggerPolicy!
                            }
                            if self.version != nil {
                                map["version"] = self.version!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("appId") && dict["appId"] != nil {
                                self.appId = dict["appId"] as! String
                            }
                            if dict.keys.contains("argumentItems") && dict["argumentItems"] != nil {
                                var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo.ArgumentItems] = []
                                for v in dict["argumentItems"] as! [Any] {
                                    var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo.ArgumentItems()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.argumentItems = tmp
                            }
                            if dict.keys.contains("condition") && dict["condition"] != nil {
                                self.condition = dict["condition"] as! String
                            }
                            if dict.keys.contains("group") && dict["group"] != nil {
                                self.group = dict["group"] as! String
                            }
                            if dict.keys.contains("methodName") && dict["methodName"] != nil {
                                self.methodName = dict["methodName"] as! String
                            }
                            if dict.keys.contains("paramTypes") && dict["paramTypes"] != nil {
                                self.paramTypes = dict["paramTypes"] as! [String]
                            }
                            if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                                self.serviceName = dict["serviceName"] as! String
                            }
                            if dict.keys.contains("tags") && dict["tags"] != nil {
                                self.tags = dict["tags"] as! [String]
                            }
                            if dict.keys.contains("triggerPolicy") && dict["triggerPolicy"] != nil {
                                self.triggerPolicy = dict["triggerPolicy"] as! String
                            }
                            if dict.keys.contains("version") && dict["version"] != nil {
                                self.version = dict["version"] as! String
                            }
                        }
                    }
                    public class Springcloud : Tea.TeaModel {
                        public class RestItems : Tea.TeaModel {
                            public var cond: String?

                            public var datum: String?

                            public var divisor: Int32?

                            public var name: String?

                            public var nameList: [String]?

                            public var operator_: String?

                            public var rate: Int32?

                            public var remainder: Int32?

                            public var type: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.cond != nil {
                                    map["cond"] = self.cond!
                                }
                                if self.datum != nil {
                                    map["datum"] = self.datum!
                                }
                                if self.divisor != nil {
                                    map["divisor"] = self.divisor!
                                }
                                if self.name != nil {
                                    map["name"] = self.name!
                                }
                                if self.nameList != nil {
                                    map["nameList"] = self.nameList!
                                }
                                if self.operator_ != nil {
                                    map["operator"] = self.operator_!
                                }
                                if self.rate != nil {
                                    map["rate"] = self.rate!
                                }
                                if self.remainder != nil {
                                    map["remainder"] = self.remainder!
                                }
                                if self.type != nil {
                                    map["type"] = self.type!
                                }
                                if self.value != nil {
                                    map["value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("cond") && dict["cond"] != nil {
                                    self.cond = dict["cond"] as! String
                                }
                                if dict.keys.contains("datum") && dict["datum"] != nil {
                                    self.datum = dict["datum"] as! String
                                }
                                if dict.keys.contains("divisor") && dict["divisor"] != nil {
                                    self.divisor = dict["divisor"] as! Int32
                                }
                                if dict.keys.contains("name") && dict["name"] != nil {
                                    self.name = dict["name"] as! String
                                }
                                if dict.keys.contains("nameList") && dict["nameList"] != nil {
                                    self.nameList = dict["nameList"] as! [String]
                                }
                                if dict.keys.contains("operator") && dict["operator"] != nil {
                                    self.operator_ = dict["operator"] as! String
                                }
                                if dict.keys.contains("rate") && dict["rate"] != nil {
                                    self.rate = dict["rate"] as! Int32
                                }
                                if dict.keys.contains("remainder") && dict["remainder"] != nil {
                                    self.remainder = dict["remainder"] as! Int32
                                }
                                if dict.keys.contains("type") && dict["type"] != nil {
                                    self.type = dict["type"] as! String
                                }
                                if dict.keys.contains("value") && dict["value"] != nil {
                                    self.value = dict["value"] as! String
                                }
                            }
                        }
                        public var appId: String?

                        public var condition: String?

                        public var enable: Bool?

                        public var path: String?

                        public var paths: [String]?

                        public var priority: Int32?

                        public var restItems: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud.RestItems]?

                        public var tags: [String]?

                        public var triggerPolicy: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.appId != nil {
                                map["appId"] = self.appId!
                            }
                            if self.condition != nil {
                                map["condition"] = self.condition!
                            }
                            if self.enable != nil {
                                map["enable"] = self.enable!
                            }
                            if self.path != nil {
                                map["path"] = self.path!
                            }
                            if self.paths != nil {
                                map["paths"] = self.paths!
                            }
                            if self.priority != nil {
                                map["priority"] = self.priority!
                            }
                            if self.restItems != nil {
                                var tmp : [Any] = []
                                for k in self.restItems! {
                                    tmp.append(k.toMap())
                                }
                                map["restItems"] = tmp
                            }
                            if self.tags != nil {
                                map["tags"] = self.tags!
                            }
                            if self.triggerPolicy != nil {
                                map["triggerPolicy"] = self.triggerPolicy!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("appId") && dict["appId"] != nil {
                                self.appId = dict["appId"] as! String
                            }
                            if dict.keys.contains("condition") && dict["condition"] != nil {
                                self.condition = dict["condition"] as! String
                            }
                            if dict.keys.contains("enable") && dict["enable"] != nil {
                                self.enable = dict["enable"] as! Bool
                            }
                            if dict.keys.contains("path") && dict["path"] != nil {
                                self.path = dict["path"] as! String
                            }
                            if dict.keys.contains("paths") && dict["paths"] != nil {
                                self.paths = dict["paths"] as! [String]
                            }
                            if dict.keys.contains("priority") && dict["priority"] != nil {
                                self.priority = dict["priority"] as! Int32
                            }
                            if dict.keys.contains("restItems") && dict["restItems"] != nil {
                                var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud.RestItems] = []
                                for v in dict["restItems"] as! [Any] {
                                    var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud.RestItems()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.restItems = tmp
                            }
                            if dict.keys.contains("tags") && dict["tags"] != nil {
                                self.tags = dict["tags"] as! [String]
                            }
                            if dict.keys.contains("triggerPolicy") && dict["triggerPolicy"] != nil {
                                self.triggerPolicy = dict["triggerPolicy"] as! String
                            }
                        }
                    }
                    public var dubbo: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo]?

                    public var springcloud: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dubbo != nil {
                            var tmp : [Any] = []
                            for k in self.dubbo! {
                                tmp.append(k.toMap())
                            }
                            map["dubbo"] = tmp
                        }
                        if self.springcloud != nil {
                            var tmp : [Any] = []
                            for k in self.springcloud! {
                                tmp.append(k.toMap())
                            }
                            map["springcloud"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("dubbo") && dict["dubbo"] != nil {
                            var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo] = []
                            for v in dict["dubbo"] as! [Any] {
                                var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.dubbo = tmp
                        }
                        if dict.keys.contains("springcloud") && dict["springcloud"] != nil {
                            var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud] = []
                            for v in dict["springcloud"] as! [Any] {
                                var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.springcloud = tmp
                        }
                    }
                }
                public var enable: Bool?

                public var id: Int64?

                public var instanceNum: Int32?

                public var name: String?

                public var rate: Int32?

                public var rules: ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules?

                public var status: Int32?

                public var tag: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.rules?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enable != nil {
                        map["Enable"] = self.enable!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.instanceNum != nil {
                        map["InstanceNum"] = self.instanceNum!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.rules != nil {
                        map["Rules"] = self.rules?.toMap()
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Enable") && dict["Enable"] != nil {
                        self.enable = dict["Enable"] as! Bool
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("InstanceNum") && dict["InstanceNum"] != nil {
                        self.instanceNum = dict["InstanceNum"] as! Int32
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Rate") && dict["Rate"] != nil {
                        self.rate = dict["Rate"] as! Int32
                    }
                    if dict.keys.contains("Rules") && dict["Rules"] != nil {
                        var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules()
                        model.fromMap(dict["Rules"] as! [String: Any])
                        self.rules = model
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! Int32
                    }
                    if dict.keys.contains("Tag") && dict["Tag"] != nil {
                        self.tag = dict["Tag"] as! String
                    }
                }
            }
            public var appId: String?

            public var appName: String?

            public var namespace: String?

            public var routeRules: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules]?

            public var routeStatus: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.routeRules != nil {
                    var tmp : [Any] = []
                    for k in self.routeRules! {
                        tmp.append(k.toMap())
                    }
                    map["RouteRules"] = tmp
                }
                if self.routeStatus != nil {
                    map["RouteStatus"] = self.routeStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RouteRules") && dict["RouteRules"] != nil {
                    var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules] = []
                    for v in dict["RouteRules"] as! [Any] {
                        var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.routeRules = tmp
                }
                if dict.keys.contains("RouteStatus") && dict["RouteStatus"] != nil {
                    self.routeStatus = dict["RouteStatus"] as! Int64
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListApplicationsWithTagRulesResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListApplicationsWithTagRulesResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: ListApplicationsWithTagRulesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListApplicationsWithTagRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListApplicationsWithTagRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsWithTagRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListApplicationsWithTagRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuthPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var name: String?

    public var namespace: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var protocol_: String?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class ListAuthPolicyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class AuthRule : Tea.TeaModel {
                public class Method : Tea.TeaModel {
                    public var group: String?

                    public var name: String?

                    public var parameterTypes: [String]?

                    public var returnType: String?

                    public var serviceName: String?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.group != nil {
                            map["Group"] = self.group!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.parameterTypes != nil {
                            map["ParameterTypes"] = self.parameterTypes!
                        }
                        if self.returnType != nil {
                            map["ReturnType"] = self.returnType!
                        }
                        if self.serviceName != nil {
                            map["ServiceName"] = self.serviceName!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Group") && dict["Group"] != nil {
                            self.group = dict["Group"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ParameterTypes") && dict["ParameterTypes"] != nil {
                            self.parameterTypes = dict["ParameterTypes"] as! [String]
                        }
                        if dict.keys.contains("ReturnType") && dict["ReturnType"] != nil {
                            self.returnType = dict["ReturnType"] as! String
                        }
                        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                            self.serviceName = dict["ServiceName"] as! String
                        }
                        if dict.keys.contains("Version") && dict["Version"] != nil {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var appIds: [String]?

                public var authType: Int32?

                public var black: Bool?

                public var k8sNamespaces: [String]?

                public var method: ListAuthPolicyResponseBody.Data.Result.AuthRule.Method?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.method?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appIds != nil {
                        map["AppIds"] = self.appIds!
                    }
                    if self.authType != nil {
                        map["AuthType"] = self.authType!
                    }
                    if self.black != nil {
                        map["Black"] = self.black!
                    }
                    if self.k8sNamespaces != nil {
                        map["K8sNamespaces"] = self.k8sNamespaces!
                    }
                    if self.method != nil {
                        map["Method"] = self.method?.toMap()
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
                        self.appIds = dict["AppIds"] as! [String]
                    }
                    if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
                        self.authType = dict["AuthType"] as! Int32
                    }
                    if dict.keys.contains("Black") && dict["Black"] != nil {
                        self.black = dict["Black"] as! Bool
                    }
                    if dict.keys.contains("K8sNamespaces") && dict["K8sNamespaces"] != nil {
                        self.k8sNamespaces = dict["K8sNamespaces"] as! [String]
                    }
                    if dict.keys.contains("Method") && dict["Method"] != nil {
                        var model = ListAuthPolicyResponseBody.Data.Result.AuthRule.Method()
                        model.fromMap(dict["Method"] as! [String: Any])
                        self.method = model
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public var accountId: String?

            public var appId: String?

            public var appName: String?

            public var authRule: [ListAuthPolicyResponseBody.Data.Result.AuthRule]?

            public var authType: Int32?

            public var enable: Bool?

            public var id: Int32?

            public var k8sNamespace: String?

            public var name: String?

            public var namespaceId: String?

            public var protocol_: String?

            public var regionId: String?

            public var source: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.authRule != nil {
                    var tmp : [Any] = []
                    for k in self.authRule! {
                        tmp.append(k.toMap())
                    }
                    map["AuthRule"] = tmp
                }
                if self.authType != nil {
                    map["AuthType"] = self.authType!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.k8sNamespace != nil {
                    map["K8sNamespace"] = self.k8sNamespace!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccountId") && dict["AccountId"] != nil {
                    self.accountId = dict["AccountId"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("AuthRule") && dict["AuthRule"] != nil {
                    var tmp : [ListAuthPolicyResponseBody.Data.Result.AuthRule] = []
                    for v in dict["AuthRule"] as! [Any] {
                        var model = ListAuthPolicyResponseBody.Data.Result.AuthRule()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.authRule = tmp
                }
                if dict.keys.contains("AuthType") && dict["AuthType"] != nil {
                    self.authType = dict["AuthType"] as! Int32
                }
                if dict.keys.contains("Enable") && dict["Enable"] != nil {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("K8sNamespace") && dict["K8sNamespace"] != nil {
                    self.k8sNamespace = dict["K8sNamespace"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListAuthPolicyResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListAuthPolicyResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListAuthPolicyResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListAuthPolicyResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListAuthPolicyResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAuthPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuthPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAuthPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCircuitBreakerRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var resource: String?

    public var resourceSearchKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceSearchKey != nil {
            map["ResourceSearchKey"] = self.resourceSearchKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageIndex") && dict["PageIndex"] != nil {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("ResourceSearchKey") && dict["ResourceSearchKey"] != nil {
            self.resourceSearchKey = dict["ResourceSearchKey"] as! String
        }
    }
}

public class ListCircuitBreakerRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var enable: Bool?

            public var fallbackObject: String?

            public var halfOpenBaseAmountPerStep: Int32?

            public var halfOpenRecoveryStepNum: Int32?

            public var maxAllowedRtMs: Int32?

            public var minRequestAmount: Int32?

            public var namespace: String?

            public var regionId: String?

            public var resource: String?

            public var resourceType: Int32?

            public var retryTimeoutMs: Int32?

            public var ruleId: Int64?

            public var statIntervalMs: Int32?

            public var strategy: Int32?

            public var threshold: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.fallbackObject != nil {
                    map["FallbackObject"] = self.fallbackObject!
                }
                if self.halfOpenBaseAmountPerStep != nil {
                    map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
                }
                if self.halfOpenRecoveryStepNum != nil {
                    map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
                }
                if self.maxAllowedRtMs != nil {
                    map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
                }
                if self.minRequestAmount != nil {
                    map["MinRequestAmount"] = self.minRequestAmount!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resource != nil {
                    map["Resource"] = self.resource!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.retryTimeoutMs != nil {
                    map["RetryTimeoutMs"] = self.retryTimeoutMs!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.statIntervalMs != nil {
                    map["StatIntervalMs"] = self.statIntervalMs!
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Enable") && dict["Enable"] != nil {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("FallbackObject") && dict["FallbackObject"] != nil {
                    self.fallbackObject = dict["FallbackObject"] as! String
                }
                if dict.keys.contains("HalfOpenBaseAmountPerStep") && dict["HalfOpenBaseAmountPerStep"] != nil {
                    self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
                }
                if dict.keys.contains("HalfOpenRecoveryStepNum") && dict["HalfOpenRecoveryStepNum"] != nil {
                    self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
                }
                if dict.keys.contains("MaxAllowedRtMs") && dict["MaxAllowedRtMs"] != nil {
                    self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
                }
                if dict.keys.contains("MinRequestAmount") && dict["MinRequestAmount"] != nil {
                    self.minRequestAmount = dict["MinRequestAmount"] as! Int32
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Resource") && dict["Resource"] != nil {
                    self.resource = dict["Resource"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! Int32
                }
                if dict.keys.contains("RetryTimeoutMs") && dict["RetryTimeoutMs"] != nil {
                    self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! Int64
                }
                if dict.keys.contains("StatIntervalMs") && dict["StatIntervalMs"] != nil {
                    self.statIntervalMs = dict["StatIntervalMs"] as! Int32
                }
                if dict.keys.contains("Strategy") && dict["Strategy"] != nil {
                    self.strategy = dict["Strategy"] as! Int32
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! Double
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListCircuitBreakerRulesResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListCircuitBreakerRulesResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListCircuitBreakerRulesResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListCircuitBreakerRulesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListCircuitBreakerRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCircuitBreakerRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCircuitBreakerRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCircuitBreakerRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterConnectionTypesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class ListClusterConnectionTypesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListClusterConnectionTypesResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListClusterConnectionTypesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListClusterConnectionTypesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterConnectionTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterConnectionTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterConnectionTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterHealthCheckTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListClusterHealthCheckTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class RiskList : Tea.TeaModel {
                public var description_: String?

                public var id: Int32?

                public var module: String?

                public var mute: Bool?

                public var noticeFeature: Bool?

                public var primaryUser: String?

                public var riskCode: String?

                public var riskLevel: String?

                public var riskName: String?

                public var riskType: String?

                public var situation: String?

                public var suggestion: String?

                public var taskId: Int64?

                public var type: Int32?

                public var values: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.module != nil {
                        map["Module"] = self.module!
                    }
                    if self.mute != nil {
                        map["Mute"] = self.mute!
                    }
                    if self.noticeFeature != nil {
                        map["NoticeFeature"] = self.noticeFeature!
                    }
                    if self.primaryUser != nil {
                        map["PrimaryUser"] = self.primaryUser!
                    }
                    if self.riskCode != nil {
                        map["RiskCode"] = self.riskCode!
                    }
                    if self.riskLevel != nil {
                        map["RiskLevel"] = self.riskLevel!
                    }
                    if self.riskName != nil {
                        map["RiskName"] = self.riskName!
                    }
                    if self.riskType != nil {
                        map["RiskType"] = self.riskType!
                    }
                    if self.situation != nil {
                        map["Situation"] = self.situation!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int32
                    }
                    if dict.keys.contains("Module") && dict["Module"] != nil {
                        self.module = dict["Module"] as! String
                    }
                    if dict.keys.contains("Mute") && dict["Mute"] != nil {
                        self.mute = dict["Mute"] as! Bool
                    }
                    if dict.keys.contains("NoticeFeature") && dict["NoticeFeature"] != nil {
                        self.noticeFeature = dict["NoticeFeature"] as! Bool
                    }
                    if dict.keys.contains("PrimaryUser") && dict["PrimaryUser"] != nil {
                        self.primaryUser = dict["PrimaryUser"] as! String
                    }
                    if dict.keys.contains("RiskCode") && dict["RiskCode"] != nil {
                        self.riskCode = dict["RiskCode"] as! String
                    }
                    if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                        self.riskLevel = dict["RiskLevel"] as! String
                    }
                    if dict.keys.contains("RiskName") && dict["RiskName"] != nil {
                        self.riskName = dict["RiskName"] as! String
                    }
                    if dict.keys.contains("RiskType") && dict["RiskType"] != nil {
                        self.riskType = dict["RiskType"] as! String
                    }
                    if dict.keys.contains("Situation") && dict["Situation"] != nil {
                        self.situation = dict["Situation"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                        self.taskId = dict["TaskId"] as! Int64
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! Int32
                    }
                    if dict.keys.contains("Values") && dict["Values"] != nil {
                        self.values = dict["Values"] as! String
                    }
                }
            }
            public var appVersion: String?

            public var chargeType: String?

            public var clusterType: String?

            public var createTime: String?

            public var id: Int32?

            public var imageVersion: String?

            public var instanceId: String?

            public var primaryUser: String?

            public var replica: String?

            public var riskList: [ListClusterHealthCheckTaskResponseBody.Data.Result.RiskList]?

            public var score: Int32?

            public var spec: String?

            public var status: String?

            public var totalItem: Int32?

            public var totalRisk: Int32?

            public var type: String?

            public var updateTime: String?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appVersion != nil {
                    map["AppVersion"] = self.appVersion!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.imageVersion != nil {
                    map["ImageVersion"] = self.imageVersion!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.primaryUser != nil {
                    map["PrimaryUser"] = self.primaryUser!
                }
                if self.replica != nil {
                    map["Replica"] = self.replica!
                }
                if self.riskList != nil {
                    var tmp : [Any] = []
                    for k in self.riskList! {
                        tmp.append(k.toMap())
                    }
                    map["RiskList"] = tmp
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.totalItem != nil {
                    map["TotalItem"] = self.totalItem!
                }
                if self.totalRisk != nil {
                    map["TotalRisk"] = self.totalRisk!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppVersion") && dict["AppVersion"] != nil {
                    self.appVersion = dict["AppVersion"] as! String
                }
                if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                    self.clusterType = dict["ClusterType"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("ImageVersion") && dict["ImageVersion"] != nil {
                    self.imageVersion = dict["ImageVersion"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PrimaryUser") && dict["PrimaryUser"] != nil {
                    self.primaryUser = dict["PrimaryUser"] as! String
                }
                if dict.keys.contains("Replica") && dict["Replica"] != nil {
                    self.replica = dict["Replica"] as! String
                }
                if dict.keys.contains("RiskList") && dict["RiskList"] != nil {
                    var tmp : [ListClusterHealthCheckTaskResponseBody.Data.Result.RiskList] = []
                    for v in dict["RiskList"] as! [Any] {
                        var model = ListClusterHealthCheckTaskResponseBody.Data.Result.RiskList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.riskList = tmp
                }
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("Spec") && dict["Spec"] != nil {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TotalItem") && dict["TotalItem"] != nil {
                    self.totalItem = dict["TotalItem"] as! Int32
                }
                if dict.keys.contains("TotalRisk") && dict["TotalRisk"] != nil {
                    self.totalRisk = dict["TotalRisk"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListClusterHealthCheckTaskResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListClusterHealthCheckTaskResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListClusterHealthCheckTaskResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListClusterHealthCheckTaskResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListClusterHealthCheckTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterHealthCheckTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterHealthCheckTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterHealthCheckTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterTypesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var connectType: String?

    public var mseVersion: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.connectType != nil {
            map["ConnectType"] = self.connectType!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConnectType") && dict["ConnectType"] != nil {
            self.connectType = dict["ConnectType"] as! String
        }
        if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListClusterTypesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListClusterTypesResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListClusterTypesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListClusterTypesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterVersionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var mseVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
            self.mseVersion = dict["MseVersion"] as! String
        }
    }
}

public class ListClusterVersionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterType: String?

        public var code: String?

        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListClusterVersionsResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListClusterVersionsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListClusterVersionsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterVersionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClustersRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var clusterAliasName: String?

    public var keyId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var tag: [ListClustersRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterAliasName != nil {
            map["ClusterAliasName"] = self.clusterAliasName!
        }
        if self.keyId != nil {
            map["KeyId"] = self.keyId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterAliasName") && dict["ClusterAliasName"] != nil {
            self.clusterAliasName = dict["ClusterAliasName"] as! String
        }
        if dict.keys.contains("KeyId") && dict["KeyId"] != nil {
            self.keyId = dict["KeyId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListClustersRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListClustersRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListClustersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class MaintenancePeriod : Tea.TeaModel {
            public var endTime: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var appVersion: String?

        public var canUpdate: Bool?

        public var chargeType: String?

        public var clusterAliasName: String?

        public var clusterName: String?

        public var clusterType: String?

        public var createTime: String?

        public var endDate: String?

        public var initStatus: String?

        public var instanceCount: Int64?

        public var instanceId: String?

        public var internetAddress: String?

        public var internetDomain: String?

        public var intranetAddress: String?

        public var intranetDomain: String?

        public var maintenancePeriod: ListClustersResponseBody.Data.MaintenancePeriod?

        public var mseVersion: String?

        public var resourceGroupId: String?

        public var tags: [String: Any]?

        public var versionCode: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.maintenancePeriod?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.canUpdate != nil {
                map["CanUpdate"] = self.canUpdate!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterAliasName != nil {
                map["ClusterAliasName"] = self.clusterAliasName!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.initStatus != nil {
                map["InitStatus"] = self.initStatus!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.internetAddress != nil {
                map["InternetAddress"] = self.internetAddress!
            }
            if self.internetDomain != nil {
                map["InternetDomain"] = self.internetDomain!
            }
            if self.intranetAddress != nil {
                map["IntranetAddress"] = self.intranetAddress!
            }
            if self.intranetDomain != nil {
                map["IntranetDomain"] = self.intranetDomain!
            }
            if self.maintenancePeriod != nil {
                map["MaintenancePeriod"] = self.maintenancePeriod?.toMap()
            }
            if self.mseVersion != nil {
                map["MseVersion"] = self.mseVersion!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppVersion") && dict["AppVersion"] != nil {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("CanUpdate") && dict["CanUpdate"] != nil {
                self.canUpdate = dict["CanUpdate"] as! Bool
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterAliasName") && dict["ClusterAliasName"] != nil {
                self.clusterAliasName = dict["ClusterAliasName"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("InitStatus") && dict["InitStatus"] != nil {
                self.initStatus = dict["InitStatus"] as! String
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InternetAddress") && dict["InternetAddress"] != nil {
                self.internetAddress = dict["InternetAddress"] as! String
            }
            if dict.keys.contains("InternetDomain") && dict["InternetDomain"] != nil {
                self.internetDomain = dict["InternetDomain"] as! String
            }
            if dict.keys.contains("IntranetAddress") && dict["IntranetAddress"] != nil {
                self.intranetAddress = dict["IntranetAddress"] as! String
            }
            if dict.keys.contains("IntranetDomain") && dict["IntranetDomain"] != nil {
                self.intranetDomain = dict["IntranetDomain"] as! String
            }
            if dict.keys.contains("MaintenancePeriod") && dict["MaintenancePeriod"] != nil {
                var model = ListClustersResponseBody.Data.MaintenancePeriod()
                model.fromMap(dict["MaintenancePeriod"] as! [String: Any])
                self.maintenancePeriod = model
            }
            if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
                self.mseVersion = dict["MseVersion"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! [String: Any]
            }
            if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
                self.versionCode = dict["VersionCode"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var data: [ListClustersResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListClustersResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListClustersResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConfigTrackRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var endTs: Int64?

    public var group: String?

    public var instanceId: String?

    public var ip: String?

    public var namespaceId: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var requestPars: String?

    public var reverse: Bool?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("Reverse") && dict["Reverse"] != nil {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class ListConfigTrackResponseBody : Tea.TeaModel {
    public class Traces : Tea.TeaModel {
        public var client: Bool?

        public var dataId: String?

        public var delay: String?

        public var event: String?

        public var group: String?

        public var logDate: String?

        public var md5: String?

        public var push: Bool?

        public var requestIp: String?

        public var responseIp: String?

        public var result: String?

        public var ts: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.client != nil {
                map["Client"] = self.client!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.event != nil {
                map["Event"] = self.event!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.logDate != nil {
                map["LogDate"] = self.logDate!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.push != nil {
                map["Push"] = self.push!
            }
            if self.requestIp != nil {
                map["RequestIp"] = self.requestIp!
            }
            if self.responseIp != nil {
                map["ResponseIp"] = self.responseIp!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.ts != nil {
                map["Ts"] = self.ts!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Client") && dict["Client"] != nil {
                self.client = dict["Client"] as! Bool
            }
            if dict.keys.contains("DataId") && dict["DataId"] != nil {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Delay") && dict["Delay"] != nil {
                self.delay = dict["Delay"] as! String
            }
            if dict.keys.contains("Event") && dict["Event"] != nil {
                self.event = dict["Event"] as! String
            }
            if dict.keys.contains("Group") && dict["Group"] != nil {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("LogDate") && dict["LogDate"] != nil {
                self.logDate = dict["LogDate"] as! String
            }
            if dict.keys.contains("Md5") && dict["Md5"] != nil {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Push") && dict["Push"] != nil {
                self.push = dict["Push"] as! Bool
            }
            if dict.keys.contains("RequestIp") && dict["RequestIp"] != nil {
                self.requestIp = dict["RequestIp"] as! String
            }
            if dict.keys.contains("ResponseIp") && dict["ResponseIp"] != nil {
                self.responseIp = dict["ResponseIp"] as! String
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Ts") && dict["Ts"] != nil {
                self.ts = dict["Ts"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var traces: [ListConfigTrackResponseBody.Traces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.traces != nil {
            var tmp : [Any] = []
            for k in self.traces! {
                tmp.append(k.toMap())
            }
            map["Traces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("Traces") && dict["Traces"] != nil {
            var tmp : [ListConfigTrackResponseBody.Traces] = []
            for v in dict["Traces"] as! [Any] {
                var model = ListConfigTrackResponseBody.Traces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traces = tmp
        }
    }
}

public class ListConfigTrackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigTrackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListConfigTrackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEngineNamespacesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListEngineNamespacesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configCount: Int32?

        public var namespace: String?

        public var namespaceDesc: String?

        public var namespaceShowName: String?

        public var quota: Int32?

        public var serviceCount: String?

        public var sourceType: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configCount != nil {
                map["ConfigCount"] = self.configCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceDesc != nil {
                map["NamespaceDesc"] = self.namespaceDesc!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.serviceCount != nil {
                map["ServiceCount"] = self.serviceCount!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigCount") && dict["ConfigCount"] != nil {
                self.configCount = dict["ConfigCount"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceDesc") && dict["NamespaceDesc"] != nil {
                self.namespaceDesc = dict["NamespaceDesc"] as! String
            }
            if dict.keys.contains("NamespaceShowName") && dict["NamespaceShowName"] != nil {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Quota") && dict["Quota"] != nil {
                self.quota = dict["Quota"] as! Int32
            }
            if dict.keys.contains("ServiceCount") && dict["ServiceCount"] != nil {
                self.serviceCount = dict["ServiceCount"] as! String
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var data: [ListEngineNamespacesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListEngineNamespacesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEngineNamespacesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEngineNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEngineNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEngineNamespacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEurekaInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListEurekaInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var app: String?

        public var durationInSecs: Int32?

        public var homePageUrl: String?

        public var hostName: String?

        public var instanceId: String?

        public var ipAddr: String?

        public var lastDirtyTimestamp: Int64?

        public var lastUpdatedTimestamp: Int64?

        public var metadata: [String: Any]?

        public var port: Int32?

        public var renewalIntervalInSecs: Int32?

        public var securePort: Int32?

        public var status: String?

        public var vipAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.durationInSecs != nil {
                map["DurationInSecs"] = self.durationInSecs!
            }
            if self.homePageUrl != nil {
                map["HomePageUrl"] = self.homePageUrl!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ipAddr != nil {
                map["IpAddr"] = self.ipAddr!
            }
            if self.lastDirtyTimestamp != nil {
                map["LastDirtyTimestamp"] = self.lastDirtyTimestamp!
            }
            if self.lastUpdatedTimestamp != nil {
                map["LastUpdatedTimestamp"] = self.lastUpdatedTimestamp!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.renewalIntervalInSecs != nil {
                map["RenewalIntervalInSecs"] = self.renewalIntervalInSecs!
            }
            if self.securePort != nil {
                map["SecurePort"] = self.securePort!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vipAddress != nil {
                map["VipAddress"] = self.vipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") && dict["App"] != nil {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("DurationInSecs") && dict["DurationInSecs"] != nil {
                self.durationInSecs = dict["DurationInSecs"] as! Int32
            }
            if dict.keys.contains("HomePageUrl") && dict["HomePageUrl"] != nil {
                self.homePageUrl = dict["HomePageUrl"] as! String
            }
            if dict.keys.contains("HostName") && dict["HostName"] != nil {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("IpAddr") && dict["IpAddr"] != nil {
                self.ipAddr = dict["IpAddr"] as! String
            }
            if dict.keys.contains("LastDirtyTimestamp") && dict["LastDirtyTimestamp"] != nil {
                self.lastDirtyTimestamp = dict["LastDirtyTimestamp"] as! Int64
            }
            if dict.keys.contains("LastUpdatedTimestamp") && dict["LastUpdatedTimestamp"] != nil {
                self.lastUpdatedTimestamp = dict["LastUpdatedTimestamp"] as! Int64
            }
            if dict.keys.contains("Metadata") && dict["Metadata"] != nil {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("RenewalIntervalInSecs") && dict["RenewalIntervalInSecs"] != nil {
                self.renewalIntervalInSecs = dict["RenewalIntervalInSecs"] as! Int32
            }
            if dict.keys.contains("SecurePort") && dict["SecurePort"] != nil {
                self.securePort = dict["SecurePort"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VipAddress") && dict["VipAddress"] != nil {
                self.vipAddress = dict["VipAddress"] as! String
            }
        }
    }
    public var data: [ListEurekaInstancesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListEurekaInstancesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEurekaInstancesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEurekaInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEurekaInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEurekaInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEurekaServicesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListEurekaServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instancesId: [String]?

        public var name: String?

        public var upStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instancesId != nil {
                map["InstancesId"] = self.instancesId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.upStatus != nil {
                map["UpStatus"] = self.upStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstancesId") && dict["InstancesId"] != nil {
                self.instancesId = dict["InstancesId"] as! [String]
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UpStatus") && dict["UpStatus"] != nil {
                self.upStatus = dict["UpStatus"] as! String
            }
        }
    }
    public var data: [ListEurekaServicesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListEurekaServicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEurekaServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEurekaServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEurekaServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEurekaServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListExportZookeeperDataRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListExportZookeeperDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var contentMap: String?

        public var createTime: Int64?

        public var exportType: String?

        public var extend: String?

        public var id: Int32?

        public var instanceId: String?

        public var kubeoneTaskIds: String?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentMap != nil {
                map["ContentMap"] = self.contentMap!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.exportType != nil {
                map["ExportType"] = self.exportType!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.kubeoneTaskIds != nil {
                map["KubeoneTaskIds"] = self.kubeoneTaskIds!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentMap") && dict["ContentMap"] != nil {
                self.contentMap = dict["ContentMap"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExportType") && dict["ExportType"] != nil {
                self.exportType = dict["ExportType"] as! String
            }
            if dict.keys.contains("Extend") && dict["Extend"] != nil {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("KubeoneTaskIds") && dict["KubeoneTaskIds"] != nil {
                self.kubeoneTaskIds = dict["KubeoneTaskIds"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var data: [ListExportZookeeperDataResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListExportZookeeperDataResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListExportZookeeperDataResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListExportZookeeperDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListExportZookeeperDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListExportZookeeperDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var resource: String?

    public var resourceSearchKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceSearchKey != nil {
            map["ResourceSearchKey"] = self.resourceSearchKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageIndex") && dict["PageIndex"] != nil {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("ResourceSearchKey") && dict["ResourceSearchKey"] != nil {
            self.resourceSearchKey = dict["ResourceSearchKey"] as! String
        }
    }
}

public class ListFlowRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var controlBehavior: Int32?

            public var enable: Bool?

            public var fallbackObject: String?

            public var maxQueueingTimeMs: Int32?

            public var metricType: Int32?

            public var namespace: String?

            public var regionId: String?

            public var resource: String?

            public var resourceType: Int32?

            public var ruleId: Int64?

            public var threshold: Double?

            public var trafficTags: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.controlBehavior != nil {
                    map["ControlBehavior"] = self.controlBehavior!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.fallbackObject != nil {
                    map["FallbackObject"] = self.fallbackObject!
                }
                if self.maxQueueingTimeMs != nil {
                    map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
                }
                if self.metricType != nil {
                    map["MetricType"] = self.metricType!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resource != nil {
                    map["Resource"] = self.resource!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.trafficTags != nil {
                    map["TrafficTags"] = self.trafficTags!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ControlBehavior") && dict["ControlBehavior"] != nil {
                    self.controlBehavior = dict["ControlBehavior"] as! Int32
                }
                if dict.keys.contains("Enable") && dict["Enable"] != nil {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("FallbackObject") && dict["FallbackObject"] != nil {
                    self.fallbackObject = dict["FallbackObject"] as! String
                }
                if dict.keys.contains("MaxQueueingTimeMs") && dict["MaxQueueingTimeMs"] != nil {
                    self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
                }
                if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
                    self.metricType = dict["MetricType"] as! Int32
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Resource") && dict["Resource"] != nil {
                    self.resource = dict["Resource"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! Int32
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! Int64
                }
                if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                    self.threshold = dict["Threshold"] as! Double
                }
                if dict.keys.contains("TrafficTags") && dict["TrafficTags"] != nil {
                    self.trafficTags = dict["TrafficTags"] as! [String: Any]
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListFlowRulesResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListFlowRulesResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListFlowRulesResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListFlowRulesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListFlowRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListFlowRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var gatewayType: String?

        public var gatewayUniqueId: String?

        public var instanceId: String?

        public var mseTag: String?

        public var name: String?

        public var resourceGroupId: String?

        public var vpc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayType != nil {
                map["GatewayType"] = self.gatewayType!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.mseTag != nil {
                map["MseTag"] = self.mseTag!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayType") && dict["GatewayType"] != nil {
                self.gatewayType = dict["GatewayType"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MseTag") && dict["MseTag"] != nil {
                self.mseTag = dict["MseTag"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Vpc") && dict["Vpc"] != nil {
                self.vpc = dict["Vpc"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: ListGatewayRequest.FilterParams?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") && dict["DescSort"] != nil {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") && dict["FilterParams"] != nil {
            var model = ListGatewayRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("OrderItem") && dict["OrderItem"] != nil {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") && dict["DescSort"] != nil {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") && dict["FilterParams"] != nil {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("OrderItem") && dict["OrderItem"] != nil {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class ElasticPolicy : Tea.TeaModel {
                public class TimePolicyList : Tea.TeaModel {
                    public var desiredReplica: Int32?

                    public var endTime: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.desiredReplica != nil {
                            map["DesiredReplica"] = self.desiredReplica!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DesiredReplica") && dict["DesiredReplica"] != nil {
                            self.desiredReplica = dict["DesiredReplica"] as! Int32
                        }
                        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public var elastic: Bool?

                public var elasticType: String?

                public var maxReplica: Int32?

                public var timePolicyList: [ListGatewayResponseBody.Data.Result.ElasticPolicy.TimePolicyList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.elastic != nil {
                        map["Elastic"] = self.elastic!
                    }
                    if self.elasticType != nil {
                        map["ElasticType"] = self.elasticType!
                    }
                    if self.maxReplica != nil {
                        map["MaxReplica"] = self.maxReplica!
                    }
                    if self.timePolicyList != nil {
                        var tmp : [Any] = []
                        for k in self.timePolicyList! {
                            tmp.append(k.toMap())
                        }
                        map["TimePolicyList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Elastic") && dict["Elastic"] != nil {
                        self.elastic = dict["Elastic"] as! Bool
                    }
                    if dict.keys.contains("ElasticType") && dict["ElasticType"] != nil {
                        self.elasticType = dict["ElasticType"] as! String
                    }
                    if dict.keys.contains("MaxReplica") && dict["MaxReplica"] != nil {
                        self.maxReplica = dict["MaxReplica"] as! Int32
                    }
                    if dict.keys.contains("TimePolicyList") && dict["TimePolicyList"] != nil {
                        var tmp : [ListGatewayResponseBody.Data.Result.ElasticPolicy.TimePolicyList] = []
                        for v in dict["TimePolicyList"] as! [Any] {
                            var model = ListGatewayResponseBody.Data.Result.ElasticPolicy.TimePolicyList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.timePolicyList = tmp
                    }
                }
            }
            public class InitConfig : Tea.TeaModel {
                public var enableWaf: Bool?

                public var supportWaf: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableWaf != nil {
                        map["EnableWaf"] = self.enableWaf!
                    }
                    if self.supportWaf != nil {
                        map["SupportWaf"] = self.supportWaf!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
                        self.enableWaf = dict["EnableWaf"] as! Bool
                    }
                    if dict.keys.contains("SupportWaf") && dict["SupportWaf"] != nil {
                        self.supportWaf = dict["SupportWaf"] as! Bool
                    }
                }
            }
            public class InternetSlb : Tea.TeaModel {
                public var gatewaySlbMode: String?

                public var gatewaySlbStatus: String?

                public var internetNetworkFlow: String?

                public var slbId: String?

                public var slbIp: String?

                public var slbPort: String?

                public var slbSpec: String?

                public var statusDesc: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gatewaySlbMode != nil {
                        map["GatewaySlbMode"] = self.gatewaySlbMode!
                    }
                    if self.gatewaySlbStatus != nil {
                        map["GatewaySlbStatus"] = self.gatewaySlbStatus!
                    }
                    if self.internetNetworkFlow != nil {
                        map["InternetNetworkFlow"] = self.internetNetworkFlow!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbIp != nil {
                        map["SlbIp"] = self.slbIp!
                    }
                    if self.slbPort != nil {
                        map["SlbPort"] = self.slbPort!
                    }
                    if self.slbSpec != nil {
                        map["SlbSpec"] = self.slbSpec!
                    }
                    if self.statusDesc != nil {
                        map["StatusDesc"] = self.statusDesc!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GatewaySlbMode") && dict["GatewaySlbMode"] != nil {
                        self.gatewaySlbMode = dict["GatewaySlbMode"] as! String
                    }
                    if dict.keys.contains("GatewaySlbStatus") && dict["GatewaySlbStatus"] != nil {
                        self.gatewaySlbStatus = dict["GatewaySlbStatus"] as! String
                    }
                    if dict.keys.contains("InternetNetworkFlow") && dict["InternetNetworkFlow"] != nil {
                        self.internetNetworkFlow = dict["InternetNetworkFlow"] as! String
                    }
                    if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
                        self.slbId = dict["SlbId"] as! String
                    }
                    if dict.keys.contains("SlbIp") && dict["SlbIp"] != nil {
                        self.slbIp = dict["SlbIp"] as! String
                    }
                    if dict.keys.contains("SlbPort") && dict["SlbPort"] != nil {
                        self.slbPort = dict["SlbPort"] as! String
                    }
                    if dict.keys.contains("SlbSpec") && dict["SlbSpec"] != nil {
                        self.slbSpec = dict["SlbSpec"] as! String
                    }
                    if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                        self.statusDesc = dict["StatusDesc"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class MaintenancePeriod : Tea.TeaModel {
                public var endTime: String?

                public var startTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public class Slb : Tea.TeaModel {
                public var gatewaySlbMode: String?

                public var gatewaySlbStatus: String?

                public var slbId: String?

                public var slbIp: String?

                public var slbPort: String?

                public var slbSpec: String?

                public var statusDesc: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gatewaySlbMode != nil {
                        map["GatewaySlbMode"] = self.gatewaySlbMode!
                    }
                    if self.gatewaySlbStatus != nil {
                        map["GatewaySlbStatus"] = self.gatewaySlbStatus!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbIp != nil {
                        map["SlbIp"] = self.slbIp!
                    }
                    if self.slbPort != nil {
                        map["SlbPort"] = self.slbPort!
                    }
                    if self.slbSpec != nil {
                        map["SlbSpec"] = self.slbSpec!
                    }
                    if self.statusDesc != nil {
                        map["StatusDesc"] = self.statusDesc!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GatewaySlbMode") && dict["GatewaySlbMode"] != nil {
                        self.gatewaySlbMode = dict["GatewaySlbMode"] as! String
                    }
                    if dict.keys.contains("GatewaySlbStatus") && dict["GatewaySlbStatus"] != nil {
                        self.gatewaySlbStatus = dict["GatewaySlbStatus"] as! String
                    }
                    if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
                        self.slbId = dict["SlbId"] as! String
                    }
                    if dict.keys.contains("SlbIp") && dict["SlbIp"] != nil {
                        self.slbIp = dict["SlbIp"] as! String
                    }
                    if dict.keys.contains("SlbPort") && dict["SlbPort"] != nil {
                        self.slbPort = dict["SlbPort"] as! String
                    }
                    if dict.keys.contains("SlbSpec") && dict["SlbSpec"] != nil {
                        self.slbSpec = dict["SlbSpec"] as! String
                    }
                    if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                        self.statusDesc = dict["StatusDesc"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var ahasOn: Bool?

            public var appVersion: String?

            public var armsOn: Bool?

            public var chargeType: String?

            public var currentVersion: String?

            public var elastic: Bool?

            public var elasticInstanceId: String?

            public var elasticPolicy: ListGatewayResponseBody.Data.Result.ElasticPolicy?

            public var elasticReplica: Int32?

            public var elasticType: String?

            public var endDate: String?

            public var gatewayType: String?

            public var gatewayUniqueId: String?

            public var gatewayVersion: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var initConfig: ListGatewayResponseBody.Data.Result.InitConfig?

            public var instanceId: String?

            public var internetSlb: [ListGatewayResponseBody.Data.Result.InternetSlb]?

            public var latestVersion: String?

            public var maintenancePeriod: ListGatewayResponseBody.Data.Result.MaintenancePeriod?

            public var mseTag: String?

            public var mseVersion: String?

            public var mustUpgrade: Bool?

            public var name: String?

            public var primaryUser: String?

            public var region: String?

            public var replica: Int32?

            public var resourceGroupId: String?

            public var rollBack: Bool?

            public var slb: [ListGatewayResponseBody.Data.Result.Slb]?

            public var spec: String?

            public var status: Int32?

            public var statusDesc: String?

            public var supportWasm: Bool?

            public var tag: String?

            public var totalReplica: Int32?

            public var upgrade: Bool?

            public var vpcId: String?

            public var vswitch2: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.elasticPolicy?.validate()
                try self.initConfig?.validate()
                try self.maintenancePeriod?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ahasOn != nil {
                    map["AhasOn"] = self.ahasOn!
                }
                if self.appVersion != nil {
                    map["AppVersion"] = self.appVersion!
                }
                if self.armsOn != nil {
                    map["ArmsOn"] = self.armsOn!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.currentVersion != nil {
                    map["CurrentVersion"] = self.currentVersion!
                }
                if self.elastic != nil {
                    map["Elastic"] = self.elastic!
                }
                if self.elasticInstanceId != nil {
                    map["ElasticInstanceId"] = self.elasticInstanceId!
                }
                if self.elasticPolicy != nil {
                    map["ElasticPolicy"] = self.elasticPolicy?.toMap()
                }
                if self.elasticReplica != nil {
                    map["ElasticReplica"] = self.elasticReplica!
                }
                if self.elasticType != nil {
                    map["ElasticType"] = self.elasticType!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.gatewayType != nil {
                    map["GatewayType"] = self.gatewayType!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gatewayVersion != nil {
                    map["GatewayVersion"] = self.gatewayVersion!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.initConfig != nil {
                    map["InitConfig"] = self.initConfig?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.internetSlb != nil {
                    var tmp : [Any] = []
                    for k in self.internetSlb! {
                        tmp.append(k.toMap())
                    }
                    map["InternetSlb"] = tmp
                }
                if self.latestVersion != nil {
                    map["LatestVersion"] = self.latestVersion!
                }
                if self.maintenancePeriod != nil {
                    map["MaintenancePeriod"] = self.maintenancePeriod?.toMap()
                }
                if self.mseTag != nil {
                    map["MseTag"] = self.mseTag!
                }
                if self.mseVersion != nil {
                    map["MseVersion"] = self.mseVersion!
                }
                if self.mustUpgrade != nil {
                    map["MustUpgrade"] = self.mustUpgrade!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.primaryUser != nil {
                    map["PrimaryUser"] = self.primaryUser!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.replica != nil {
                    map["Replica"] = self.replica!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.rollBack != nil {
                    map["RollBack"] = self.rollBack!
                }
                if self.slb != nil {
                    var tmp : [Any] = []
                    for k in self.slb! {
                        tmp.append(k.toMap())
                    }
                    map["Slb"] = tmp
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusDesc != nil {
                    map["StatusDesc"] = self.statusDesc!
                }
                if self.supportWasm != nil {
                    map["SupportWasm"] = self.supportWasm!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.totalReplica != nil {
                    map["TotalReplica"] = self.totalReplica!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vswitch2 != nil {
                    map["Vswitch2"] = self.vswitch2!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AhasOn") && dict["AhasOn"] != nil {
                    self.ahasOn = dict["AhasOn"] as! Bool
                }
                if dict.keys.contains("AppVersion") && dict["AppVersion"] != nil {
                    self.appVersion = dict["AppVersion"] as! String
                }
                if dict.keys.contains("ArmsOn") && dict["ArmsOn"] != nil {
                    self.armsOn = dict["ArmsOn"] as! Bool
                }
                if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CurrentVersion") && dict["CurrentVersion"] != nil {
                    self.currentVersion = dict["CurrentVersion"] as! String
                }
                if dict.keys.contains("Elastic") && dict["Elastic"] != nil {
                    self.elastic = dict["Elastic"] as! Bool
                }
                if dict.keys.contains("ElasticInstanceId") && dict["ElasticInstanceId"] != nil {
                    self.elasticInstanceId = dict["ElasticInstanceId"] as! String
                }
                if dict.keys.contains("ElasticPolicy") && dict["ElasticPolicy"] != nil {
                    var model = ListGatewayResponseBody.Data.Result.ElasticPolicy()
                    model.fromMap(dict["ElasticPolicy"] as! [String: Any])
                    self.elasticPolicy = model
                }
                if dict.keys.contains("ElasticReplica") && dict["ElasticReplica"] != nil {
                    self.elasticReplica = dict["ElasticReplica"] as! Int32
                }
                if dict.keys.contains("ElasticType") && dict["ElasticType"] != nil {
                    self.elasticType = dict["ElasticType"] as! String
                }
                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("GatewayType") && dict["GatewayType"] != nil {
                    self.gatewayType = dict["GatewayType"] as! String
                }
                if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GatewayVersion") && dict["GatewayVersion"] != nil {
                    self.gatewayVersion = dict["GatewayVersion"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InitConfig") && dict["InitConfig"] != nil {
                    var model = ListGatewayResponseBody.Data.Result.InitConfig()
                    model.fromMap(dict["InitConfig"] as! [String: Any])
                    self.initConfig = model
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InternetSlb") && dict["InternetSlb"] != nil {
                    var tmp : [ListGatewayResponseBody.Data.Result.InternetSlb] = []
                    for v in dict["InternetSlb"] as! [Any] {
                        var model = ListGatewayResponseBody.Data.Result.InternetSlb()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.internetSlb = tmp
                }
                if dict.keys.contains("LatestVersion") && dict["LatestVersion"] != nil {
                    self.latestVersion = dict["LatestVersion"] as! String
                }
                if dict.keys.contains("MaintenancePeriod") && dict["MaintenancePeriod"] != nil {
                    var model = ListGatewayResponseBody.Data.Result.MaintenancePeriod()
                    model.fromMap(dict["MaintenancePeriod"] as! [String: Any])
                    self.maintenancePeriod = model
                }
                if dict.keys.contains("MseTag") && dict["MseTag"] != nil {
                    self.mseTag = dict["MseTag"] as! String
                }
                if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
                    self.mseVersion = dict["MseVersion"] as! String
                }
                if dict.keys.contains("MustUpgrade") && dict["MustUpgrade"] != nil {
                    self.mustUpgrade = dict["MustUpgrade"] as! Bool
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PrimaryUser") && dict["PrimaryUser"] != nil {
                    self.primaryUser = dict["PrimaryUser"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Replica") && dict["Replica"] != nil {
                    self.replica = dict["Replica"] as! Int32
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RollBack") && dict["RollBack"] != nil {
                    self.rollBack = dict["RollBack"] as! Bool
                }
                if dict.keys.contains("Slb") && dict["Slb"] != nil {
                    var tmp : [ListGatewayResponseBody.Data.Result.Slb] = []
                    for v in dict["Slb"] as! [Any] {
                        var model = ListGatewayResponseBody.Data.Result.Slb()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.slb = tmp
                }
                if dict.keys.contains("Spec") && dict["Spec"] != nil {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                    self.statusDesc = dict["StatusDesc"] as! String
                }
                if dict.keys.contains("SupportWasm") && dict["SupportWasm"] != nil {
                    self.supportWasm = dict["SupportWasm"] as! Bool
                }
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("TotalReplica") && dict["TotalReplica"] != nil {
                    self.totalReplica = dict["TotalReplica"] as! Int32
                }
                if dict.keys.contains("Upgrade") && dict["Upgrade"] != nil {
                    self.upgrade = dict["Upgrade"] as! Bool
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("Vswitch2") && dict["Vswitch2"] != nil {
                    self.vswitch2 = dict["Vswitch2"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListGatewayResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayAuthConsumerRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerStatus: Bool?

    public var gatewayUniqueId: String?

    public var name: String?

    public var pageNum: String?

    public var pageSize: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerStatus != nil {
            map["ConsumerStatus"] = self.consumerStatus!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerStatus") && dict["ConsumerStatus"] != nil {
            self.consumerStatus = dict["ConsumerStatus"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListGatewayAuthConsumerResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var consumerStatus: Bool?

            public var description_: String?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var name: String?

            public var primaryUser: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumerStatus != nil {
                    map["ConsumerStatus"] = self.consumerStatus!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.primaryUser != nil {
                    map["PrimaryUser"] = self.primaryUser!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumerStatus") && dict["ConsumerStatus"] != nil {
                    self.consumerStatus = dict["ConsumerStatus"] as! Bool
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PrimaryUser") && dict["PrimaryUser"] != nil {
                    self.primaryUser = dict["PrimaryUser"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayAuthConsumerResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListGatewayAuthConsumerResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayAuthConsumerResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayAuthConsumerResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListGatewayAuthConsumerResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayAuthConsumerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayAuthConsumerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListGatewayAuthConsumerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayAuthConsumerResourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var pageNum: String?

    public var pageSize: String?

    public var resourceStatus: Bool?

    public var routeName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceStatus != nil {
            map["ResourceStatus"] = self.resourceStatus!
        }
        if self.routeName != nil {
            map["RouteName"] = self.routeName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") && dict["ConsumerId"] != nil {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ResourceStatus") && dict["ResourceStatus"] != nil {
            self.resourceStatus = dict["ResourceStatus"] as! Bool
        }
        if dict.keys.contains("RouteName") && dict["RouteName"] != nil {
            self.routeName = dict["RouteName"] as! String
        }
    }
}

public class ListGatewayAuthConsumerResourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var consumerId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var resourceStatus: Bool?

            public var routeId: Int64?

            public var routeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumerId != nil {
                    map["ConsumerId"] = self.consumerId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.resourceStatus != nil {
                    map["ResourceStatus"] = self.resourceStatus!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumerId") && dict["ConsumerId"] != nil {
                    self.consumerId = dict["ConsumerId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ResourceStatus") && dict["ResourceStatus"] != nil {
                    self.resourceStatus = dict["ResourceStatus"] as! Bool
                }
                if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") && dict["RouteName"] != nil {
                    self.routeName = dict["RouteName"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayAuthConsumerResourceResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListGatewayAuthConsumerResourceResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayAuthConsumerResourceResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayAuthConsumerResourceResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListGatewayAuthConsumerResourceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayAuthConsumerResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayAuthConsumerResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListGatewayAuthConsumerResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var domainName: String?

    public var gatewayUniqueId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListGatewayDomainResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Comment : Tea.TeaModel {
            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var certBeforeDate: String?

        public var certIdentifier: String?

        public var comment: ListGatewayDomainResponseBody.Data.Comment?

        public var gatewayId: Int64?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var http2: String?

        public var id: Int64?

        public var mustHttps: Bool?

        public var name: String?

        public var protocol_: String?

        public var status: Int32?

        public var tlsMax: String?

        public var tlsMin: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.comment?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certBeforeDate != nil {
                map["CertBeforeDate"] = self.certBeforeDate!
            }
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.comment != nil {
                map["Comment"] = self.comment?.toMap()
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.http2 != nil {
                map["Http2"] = self.http2!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mustHttps != nil {
                map["MustHttps"] = self.mustHttps!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tlsMax != nil {
                map["TlsMax"] = self.tlsMax!
            }
            if self.tlsMin != nil {
                map["TlsMin"] = self.tlsMin!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertBeforeDate") && dict["CertBeforeDate"] != nil {
                self.certBeforeDate = dict["CertBeforeDate"] as! String
            }
            if dict.keys.contains("CertIdentifier") && dict["CertIdentifier"] != nil {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                var model = ListGatewayDomainResponseBody.Data.Comment()
                model.fromMap(dict["Comment"] as! [String: Any])
                self.comment = model
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Http2") && dict["Http2"] != nil {
                self.http2 = dict["Http2"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MustHttps") && dict["MustHttps"] != nil {
                self.mustHttps = dict["MustHttps"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TlsMax") && dict["TlsMax"] != nil {
                self.tlsMax = dict["TlsMax"] as! String
            }
            if dict.keys.contains("TlsMin") && dict["TlsMin"] != nil {
                self.tlsMin = dict["TlsMin"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListGatewayDomainResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListGatewayDomainResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListGatewayDomainResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayRouteRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var defaultServiceId: Int64?

        public var domainId: Int64?

        public var domainName: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var name: String?

        public var path: String?

        public var routeOrder: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultServiceId") && dict["DefaultServiceId"] != nil {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("RouteOrder") && dict["RouteOrder"] != nil {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: ListGatewayRouteRequest.FilterParams?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") && dict["DescSort"] != nil {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") && dict["FilterParams"] != nil {
            var model = ListGatewayRouteRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("OrderItem") && dict["OrderItem"] != nil {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") && dict["DescSort"] != nil {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") && dict["FilterParams"] != nil {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("OrderItem") && dict["OrderItem"] != nil {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class Comment : Tea.TeaModel {
                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DirectResponse : Tea.TeaModel {
                public var body: String?

                public var code: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body!
                    }
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") && dict["Body"] != nil {
                        self.body = dict["Body"] as! String
                    }
                    if dict.keys.contains("Code") && dict["Code"] != nil {
                        self.code = dict["Code"] as! Int32
                    }
                }
            }
            public class FallbackServices : Tea.TeaModel {
                public var agreementType: String?

                public var groupName: String?

                public var name: String?

                public var namespace: String?

                public var percent: Int32?

                public var serviceId: Int64?

                public var serviceName: String?

                public var servicePort: Int32?

                public var sourceType: String?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agreementType != nil {
                        map["AgreementType"] = self.agreementType!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.serviceId != nil {
                        map["ServiceId"] = self.serviceId!
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    if self.servicePort != nil {
                        map["ServicePort"] = self.servicePort!
                    }
                    if self.sourceType != nil {
                        map["SourceType"] = self.sourceType!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AgreementType") && dict["AgreementType"] != nil {
                        self.agreementType = dict["AgreementType"] as! String
                    }
                    if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("Percent") && dict["Percent"] != nil {
                        self.percent = dict["Percent"] as! Int32
                    }
                    if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                        self.serviceId = dict["ServiceId"] as! Int64
                    }
                    if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                        self.serviceName = dict["ServiceName"] as! String
                    }
                    if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                        self.servicePort = dict["ServicePort"] as! Int32
                    }
                    if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                        self.sourceType = dict["SourceType"] as! String
                    }
                    if dict.keys.contains("Version") && dict["Version"] != nil {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public class Redirect : Tea.TeaModel {
                public var code: Int32?

                public var host: String?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") && dict["Code"] != nil {
                        self.code = dict["Code"] as! Int32
                    }
                    if dict.keys.contains("Host") && dict["Host"] != nil {
                        self.host = dict["Host"] as! String
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public class RoutePredicates : Tea.TeaModel {
                public class HeaderPredicates : Tea.TeaModel {
                    public var key: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class PathPredicates : Tea.TeaModel {
                    public var ignoreCase: Bool?

                    public var path: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ignoreCase != nil {
                            map["IgnoreCase"] = self.ignoreCase!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IgnoreCase") && dict["IgnoreCase"] != nil {
                            self.ignoreCase = dict["IgnoreCase"] as! Bool
                        }
                        if dict.keys.contains("Path") && dict["Path"] != nil {
                            self.path = dict["Path"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class QueryPredicates : Tea.TeaModel {
                    public var key: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") && dict["Key"] != nil {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var headerPredicates: [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.HeaderPredicates]?

                public var methodPredicates: [String]?

                public var pathPredicates: ListGatewayRouteResponseBody.Data.Result.RoutePredicates.PathPredicates?

                public var queryPredicates: [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.QueryPredicates]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.pathPredicates?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerPredicates != nil {
                        var tmp : [Any] = []
                        for k in self.headerPredicates! {
                            tmp.append(k.toMap())
                        }
                        map["HeaderPredicates"] = tmp
                    }
                    if self.methodPredicates != nil {
                        map["MethodPredicates"] = self.methodPredicates!
                    }
                    if self.pathPredicates != nil {
                        map["PathPredicates"] = self.pathPredicates?.toMap()
                    }
                    if self.queryPredicates != nil {
                        var tmp : [Any] = []
                        for k in self.queryPredicates! {
                            tmp.append(k.toMap())
                        }
                        map["QueryPredicates"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderPredicates") && dict["HeaderPredicates"] != nil {
                        var tmp : [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.HeaderPredicates] = []
                        for v in dict["HeaderPredicates"] as! [Any] {
                            var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates.HeaderPredicates()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.headerPredicates = tmp
                    }
                    if dict.keys.contains("MethodPredicates") && dict["MethodPredicates"] != nil {
                        self.methodPredicates = dict["MethodPredicates"] as! [String]
                    }
                    if dict.keys.contains("PathPredicates") && dict["PathPredicates"] != nil {
                        var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates.PathPredicates()
                        model.fromMap(dict["PathPredicates"] as! [String: Any])
                        self.pathPredicates = model
                    }
                    if dict.keys.contains("QueryPredicates") && dict["QueryPredicates"] != nil {
                        var tmp : [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.QueryPredicates] = []
                        for v in dict["QueryPredicates"] as! [Any] {
                            var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates.QueryPredicates()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.queryPredicates = tmp
                    }
                }
            }
            public class RouteServices : Tea.TeaModel {
                public class HttpDubboTranscoder : Tea.TeaModel {
                    public class MothedMapList : Tea.TeaModel {
                        public class ParamMapsList : Tea.TeaModel {
                            public var extractKey: String?

                            public var extractKeySpec: String?

                            public var mappingType: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.extractKey != nil {
                                    map["ExtractKey"] = self.extractKey!
                                }
                                if self.extractKeySpec != nil {
                                    map["ExtractKeySpec"] = self.extractKeySpec!
                                }
                                if self.mappingType != nil {
                                    map["MappingType"] = self.mappingType!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ExtractKey") && dict["ExtractKey"] != nil {
                                    self.extractKey = dict["ExtractKey"] as! String
                                }
                                if dict.keys.contains("ExtractKeySpec") && dict["ExtractKeySpec"] != nil {
                                    self.extractKeySpec = dict["ExtractKeySpec"] as! String
                                }
                                if dict.keys.contains("MappingType") && dict["MappingType"] != nil {
                                    self.mappingType = dict["MappingType"] as! String
                                }
                            }
                        }
                        public var dubboMothedName: String?

                        public var httpMothed: String?

                        public var mothedpath: String?

                        public var paramMapsList: [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                        public var passThroughAllHeaders: String?

                        public var passThroughList: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dubboMothedName != nil {
                                map["DubboMothedName"] = self.dubboMothedName!
                            }
                            if self.httpMothed != nil {
                                map["HttpMothed"] = self.httpMothed!
                            }
                            if self.mothedpath != nil {
                                map["Mothedpath"] = self.mothedpath!
                            }
                            if self.paramMapsList != nil {
                                var tmp : [Any] = []
                                for k in self.paramMapsList! {
                                    tmp.append(k.toMap())
                                }
                                map["ParamMapsList"] = tmp
                            }
                            if self.passThroughAllHeaders != nil {
                                map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                            }
                            if self.passThroughList != nil {
                                map["PassThroughList"] = self.passThroughList!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DubboMothedName") && dict["DubboMothedName"] != nil {
                                self.dubboMothedName = dict["DubboMothedName"] as! String
                            }
                            if dict.keys.contains("HttpMothed") && dict["HttpMothed"] != nil {
                                self.httpMothed = dict["HttpMothed"] as! String
                            }
                            if dict.keys.contains("Mothedpath") && dict["Mothedpath"] != nil {
                                self.mothedpath = dict["Mothedpath"] as! String
                            }
                            if dict.keys.contains("ParamMapsList") && dict["ParamMapsList"] != nil {
                                var tmp : [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList] = []
                                for v in dict["ParamMapsList"] as! [Any] {
                                    var model = ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.paramMapsList = tmp
                            }
                            if dict.keys.contains("PassThroughAllHeaders") && dict["PassThroughAllHeaders"] != nil {
                                self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                            }
                            if dict.keys.contains("PassThroughList") && dict["PassThroughList"] != nil {
                                self.passThroughList = dict["PassThroughList"] as! [String]
                            }
                        }
                    }
                    public var dubboServiceGroup: String?

                    public var dubboServiceName: String?

                    public var dubboServiceVersion: String?

                    public var mothedMapList: [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dubboServiceGroup != nil {
                            map["DubboServiceGroup"] = self.dubboServiceGroup!
                        }
                        if self.dubboServiceName != nil {
                            map["DubboServiceName"] = self.dubboServiceName!
                        }
                        if self.dubboServiceVersion != nil {
                            map["DubboServiceVersion"] = self.dubboServiceVersion!
                        }
                        if self.mothedMapList != nil {
                            var tmp : [Any] = []
                            for k in self.mothedMapList! {
                                tmp.append(k.toMap())
                            }
                            map["MothedMapList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DubboServiceGroup") && dict["DubboServiceGroup"] != nil {
                            self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                        }
                        if dict.keys.contains("DubboServiceName") && dict["DubboServiceName"] != nil {
                            self.dubboServiceName = dict["DubboServiceName"] as! String
                        }
                        if dict.keys.contains("DubboServiceVersion") && dict["DubboServiceVersion"] != nil {
                            self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                        }
                        if dict.keys.contains("MothedMapList") && dict["MothedMapList"] != nil {
                            var tmp : [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList] = []
                            for v in dict["MothedMapList"] as! [Any] {
                                var model = ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.mothedMapList = tmp
                        }
                    }
                }
                public var agreementType: String?

                public var groupName: String?

                public var healthStatus: String?

                public var httpDubboTranscoder: ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder?

                public var name: String?

                public var namespace: String?

                public var percent: Int32?

                public var serviceId: Int64?

                public var serviceName: String?

                public var servicePort: Int32?

                public var sourceType: String?

                public var unhealthyEndpoints: [String]?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.httpDubboTranscoder?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agreementType != nil {
                        map["AgreementType"] = self.agreementType!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.healthStatus != nil {
                        map["HealthStatus"] = self.healthStatus!
                    }
                    if self.httpDubboTranscoder != nil {
                        map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.serviceId != nil {
                        map["ServiceId"] = self.serviceId!
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    if self.servicePort != nil {
                        map["ServicePort"] = self.servicePort!
                    }
                    if self.sourceType != nil {
                        map["SourceType"] = self.sourceType!
                    }
                    if self.unhealthyEndpoints != nil {
                        map["UnhealthyEndpoints"] = self.unhealthyEndpoints!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AgreementType") && dict["AgreementType"] != nil {
                        self.agreementType = dict["AgreementType"] as! String
                    }
                    if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                        self.healthStatus = dict["HealthStatus"] as! String
                    }
                    if dict.keys.contains("HttpDubboTranscoder") && dict["HttpDubboTranscoder"] != nil {
                        var model = ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder()
                        model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                        self.httpDubboTranscoder = model
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("Percent") && dict["Percent"] != nil {
                        self.percent = dict["Percent"] as! Int32
                    }
                    if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                        self.serviceId = dict["ServiceId"] as! Int64
                    }
                    if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                        self.serviceName = dict["ServiceName"] as! String
                    }
                    if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                        self.servicePort = dict["ServicePort"] as! Int32
                    }
                    if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                        self.sourceType = dict["SourceType"] as! String
                    }
                    if dict.keys.contains("UnhealthyEndpoints") && dict["UnhealthyEndpoints"] != nil {
                        self.unhealthyEndpoints = dict["UnhealthyEndpoints"] as! [String]
                    }
                    if dict.keys.contains("Version") && dict["Version"] != nil {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public var comment: ListGatewayRouteResponseBody.Data.Result.Comment?

            public var defaultServiceId: Int64?

            public var defaultServiceName: String?

            public var destinationType: String?

            public var directResponse: ListGatewayRouteResponseBody.Data.Result.DirectResponse?

            public var domainId: Int64?

            public var domainIdList: [Int64]?

            public var domainName: String?

            public var domainNameList: [String]?

            public var enableWaf: String?

            public var fallback: Bool?

            public var fallbackServices: [ListGatewayRouteResponseBody.Data.Result.FallbackServices]?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var name: String?

            public var predicates: String?

            public var redirect: ListGatewayRouteResponseBody.Data.Result.Redirect?

            public var routeOrder: Int32?

            public var routePredicates: ListGatewayRouteResponseBody.Data.Result.RoutePredicates?

            public var routeServices: [ListGatewayRouteResponseBody.Data.Result.RouteServices]?

            public var services: String?

            public var status: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.comment?.validate()
                try self.directResponse?.validate()
                try self.redirect?.validate()
                try self.routePredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment?.toMap()
                }
                if self.defaultServiceId != nil {
                    map["DefaultServiceId"] = self.defaultServiceId!
                }
                if self.defaultServiceName != nil {
                    map["DefaultServiceName"] = self.defaultServiceName!
                }
                if self.destinationType != nil {
                    map["DestinationType"] = self.destinationType!
                }
                if self.directResponse != nil {
                    map["DirectResponse"] = self.directResponse?.toMap()
                }
                if self.domainId != nil {
                    map["DomainId"] = self.domainId!
                }
                if self.domainIdList != nil {
                    map["DomainIdList"] = self.domainIdList!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainNameList != nil {
                    map["DomainNameList"] = self.domainNameList!
                }
                if self.enableWaf != nil {
                    map["EnableWaf"] = self.enableWaf!
                }
                if self.fallback != nil {
                    map["Fallback"] = self.fallback!
                }
                if self.fallbackServices != nil {
                    var tmp : [Any] = []
                    for k in self.fallbackServices! {
                        tmp.append(k.toMap())
                    }
                    map["FallbackServices"] = tmp
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.predicates != nil {
                    map["Predicates"] = self.predicates!
                }
                if self.redirect != nil {
                    map["Redirect"] = self.redirect?.toMap()
                }
                if self.routeOrder != nil {
                    map["RouteOrder"] = self.routeOrder!
                }
                if self.routePredicates != nil {
                    map["RoutePredicates"] = self.routePredicates?.toMap()
                }
                if self.routeServices != nil {
                    var tmp : [Any] = []
                    for k in self.routeServices! {
                        tmp.append(k.toMap())
                    }
                    map["RouteServices"] = tmp
                }
                if self.services != nil {
                    map["Services"] = self.services!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Comment") && dict["Comment"] != nil {
                    var model = ListGatewayRouteResponseBody.Data.Result.Comment()
                    model.fromMap(dict["Comment"] as! [String: Any])
                    self.comment = model
                }
                if dict.keys.contains("DefaultServiceId") && dict["DefaultServiceId"] != nil {
                    self.defaultServiceId = dict["DefaultServiceId"] as! Int64
                }
                if dict.keys.contains("DefaultServiceName") && dict["DefaultServiceName"] != nil {
                    self.defaultServiceName = dict["DefaultServiceName"] as! String
                }
                if dict.keys.contains("DestinationType") && dict["DestinationType"] != nil {
                    self.destinationType = dict["DestinationType"] as! String
                }
                if dict.keys.contains("DirectResponse") && dict["DirectResponse"] != nil {
                    var model = ListGatewayRouteResponseBody.Data.Result.DirectResponse()
                    model.fromMap(dict["DirectResponse"] as! [String: Any])
                    self.directResponse = model
                }
                if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
                    self.domainId = dict["DomainId"] as! Int64
                }
                if dict.keys.contains("DomainIdList") && dict["DomainIdList"] != nil {
                    self.domainIdList = dict["DomainIdList"] as! [Int64]
                }
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainNameList") && dict["DomainNameList"] != nil {
                    self.domainNameList = dict["DomainNameList"] as! [String]
                }
                if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
                    self.enableWaf = dict["EnableWaf"] as! String
                }
                if dict.keys.contains("Fallback") && dict["Fallback"] != nil {
                    self.fallback = dict["Fallback"] as! Bool
                }
                if dict.keys.contains("FallbackServices") && dict["FallbackServices"] != nil {
                    var tmp : [ListGatewayRouteResponseBody.Data.Result.FallbackServices] = []
                    for v in dict["FallbackServices"] as! [Any] {
                        var model = ListGatewayRouteResponseBody.Data.Result.FallbackServices()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.fallbackServices = tmp
                }
                if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Predicates") && dict["Predicates"] != nil {
                    self.predicates = dict["Predicates"] as! String
                }
                if dict.keys.contains("Redirect") && dict["Redirect"] != nil {
                    var model = ListGatewayRouteResponseBody.Data.Result.Redirect()
                    model.fromMap(dict["Redirect"] as! [String: Any])
                    self.redirect = model
                }
                if dict.keys.contains("RouteOrder") && dict["RouteOrder"] != nil {
                    self.routeOrder = dict["RouteOrder"] as! Int32
                }
                if dict.keys.contains("RoutePredicates") && dict["RoutePredicates"] != nil {
                    var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates()
                    model.fromMap(dict["RoutePredicates"] as! [String: Any])
                    self.routePredicates = model
                }
                if dict.keys.contains("RouteServices") && dict["RouteServices"] != nil {
                    var tmp : [ListGatewayRouteResponseBody.Data.Result.RouteServices] = []
                    for v in dict["RouteServices"] as! [Any] {
                        var model = ListGatewayRouteResponseBody.Data.Result.RouteServices()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.routeServices = tmp
                }
                if dict.keys.contains("Services") && dict["Services"] != nil {
                    self.services = dict["Services"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayRouteResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListGatewayRouteResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayRouteResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayRouteResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListGatewayRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayRouteOnAuthRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListGatewayRouteOnAuthResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RoutePredicates : Tea.TeaModel {
            public class PathPredicates : Tea.TeaModel {
                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var pathPredicates: ListGatewayRouteOnAuthResponseBody.Data.RoutePredicates.PathPredicates?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pathPredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pathPredicates != nil {
                    map["PathPredicates"] = self.pathPredicates?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PathPredicates") && dict["PathPredicates"] != nil {
                    var model = ListGatewayRouteOnAuthResponseBody.Data.RoutePredicates.PathPredicates()
                    model.fromMap(dict["PathPredicates"] as! [String: Any])
                    self.pathPredicates = model
                }
            }
        }
        public var domainId: Int64?

        public var domainIdList: [Int64]?

        public var domainName: String?

        public var domainNameList: [String]?

        public var gatewayId: String?

        public var gatewayUniqueId: String?

        public var id: Int32?

        public var name: String?

        public var routePredicates: ListGatewayRouteOnAuthResponseBody.Data.RoutePredicates?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.routePredicates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainIdList != nil {
                map["DomainIdList"] = self.domainIdList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameList != nil {
                map["DomainNameList"] = self.domainNameList!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.routePredicates != nil {
                map["RoutePredicates"] = self.routePredicates?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainIdList") && dict["DomainIdList"] != nil {
                self.domainIdList = dict["DomainIdList"] as! [Int64]
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainNameList") && dict["DomainNameList"] != nil {
                self.domainNameList = dict["DomainNameList"] as! [String]
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RoutePredicates") && dict["RoutePredicates"] != nil {
                var model = ListGatewayRouteOnAuthResponseBody.Data.RoutePredicates()
                model.fromMap(dict["RoutePredicates"] as! [String: Any])
                self.routePredicates = model
            }
        }
    }
    public var code: Int32?

    public var data: [ListGatewayRouteOnAuthResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListGatewayRouteOnAuthResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListGatewayRouteOnAuthResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayRouteOnAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayRouteOnAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListGatewayRouteOnAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayServiceRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var gatewayUniqueId: String?

        public var groupName: String?

        public var name: String?

        public var namespace: String?

        public var serviceProtocol: String?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServiceProtocol") && dict["ServiceProtocol"] != nil {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: ListGatewayServiceRequest.FilterParams?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") && dict["DescSort"] != nil {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") && dict["FilterParams"] != nil {
            var model = ListGatewayServiceRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("OrderItem") && dict["OrderItem"] != nil {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayServiceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") && dict["DescSort"] != nil {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") && dict["FilterParams"] != nil {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("OrderItem") && dict["OrderItem"] != nil {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class GatewayTrafficPolicy : Tea.TeaModel {
                public class LoadBalancerSettings : Tea.TeaModel {
                    public class ConsistentHashLBConfig : Tea.TeaModel {
                        public class HttpCookie : Tea.TeaModel {
                            public var name: String?

                            public var path: String?

                            public var ttl: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.name != nil {
                                    map["Name"] = self.name!
                                }
                                if self.path != nil {
                                    map["Path"] = self.path!
                                }
                                if self.ttl != nil {
                                    map["Ttl"] = self.ttl!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Name") && dict["Name"] != nil {
                                    self.name = dict["Name"] as! String
                                }
                                if dict.keys.contains("Path") && dict["Path"] != nil {
                                    self.path = dict["Path"] as! String
                                }
                                if dict.keys.contains("Ttl") && dict["Ttl"] != nil {
                                    self.ttl = dict["Ttl"] as! String
                                }
                            }
                        }
                        public var consistentHashLBType: String?

                        public var httpCookie: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie?

                        public var minimumRingSize: Int64?

                        public var parameterName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.httpCookie?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.consistentHashLBType != nil {
                                map["ConsistentHashLBType"] = self.consistentHashLBType!
                            }
                            if self.httpCookie != nil {
                                map["HttpCookie"] = self.httpCookie?.toMap()
                            }
                            if self.minimumRingSize != nil {
                                map["MinimumRingSize"] = self.minimumRingSize!
                            }
                            if self.parameterName != nil {
                                map["ParameterName"] = self.parameterName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ConsistentHashLBType") && dict["ConsistentHashLBType"] != nil {
                                self.consistentHashLBType = dict["ConsistentHashLBType"] as! String
                            }
                            if dict.keys.contains("HttpCookie") && dict["HttpCookie"] != nil {
                                var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie()
                                model.fromMap(dict["HttpCookie"] as! [String: Any])
                                self.httpCookie = model
                            }
                            if dict.keys.contains("MinimumRingSize") && dict["MinimumRingSize"] != nil {
                                self.minimumRingSize = dict["MinimumRingSize"] as! Int64
                            }
                            if dict.keys.contains("ParameterName") && dict["ParameterName"] != nil {
                                self.parameterName = dict["ParameterName"] as! String
                            }
                        }
                    }
                    public var consistentHashLBConfig: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig?

                    public var loadbalancerType: String?

                    public var warmupDuration: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.consistentHashLBConfig?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.consistentHashLBConfig != nil {
                            map["ConsistentHashLBConfig"] = self.consistentHashLBConfig?.toMap()
                        }
                        if self.loadbalancerType != nil {
                            map["LoadbalancerType"] = self.loadbalancerType!
                        }
                        if self.warmupDuration != nil {
                            map["WarmupDuration"] = self.warmupDuration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConsistentHashLBConfig") && dict["ConsistentHashLBConfig"] != nil {
                            var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig()
                            model.fromMap(dict["ConsistentHashLBConfig"] as! [String: Any])
                            self.consistentHashLBConfig = model
                        }
                        if dict.keys.contains("LoadbalancerType") && dict["LoadbalancerType"] != nil {
                            self.loadbalancerType = dict["LoadbalancerType"] as! String
                        }
                        if dict.keys.contains("WarmupDuration") && dict["WarmupDuration"] != nil {
                            self.warmupDuration = dict["WarmupDuration"] as! Int32
                        }
                    }
                }
                public class Tls : Tea.TeaModel {
                    public var caCertContent: String?

                    public var caCertId: String?

                    public var certId: String?

                    public var mode: String?

                    public var sni: String?

                    public var subjectAltNames: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.caCertContent != nil {
                            map["CaCertContent"] = self.caCertContent!
                        }
                        if self.caCertId != nil {
                            map["CaCertId"] = self.caCertId!
                        }
                        if self.certId != nil {
                            map["CertId"] = self.certId!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.sni != nil {
                            map["Sni"] = self.sni!
                        }
                        if self.subjectAltNames != nil {
                            map["SubjectAltNames"] = self.subjectAltNames!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CaCertContent") && dict["CaCertContent"] != nil {
                            self.caCertContent = dict["CaCertContent"] as! String
                        }
                        if dict.keys.contains("CaCertId") && dict["CaCertId"] != nil {
                            self.caCertId = dict["CaCertId"] as! String
                        }
                        if dict.keys.contains("CertId") && dict["CertId"] != nil {
                            self.certId = dict["CertId"] as! String
                        }
                        if dict.keys.contains("Mode") && dict["Mode"] != nil {
                            self.mode = dict["Mode"] as! String
                        }
                        if dict.keys.contains("Sni") && dict["Sni"] != nil {
                            self.sni = dict["Sni"] as! String
                        }
                        if dict.keys.contains("SubjectAltNames") && dict["SubjectAltNames"] != nil {
                            self.subjectAltNames = dict["SubjectAltNames"] as! [String]
                        }
                    }
                }
                public var loadBalancerSettings: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings?

                public var tls: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.Tls?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.loadBalancerSettings?.validate()
                    try self.tls?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.loadBalancerSettings != nil {
                        map["LoadBalancerSettings"] = self.loadBalancerSettings?.toMap()
                    }
                    if self.tls != nil {
                        map["Tls"] = self.tls?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LoadBalancerSettings") && dict["LoadBalancerSettings"] != nil {
                        var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings()
                        model.fromMap(dict["LoadBalancerSettings"] as! [String: Any])
                        self.loadBalancerSettings = model
                    }
                    if dict.keys.contains("Tls") && dict["Tls"] != nil {
                        var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.Tls()
                        model.fromMap(dict["Tls"] as! [String: Any])
                        self.tls = model
                    }
                }
            }
            public class HealthCheckInfo : Tea.TeaModel {
                public var check: Bool?

                public var expectedStatuses: [Int32]?

                public var healthyThreshold: Int32?

                public var httpHost: String?

                public var httpPath: String?

                public var interval: Int32?

                public var protocol_: String?

                public var timeout: Int32?

                public var unhealthyThreshold: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.check != nil {
                        map["Check"] = self.check!
                    }
                    if self.expectedStatuses != nil {
                        map["ExpectedStatuses"] = self.expectedStatuses!
                    }
                    if self.healthyThreshold != nil {
                        map["HealthyThreshold"] = self.healthyThreshold!
                    }
                    if self.httpHost != nil {
                        map["HttpHost"] = self.httpHost!
                    }
                    if self.httpPath != nil {
                        map["HttpPath"] = self.httpPath!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.unhealthyThreshold != nil {
                        map["UnhealthyThreshold"] = self.unhealthyThreshold!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Check") && dict["Check"] != nil {
                        self.check = dict["Check"] as! Bool
                    }
                    if dict.keys.contains("ExpectedStatuses") && dict["ExpectedStatuses"] != nil {
                        self.expectedStatuses = dict["ExpectedStatuses"] as! [Int32]
                    }
                    if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
                        self.healthyThreshold = dict["HealthyThreshold"] as! Int32
                    }
                    if dict.keys.contains("HttpHost") && dict["HttpHost"] != nil {
                        self.httpHost = dict["HttpHost"] as! String
                    }
                    if dict.keys.contains("HttpPath") && dict["HttpPath"] != nil {
                        self.httpPath = dict["HttpPath"] as! String
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                    if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                        self.timeout = dict["Timeout"] as! Int32
                    }
                    if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
                        self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
                    }
                }
            }
            public class Versions : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var gatewayId: Int64?

            public var gatewayTrafficPolicy: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var groupName: String?

            public var healehStatus: String?

            public var healthCheck: Bool?

            public var healthCheckInfo: ListGatewayServiceResponseBody.Data.Result.HealthCheckInfo?

            public var healthStatus: String?

            public var id: Int64?

            public var ips: [String]?

            public var metaInfo: String?

            public var name: String?

            public var namespace: String?

            public var ports: [Int32]?

            public var serviceNameInRegistry: String?

            public var servicePort: Int64?

            public var serviceProtocol: String?

            public var sourceId: Int64?

            public var sourceType: String?

            public var unhealthyEndpoints: [String]?

            public var versions: [ListGatewayServiceResponseBody.Data.Result.Versions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.gatewayTrafficPolicy?.validate()
                try self.healthCheckInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayTrafficPolicy != nil {
                    map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.healehStatus != nil {
                    map["HealehStatus"] = self.healehStatus!
                }
                if self.healthCheck != nil {
                    map["HealthCheck"] = self.healthCheck!
                }
                if self.healthCheckInfo != nil {
                    map["HealthCheckInfo"] = self.healthCheckInfo?.toMap()
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips!
                }
                if self.metaInfo != nil {
                    map["MetaInfo"] = self.metaInfo!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.ports != nil {
                    map["Ports"] = self.ports!
                }
                if self.serviceNameInRegistry != nil {
                    map["ServiceNameInRegistry"] = self.serviceNameInRegistry!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.serviceProtocol != nil {
                    map["ServiceProtocol"] = self.serviceProtocol!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.unhealthyEndpoints != nil {
                    map["UnhealthyEndpoints"] = self.unhealthyEndpoints!
                }
                if self.versions != nil {
                    var tmp : [Any] = []
                    for k in self.versions! {
                        tmp.append(k.toMap())
                    }
                    map["Versions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayTrafficPolicy") && dict["GatewayTrafficPolicy"] != nil {
                    var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy()
                    model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
                    self.gatewayTrafficPolicy = model
                }
                if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HealehStatus") && dict["HealehStatus"] != nil {
                    self.healehStatus = dict["HealehStatus"] as! String
                }
                if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
                    self.healthCheck = dict["HealthCheck"] as! Bool
                }
                if dict.keys.contains("HealthCheckInfo") && dict["HealthCheckInfo"] != nil {
                    var model = ListGatewayServiceResponseBody.Data.Result.HealthCheckInfo()
                    model.fromMap(dict["HealthCheckInfo"] as! [String: Any])
                    self.healthCheckInfo = model
                }
                if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Ips") && dict["Ips"] != nil {
                    self.ips = dict["Ips"] as! [String]
                }
                if dict.keys.contains("MetaInfo") && dict["MetaInfo"] != nil {
                    self.metaInfo = dict["MetaInfo"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Ports") && dict["Ports"] != nil {
                    self.ports = dict["Ports"] as! [Int32]
                }
                if dict.keys.contains("ServiceNameInRegistry") && dict["ServiceNameInRegistry"] != nil {
                    self.serviceNameInRegistry = dict["ServiceNameInRegistry"] as! String
                }
                if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                    self.servicePort = dict["ServicePort"] as! Int64
                }
                if dict.keys.contains("ServiceProtocol") && dict["ServiceProtocol"] != nil {
                    self.serviceProtocol = dict["ServiceProtocol"] as! String
                }
                if dict.keys.contains("SourceId") && dict["SourceId"] != nil {
                    self.sourceId = dict["SourceId"] as! Int64
                }
                if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("UnhealthyEndpoints") && dict["UnhealthyEndpoints"] != nil {
                    self.unhealthyEndpoints = dict["UnhealthyEndpoints"] as! [String]
                }
                if dict.keys.contains("Versions") && dict["Versions"] != nil {
                    var tmp : [ListGatewayServiceResponseBody.Data.Result.Versions] = []
                    for v in dict["Versions"] as! [Any] {
                        var model = ListGatewayServiceResponseBody.Data.Result.Versions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.versions = tmp
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayServiceResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListGatewayServiceResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayServiceResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayServiceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListGatewayServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListGatewayServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class ListGatewaySlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class VServiceList : Tea.TeaModel {
            public var port: String?

            public var protocol_: String?

            public var VServerGroupId: String?

            public var VServerGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                if self.VServerGroupName != nil {
                    map["VServerGroupName"] = self.VServerGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                    self.VServerGroupId = dict["VServerGroupId"] as! String
                }
                if dict.keys.contains("VServerGroupName") && dict["VServerGroupName"] != nil {
                    self.VServerGroupName = dict["VServerGroupName"] as! String
                }
            }
        }
        public var editEnable: Bool?

        public var gatewayId: String?

        public var gatewaySlbMode: String?

        public var gatewaySlbStatus: String?

        public var gmtCreate: String?

        public var httpPort: Int32?

        public var httpsPort: Int32?

        public var httpsVServerGroupId: String?

        public var id: String?

        public var serviceWeight: Int32?

        public var slbId: String?

        public var slbIp: String?

        public var slbPort: String?

        public var slbType: String?

        public var statusDesc: String?

        public var type: String?

        public var VServerGroupId: String?

        public var VServiceList: [ListGatewaySlbResponseBody.Data.VServiceList]?

        public var vsMetaInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.editEnable != nil {
                map["EditEnable"] = self.editEnable!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewaySlbMode != nil {
                map["GatewaySlbMode"] = self.gatewaySlbMode!
            }
            if self.gatewaySlbStatus != nil {
                map["GatewaySlbStatus"] = self.gatewaySlbStatus!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.httpsPort != nil {
                map["HttpsPort"] = self.httpsPort!
            }
            if self.httpsVServerGroupId != nil {
                map["HttpsVServerGroupId"] = self.httpsVServerGroupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.serviceWeight != nil {
                map["ServiceWeight"] = self.serviceWeight!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbIp != nil {
                map["SlbIp"] = self.slbIp!
            }
            if self.slbPort != nil {
                map["SlbPort"] = self.slbPort!
            }
            if self.slbType != nil {
                map["SlbType"] = self.slbType!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.VServerGroupId != nil {
                map["VServerGroupId"] = self.VServerGroupId!
            }
            if self.VServiceList != nil {
                var tmp : [Any] = []
                for k in self.VServiceList! {
                    tmp.append(k.toMap())
                }
                map["VServiceList"] = tmp
            }
            if self.vsMetaInfo != nil {
                map["VsMetaInfo"] = self.vsMetaInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EditEnable") && dict["EditEnable"] != nil {
                self.editEnable = dict["EditEnable"] as! Bool
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! String
            }
            if dict.keys.contains("GatewaySlbMode") && dict["GatewaySlbMode"] != nil {
                self.gatewaySlbMode = dict["GatewaySlbMode"] as! String
            }
            if dict.keys.contains("GatewaySlbStatus") && dict["GatewaySlbStatus"] != nil {
                self.gatewaySlbStatus = dict["GatewaySlbStatus"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("HttpPort") && dict["HttpPort"] != nil {
                self.httpPort = dict["HttpPort"] as! Int32
            }
            if dict.keys.contains("HttpsPort") && dict["HttpsPort"] != nil {
                self.httpsPort = dict["HttpsPort"] as! Int32
            }
            if dict.keys.contains("HttpsVServerGroupId") && dict["HttpsVServerGroupId"] != nil {
                self.httpsVServerGroupId = dict["HttpsVServerGroupId"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ServiceWeight") && dict["ServiceWeight"] != nil {
                self.serviceWeight = dict["ServiceWeight"] as! Int32
            }
            if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbIp") && dict["SlbIp"] != nil {
                self.slbIp = dict["SlbIp"] as! String
            }
            if dict.keys.contains("SlbPort") && dict["SlbPort"] != nil {
                self.slbPort = dict["SlbPort"] as! String
            }
            if dict.keys.contains("SlbType") && dict["SlbType"] != nil {
                self.slbType = dict["SlbType"] as! String
            }
            if dict.keys.contains("StatusDesc") && dict["StatusDesc"] != nil {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                self.VServerGroupId = dict["VServerGroupId"] as! String
            }
            if dict.keys.contains("VServiceList") && dict["VServiceList"] != nil {
                var tmp : [ListGatewaySlbResponseBody.Data.VServiceList] = []
                for v in dict["VServiceList"] as! [Any] {
                    var model = ListGatewaySlbResponseBody.Data.VServiceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServiceList = tmp
            }
            if dict.keys.contains("VsMetaInfo") && dict["VsMetaInfo"] != nil {
                self.vsMetaInfo = dict["VsMetaInfo"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListGatewaySlbResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListGatewaySlbResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListGatewaySlbResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceCountRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var mseVersion: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListInstanceCountResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [Int32]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [Int32]
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListInstanceCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInstanceCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListListenersByConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListListenersByConfigResponseBody : Tea.TeaModel {
    public class Listeners : Tea.TeaModel {
        public var ip: String?

        public var md5: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Md5") && dict["Md5"] != nil {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var listeners: [ListListenersByConfigResponseBody.Listeners]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.listeners != nil {
            var tmp : [Any] = []
            for k in self.listeners! {
                tmp.append(k.toMap())
            }
            map["Listeners"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Listeners") && dict["Listeners"] != nil {
            var tmp : [ListListenersByConfigResponseBody.Listeners] = []
            for v in dict["Listeners"] as! [Any] {
                var model = ListListenersByConfigResponseBody.Listeners()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.listeners = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListListenersByConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListListenersByConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListListenersByConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListListenersByIpRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var ip: String?

    public var namespaceId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListListenersByIpResponseBody : Tea.TeaModel {
    public class Listeners : Tea.TeaModel {
        public var dataId: String?

        public var group: String?

        public var md5: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataId") && dict["DataId"] != nil {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Group") && dict["Group"] != nil {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Md5") && dict["Md5"] != nil {
                self.md5 = dict["Md5"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var listeners: [ListListenersByIpResponseBody.Listeners]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.listeners != nil {
            var tmp : [Any] = []
            for k in self.listeners! {
                tmp.append(k.toMap())
            }
            map["Listeners"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Listeners") && dict["Listeners"] != nil {
            var tmp : [ListListenersByIpResponseBody.Listeners] = []
            for v in dict["Listeners"] as! [Any] {
                var model = ListListenersByIpResponseBody.Listeners()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.listeners = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListListenersByIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListListenersByIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListListenersByIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMigrationTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var originInstanceName: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.originInstanceName != nil {
            map["OriginInstanceName"] = self.originInstanceName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("OriginInstanceName") && dict["OriginInstanceName"] != nil {
            self.originInstanceName = dict["OriginInstanceName"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListMigrationTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterType: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var originInstanceAddress: String?

        public var originInstanceName: String?

        public var originInstanceNamespace: String?

        public var projectDesc: String?

        public var targetClusterName: String?

        public var targetClusterUrl: String?

        public var targetInstanceId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.originInstanceAddress != nil {
                map["OriginInstanceAddress"] = self.originInstanceAddress!
            }
            if self.originInstanceName != nil {
                map["OriginInstanceName"] = self.originInstanceName!
            }
            if self.originInstanceNamespace != nil {
                map["OriginInstanceNamespace"] = self.originInstanceNamespace!
            }
            if self.projectDesc != nil {
                map["ProjectDesc"] = self.projectDesc!
            }
            if self.targetClusterName != nil {
                map["TargetClusterName"] = self.targetClusterName!
            }
            if self.targetClusterUrl != nil {
                map["TargetClusterUrl"] = self.targetClusterUrl!
            }
            if self.targetInstanceId != nil {
                map["TargetInstanceId"] = self.targetInstanceId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("OriginInstanceAddress") && dict["OriginInstanceAddress"] != nil {
                self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
            }
            if dict.keys.contains("OriginInstanceName") && dict["OriginInstanceName"] != nil {
                self.originInstanceName = dict["OriginInstanceName"] as! String
            }
            if dict.keys.contains("OriginInstanceNamespace") && dict["OriginInstanceNamespace"] != nil {
                self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
            }
            if dict.keys.contains("ProjectDesc") && dict["ProjectDesc"] != nil {
                self.projectDesc = dict["ProjectDesc"] as! String
            }
            if dict.keys.contains("TargetClusterName") && dict["TargetClusterName"] != nil {
                self.targetClusterName = dict["TargetClusterName"] as! String
            }
            if dict.keys.contains("TargetClusterUrl") && dict["TargetClusterUrl"] != nil {
                self.targetClusterUrl = dict["TargetClusterUrl"] as! String
            }
            if dict.keys.contains("TargetInstanceId") && dict["TargetInstanceId"] != nil {
                self.targetInstanceId = dict["TargetInstanceId"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var data: [ListMigrationTaskResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListMigrationTaskResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListMigrationTaskResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListMigrationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMigrationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMigrationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNacosConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class ListNacosConfigsResponseBody : Tea.TeaModel {
    public class Configurations : Tea.TeaModel {
        public var appName: String?

        public var dataId: String?

        public var group: String?

        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DataId") && dict["DataId"] != nil {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Group") && dict["Group"] != nil {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var code: Int32?

    public var configurations: [ListNacosConfigsResponseBody.Configurations]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.configurations != nil {
            var tmp : [Any] = []
            for k in self.configurations! {
                tmp.append(k.toMap())
            }
            map["Configurations"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Configurations") && dict["Configurations"] != nil {
            var tmp : [ListNacosConfigsResponseBody.Configurations] = []
            for v in dict["Configurations"] as! [Any] {
                var model = ListNacosConfigsResponseBody.Configurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configurations = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListNacosConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNacosConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListNacosConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNacosHistoryConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListNacosHistoryConfigsResponseBody : Tea.TeaModel {
    public class HistoryItems : Tea.TeaModel {
        public var appName: String?

        public var dataId: String?

        public var group: String?

        public var id: Int64?

        public var lastModifiedTime: Int64?

        public var opType: String?

        public var srcUser: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lastModifiedTime != nil {
                map["LastModifiedTime"] = self.lastModifiedTime!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            if self.srcUser != nil {
                map["SrcUser"] = self.srcUser!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DataId") && dict["DataId"] != nil {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Group") && dict["Group"] != nil {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("LastModifiedTime") && dict["LastModifiedTime"] != nil {
                self.lastModifiedTime = dict["LastModifiedTime"] as! Int64
            }
            if dict.keys.contains("OpType") && dict["OpType"] != nil {
                self.opType = dict["OpType"] as! String
            }
            if dict.keys.contains("SrcUser") && dict["SrcUser"] != nil {
                self.srcUser = dict["SrcUser"] as! String
            }
        }
    }
    public var errorCode: String?

    public var historyItems: [ListNacosHistoryConfigsResponseBody.HistoryItems]?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.historyItems != nil {
            var tmp : [Any] = []
            for k in self.historyItems! {
                tmp.append(k.toMap())
            }
            map["HistoryItems"] = tmp
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HistoryItems") && dict["HistoryItems"] != nil {
            var tmp : [ListNacosHistoryConfigsResponseBody.HistoryItems] = []
            for v in dict["HistoryItems"] as! [Any] {
                var model = ListNacosHistoryConfigsResponseBody.HistoryItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.historyItems = tmp
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListNacosHistoryConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNacosHistoryConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListNacosHistoryConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNamingTrackRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var endTs: Int64?

    public var group: String?

    public var instanceId: String?

    public var ip: String?

    public var namespaceId: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var requestPars: String?

    public var reverse: Bool?

    public var serviceName: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("Reverse") && dict["Reverse"] != nil {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class ListNamingTrackResponseBody : Tea.TeaModel {
    public class Traces : Tea.TeaModel {
        public var clientIp: String?

        public var group: String?

        public var instanceSize: String?

        public var nodeName: String?

        public var pushTime: String?

        public var pushTimeAll: String?

        public var pushTimeNetwork: String?

        public var serverName: String?

        public var slaTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.instanceSize != nil {
                map["InstanceSize"] = self.instanceSize!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.pushTime != nil {
                map["PushTime"] = self.pushTime!
            }
            if self.pushTimeAll != nil {
                map["PushTimeAll"] = self.pushTimeAll!
            }
            if self.pushTimeNetwork != nil {
                map["PushTimeNetwork"] = self.pushTimeNetwork!
            }
            if self.serverName != nil {
                map["ServerName"] = self.serverName!
            }
            if self.slaTime != nil {
                map["SlaTime"] = self.slaTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientIp") && dict["ClientIp"] != nil {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("Group") && dict["Group"] != nil {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("InstanceSize") && dict["InstanceSize"] != nil {
                self.instanceSize = dict["InstanceSize"] as! String
            }
            if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("PushTime") && dict["PushTime"] != nil {
                self.pushTime = dict["PushTime"] as! String
            }
            if dict.keys.contains("PushTimeAll") && dict["PushTimeAll"] != nil {
                self.pushTimeAll = dict["PushTimeAll"] as! String
            }
            if dict.keys.contains("PushTimeNetwork") && dict["PushTimeNetwork"] != nil {
                self.pushTimeNetwork = dict["PushTimeNetwork"] as! String
            }
            if dict.keys.contains("ServerName") && dict["ServerName"] != nil {
                self.serverName = dict["ServerName"] as! String
            }
            if dict.keys.contains("SlaTime") && dict["SlaTime"] != nil {
                self.slaTime = dict["SlaTime"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var traces: [ListNamingTrackResponseBody.Traces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.traces != nil {
            var tmp : [Any] = []
            for k in self.traces! {
                tmp.append(k.toMap())
            }
            map["Traces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("Traces") && dict["Traces"] != nil {
            var tmp : [ListNamingTrackResponseBody.Traces] = []
            for v in dict["Traces"] as! [Any] {
                var model = ListNamingTrackResponseBody.Traces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traces = tmp
        }
    }
}

public class ListNamingTrackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNamingTrackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListNamingTrackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSSLCertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certName: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertName") && dict["CertName"] != nil {
            self.certName = dict["CertName"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class ListSSLCertResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var afterDate: String?

        public var algorithm: String?

        public var beforeDate: String?

        public var certIdentifier: String?

        public var certName: String?

        public var commonName: String?

        public var gmtAfter: String?

        public var gmtBefore: String?

        public var issuer: String?

        public var sans: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.afterDate != nil {
                map["AfterDate"] = self.afterDate!
            }
            if self.algorithm != nil {
                map["Algorithm"] = self.algorithm!
            }
            if self.beforeDate != nil {
                map["BeforeDate"] = self.beforeDate!
            }
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.commonName != nil {
                map["CommonName"] = self.commonName!
            }
            if self.gmtAfter != nil {
                map["GmtAfter"] = self.gmtAfter!
            }
            if self.gmtBefore != nil {
                map["GmtBefore"] = self.gmtBefore!
            }
            if self.issuer != nil {
                map["Issuer"] = self.issuer!
            }
            if self.sans != nil {
                map["Sans"] = self.sans!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AfterDate") && dict["AfterDate"] != nil {
                self.afterDate = dict["AfterDate"] as! String
            }
            if dict.keys.contains("Algorithm") && dict["Algorithm"] != nil {
                self.algorithm = dict["Algorithm"] as! String
            }
            if dict.keys.contains("BeforeDate") && dict["BeforeDate"] != nil {
                self.beforeDate = dict["BeforeDate"] as! String
            }
            if dict.keys.contains("CertIdentifier") && dict["CertIdentifier"] != nil {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("CertName") && dict["CertName"] != nil {
                self.certName = dict["CertName"] as! String
            }
            if dict.keys.contains("CommonName") && dict["CommonName"] != nil {
                self.commonName = dict["CommonName"] as! String
            }
            if dict.keys.contains("GmtAfter") && dict["GmtAfter"] != nil {
                self.gmtAfter = dict["GmtAfter"] as! String
            }
            if dict.keys.contains("GmtBefore") && dict["GmtBefore"] != nil {
                self.gmtBefore = dict["GmtBefore"] as! String
            }
            if dict.keys.contains("Issuer") && dict["Issuer"] != nil {
                self.issuer = dict["Issuer"] as! String
            }
            if dict.keys.contains("Sans") && dict["Sans"] != nil {
                self.sans = dict["Sans"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSSLCertResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListSSLCertResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListSSLCertResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSSLCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSSLCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSSLCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSecurityGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class ListSecurityGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var securityGroupId: String?

        public var securityGroupName: String?

        public var securityGroupType: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupName != nil {
                map["SecurityGroupName"] = self.securityGroupName!
            }
            if self.securityGroupType != nil {
                map["SecurityGroupType"] = self.securityGroupType!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
                self.securityGroupName = dict["SecurityGroupName"] as! String
            }
            if dict.keys.contains("SecurityGroupType") && dict["SecurityGroupType"] != nil {
                self.securityGroupType = dict["SecurityGroupType"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSecurityGroupResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListSecurityGroupResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListSecurityGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSecurityGroupRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class ListSecurityGroupRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var authCidrs: [String]?

        public var description_: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: String?

        public var ipProtocol: String?

        public var portRange: String?

        public var securityGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authCidrs != nil {
                map["AuthCidrs"] = self.authCidrs!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthCidrs") && dict["AuthCidrs"] != nil {
                self.authCidrs = dict["AuthCidrs"] as! [String]
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSecurityGroupRuleResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListSecurityGroupRuleResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListSecurityGroupRuleResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class ListServiceSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class IngressOptions : Tea.TeaModel {
            public var enableIngress: Bool?

            public var enableStatus: Bool?

            public var ingressClass: String?

            public var watchNamespace: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableIngress != nil {
                    map["EnableIngress"] = self.enableIngress!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.ingressClass != nil {
                    map["IngressClass"] = self.ingressClass!
                }
                if self.watchNamespace != nil {
                    map["WatchNamespace"] = self.watchNamespace!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnableIngress") && dict["EnableIngress"] != nil {
                    self.enableIngress = dict["EnableIngress"] as! Bool
                }
                if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                    self.enableStatus = dict["EnableStatus"] as! Bool
                }
                if dict.keys.contains("IngressClass") && dict["IngressClass"] != nil {
                    self.ingressClass = dict["IngressClass"] as! String
                }
                if dict.keys.contains("WatchNamespace") && dict["WatchNamespace"] != nil {
                    self.watchNamespace = dict["WatchNamespace"] as! String
                }
            }
        }
        public var address: String?

        public var bindingWithGateway: Int32?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupList: [String]?

        public var id: Int64?

        public var ingressOptions: ListServiceSourceResponseBody.Data.IngressOptions?

        public var name: String?

        public var pathList: [String]?

        public var source: String?

        public var sourceUniqueId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ingressOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.bindingWithGateway != nil {
                map["BindingWithGateway"] = self.bindingWithGateway!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.groupList != nil {
                map["GroupList"] = self.groupList!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ingressOptions != nil {
                map["IngressOptions"] = self.ingressOptions?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pathList != nil {
                map["PathList"] = self.pathList!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.sourceUniqueId != nil {
                map["SourceUniqueId"] = self.sourceUniqueId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("BindingWithGateway") && dict["BindingWithGateway"] != nil {
                self.bindingWithGateway = dict["BindingWithGateway"] as! Int32
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GroupList") && dict["GroupList"] != nil {
                self.groupList = dict["GroupList"] as! [String]
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IngressOptions") && dict["IngressOptions"] != nil {
                var model = ListServiceSourceResponseBody.Data.IngressOptions()
                model.fromMap(dict["IngressOptions"] as! [String: Any])
                self.ingressOptions = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PathList") && dict["PathList"] != nil {
                self.pathList = dict["PathList"] as! [String]
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("SourceUniqueId") && dict["SourceUniqueId"] != nil {
                self.sourceUniqueId = dict["SourceUniqueId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListServiceSourceResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListServiceSourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListServiceSourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var nextToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") && dict["TagResource"] != nil {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var errorCode: String?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagResources") && dict["TagResources"] != nil {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListZkTrackRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var endTs: Int64?

    public var instanceId: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var path: String?

    public var requestPars: String?

    public var reverse: Bool?

    public var sessionId: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EndTs") && dict["EndTs"] != nil {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("Reverse") && dict["Reverse"] != nil {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("SessionId") && dict["SessionId"] != nil {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class ListZkTrackResponseBody : Tea.TeaModel {
    public class Traces : Tea.TeaModel {
        public var acl: String?

        public var dataType: String?

        public var eventType: String?

        public var finished: Bool?

        public var logDate: String?

        public var multiSize: Int64?

        public var opType: String?

        public var path: String?

        public var result: String?

        public var sessionId: String?

        public var timestamp: String?

        public var traceType: String?

        public var ttl: Int64?

        public var watch: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acl != nil {
                map["Acl"] = self.acl!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.finished != nil {
                map["Finished"] = self.finished!
            }
            if self.logDate != nil {
                map["LogDate"] = self.logDate!
            }
            if self.multiSize != nil {
                map["MultiSize"] = self.multiSize!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.traceType != nil {
                map["TraceType"] = self.traceType!
            }
            if self.ttl != nil {
                map["Ttl"] = self.ttl!
            }
            if self.watch != nil {
                map["Watch"] = self.watch!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Acl") && dict["Acl"] != nil {
                self.acl = dict["Acl"] as! String
            }
            if dict.keys.contains("DataType") && dict["DataType"] != nil {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("EventType") && dict["EventType"] != nil {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("Finished") && dict["Finished"] != nil {
                self.finished = dict["Finished"] as! Bool
            }
            if dict.keys.contains("LogDate") && dict["LogDate"] != nil {
                self.logDate = dict["LogDate"] as! String
            }
            if dict.keys.contains("MultiSize") && dict["MultiSize"] != nil {
                self.multiSize = dict["MultiSize"] as! Int64
            }
            if dict.keys.contains("OpType") && dict["OpType"] != nil {
                self.opType = dict["OpType"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("SessionId") && dict["SessionId"] != nil {
                self.sessionId = dict["SessionId"] as! String
            }
            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                self.timestamp = dict["Timestamp"] as! String
            }
            if dict.keys.contains("TraceType") && dict["TraceType"] != nil {
                self.traceType = dict["TraceType"] as! String
            }
            if dict.keys.contains("Ttl") && dict["Ttl"] != nil {
                self.ttl = dict["Ttl"] as! Int64
            }
            if dict.keys.contains("Watch") && dict["Watch"] != nil {
                self.watch = dict["Watch"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var traces: [ListZkTrackResponseBody.Traces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.traces != nil {
            var tmp : [Any] = []
            for k in self.traces! {
                tmp.append(k.toMap())
            }
            map["Traces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("Traces") && dict["Traces"] != nil {
            var tmp : [ListZkTrackResponseBody.Traces] = []
            for v in dict["Traces"] as! [Any] {
                var model = ListZkTrackResponseBody.Traces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traces = tmp
        }
    }
}

public class ListZkTrackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListZkTrackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListZkTrackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListZnodeChildrenRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
    }
}

public class ListZnodeChildrenResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") && dict["Dir"] != nil {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: [ListZnodeChildrenResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListZnodeChildrenResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListZnodeChildrenResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListZnodeChildrenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListZnodeChildrenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListZnodeChildrenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyGovernanceKubernetesClusterRequest : Tea.TeaModel {
    public class NamespaceInfos : Tea.TeaModel {
        public var mseNamespace: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mseNamespace != nil {
                map["MseNamespace"] = self.mseNamespace!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MseNamespace") && dict["MseNamespace"] != nil {
                self.mseNamespace = dict["MseNamespace"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var clusterId: String?

    public var namespaceInfos: [ModifyGovernanceKubernetesClusterRequest.NamespaceInfos]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespaceInfos != nil {
            var tmp : [Any] = []
            for k in self.namespaceInfos! {
                tmp.append(k.toMap())
            }
            map["NamespaceInfos"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("NamespaceInfos") && dict["NamespaceInfos"] != nil {
            var tmp : [ModifyGovernanceKubernetesClusterRequest.NamespaceInfos] = []
            for v in dict["NamespaceInfos"] as! [Any] {
                var model = ModifyGovernanceKubernetesClusterRequest.NamespaceInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.namespaceInfos = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyGovernanceKubernetesClusterShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var namespaceInfosShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespaceInfosShrink != nil {
            map["NamespaceInfos"] = self.namespaceInfosShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("NamespaceInfos") && dict["NamespaceInfos"] != nil {
            self.namespaceInfosShrink = dict["NamespaceInfos"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyGovernanceKubernetesClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyGovernanceKubernetesClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGovernanceKubernetesClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyGovernanceKubernetesClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLosslessRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aligned: Bool?

    public var appId: String?

    public var appName: String?

    public var delayTime: Int32?

    public var enable: Bool?

    public var funcType: Int32?

    public var lossLessDetail: Bool?

    public var namespace: String?

    public var notice: Bool?

    public var regionId: String?

    public var related: Bool?

    public var warmupTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aligned != nil {
            map["Aligned"] = self.aligned!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.delayTime != nil {
            map["DelayTime"] = self.delayTime!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.funcType != nil {
            map["FuncType"] = self.funcType!
        }
        if self.lossLessDetail != nil {
            map["LossLessDetail"] = self.lossLessDetail!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.notice != nil {
            map["Notice"] = self.notice!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.related != nil {
            map["Related"] = self.related!
        }
        if self.warmupTime != nil {
            map["WarmupTime"] = self.warmupTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Aligned") && dict["Aligned"] != nil {
            self.aligned = dict["Aligned"] as! Bool
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DelayTime") && dict["DelayTime"] != nil {
            self.delayTime = dict["DelayTime"] as! Int32
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("FuncType") && dict["FuncType"] != nil {
            self.funcType = dict["FuncType"] as! Int32
        }
        if dict.keys.contains("LossLessDetail") && dict["LossLessDetail"] != nil {
            self.lossLessDetail = dict["LossLessDetail"] as! Bool
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Notice") && dict["Notice"] != nil {
            self.notice = dict["Notice"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Related") && dict["Related"] != nil {
            self.related = dict["Related"] as! Bool
        }
        if dict.keys.contains("WarmupTime") && dict["WarmupTime"] != nil {
            self.warmupTime = dict["WarmupTime"] as! Int32
        }
    }
}

public class ModifyLosslessRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyLosslessRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLosslessRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyLosslessRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OfflineGatewayRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
            self.routeId = dict["RouteId"] as! String
        }
    }
}

public class OfflineGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class OfflineGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OfflineGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OfflineGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OrderClusterHealthCheckRiskNoticeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var mute: Bool?

    public var noticeType: String?

    public var regionId: String?

    public var requestPars: String?

    public var riskCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mute != nil {
            map["Mute"] = self.mute!
        }
        if self.noticeType != nil {
            map["NoticeType"] = self.noticeType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.riskCode != nil {
            map["RiskCode"] = self.riskCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Mute") && dict["Mute"] != nil {
            self.mute = dict["Mute"] as! Bool
        }
        if dict.keys.contains("NoticeType") && dict["NoticeType"] != nil {
            self.noticeType = dict["NoticeType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("RiskCode") && dict["RiskCode"] != nil {
            self.riskCode = dict["RiskCode"] as! String
        }
    }
}

public class OrderClusterHealthCheckRiskNoticeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class OrderClusterHealthCheckRiskNoticeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OrderClusterHealthCheckRiskNoticeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OrderClusterHealthCheckRiskNoticeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PullServicesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var namespace: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class PullServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Services : Tea.TeaModel {
            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var sourceId: String?

            public var sourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("SourceId") && dict["SourceId"] != nil {
                    self.sourceId = dict["SourceId"] as! String
                }
                if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                    self.sourceType = dict["SourceType"] as! String
                }
            }
        }
        public var groupName: String?

        public var namespace: String?

        public var namespaceShowName: String?

        public var services: [PullServicesResponseBody.Data.Services]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.services != nil {
                var tmp : [Any] = []
                for k in self.services! {
                    tmp.append(k.toMap())
                }
                map["Services"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceShowName") && dict["NamespaceShowName"] != nil {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Services") && dict["Services"] != nil {
                var tmp : [PullServicesResponseBody.Data.Services] = []
                for v in dict["Services"] as! [Any] {
                    var model = PullServicesResponseBody.Data.Services()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.services = tmp
            }
        }
    }
    public var code: Int32?

    public var data: [PullServicesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [PullServicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = PullServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PullServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PullServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PullServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutClusterHealthCheckTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class PutClusterHealthCheckTaskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutClusterHealthCheckTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutClusterHealthCheckTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PutClusterHealthCheckTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAllSwimmingLaneRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class QueryAllSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EntryRules : Tea.TeaModel {
            public class RestItems : Tea.TeaModel {
                public var cond: String?

                public var datum: String?

                public var divisor: Int32?

                public var name: String?

                public var nameList: [String]?

                public var operator_: String?

                public var rate: Int32?

                public var remainder: Int32?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cond") && dict["cond"] != nil {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("datum") && dict["datum"] != nil {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("divisor") && dict["divisor"] != nil {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("nameList") && dict["nameList"] != nil {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("operator") && dict["operator"] != nil {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("rate") && dict["rate"] != nil {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("remainder") && dict["remainder"] != nil {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("type") && dict["type"] != nil {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("value") && dict["value"] != nil {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var condition: String?

            public var path: String?

            public var paths: [String]?

            public var restItems: [QueryAllSwimmingLaneResponseBody.Data.EntryRules.RestItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.paths != nil {
                    map["paths"] = self.paths!
                }
                if self.restItems != nil {
                    var tmp : [Any] = []
                    for k in self.restItems! {
                        tmp.append(k.toMap())
                    }
                    map["restItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") && dict["condition"] != nil {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("path") && dict["path"] != nil {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("paths") && dict["paths"] != nil {
                    self.paths = dict["paths"] as! [String]
                }
                if dict.keys.contains("restItems") && dict["restItems"] != nil {
                    var tmp : [QueryAllSwimmingLaneResponseBody.Data.EntryRules.RestItems] = []
                    for v in dict["restItems"] as! [Any] {
                        var model = QueryAllSwimmingLaneResponseBody.Data.EntryRules.RestItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restItems = tmp
                }
            }
        }
        public var entryRules: [QueryAllSwimmingLaneResponseBody.Data.EntryRules]?

        public var groupId: String?

        public var id: Int64?

        public var messageQueueFilterSide: String?

        public var messageQueueGrayEnable: Bool?

        public var name: String?

        public var namespace: String?

        public var recordCanaryDetail: Bool?

        public var regionId: String?

        public var tag: String?

        public var userId: String?

        public var enableRules: Bool?

        public var gmtCreate: String?

        public var gmtModified: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entryRules != nil {
                var tmp : [Any] = []
                for k in self.entryRules! {
                    tmp.append(k.toMap())
                }
                map["EntryRules"] = tmp
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.messageQueueFilterSide != nil {
                map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
            }
            if self.messageQueueGrayEnable != nil {
                map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.recordCanaryDetail != nil {
                map["RecordCanaryDetail"] = self.recordCanaryDetail!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.enableRules != nil {
                map["enableRules"] = self.enableRules!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EntryRules") && dict["EntryRules"] != nil {
                var tmp : [QueryAllSwimmingLaneResponseBody.Data.EntryRules] = []
                for v in dict["EntryRules"] as! [Any] {
                    var model = QueryAllSwimmingLaneResponseBody.Data.EntryRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entryRules = tmp
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MessageQueueFilterSide") && dict["MessageQueueFilterSide"] != nil {
                self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
            }
            if dict.keys.contains("MessageQueueGrayEnable") && dict["MessageQueueGrayEnable"] != nil {
                self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RecordCanaryDetail") && dict["RecordCanaryDetail"] != nil {
                self.recordCanaryDetail = dict["RecordCanaryDetail"] as! Bool
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("enableRules") && dict["enableRules"] != nil {
                self.enableRules = dict["enableRules"] as! Bool
            }
            if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") && dict["gmtModified"] != nil {
                self.gmtModified = dict["gmtModified"] as! String
            }
        }
    }
    public var data: [QueryAllSwimmingLaneResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QueryAllSwimmingLaneResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryAllSwimmingLaneResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAllSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAllSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAllSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAllSwimmingLaneGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class QueryAllSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appIds: String?

        public var entryApp: String?

        public var id: Int64?

        public var messageQueueFilterSide: String?

        public var messageQueueGrayEnable: Bool?

        public var name: String?

        public var namespace: String?

        public var recordCanaryDetail: Bool?

        public var region: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appIds != nil {
                map["AppIds"] = self.appIds!
            }
            if self.entryApp != nil {
                map["EntryApp"] = self.entryApp!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.messageQueueFilterSide != nil {
                map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
            }
            if self.messageQueueGrayEnable != nil {
                map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.recordCanaryDetail != nil {
                map["RecordCanaryDetail"] = self.recordCanaryDetail!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
                self.appIds = dict["AppIds"] as! String
            }
            if dict.keys.contains("EntryApp") && dict["EntryApp"] != nil {
                self.entryApp = dict["EntryApp"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MessageQueueFilterSide") && dict["MessageQueueFilterSide"] != nil {
                self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
            }
            if dict.keys.contains("MessageQueueGrayEnable") && dict["MessageQueueGrayEnable"] != nil {
                self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RecordCanaryDetail") && dict["RecordCanaryDetail"] != nil {
                self.recordCanaryDetail = dict["RecordCanaryDetail"] as! Bool
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [QueryAllSwimmingLaneGroupResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QueryAllSwimmingLaneGroupResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryAllSwimmingLaneGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAllSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAllSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAllSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBusinessLocationsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class QueryBusinessLocationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cnName: String?

        public var description_: String?

        public var districtCnName: String?

        public var districtEnName: String?

        public var districtId: String?

        public var districtOrdering: Int32?

        public var districtShowName: String?

        public var enDescription: String?

        public var enName: String?

        public var name: String?

        public var ordering: Int32?

        public var showName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cnName != nil {
                map["CnName"] = self.cnName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.districtCnName != nil {
                map["DistrictCnName"] = self.districtCnName!
            }
            if self.districtEnName != nil {
                map["DistrictEnName"] = self.districtEnName!
            }
            if self.districtId != nil {
                map["DistrictId"] = self.districtId!
            }
            if self.districtOrdering != nil {
                map["DistrictOrdering"] = self.districtOrdering!
            }
            if self.districtShowName != nil {
                map["DistrictShowName"] = self.districtShowName!
            }
            if self.enDescription != nil {
                map["EnDescription"] = self.enDescription!
            }
            if self.enName != nil {
                map["EnName"] = self.enName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ordering != nil {
                map["Ordering"] = self.ordering!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CnName") && dict["CnName"] != nil {
                self.cnName = dict["CnName"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DistrictCnName") && dict["DistrictCnName"] != nil {
                self.districtCnName = dict["DistrictCnName"] as! String
            }
            if dict.keys.contains("DistrictEnName") && dict["DistrictEnName"] != nil {
                self.districtEnName = dict["DistrictEnName"] as! String
            }
            if dict.keys.contains("DistrictId") && dict["DistrictId"] != nil {
                self.districtId = dict["DistrictId"] as! String
            }
            if dict.keys.contains("DistrictOrdering") && dict["DistrictOrdering"] != nil {
                self.districtOrdering = dict["DistrictOrdering"] as! Int32
            }
            if dict.keys.contains("DistrictShowName") && dict["DistrictShowName"] != nil {
                self.districtShowName = dict["DistrictShowName"] as! String
            }
            if dict.keys.contains("EnDescription") && dict["EnDescription"] != nil {
                self.enDescription = dict["EnDescription"] as! String
            }
            if dict.keys.contains("EnName") && dict["EnName"] != nil {
                self.enName = dict["EnName"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Ordering") && dict["Ordering"] != nil {
                self.ordering = dict["Ordering"] as! Int32
            }
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [QueryBusinessLocationsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QueryBusinessLocationsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryBusinessLocationsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class QueryBusinessLocationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBusinessLocationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryBusinessLocationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aclSwitch: Bool?

    public var instanceId: String?

    public var orderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aclSwitch != nil {
            map["AclSwitch"] = self.aclSwitch!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AclSwitch") && dict["AclSwitch"] != nil {
            self.aclSwitch = dict["AclSwitch"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
    }
}

public class QueryClusterDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class InstanceModels : Tea.TeaModel {
            public var creationTimestamp: String?

            public var healthStatus: String?

            public var internetIp: String?

            public var ip: String?

            public var podName: String?

            public var role: String?

            public var singleTunnelVip: String?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTimestamp != nil {
                    map["CreationTimestamp"] = self.creationTimestamp!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.podName != nil {
                    map["PodName"] = self.podName!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.singleTunnelVip != nil {
                    map["SingleTunnelVip"] = self.singleTunnelVip!
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTimestamp") && dict["CreationTimestamp"] != nil {
                    self.creationTimestamp = dict["CreationTimestamp"] as! String
                }
                if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("PodName") && dict["PodName"] != nil {
                    self.podName = dict["PodName"] as! String
                }
                if dict.keys.contains("Role") && dict["Role"] != nil {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("SingleTunnelVip") && dict["SingleTunnelVip"] != nil {
                    self.singleTunnelVip = dict["SingleTunnelVip"] as! String
                }
                if dict.keys.contains("Zone") && dict["Zone"] != nil {
                    self.zone = dict["Zone"] as! String
                }
            }
        }
        public var aclEntryList: String?

        public var aclId: String?

        public var appVersion: String?

        public var chargeType: String?

        public var clusterAliasName: String?

        public var clusterName: String?

        public var clusterSpecification: String?

        public var clusterType: String?

        public var clusterVersion: String?

        public var connectionType: String?

        public var cpu: Int32?

        public var createTime: String?

        public var diskCapacity: Int64?

        public var diskType: String?

        public var healthStatus: String?

        public var initCostTime: Int64?

        public var initStatus: String?

        public var instanceCount: Int32?

        public var instanceId: String?

        public var instanceModels: [QueryClusterDetailResponseBody.Data.InstanceModels]?

        public var internetAddress: String?

        public var internetDomain: String?

        public var internetPort: String?

        public var intranetAddress: String?

        public var intranetDomain: String?

        public var intranetPort: String?

        public var memoryCapacity: Int64?

        public var mseVersion: String?

        public var netType: String?

        public var orderClusterVersion: String?

        public var payInfo: String?

        public var pubNetworkFlow: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var tags: [String: Any]?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclEntryList != nil {
                map["AclEntryList"] = self.aclEntryList!
            }
            if self.aclId != nil {
                map["AclId"] = self.aclId!
            }
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterAliasName != nil {
                map["ClusterAliasName"] = self.clusterAliasName!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterSpecification != nil {
                map["ClusterSpecification"] = self.clusterSpecification!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.clusterVersion != nil {
                map["ClusterVersion"] = self.clusterVersion!
            }
            if self.connectionType != nil {
                map["ConnectionType"] = self.connectionType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.initCostTime != nil {
                map["InitCostTime"] = self.initCostTime!
            }
            if self.initStatus != nil {
                map["InitStatus"] = self.initStatus!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceModels != nil {
                var tmp : [Any] = []
                for k in self.instanceModels! {
                    tmp.append(k.toMap())
                }
                map["InstanceModels"] = tmp
            }
            if self.internetAddress != nil {
                map["InternetAddress"] = self.internetAddress!
            }
            if self.internetDomain != nil {
                map["InternetDomain"] = self.internetDomain!
            }
            if self.internetPort != nil {
                map["InternetPort"] = self.internetPort!
            }
            if self.intranetAddress != nil {
                map["IntranetAddress"] = self.intranetAddress!
            }
            if self.intranetDomain != nil {
                map["IntranetDomain"] = self.intranetDomain!
            }
            if self.intranetPort != nil {
                map["IntranetPort"] = self.intranetPort!
            }
            if self.memoryCapacity != nil {
                map["MemoryCapacity"] = self.memoryCapacity!
            }
            if self.mseVersion != nil {
                map["MseVersion"] = self.mseVersion!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.orderClusterVersion != nil {
                map["OrderClusterVersion"] = self.orderClusterVersion!
            }
            if self.payInfo != nil {
                map["PayInfo"] = self.payInfo!
            }
            if self.pubNetworkFlow != nil {
                map["PubNetworkFlow"] = self.pubNetworkFlow!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclEntryList") && dict["AclEntryList"] != nil {
                self.aclEntryList = dict["AclEntryList"] as! String
            }
            if dict.keys.contains("AclId") && dict["AclId"] != nil {
                self.aclId = dict["AclId"] as! String
            }
            if dict.keys.contains("AppVersion") && dict["AppVersion"] != nil {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterAliasName") && dict["ClusterAliasName"] != nil {
                self.clusterAliasName = dict["ClusterAliasName"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterSpecification") && dict["ClusterSpecification"] != nil {
                self.clusterSpecification = dict["ClusterSpecification"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("ClusterVersion") && dict["ClusterVersion"] != nil {
                self.clusterVersion = dict["ClusterVersion"] as! String
            }
            if dict.keys.contains("ConnectionType") && dict["ConnectionType"] != nil {
                self.connectionType = dict["ConnectionType"] as! String
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DiskCapacity") && dict["DiskCapacity"] != nil {
                self.diskCapacity = dict["DiskCapacity"] as! Int64
            }
            if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InitCostTime") && dict["InitCostTime"] != nil {
                self.initCostTime = dict["InitCostTime"] as! Int64
            }
            if dict.keys.contains("InitStatus") && dict["InitStatus"] != nil {
                self.initStatus = dict["InitStatus"] as! String
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceModels") && dict["InstanceModels"] != nil {
                var tmp : [QueryClusterDetailResponseBody.Data.InstanceModels] = []
                for v in dict["InstanceModels"] as! [Any] {
                    var model = QueryClusterDetailResponseBody.Data.InstanceModels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceModels = tmp
            }
            if dict.keys.contains("InternetAddress") && dict["InternetAddress"] != nil {
                self.internetAddress = dict["InternetAddress"] as! String
            }
            if dict.keys.contains("InternetDomain") && dict["InternetDomain"] != nil {
                self.internetDomain = dict["InternetDomain"] as! String
            }
            if dict.keys.contains("InternetPort") && dict["InternetPort"] != nil {
                self.internetPort = dict["InternetPort"] as! String
            }
            if dict.keys.contains("IntranetAddress") && dict["IntranetAddress"] != nil {
                self.intranetAddress = dict["IntranetAddress"] as! String
            }
            if dict.keys.contains("IntranetDomain") && dict["IntranetDomain"] != nil {
                self.intranetDomain = dict["IntranetDomain"] as! String
            }
            if dict.keys.contains("IntranetPort") && dict["IntranetPort"] != nil {
                self.intranetPort = dict["IntranetPort"] as! String
            }
            if dict.keys.contains("MemoryCapacity") && dict["MemoryCapacity"] != nil {
                self.memoryCapacity = dict["MemoryCapacity"] as! Int64
            }
            if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
                self.mseVersion = dict["MseVersion"] as! String
            }
            if dict.keys.contains("NetType") && dict["NetType"] != nil {
                self.netType = dict["NetType"] as! String
            }
            if dict.keys.contains("OrderClusterVersion") && dict["OrderClusterVersion"] != nil {
                self.orderClusterVersion = dict["OrderClusterVersion"] as! String
            }
            if dict.keys.contains("PayInfo") && dict["PayInfo"] != nil {
                self.payInfo = dict["PayInfo"] as! String
            }
            if dict.keys.contains("PubNetworkFlow") && dict["PubNetworkFlow"] != nil {
                self.pubNetworkFlow = dict["PubNetworkFlow"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! [String: Any]
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var data: QueryClusterDetailResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryClusterDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryClusterDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterDiskSpecificationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
    }
}

public class QueryClusterDiskSpecificationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var max: Int32?

        public var min: Int32?

        public var step: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.max != nil {
                map["Max"] = self.max!
            }
            if self.min != nil {
                map["Min"] = self.min!
            }
            if self.step != nil {
                map["Step"] = self.step!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Max") && dict["Max"] != nil {
                self.max = dict["Max"] as! Int32
            }
            if dict.keys.contains("Min") && dict["Min"] != nil {
                self.min = dict["Min"] as! Int32
            }
            if dict.keys.contains("Step") && dict["Step"] != nil {
                self.step = dict["Step"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: QueryClusterDiskSpecificationResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryClusterDiskSpecificationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterDiskSpecificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterDiskSpecificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryClusterDiskSpecificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterInfoRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aclSwitch: Bool?

    public var clusterId: String?

    public var instanceId: String?

    public var orderId: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aclSwitch != nil {
            map["AclSwitch"] = self.aclSwitch!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AclSwitch") && dict["AclSwitch"] != nil {
            self.aclSwitch = dict["AclSwitch"] as! Bool
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryClusterInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class InstanceModels : Tea.TeaModel {
            public var creationTimestamp: String?

            public var healthStatus: String?

            public var internetIp: String?

            public var ip: String?

            public var podName: String?

            public var role: String?

            public var singleTunnelVip: String?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTimestamp != nil {
                    map["CreationTimestamp"] = self.creationTimestamp!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.podName != nil {
                    map["PodName"] = self.podName!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.singleTunnelVip != nil {
                    map["SingleTunnelVip"] = self.singleTunnelVip!
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTimestamp") && dict["CreationTimestamp"] != nil {
                    self.creationTimestamp = dict["CreationTimestamp"] as! String
                }
                if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("PodName") && dict["PodName"] != nil {
                    self.podName = dict["PodName"] as! String
                }
                if dict.keys.contains("Role") && dict["Role"] != nil {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("SingleTunnelVip") && dict["SingleTunnelVip"] != nil {
                    self.singleTunnelVip = dict["SingleTunnelVip"] as! String
                }
                if dict.keys.contains("Zone") && dict["Zone"] != nil {
                    self.zone = dict["Zone"] as! String
                }
            }
        }
        public class MaintenancePeriod : Tea.TeaModel {
            public var endTime: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var aclEntryList: String?

        public var aclId: String?

        public var appVersion: String?

        public var canUpdate: Bool?

        public var chargeType: String?

        public var clusterAliasName: String?

        public var clusterName: String?

        public var clusterSpecification: String?

        public var clusterType: String?

        public var clusterVersion: String?

        public var connectionType: String?

        public var cpu: Int32?

        public var createTime: String?

        public var diskCapacity: Int64?

        public var diskType: String?

        public var eipInstanceId: String?

        public var endDate: String?

        public var expectZones: [String]?

        public var healthStatus: String?

        public var initCostTime: Int64?

        public var initStatus: String?

        public var instanceCount: Int32?

        public var instanceId: String?

        public var instanceModels: [QueryClusterInfoResponseBody.Data.InstanceModels]?

        public var internetAddress: String?

        public var internetDomain: String?

        public var internetPort: String?

        public var intranetAddress: String?

        public var intranetDomain: String?

        public var intranetPort: String?

        public var maintenancePeriod: QueryClusterInfoResponseBody.Data.MaintenancePeriod?

        public var memoryCapacity: Int64?

        public var mseVersion: String?

        public var netType: String?

        public var payInfo: String?

        public var pubNetworkFlow: String?

        public var regionId: String?

        public var securityGroupId: String?

        public var securityGroupType: String?

        public var tags: [String: Any]?

        public var vSwitchId: String?

        public var versionCode: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.maintenancePeriod?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclEntryList != nil {
                map["AclEntryList"] = self.aclEntryList!
            }
            if self.aclId != nil {
                map["AclId"] = self.aclId!
            }
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.canUpdate != nil {
                map["CanUpdate"] = self.canUpdate!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterAliasName != nil {
                map["ClusterAliasName"] = self.clusterAliasName!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterSpecification != nil {
                map["ClusterSpecification"] = self.clusterSpecification!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.clusterVersion != nil {
                map["ClusterVersion"] = self.clusterVersion!
            }
            if self.connectionType != nil {
                map["ConnectionType"] = self.connectionType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.eipInstanceId != nil {
                map["EipInstanceId"] = self.eipInstanceId!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.expectZones != nil {
                map["ExpectZones"] = self.expectZones!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.initCostTime != nil {
                map["InitCostTime"] = self.initCostTime!
            }
            if self.initStatus != nil {
                map["InitStatus"] = self.initStatus!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceModels != nil {
                var tmp : [Any] = []
                for k in self.instanceModels! {
                    tmp.append(k.toMap())
                }
                map["InstanceModels"] = tmp
            }
            if self.internetAddress != nil {
                map["InternetAddress"] = self.internetAddress!
            }
            if self.internetDomain != nil {
                map["InternetDomain"] = self.internetDomain!
            }
            if self.internetPort != nil {
                map["InternetPort"] = self.internetPort!
            }
            if self.intranetAddress != nil {
                map["IntranetAddress"] = self.intranetAddress!
            }
            if self.intranetDomain != nil {
                map["IntranetDomain"] = self.intranetDomain!
            }
            if self.intranetPort != nil {
                map["IntranetPort"] = self.intranetPort!
            }
            if self.maintenancePeriod != nil {
                map["MaintenancePeriod"] = self.maintenancePeriod?.toMap()
            }
            if self.memoryCapacity != nil {
                map["MemoryCapacity"] = self.memoryCapacity!
            }
            if self.mseVersion != nil {
                map["MseVersion"] = self.mseVersion!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.payInfo != nil {
                map["PayInfo"] = self.payInfo!
            }
            if self.pubNetworkFlow != nil {
                map["PubNetworkFlow"] = self.pubNetworkFlow!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupType != nil {
                map["SecurityGroupType"] = self.securityGroupType!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclEntryList") && dict["AclEntryList"] != nil {
                self.aclEntryList = dict["AclEntryList"] as! String
            }
            if dict.keys.contains("AclId") && dict["AclId"] != nil {
                self.aclId = dict["AclId"] as! String
            }
            if dict.keys.contains("AppVersion") && dict["AppVersion"] != nil {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("CanUpdate") && dict["CanUpdate"] != nil {
                self.canUpdate = dict["CanUpdate"] as! Bool
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterAliasName") && dict["ClusterAliasName"] != nil {
                self.clusterAliasName = dict["ClusterAliasName"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterSpecification") && dict["ClusterSpecification"] != nil {
                self.clusterSpecification = dict["ClusterSpecification"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("ClusterVersion") && dict["ClusterVersion"] != nil {
                self.clusterVersion = dict["ClusterVersion"] as! String
            }
            if dict.keys.contains("ConnectionType") && dict["ConnectionType"] != nil {
                self.connectionType = dict["ConnectionType"] as! String
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DiskCapacity") && dict["DiskCapacity"] != nil {
                self.diskCapacity = dict["DiskCapacity"] as! Int64
            }
            if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("EipInstanceId") && dict["EipInstanceId"] != nil {
                self.eipInstanceId = dict["EipInstanceId"] as! String
            }
            if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("ExpectZones") && dict["ExpectZones"] != nil {
                self.expectZones = dict["ExpectZones"] as! [String]
            }
            if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InitCostTime") && dict["InitCostTime"] != nil {
                self.initCostTime = dict["InitCostTime"] as! Int64
            }
            if dict.keys.contains("InitStatus") && dict["InitStatus"] != nil {
                self.initStatus = dict["InitStatus"] as! String
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceModels") && dict["InstanceModels"] != nil {
                var tmp : [QueryClusterInfoResponseBody.Data.InstanceModels] = []
                for v in dict["InstanceModels"] as! [Any] {
                    var model = QueryClusterInfoResponseBody.Data.InstanceModels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceModels = tmp
            }
            if dict.keys.contains("InternetAddress") && dict["InternetAddress"] != nil {
                self.internetAddress = dict["InternetAddress"] as! String
            }
            if dict.keys.contains("InternetDomain") && dict["InternetDomain"] != nil {
                self.internetDomain = dict["InternetDomain"] as! String
            }
            if dict.keys.contains("InternetPort") && dict["InternetPort"] != nil {
                self.internetPort = dict["InternetPort"] as! String
            }
            if dict.keys.contains("IntranetAddress") && dict["IntranetAddress"] != nil {
                self.intranetAddress = dict["IntranetAddress"] as! String
            }
            if dict.keys.contains("IntranetDomain") && dict["IntranetDomain"] != nil {
                self.intranetDomain = dict["IntranetDomain"] as! String
            }
            if dict.keys.contains("IntranetPort") && dict["IntranetPort"] != nil {
                self.intranetPort = dict["IntranetPort"] as! String
            }
            if dict.keys.contains("MaintenancePeriod") && dict["MaintenancePeriod"] != nil {
                var model = QueryClusterInfoResponseBody.Data.MaintenancePeriod()
                model.fromMap(dict["MaintenancePeriod"] as! [String: Any])
                self.maintenancePeriod = model
            }
            if dict.keys.contains("MemoryCapacity") && dict["MemoryCapacity"] != nil {
                self.memoryCapacity = dict["MemoryCapacity"] as! Int64
            }
            if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
                self.mseVersion = dict["MseVersion"] as! String
            }
            if dict.keys.contains("NetType") && dict["NetType"] != nil {
                self.netType = dict["NetType"] as! String
            }
            if dict.keys.contains("PayInfo") && dict["PayInfo"] != nil {
                self.payInfo = dict["PayInfo"] as! String
            }
            if dict.keys.contains("PubNetworkFlow") && dict["PubNetworkFlow"] != nil {
                self.pubNetworkFlow = dict["PubNetworkFlow"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupType") && dict["SecurityGroupType"] != nil {
                self.securityGroupType = dict["SecurityGroupType"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! [String: Any]
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
                self.versionCode = dict["VersionCode"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var data: QueryClusterInfoResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryClusterInfoResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryClusterInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterSpecificationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var connectType: String?

    public var mseVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.connectType != nil {
            map["ConnectType"] = self.connectType!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConnectType") && dict["ConnectType"] != nil {
            self.connectType = dict["ConnectType"] as! String
        }
        if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
            self.mseVersion = dict["MseVersion"] as! String
        }
    }
}

public class QueryClusterSpecificationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterSpecificationName: String?

        public var cpuCapacity: String?

        public var memoryCapacity: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterSpecificationName != nil {
                map["ClusterSpecificationName"] = self.clusterSpecificationName!
            }
            if self.cpuCapacity != nil {
                map["CpuCapacity"] = self.cpuCapacity!
            }
            if self.memoryCapacity != nil {
                map["MemoryCapacity"] = self.memoryCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterSpecificationName") && dict["ClusterSpecificationName"] != nil {
                self.clusterSpecificationName = dict["ClusterSpecificationName"] as! String
            }
            if dict.keys.contains("CpuCapacity") && dict["CpuCapacity"] != nil {
                self.cpuCapacity = dict["CpuCapacity"] as! String
            }
            if dict.keys.contains("MemoryCapacity") && dict["MemoryCapacity"] != nil {
                self.memoryCapacity = dict["MemoryCapacity"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [QueryClusterSpecificationResponseBody.Data]?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QueryClusterSpecificationResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryClusterSpecificationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterSpecificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterSpecificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryClusterSpecificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var configType: String?

    public var instanceId: String?

    public var needRunningConf: Bool?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.needRunningConf != nil {
            map["NeedRunningConf"] = self.needRunningConf!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigType") && dict["ConfigType"] != nil {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NeedRunningConf") && dict["NeedRunningConf"] != nil {
            self.needRunningConf = dict["NeedRunningConf"] as! Bool
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class NacosRunningEnv : Tea.TeaModel {
            public var emptyProtect: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.emptyProtect != nil {
                    map["emptyProtect"] = self.emptyProtect!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("emptyProtect") && dict["emptyProtect"] != nil {
                    self.emptyProtect = dict["emptyProtect"] as! Bool
                }
            }
        }
        public var autopurgePurgeInterval: String?

        public var autopurgeSnapRetainCount: String?

        public var clusterName: String?

        public var configAuthEnabled: Bool?

        public var configAuthSupported: Bool?

        public var configContentLimit: Int64?

        public var configSecretEnabled: Bool?

        public var configSecretSupported: Bool?

        public var consoleUIEnabled: Bool?

        public var eurekaSupported: Bool?

        public var extendedTypesEnable: Bool?

        public var initLimit: String?

        public var juteMaxbuffer: String?

        public var jvmFlagsCustom: String?

        public var MCPEnabled: Bool?

        public var MCPSupported: Bool?

        public var maxClientCnxns: String?

        public var maxSessionTimeout: String?

        public var minSessionTimeout: String?

        public var nacosRunningEnv: QueryConfigResponseBody.Data.NacosRunningEnv?

        public var namingAuthEnabled: Bool?

        public var namingAuthSupported: Bool?

        public var namingCreateServiceSupported: Bool?

        public var openSuperAcl: Bool?

        public var passWord: String?

        public var restartFlag: Bool?

        public var snapshotCount: String?

        public var syncLimit: String?

        public var TLSEnabled: Bool?

        public var tickTime: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.nacosRunningEnv?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autopurgePurgeInterval != nil {
                map["AutopurgePurgeInterval"] = self.autopurgePurgeInterval!
            }
            if self.autopurgeSnapRetainCount != nil {
                map["AutopurgeSnapRetainCount"] = self.autopurgeSnapRetainCount!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.configAuthEnabled != nil {
                map["ConfigAuthEnabled"] = self.configAuthEnabled!
            }
            if self.configAuthSupported != nil {
                map["ConfigAuthSupported"] = self.configAuthSupported!
            }
            if self.configContentLimit != nil {
                map["ConfigContentLimit"] = self.configContentLimit!
            }
            if self.configSecretEnabled != nil {
                map["ConfigSecretEnabled"] = self.configSecretEnabled!
            }
            if self.configSecretSupported != nil {
                map["ConfigSecretSupported"] = self.configSecretSupported!
            }
            if self.consoleUIEnabled != nil {
                map["ConsoleUIEnabled"] = self.consoleUIEnabled!
            }
            if self.eurekaSupported != nil {
                map["EurekaSupported"] = self.eurekaSupported!
            }
            if self.extendedTypesEnable != nil {
                map["ExtendedTypesEnable"] = self.extendedTypesEnable!
            }
            if self.initLimit != nil {
                map["InitLimit"] = self.initLimit!
            }
            if self.juteMaxbuffer != nil {
                map["JuteMaxbuffer"] = self.juteMaxbuffer!
            }
            if self.jvmFlagsCustom != nil {
                map["JvmFlagsCustom"] = self.jvmFlagsCustom!
            }
            if self.MCPEnabled != nil {
                map["MCPEnabled"] = self.MCPEnabled!
            }
            if self.MCPSupported != nil {
                map["MCPSupported"] = self.MCPSupported!
            }
            if self.maxClientCnxns != nil {
                map["MaxClientCnxns"] = self.maxClientCnxns!
            }
            if self.maxSessionTimeout != nil {
                map["MaxSessionTimeout"] = self.maxSessionTimeout!
            }
            if self.minSessionTimeout != nil {
                map["MinSessionTimeout"] = self.minSessionTimeout!
            }
            if self.nacosRunningEnv != nil {
                map["NacosRunningEnv"] = self.nacosRunningEnv?.toMap()
            }
            if self.namingAuthEnabled != nil {
                map["NamingAuthEnabled"] = self.namingAuthEnabled!
            }
            if self.namingAuthSupported != nil {
                map["NamingAuthSupported"] = self.namingAuthSupported!
            }
            if self.namingCreateServiceSupported != nil {
                map["NamingCreateServiceSupported"] = self.namingCreateServiceSupported!
            }
            if self.openSuperAcl != nil {
                map["OpenSuperAcl"] = self.openSuperAcl!
            }
            if self.passWord != nil {
                map["PassWord"] = self.passWord!
            }
            if self.restartFlag != nil {
                map["RestartFlag"] = self.restartFlag!
            }
            if self.snapshotCount != nil {
                map["SnapshotCount"] = self.snapshotCount!
            }
            if self.syncLimit != nil {
                map["SyncLimit"] = self.syncLimit!
            }
            if self.TLSEnabled != nil {
                map["TLSEnabled"] = self.TLSEnabled!
            }
            if self.tickTime != nil {
                map["TickTime"] = self.tickTime!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutopurgePurgeInterval") && dict["AutopurgePurgeInterval"] != nil {
                self.autopurgePurgeInterval = dict["AutopurgePurgeInterval"] as! String
            }
            if dict.keys.contains("AutopurgeSnapRetainCount") && dict["AutopurgeSnapRetainCount"] != nil {
                self.autopurgeSnapRetainCount = dict["AutopurgeSnapRetainCount"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ConfigAuthEnabled") && dict["ConfigAuthEnabled"] != nil {
                self.configAuthEnabled = dict["ConfigAuthEnabled"] as! Bool
            }
            if dict.keys.contains("ConfigAuthSupported") && dict["ConfigAuthSupported"] != nil {
                self.configAuthSupported = dict["ConfigAuthSupported"] as! Bool
            }
            if dict.keys.contains("ConfigContentLimit") && dict["ConfigContentLimit"] != nil {
                self.configContentLimit = dict["ConfigContentLimit"] as! Int64
            }
            if dict.keys.contains("ConfigSecretEnabled") && dict["ConfigSecretEnabled"] != nil {
                self.configSecretEnabled = dict["ConfigSecretEnabled"] as! Bool
            }
            if dict.keys.contains("ConfigSecretSupported") && dict["ConfigSecretSupported"] != nil {
                self.configSecretSupported = dict["ConfigSecretSupported"] as! Bool
            }
            if dict.keys.contains("ConsoleUIEnabled") && dict["ConsoleUIEnabled"] != nil {
                self.consoleUIEnabled = dict["ConsoleUIEnabled"] as! Bool
            }
            if dict.keys.contains("EurekaSupported") && dict["EurekaSupported"] != nil {
                self.eurekaSupported = dict["EurekaSupported"] as! Bool
            }
            if dict.keys.contains("ExtendedTypesEnable") && dict["ExtendedTypesEnable"] != nil {
                self.extendedTypesEnable = dict["ExtendedTypesEnable"] as! Bool
            }
            if dict.keys.contains("InitLimit") && dict["InitLimit"] != nil {
                self.initLimit = dict["InitLimit"] as! String
            }
            if dict.keys.contains("JuteMaxbuffer") && dict["JuteMaxbuffer"] != nil {
                self.juteMaxbuffer = dict["JuteMaxbuffer"] as! String
            }
            if dict.keys.contains("JvmFlagsCustom") && dict["JvmFlagsCustom"] != nil {
                self.jvmFlagsCustom = dict["JvmFlagsCustom"] as! String
            }
            if dict.keys.contains("MCPEnabled") && dict["MCPEnabled"] != nil {
                self.MCPEnabled = dict["MCPEnabled"] as! Bool
            }
            if dict.keys.contains("MCPSupported") && dict["MCPSupported"] != nil {
                self.MCPSupported = dict["MCPSupported"] as! Bool
            }
            if dict.keys.contains("MaxClientCnxns") && dict["MaxClientCnxns"] != nil {
                self.maxClientCnxns = dict["MaxClientCnxns"] as! String
            }
            if dict.keys.contains("MaxSessionTimeout") && dict["MaxSessionTimeout"] != nil {
                self.maxSessionTimeout = dict["MaxSessionTimeout"] as! String
            }
            if dict.keys.contains("MinSessionTimeout") && dict["MinSessionTimeout"] != nil {
                self.minSessionTimeout = dict["MinSessionTimeout"] as! String
            }
            if dict.keys.contains("NacosRunningEnv") && dict["NacosRunningEnv"] != nil {
                var model = QueryConfigResponseBody.Data.NacosRunningEnv()
                model.fromMap(dict["NacosRunningEnv"] as! [String: Any])
                self.nacosRunningEnv = model
            }
            if dict.keys.contains("NamingAuthEnabled") && dict["NamingAuthEnabled"] != nil {
                self.namingAuthEnabled = dict["NamingAuthEnabled"] as! Bool
            }
            if dict.keys.contains("NamingAuthSupported") && dict["NamingAuthSupported"] != nil {
                self.namingAuthSupported = dict["NamingAuthSupported"] as! Bool
            }
            if dict.keys.contains("NamingCreateServiceSupported") && dict["NamingCreateServiceSupported"] != nil {
                self.namingCreateServiceSupported = dict["NamingCreateServiceSupported"] as! Bool
            }
            if dict.keys.contains("OpenSuperAcl") && dict["OpenSuperAcl"] != nil {
                self.openSuperAcl = dict["OpenSuperAcl"] as! Bool
            }
            if dict.keys.contains("PassWord") && dict["PassWord"] != nil {
                self.passWord = dict["PassWord"] as! String
            }
            if dict.keys.contains("RestartFlag") && dict["RestartFlag"] != nil {
                self.restartFlag = dict["RestartFlag"] as! Bool
            }
            if dict.keys.contains("SnapshotCount") && dict["SnapshotCount"] != nil {
                self.snapshotCount = dict["SnapshotCount"] as! String
            }
            if dict.keys.contains("SyncLimit") && dict["SyncLimit"] != nil {
                self.syncLimit = dict["SyncLimit"] as! String
            }
            if dict.keys.contains("TLSEnabled") && dict["TLSEnabled"] != nil {
                self.TLSEnabled = dict["TLSEnabled"] as! Bool
            }
            if dict.keys.contains("TickTime") && dict["TickTime"] != nil {
                self.tickTime = dict["TickTime"] as! String
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: QueryConfigResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGatewayRegionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class QueryGatewayRegionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGatewayRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGatewayRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryGatewayRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGatewayTypeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class QueryGatewayTypeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGatewayTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGatewayTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryGatewayTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGovernanceKubernetesClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryGovernanceKubernetesClusterResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var clusterId: String?

            public var clusterName: String?

            public var k8sVersion: String?

            public var namespaceInfos: String?

            public var pilotStartTime: String?

            public var region: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.k8sVersion != nil {
                    map["K8sVersion"] = self.k8sVersion!
                }
                if self.namespaceInfos != nil {
                    map["NamespaceInfos"] = self.namespaceInfos!
                }
                if self.pilotStartTime != nil {
                    map["PilotStartTime"] = self.pilotStartTime!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("K8sVersion") && dict["K8sVersion"] != nil {
                    self.k8sVersion = dict["K8sVersion"] as! String
                }
                if dict.keys.contains("NamespaceInfos") && dict["NamespaceInfos"] != nil {
                    self.namespaceInfos = dict["NamespaceInfos"] as! String
                }
                if dict.keys.contains("PilotStartTime") && dict["PilotStartTime"] != nil {
                    self.pilotStartTime = dict["PilotStartTime"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [QueryGovernanceKubernetesClusterResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [QueryGovernanceKubernetesClusterResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = QueryGovernanceKubernetesClusterResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: QueryGovernanceKubernetesClusterResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryGovernanceKubernetesClusterResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGovernanceKubernetesClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGovernanceKubernetesClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryGovernanceKubernetesClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryInstancesInfoRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var instanceId: String?

    public var orderId: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryInstancesInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clientPort: String?

        public var creationTimestamp: String?

        public var healthStatus: String?

        public var internetIp: String?

        public var ip: String?

        public var podName: String?

        public var role: String?

        public var singleTunnelVip: String?

        public var zone: String?

        public var zoneDistributed: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientPort != nil {
                map["ClientPort"] = self.clientPort!
            }
            if self.creationTimestamp != nil {
                map["CreationTimestamp"] = self.creationTimestamp!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.podName != nil {
                map["PodName"] = self.podName!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.singleTunnelVip != nil {
                map["SingleTunnelVip"] = self.singleTunnelVip!
            }
            if self.zone != nil {
                map["Zone"] = self.zone!
            }
            if self.zoneDistributed != nil {
                map["ZoneDistributed"] = self.zoneDistributed!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientPort") && dict["ClientPort"] != nil {
                self.clientPort = dict["ClientPort"] as! String
            }
            if dict.keys.contains("CreationTimestamp") && dict["CreationTimestamp"] != nil {
                self.creationTimestamp = dict["CreationTimestamp"] as! String
            }
            if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("PodName") && dict["PodName"] != nil {
                self.podName = dict["PodName"] as! String
            }
            if dict.keys.contains("Role") && dict["Role"] != nil {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("SingleTunnelVip") && dict["SingleTunnelVip"] != nil {
                self.singleTunnelVip = dict["SingleTunnelVip"] as! String
            }
            if dict.keys.contains("Zone") && dict["Zone"] != nil {
                self.zone = dict["Zone"] as! String
            }
            if dict.keys.contains("ZoneDistributed") && dict["ZoneDistributed"] != nil {
                self.zoneDistributed = dict["ZoneDistributed"] as! Bool
            }
        }
    }
    public var data: [QueryInstancesInfoResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QueryInstancesInfoResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryInstancesInfoResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryInstancesInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryInstancesInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryInstancesInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMonitorRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var monitorType: String?

    public var requestPars: String?

    public var startTime: Int64?

    public var step: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.monitorType != nil {
            map["MonitorType"] = self.monitorType!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.step != nil {
            map["Step"] = self.step!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MonitorType") && dict["MonitorType"] != nil {
            self.monitorType = dict["MonitorType"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Step") && dict["Step"] != nil {
            self.step = dict["Step"] as! Int64
        }
    }
}

public class QueryMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterNamePrefix: String?

        public var podName: String?

        public var values: [[String: Any]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterNamePrefix != nil {
                map["clusterNamePrefix"] = self.clusterNamePrefix!
            }
            if self.podName != nil {
                map["podName"] = self.podName!
            }
            if self.values != nil {
                map["values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("clusterNamePrefix") && dict["clusterNamePrefix"] != nil {
                self.clusterNamePrefix = dict["clusterNamePrefix"] as! String
            }
            if dict.keys.contains("podName") && dict["podName"] != nil {
                self.podName = dict["podName"] as! String
            }
            if dict.keys.contains("values") && dict["values"] != nil {
                self.values = dict["values"] as! [[String: Any]]
            }
        }
    }
    public var data: [QueryMonitorResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QueryMonitorResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryMonitorResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var name: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
    }
}

public class QueryNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var namespace: String?

        public var region: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
        }
    }
    public var data: [QueryNamespaceResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QueryNamespaceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryNamespaceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySlbSpecRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class QuerySlbSpecResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int32?

        public var maxConnection: String?

        public var name: String?

        public var newConnectionPerSecond: String?

        public var qps: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxConnection != nil {
                map["MaxConnection"] = self.maxConnection!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.newConnectionPerSecond != nil {
                map["NewConnectionPerSecond"] = self.newConnectionPerSecond!
            }
            if self.qps != nil {
                map["Qps"] = self.qps!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("MaxConnection") && dict["MaxConnection"] != nil {
                self.maxConnection = dict["MaxConnection"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NewConnectionPerSecond") && dict["NewConnectionPerSecond"] != nil {
                self.newConnectionPerSecond = dict["NewConnectionPerSecond"] as! String
            }
            if dict.keys.contains("Qps") && dict["Qps"] != nil {
                self.qps = dict["Qps"] as! String
            }
            if dict.keys.contains("Spec") && dict["Spec"] != nil {
                self.spec = dict["Spec"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [QuerySlbSpecResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QuerySlbSpecResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QuerySlbSpecResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QuerySlbSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySlbSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QuerySlbSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySwimmingLaneByIdRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var laneId: Int64?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("LaneId") && dict["LaneId"] != nil {
            self.laneId = dict["LaneId"] as! Int64
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class QuerySwimmingLaneByIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EntryRules : Tea.TeaModel {
            public class RestItems : Tea.TeaModel {
                public var cond: String?

                public var datum: String?

                public var divisor: Int32?

                public var name: String?

                public var nameList: [String]?

                public var operator_: String?

                public var rate: Int32?

                public var remainder: Int32?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cond") && dict["cond"] != nil {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("datum") && dict["datum"] != nil {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("divisor") && dict["divisor"] != nil {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("nameList") && dict["nameList"] != nil {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("operator") && dict["operator"] != nil {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("rate") && dict["rate"] != nil {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("remainder") && dict["remainder"] != nil {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("type") && dict["type"] != nil {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("value") && dict["value"] != nil {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var condition: String?

            public var path: String?

            public var paths: [String]?

            public var restItems: [QuerySwimmingLaneByIdResponseBody.Data.EntryRules.RestItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.paths != nil {
                    map["paths"] = self.paths!
                }
                if self.restItems != nil {
                    var tmp : [Any] = []
                    for k in self.restItems! {
                        tmp.append(k.toMap())
                    }
                    map["restItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") && dict["condition"] != nil {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("path") && dict["path"] != nil {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("paths") && dict["paths"] != nil {
                    self.paths = dict["paths"] as! [String]
                }
                if dict.keys.contains("restItems") && dict["restItems"] != nil {
                    var tmp : [QuerySwimmingLaneByIdResponseBody.Data.EntryRules.RestItems] = []
                    for v in dict["restItems"] as! [Any] {
                        var model = QuerySwimmingLaneByIdResponseBody.Data.EntryRules.RestItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restItems = tmp
                }
            }
        }
        public var enable: Bool?

        public var enableRules: Bool?

        public var entryRule: String?

        public var entryRules: [QuerySwimmingLaneByIdResponseBody.Data.EntryRules]?

        public var gatewaySwimmingLaneRouteJson: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var regionId: String?

        public var status: Int32?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.enableRules != nil {
                map["enableRules"] = self.enableRules!
            }
            if self.entryRule != nil {
                map["entryRule"] = self.entryRule!
            }
            if self.entryRules != nil {
                var tmp : [Any] = []
                for k in self.entryRules! {
                    tmp.append(k.toMap())
                }
                map["entryRules"] = tmp
            }
            if self.gatewaySwimmingLaneRouteJson != nil {
                map["gatewaySwimmingLaneRouteJson"] = self.gatewaySwimmingLaneRouteJson!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.groupId != nil {
                map["groupId"] = self.groupId!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tag != nil {
                map["tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("enable") && dict["enable"] != nil {
                self.enable = dict["enable"] as! Bool
            }
            if dict.keys.contains("enableRules") && dict["enableRules"] != nil {
                self.enableRules = dict["enableRules"] as! Bool
            }
            if dict.keys.contains("entryRule") && dict["entryRule"] != nil {
                self.entryRule = dict["entryRule"] as! String
            }
            if dict.keys.contains("entryRules") && dict["entryRules"] != nil {
                var tmp : [QuerySwimmingLaneByIdResponseBody.Data.EntryRules] = []
                for v in dict["entryRules"] as! [Any] {
                    var model = QuerySwimmingLaneByIdResponseBody.Data.EntryRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entryRules = tmp
            }
            if dict.keys.contains("gatewaySwimmingLaneRouteJson") && dict["gatewaySwimmingLaneRouteJson"] != nil {
                self.gatewaySwimmingLaneRouteJson = dict["gatewaySwimmingLaneRouteJson"] as! String
            }
            if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") && dict["gmtModified"] != nil {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("groupId") && dict["groupId"] != nil {
                self.groupId = dict["groupId"] as! Int64
            }
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") && dict["name"] != nil {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("regionId") && dict["regionId"] != nil {
                self.regionId = dict["regionId"] as! String
            }
            if dict.keys.contains("status") && dict["status"] != nil {
                self.status = dict["status"] as! Int32
            }
            if dict.keys.contains("tag") && dict["tag"] != nil {
                self.tag = dict["tag"] as! String
            }
        }
    }
    public var data: QuerySwimmingLaneByIdResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QuerySwimmingLaneByIdResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QuerySwimmingLaneByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySwimmingLaneByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QuerySwimmingLaneByIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryZnodeDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var instanceId: String?

    public var path: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryZnodeDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") && dict["Dir"] != nil {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: QueryZnodeDetailResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = QueryZnodeDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class QueryZnodeDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryZnodeDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryZnodeDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveApplicationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
    }
}

public class RemoveApplicationResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAuthPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var policyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! String
        }
    }
}

public class RemoveAuthPolicyResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveAuthPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAuthPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveAuthPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var instanceId: String?

    public var podNameList: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.podNameList != nil {
            map["PodNameList"] = self.podNameList!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PodNameList") && dict["PodNameList"] != nil {
            self.podNameList = dict["PodNameList"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class RestartClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestartClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RestartClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class RetryClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RetryClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RetryClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SelectGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var name: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class SelectGatewaySlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var slbId: String?

        public var slbName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbName != nil {
                map["SlbName"] = self.slbName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbName") && dict["SlbName"] != nil {
                self.slbName = dict["SlbName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [SelectGatewaySlbResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [SelectGatewaySlbResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = SelectGatewaySlbResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SelectGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SelectGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SelectGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var all: Bool?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("All") && dict["All"] != nil {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAclRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aclEntryList: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aclEntryList != nil {
            map["AclEntryList"] = self.aclEntryList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AclEntryList") && dict["AclEntryList"] != nil {
            self.aclEntryList = dict["AclEntryList"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class UpdateAclResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAuthPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var authRule: String?

    public var enable: String?

    public var id: String?

    public var k8sNamespace: String?

    public var name: String?

    public var protocol_: String?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authRule != nil {
            map["AuthRule"] = self.authRule!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.k8sNamespace != nil {
            map["K8sNamespace"] = self.k8sNamespace!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AuthRule") && dict["AuthRule"] != nil {
            self.authRule = dict["AuthRule"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("K8sNamespace") && dict["K8sNamespace"] != nil {
            self.k8sNamespace = dict["K8sNamespace"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class UpdateAuthPolicyResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAuthPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAuthPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAuthPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBlackWhiteListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var content: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var isWhite: Bool?

    public var name: String?

    public var note: String?

    public var resourceIdJsonList: String?

    public var resourceType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.resourceIdJsonList != nil {
            map["ResourceIdJsonList"] = self.resourceIdJsonList!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IsWhite") && dict["IsWhite"] != nil {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("ResourceIdJsonList") && dict["ResourceIdJsonList"] != nil {
            self.resourceIdJsonList = dict["ResourceIdJsonList"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateBlackWhiteListResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCircuitBreakerRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var halfOpenBaseAmountPerStep: Int32?

    public var halfOpenRecoveryStepNum: Int32?

    public var maxAllowedRtMs: Int32?

    public var minRequestAmount: Int32?

    public var namespace: String?

    public var retryTimeoutMs: Int32?

    public var ruleId: Int64?

    public var statIntervalMs: Int32?

    public var strategy: Int32?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.halfOpenBaseAmountPerStep != nil {
            map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
        }
        if self.halfOpenRecoveryStepNum != nil {
            map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
        }
        if self.maxAllowedRtMs != nil {
            map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
        }
        if self.minRequestAmount != nil {
            map["MinRequestAmount"] = self.minRequestAmount!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.retryTimeoutMs != nil {
            map["RetryTimeoutMs"] = self.retryTimeoutMs!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.statIntervalMs != nil {
            map["StatIntervalMs"] = self.statIntervalMs!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("HalfOpenBaseAmountPerStep") && dict["HalfOpenBaseAmountPerStep"] != nil {
            self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
        }
        if dict.keys.contains("HalfOpenRecoveryStepNum") && dict["HalfOpenRecoveryStepNum"] != nil {
            self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
        }
        if dict.keys.contains("MaxAllowedRtMs") && dict["MaxAllowedRtMs"] != nil {
            self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
        }
        if dict.keys.contains("MinRequestAmount") && dict["MinRequestAmount"] != nil {
            self.minRequestAmount = dict["MinRequestAmount"] as! Int32
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RetryTimeoutMs") && dict["RetryTimeoutMs"] != nil {
            self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("StatIntervalMs") && dict["StatIntervalMs"] != nil {
            self.statIntervalMs = dict["StatIntervalMs"] as! Int32
        }
        if dict.keys.contains("Strategy") && dict["Strategy"] != nil {
            self.strategy = dict["Strategy"] as! Int32
        }
        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class UpdateCircuitBreakerRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var enable: Bool?

        public var halfOpenBaseAmountPerStep: Int32?

        public var halfOpenRecoveryStepNum: Int32?

        public var id: Int64?

        public var maxAllowedRtMs: Int32?

        public var minRequestAmount: Int32?

        public var namespace: String?

        public var resource: String?

        public var retryTimeoutMs: Int32?

        public var statIntervalMs: Int32?

        public var strategy: Int32?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.halfOpenBaseAmountPerStep != nil {
                map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
            }
            if self.halfOpenRecoveryStepNum != nil {
                map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxAllowedRtMs != nil {
                map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
            }
            if self.minRequestAmount != nil {
                map["MinRequestAmount"] = self.minRequestAmount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.retryTimeoutMs != nil {
                map["RetryTimeoutMs"] = self.retryTimeoutMs!
            }
            if self.statIntervalMs != nil {
                map["StatIntervalMs"] = self.statIntervalMs!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("HalfOpenBaseAmountPerStep") && dict["HalfOpenBaseAmountPerStep"] != nil {
                self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
            }
            if dict.keys.contains("HalfOpenRecoveryStepNum") && dict["HalfOpenRecoveryStepNum"] != nil {
                self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MaxAllowedRtMs") && dict["MaxAllowedRtMs"] != nil {
                self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
            }
            if dict.keys.contains("MinRequestAmount") && dict["MinRequestAmount"] != nil {
                self.minRequestAmount = dict["MinRequestAmount"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("RetryTimeoutMs") && dict["RetryTimeoutMs"] != nil {
                self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
            }
            if dict.keys.contains("StatIntervalMs") && dict["StatIntervalMs"] != nil {
                self.statIntervalMs = dict["StatIntervalMs"] as! Int32
            }
            if dict.keys.contains("Strategy") && dict["Strategy"] != nil {
                self.strategy = dict["Strategy"] as! Int32
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: UpdateCircuitBreakerRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateCircuitBreakerRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCircuitBreakerRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCircuitBreakerRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateCircuitBreakerRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterAliasName: String?

    public var instanceId: String?

    public var maintenanceEndTime: String?

    public var maintenanceStartTime: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterAliasName != nil {
            map["ClusterAliasName"] = self.clusterAliasName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maintenanceEndTime != nil {
            map["MaintenanceEndTime"] = self.maintenanceEndTime!
        }
        if self.maintenanceStartTime != nil {
            map["MaintenanceStartTime"] = self.maintenanceStartTime!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterAliasName") && dict["ClusterAliasName"] != nil {
            self.clusterAliasName = dict["ClusterAliasName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaintenanceEndTime") && dict["MaintenanceEndTime"] != nil {
            self.maintenanceEndTime = dict["MaintenanceEndTime"] as! String
        }
        if dict.keys.contains("MaintenanceStartTime") && dict["MaintenanceStartTime"] != nil {
            self.maintenanceStartTime = dict["MaintenanceStartTime"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class UpdateClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateClusterSpecRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var autoPay: Bool?

    public var clusterId: String?

    public var clusterSpecification: String?

    public var instanceCount: Int32?

    public var instanceId: String?

    public var mseVersion: String?

    public var pubNetworkFlow: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterSpecification != nil {
            map["ClusterSpecification"] = self.clusterSpecification!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.pubNetworkFlow != nil {
            map["PubNetworkFlow"] = self.pubNetworkFlow!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterSpecification") && dict["ClusterSpecification"] != nil {
            self.clusterSpecification = dict["ClusterSpecification"] as! String
        }
        if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
            self.instanceCount = dict["InstanceCount"] as! Int32
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseVersion") && dict["MseVersion"] != nil {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("PubNetworkFlow") && dict["PubNetworkFlow"] != nil {
            self.pubNetworkFlow = dict["PubNetworkFlow"] as! Int32
        }
    }
}

public class UpdateClusterSpecResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateClusterSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateClusterSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateClusterSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var autopurgePurgeInterval: String?

    public var autopurgeSnapRetainCount: String?

    public var clusterId: String?

    public var configAuthEnabled: Bool?

    public var configSecretEnabled: Bool?

    public var configType: String?

    public var consoleUIEnabled: Bool?

    public var eurekaSupported: Bool?

    public var extendedTypesEnable: String?

    public var initLimit: String?

    public var instanceId: String?

    public var juteMaxbuffer: String?

    public var MCPEnabled: Bool?

    public var maxClientCnxns: String?

    public var maxSessionTimeout: String?

    public var minSessionTimeout: String?

    public var namingAuthEnabled: Bool?

    public var openSuperAcl: String?

    public var passWord: String?

    public var requestPars: String?

    public var snapshotCount: String?

    public var syncLimit: String?

    public var TLSEnabled: Bool?

    public var tickTime: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.autopurgePurgeInterval != nil {
            map["AutopurgePurgeInterval"] = self.autopurgePurgeInterval!
        }
        if self.autopurgeSnapRetainCount != nil {
            map["AutopurgeSnapRetainCount"] = self.autopurgeSnapRetainCount!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configAuthEnabled != nil {
            map["ConfigAuthEnabled"] = self.configAuthEnabled!
        }
        if self.configSecretEnabled != nil {
            map["ConfigSecretEnabled"] = self.configSecretEnabled!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.consoleUIEnabled != nil {
            map["ConsoleUIEnabled"] = self.consoleUIEnabled!
        }
        if self.eurekaSupported != nil {
            map["EurekaSupported"] = self.eurekaSupported!
        }
        if self.extendedTypesEnable != nil {
            map["ExtendedTypesEnable"] = self.extendedTypesEnable!
        }
        if self.initLimit != nil {
            map["InitLimit"] = self.initLimit!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.juteMaxbuffer != nil {
            map["JuteMaxbuffer"] = self.juteMaxbuffer!
        }
        if self.MCPEnabled != nil {
            map["MCPEnabled"] = self.MCPEnabled!
        }
        if self.maxClientCnxns != nil {
            map["MaxClientCnxns"] = self.maxClientCnxns!
        }
        if self.maxSessionTimeout != nil {
            map["MaxSessionTimeout"] = self.maxSessionTimeout!
        }
        if self.minSessionTimeout != nil {
            map["MinSessionTimeout"] = self.minSessionTimeout!
        }
        if self.namingAuthEnabled != nil {
            map["NamingAuthEnabled"] = self.namingAuthEnabled!
        }
        if self.openSuperAcl != nil {
            map["OpenSuperAcl"] = self.openSuperAcl!
        }
        if self.passWord != nil {
            map["PassWord"] = self.passWord!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.snapshotCount != nil {
            map["SnapshotCount"] = self.snapshotCount!
        }
        if self.syncLimit != nil {
            map["SyncLimit"] = self.syncLimit!
        }
        if self.TLSEnabled != nil {
            map["TLSEnabled"] = self.TLSEnabled!
        }
        if self.tickTime != nil {
            map["TickTime"] = self.tickTime!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AutopurgePurgeInterval") && dict["AutopurgePurgeInterval"] != nil {
            self.autopurgePurgeInterval = dict["AutopurgePurgeInterval"] as! String
        }
        if dict.keys.contains("AutopurgeSnapRetainCount") && dict["AutopurgeSnapRetainCount"] != nil {
            self.autopurgeSnapRetainCount = dict["AutopurgeSnapRetainCount"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigAuthEnabled") && dict["ConfigAuthEnabled"] != nil {
            self.configAuthEnabled = dict["ConfigAuthEnabled"] as! Bool
        }
        if dict.keys.contains("ConfigSecretEnabled") && dict["ConfigSecretEnabled"] != nil {
            self.configSecretEnabled = dict["ConfigSecretEnabled"] as! Bool
        }
        if dict.keys.contains("ConfigType") && dict["ConfigType"] != nil {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("ConsoleUIEnabled") && dict["ConsoleUIEnabled"] != nil {
            self.consoleUIEnabled = dict["ConsoleUIEnabled"] as! Bool
        }
        if dict.keys.contains("EurekaSupported") && dict["EurekaSupported"] != nil {
            self.eurekaSupported = dict["EurekaSupported"] as! Bool
        }
        if dict.keys.contains("ExtendedTypesEnable") && dict["ExtendedTypesEnable"] != nil {
            self.extendedTypesEnable = dict["ExtendedTypesEnable"] as! String
        }
        if dict.keys.contains("InitLimit") && dict["InitLimit"] != nil {
            self.initLimit = dict["InitLimit"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JuteMaxbuffer") && dict["JuteMaxbuffer"] != nil {
            self.juteMaxbuffer = dict["JuteMaxbuffer"] as! String
        }
        if dict.keys.contains("MCPEnabled") && dict["MCPEnabled"] != nil {
            self.MCPEnabled = dict["MCPEnabled"] as! Bool
        }
        if dict.keys.contains("MaxClientCnxns") && dict["MaxClientCnxns"] != nil {
            self.maxClientCnxns = dict["MaxClientCnxns"] as! String
        }
        if dict.keys.contains("MaxSessionTimeout") && dict["MaxSessionTimeout"] != nil {
            self.maxSessionTimeout = dict["MaxSessionTimeout"] as! String
        }
        if dict.keys.contains("MinSessionTimeout") && dict["MinSessionTimeout"] != nil {
            self.minSessionTimeout = dict["MinSessionTimeout"] as! String
        }
        if dict.keys.contains("NamingAuthEnabled") && dict["NamingAuthEnabled"] != nil {
            self.namingAuthEnabled = dict["NamingAuthEnabled"] as! Bool
        }
        if dict.keys.contains("OpenSuperAcl") && dict["OpenSuperAcl"] != nil {
            self.openSuperAcl = dict["OpenSuperAcl"] as! String
        }
        if dict.keys.contains("PassWord") && dict["PassWord"] != nil {
            self.passWord = dict["PassWord"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("SnapshotCount") && dict["SnapshotCount"] != nil {
            self.snapshotCount = dict["SnapshotCount"] as! String
        }
        if dict.keys.contains("SyncLimit") && dict["SyncLimit"] != nil {
            self.syncLimit = dict["SyncLimit"] as! String
        }
        if dict.keys.contains("TLSEnabled") && dict["TLSEnabled"] != nil {
            self.TLSEnabled = dict["TLSEnabled"] as! Bool
        }
        if dict.keys.contains("TickTime") && dict["TickTime"] != nil {
            self.tickTime = dict["TickTime"] as! String
        }
        if dict.keys.contains("UserName") && dict["UserName"] != nil {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class UpdateConfigResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEngineNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var desc: String?

    public var id: String?

    public var instanceId: String?

    public var name: String?

    public var serviceCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.serviceCount != nil {
            map["ServiceCount"] = self.serviceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServiceCount") && dict["ServiceCount"] != nil {
            self.serviceCount = dict["ServiceCount"] as! Int32
        }
    }
}

public class UpdateEngineNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configCount: Int32?

        public var namespace: String?

        public var namespaceDesc: String?

        public var namespaceShowName: String?

        public var quota: Int32?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configCount != nil {
                map["ConfigCount"] = self.configCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceDesc != nil {
                map["NamespaceDesc"] = self.namespaceDesc!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigCount") && dict["ConfigCount"] != nil {
                self.configCount = dict["ConfigCount"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceDesc") && dict["NamespaceDesc"] != nil {
                self.namespaceDesc = dict["NamespaceDesc"] as! String
            }
            if dict.keys.contains("NamespaceShowName") && dict["NamespaceShowName"] != nil {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Quota") && dict["Quota"] != nil {
                self.quota = dict["Quota"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var data: UpdateEngineNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateEngineNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEngineNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEngineNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEngineNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFlowRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var controlBehavior: Int32?

    public var enable: Bool?

    public var maxQueueingTimeMs: Int32?

    public var namespace: String?

    public var ruleId: Int64?

    public var threshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.controlBehavior != nil {
            map["ControlBehavior"] = self.controlBehavior!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.maxQueueingTimeMs != nil {
            map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ControlBehavior") && dict["ControlBehavior"] != nil {
            self.controlBehavior = dict["ControlBehavior"] as! Int32
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("MaxQueueingTimeMs") && dict["MaxQueueingTimeMs"] != nil {
            self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
            self.threshold = dict["Threshold"] as! Int32
        }
    }
}

public class UpdateFlowRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var controlBehavior: Int32?

        public var enable: Bool?

        public var id: Int64?

        public var maxQueueingTimeMs: Int32?

        public var namespace: String?

        public var resource: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.controlBehavior != nil {
                map["ControlBehavior"] = self.controlBehavior!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxQueueingTimeMs != nil {
                map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ControlBehavior") && dict["ControlBehavior"] != nil {
                self.controlBehavior = dict["ControlBehavior"] as! Int32
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MaxQueueingTimeMs") && dict["MaxQueueingTimeMs"] != nil {
                self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: UpdateFlowRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateFlowRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateFlowRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFlowRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateFlowRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayAuthConsumerRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var encodeType: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var jwks: String?

    public var keyName: String?

    public var keyValue: String?

    public var tokenName: String?

    public var tokenPass: Bool?

    public var tokenPosition: String?

    public var tokenPrefix: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.encodeType != nil {
            map["EncodeType"] = self.encodeType!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.jwks != nil {
            map["Jwks"] = self.jwks!
        }
        if self.keyName != nil {
            map["KeyName"] = self.keyName!
        }
        if self.keyValue != nil {
            map["KeyValue"] = self.keyValue!
        }
        if self.tokenName != nil {
            map["TokenName"] = self.tokenName!
        }
        if self.tokenPass != nil {
            map["TokenPass"] = self.tokenPass!
        }
        if self.tokenPosition != nil {
            map["TokenPosition"] = self.tokenPosition!
        }
        if self.tokenPrefix != nil {
            map["TokenPrefix"] = self.tokenPrefix!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EncodeType") && dict["EncodeType"] != nil {
            self.encodeType = dict["EncodeType"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Jwks") && dict["Jwks"] != nil {
            self.jwks = dict["Jwks"] as! String
        }
        if dict.keys.contains("KeyName") && dict["KeyName"] != nil {
            self.keyName = dict["KeyName"] as! String
        }
        if dict.keys.contains("KeyValue") && dict["KeyValue"] != nil {
            self.keyValue = dict["KeyValue"] as! String
        }
        if dict.keys.contains("TokenName") && dict["TokenName"] != nil {
            self.tokenName = dict["TokenName"] as! String
        }
        if dict.keys.contains("TokenPass") && dict["TokenPass"] != nil {
            self.tokenPass = dict["TokenPass"] as! Bool
        }
        if dict.keys.contains("TokenPosition") && dict["TokenPosition"] != nil {
            self.tokenPosition = dict["TokenPosition"] as! String
        }
        if dict.keys.contains("TokenPrefix") && dict["TokenPrefix"] != nil {
            self.tokenPrefix = dict["TokenPrefix"] as! String
        }
    }
}

public class UpdateGatewayAuthConsumerResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayAuthConsumerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayAuthConsumerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayAuthConsumerResourceRequest : Tea.TeaModel {
    public class ResourceList : Tea.TeaModel {
        public var routeId: Int64?

        public var routeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.routeName != nil {
                map["RouteName"] = self.routeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
                self.routeId = dict["RouteId"] as! Int64
            }
            if dict.keys.contains("RouteName") && dict["RouteName"] != nil {
                self.routeName = dict["RouteName"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var resourceList: [UpdateGatewayAuthConsumerResourceRequest.ResourceList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.resourceList != nil {
            var tmp : [Any] = []
            for k in self.resourceList! {
                tmp.append(k.toMap())
            }
            map["ResourceList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") && dict["ConsumerId"] != nil {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ResourceList") && dict["ResourceList"] != nil {
            var tmp : [UpdateGatewayAuthConsumerResourceRequest.ResourceList] = []
            for v in dict["ResourceList"] as! [Any] {
                var model = UpdateGatewayAuthConsumerResourceRequest.ResourceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceList = tmp
        }
    }
}

public class UpdateGatewayAuthConsumerResourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var resourceListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.resourceListShrink != nil {
            map["ResourceList"] = self.resourceListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") && dict["ConsumerId"] != nil {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ResourceList") && dict["ResourceList"] != nil {
            self.resourceListShrink = dict["ResourceList"] as! String
        }
    }
}

public class UpdateGatewayAuthConsumerResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayAuthConsumerResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayAuthConsumerResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayAuthConsumerResourceStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var idList: String?

    public var resourceStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.idList != nil {
            map["IdList"] = self.idList!
        }
        if self.resourceStatus != nil {
            map["ResourceStatus"] = self.resourceStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") && dict["ConsumerId"] != nil {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IdList") && dict["IdList"] != nil {
            self.idList = dict["IdList"] as! String
        }
        if dict.keys.contains("ResourceStatus") && dict["ResourceStatus"] != nil {
            self.resourceStatus = dict["ResourceStatus"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerResourceStatusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerResourceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayAuthConsumerResourceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayAuthConsumerResourceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayAuthConsumerStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerStatus: Bool?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerStatus != nil {
            map["ConsumerStatus"] = self.consumerStatus!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerStatus") && dict["ConsumerStatus"] != nil {
            self.consumerStatus = dict["ConsumerStatus"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayAuthConsumerStatusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayAuthConsumerStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayAuthConsumerStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var gatewayUniqueId: String?

    public var http2: String?

    public var id: Int64?

    public var mustHttps: Bool?

    public var protocol_: String?

    public var tlsMax: String?

    public var tlsMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.http2 != nil {
            map["Http2"] = self.http2!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mustHttps != nil {
            map["MustHttps"] = self.mustHttps!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.tlsMax != nil {
            map["TlsMax"] = self.tlsMax!
        }
        if self.tlsMin != nil {
            map["TlsMin"] = self.tlsMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") && dict["CertIdentifier"] != nil {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Http2") && dict["Http2"] != nil {
            self.http2 = dict["Http2"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MustHttps") && dict["MustHttps"] != nil {
            self.mustHttps = dict["MustHttps"] as! Bool
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TlsMax") && dict["TlsMax"] != nil {
            self.tlsMax = dict["TlsMax"] as! String
        }
        if dict.keys.contains("TlsMin") && dict["TlsMin"] != nil {
            self.tlsMin = dict["TlsMin"] as! String
        }
    }
}

public class UpdateGatewayDomainResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayNameRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateGatewayNameResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayOptionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayOption: GatewayOption?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewayOption?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayOption != nil {
            map["GatewayOption"] = self.gatewayOption?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayOption") && dict["GatewayOption"] != nil {
            var model = GatewayOption()
            model.fromMap(dict["GatewayOption"] as! [String: Any])
            self.gatewayOption = model
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class UpdateGatewayOptionShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayOptionShrink: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayOptionShrink != nil {
            map["GatewayOption"] = self.gatewayOptionShrink!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayOption") && dict["GatewayOption"] != nil {
            self.gatewayOptionShrink = dict["GatewayOption"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class UpdateGatewayOptionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GatewayOption?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GatewayOption()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayOptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayOptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayOptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteRequest : Tea.TeaModel {
    public class DirectResponseJSON : Tea.TeaModel {
        public var body: String?

        public var code: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.body != nil {
                map["Body"] = self.body!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Body") && dict["Body"] != nil {
                self.body = dict["Body"] as! String
            }
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! Int64
            }
        }
    }
    public class FallbackServices : Tea.TeaModel {
        public var agreementType: String?

        public var groupName: String?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") && dict["AgreementType"] != nil {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") && dict["Percent"] != nil {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public class Predicates : Tea.TeaModel {
        public class HeaderPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class PathPredicates : Tea.TeaModel {
            public var ignoreCase: Bool?

            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ignoreCase != nil {
                    map["IgnoreCase"] = self.ignoreCase!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IgnoreCase") && dict["IgnoreCase"] != nil {
                    self.ignoreCase = dict["IgnoreCase"] as! Bool
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class QueryPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var headerPredicates: [UpdateGatewayRouteRequest.Predicates.HeaderPredicates]?

        public var methodPredicates: [String]?

        public var pathPredicates: UpdateGatewayRouteRequest.Predicates.PathPredicates?

        public var queryPredicates: [UpdateGatewayRouteRequest.Predicates.QueryPredicates]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pathPredicates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerPredicates != nil {
                var tmp : [Any] = []
                for k in self.headerPredicates! {
                    tmp.append(k.toMap())
                }
                map["HeaderPredicates"] = tmp
            }
            if self.methodPredicates != nil {
                map["MethodPredicates"] = self.methodPredicates!
            }
            if self.pathPredicates != nil {
                map["PathPredicates"] = self.pathPredicates?.toMap()
            }
            if self.queryPredicates != nil {
                var tmp : [Any] = []
                for k in self.queryPredicates! {
                    tmp.append(k.toMap())
                }
                map["QueryPredicates"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HeaderPredicates") && dict["HeaderPredicates"] != nil {
                var tmp : [UpdateGatewayRouteRequest.Predicates.HeaderPredicates] = []
                for v in dict["HeaderPredicates"] as! [Any] {
                    var model = UpdateGatewayRouteRequest.Predicates.HeaderPredicates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.headerPredicates = tmp
            }
            if dict.keys.contains("MethodPredicates") && dict["MethodPredicates"] != nil {
                self.methodPredicates = dict["MethodPredicates"] as! [String]
            }
            if dict.keys.contains("PathPredicates") && dict["PathPredicates"] != nil {
                var model = UpdateGatewayRouteRequest.Predicates.PathPredicates()
                model.fromMap(dict["PathPredicates"] as! [String: Any])
                self.pathPredicates = model
            }
            if dict.keys.contains("QueryPredicates") && dict["QueryPredicates"] != nil {
                var tmp : [UpdateGatewayRouteRequest.Predicates.QueryPredicates] = []
                for v in dict["QueryPredicates"] as! [Any] {
                    var model = UpdateGatewayRouteRequest.Predicates.QueryPredicates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.queryPredicates = tmp
            }
        }
    }
    public class RedirectJSON : Tea.TeaModel {
        public var code: Int32?

        public var host: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! Int32
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class Services : Tea.TeaModel {
        public class HttpDubboTranscoder : Tea.TeaModel {
            public class MothedMapList : Tea.TeaModel {
                public class ParamMapsList : Tea.TeaModel {
                    public var extractKey: String?

                    public var extractKeySpec: String?

                    public var mappingType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extractKey != nil {
                            map["ExtractKey"] = self.extractKey!
                        }
                        if self.extractKeySpec != nil {
                            map["ExtractKeySpec"] = self.extractKeySpec!
                        }
                        if self.mappingType != nil {
                            map["MappingType"] = self.mappingType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtractKey") && dict["ExtractKey"] != nil {
                            self.extractKey = dict["ExtractKey"] as! String
                        }
                        if dict.keys.contains("ExtractKeySpec") && dict["ExtractKeySpec"] != nil {
                            self.extractKeySpec = dict["ExtractKeySpec"] as! String
                        }
                        if dict.keys.contains("MappingType") && dict["MappingType"] != nil {
                            self.mappingType = dict["MappingType"] as! String
                        }
                    }
                }
                public var dubboMothedName: String?

                public var httpMothed: String?

                public var mothedpath: String?

                public var paramMapsList: [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                public var passThroughAllHeaders: String?

                public var passThroughList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dubboMothedName != nil {
                        map["DubboMothedName"] = self.dubboMothedName!
                    }
                    if self.httpMothed != nil {
                        map["HttpMothed"] = self.httpMothed!
                    }
                    if self.mothedpath != nil {
                        map["Mothedpath"] = self.mothedpath!
                    }
                    if self.paramMapsList != nil {
                        var tmp : [Any] = []
                        for k in self.paramMapsList! {
                            tmp.append(k.toMap())
                        }
                        map["ParamMapsList"] = tmp
                    }
                    if self.passThroughAllHeaders != nil {
                        map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                    }
                    if self.passThroughList != nil {
                        map["PassThroughList"] = self.passThroughList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DubboMothedName") && dict["DubboMothedName"] != nil {
                        self.dubboMothedName = dict["DubboMothedName"] as! String
                    }
                    if dict.keys.contains("HttpMothed") && dict["HttpMothed"] != nil {
                        self.httpMothed = dict["HttpMothed"] as! String
                    }
                    if dict.keys.contains("Mothedpath") && dict["Mothedpath"] != nil {
                        self.mothedpath = dict["Mothedpath"] as! String
                    }
                    if dict.keys.contains("ParamMapsList") && dict["ParamMapsList"] != nil {
                        var tmp : [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList] = []
                        for v in dict["ParamMapsList"] as! [Any] {
                            var model = UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.paramMapsList = tmp
                    }
                    if dict.keys.contains("PassThroughAllHeaders") && dict["PassThroughAllHeaders"] != nil {
                        self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                    }
                    if dict.keys.contains("PassThroughList") && dict["PassThroughList"] != nil {
                        self.passThroughList = dict["PassThroughList"] as! [String]
                    }
                }
            }
            public var dubboServiceGroup: String?

            public var dubboServiceName: String?

            public var dubboServiceVersion: String?

            public var mothedMapList: [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dubboServiceGroup != nil {
                    map["DubboServiceGroup"] = self.dubboServiceGroup!
                }
                if self.dubboServiceName != nil {
                    map["DubboServiceName"] = self.dubboServiceName!
                }
                if self.dubboServiceVersion != nil {
                    map["DubboServiceVersion"] = self.dubboServiceVersion!
                }
                if self.mothedMapList != nil {
                    var tmp : [Any] = []
                    for k in self.mothedMapList! {
                        tmp.append(k.toMap())
                    }
                    map["MothedMapList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DubboServiceGroup") && dict["DubboServiceGroup"] != nil {
                    self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                }
                if dict.keys.contains("DubboServiceName") && dict["DubboServiceName"] != nil {
                    self.dubboServiceName = dict["DubboServiceName"] as! String
                }
                if dict.keys.contains("DubboServiceVersion") && dict["DubboServiceVersion"] != nil {
                    self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                }
                if dict.keys.contains("MothedMapList") && dict["MothedMapList"] != nil {
                    var tmp : [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList] = []
                    for v in dict["MothedMapList"] as! [Any] {
                        var model = UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.mothedMapList = tmp
                }
            }
        }
        public var agreementType: String?

        public var groupName: String?

        public var httpDubboTranscoder: UpdateGatewayRouteRequest.Services.HttpDubboTranscoder?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.httpDubboTranscoder?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.httpDubboTranscoder != nil {
                map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") && dict["AgreementType"] != nil {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HttpDubboTranscoder") && dict["HttpDubboTranscoder"] != nil {
                var model = UpdateGatewayRouteRequest.Services.HttpDubboTranscoder()
                model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                self.httpDubboTranscoder = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") && dict["Percent"] != nil {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var description_: String?

    public var destinationType: String?

    public var directResponseJSON: UpdateGatewayRouteRequest.DirectResponseJSON?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServices: [UpdateGatewayRouteRequest.FallbackServices]?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var name: String?

    public var predicates: UpdateGatewayRouteRequest.Predicates?

    public var redirectJSON: UpdateGatewayRouteRequest.RedirectJSON?

    public var routeOrder: Int32?

    public var services: [UpdateGatewayRouteRequest.Services]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.directResponseJSON?.validate()
        try self.predicates?.validate()
        try self.redirectJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSON != nil {
            map["DirectResponseJSON"] = self.directResponseJSON?.toMap()
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServices != nil {
            var tmp : [Any] = []
            for k in self.fallbackServices! {
                tmp.append(k.toMap())
            }
            map["FallbackServices"] = tmp
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.predicates != nil {
            map["Predicates"] = self.predicates?.toMap()
        }
        if self.redirectJSON != nil {
            map["RedirectJSON"] = self.redirectJSON?.toMap()
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationType") && dict["DestinationType"] != nil {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") && dict["DirectResponseJSON"] != nil {
            var model = UpdateGatewayRouteRequest.DirectResponseJSON()
            model.fromMap(dict["DirectResponseJSON"] as! [String: Any])
            self.directResponseJSON = model
        }
        if dict.keys.contains("DomainIdListJSON") && dict["DomainIdListJSON"] != nil {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") && dict["Fallback"] != nil {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") && dict["FallbackServices"] != nil {
            var tmp : [UpdateGatewayRouteRequest.FallbackServices] = []
            for v in dict["FallbackServices"] as! [Any] {
                var model = UpdateGatewayRouteRequest.FallbackServices()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fallbackServices = tmp
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Predicates") && dict["Predicates"] != nil {
            var model = UpdateGatewayRouteRequest.Predicates()
            model.fromMap(dict["Predicates"] as! [String: Any])
            self.predicates = model
        }
        if dict.keys.contains("RedirectJSON") && dict["RedirectJSON"] != nil {
            var model = UpdateGatewayRouteRequest.RedirectJSON()
            model.fromMap(dict["RedirectJSON"] as! [String: Any])
            self.redirectJSON = model
        }
        if dict.keys.contains("RouteOrder") && dict["RouteOrder"] != nil {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("Services") && dict["Services"] != nil {
            var tmp : [UpdateGatewayRouteRequest.Services] = []
            for v in dict["Services"] as! [Any] {
                var model = UpdateGatewayRouteRequest.Services()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.services = tmp
        }
    }
}

public class UpdateGatewayRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var destinationType: String?

    public var directResponseJSONShrink: String?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServicesShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var name: String?

    public var predicatesShrink: String?

    public var redirectJSONShrink: String?

    public var routeOrder: Int32?

    public var servicesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSONShrink != nil {
            map["DirectResponseJSON"] = self.directResponseJSONShrink!
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServicesShrink != nil {
            map["FallbackServices"] = self.fallbackServicesShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.predicatesShrink != nil {
            map["Predicates"] = self.predicatesShrink!
        }
        if self.redirectJSONShrink != nil {
            map["RedirectJSON"] = self.redirectJSONShrink!
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.servicesShrink != nil {
            map["Services"] = self.servicesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationType") && dict["DestinationType"] != nil {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") && dict["DirectResponseJSON"] != nil {
            self.directResponseJSONShrink = dict["DirectResponseJSON"] as! String
        }
        if dict.keys.contains("DomainIdListJSON") && dict["DomainIdListJSON"] != nil {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") && dict["Fallback"] != nil {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") && dict["FallbackServices"] != nil {
            self.fallbackServicesShrink = dict["FallbackServices"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Predicates") && dict["Predicates"] != nil {
            self.predicatesShrink = dict["Predicates"] as! String
        }
        if dict.keys.contains("RedirectJSON") && dict["RedirectJSON"] != nil {
            self.redirectJSONShrink = dict["RedirectJSON"] as! String
        }
        if dict.keys.contains("RouteOrder") && dict["RouteOrder"] != nil {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("Services") && dict["Services"] != nil {
            self.servicesShrink = dict["Services"] as! String
        }
    }
}

public class UpdateGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteAuthRequest : Tea.TeaModel {
    public class AuthJSON : Tea.TeaModel {
        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var authJSON: UpdateGatewayRouteAuthRequest.AuthJSON?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authJSON != nil {
            map["AuthJSON"] = self.authJSON?.toMap()
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthJSON") && dict["AuthJSON"] != nil {
            var model = UpdateGatewayRouteAuthRequest.AuthJSON()
            model.fromMap(dict["AuthJSON"] as! [String: Any])
            self.authJSON = model
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteAuthShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var authJSONShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authJSONShrink != nil {
            map["AuthJSON"] = self.authJSONShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthJSON") && dict["AuthJSON"] != nil {
            self.authJSONShrink = dict["AuthJSON"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteAuthResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("DynamicCode") && dict["DynamicCode"] != nil {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayRouteAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteCORSRequest : Tea.TeaModel {
    public class CorsJSON : Tea.TeaModel {
        public var allowCredentials: Bool?

        public var allowHeaders: String?

        public var allowMethods: String?

        public var allowOrigins: String?

        public var exposeHeaders: String?

        public var status: String?

        public var timeUnit: String?

        public var unitNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowCredentials != nil {
                map["AllowCredentials"] = self.allowCredentials!
            }
            if self.allowHeaders != nil {
                map["AllowHeaders"] = self.allowHeaders!
            }
            if self.allowMethods != nil {
                map["AllowMethods"] = self.allowMethods!
            }
            if self.allowOrigins != nil {
                map["AllowOrigins"] = self.allowOrigins!
            }
            if self.exposeHeaders != nil {
                map["ExposeHeaders"] = self.exposeHeaders!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeUnit != nil {
                map["TimeUnit"] = self.timeUnit!
            }
            if self.unitNum != nil {
                map["UnitNum"] = self.unitNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowCredentials") && dict["AllowCredentials"] != nil {
                self.allowCredentials = dict["AllowCredentials"] as! Bool
            }
            if dict.keys.contains("AllowHeaders") && dict["AllowHeaders"] != nil {
                self.allowHeaders = dict["AllowHeaders"] as! String
            }
            if dict.keys.contains("AllowMethods") && dict["AllowMethods"] != nil {
                self.allowMethods = dict["AllowMethods"] as! String
            }
            if dict.keys.contains("AllowOrigins") && dict["AllowOrigins"] != nil {
                self.allowOrigins = dict["AllowOrigins"] as! String
            }
            if dict.keys.contains("ExposeHeaders") && dict["ExposeHeaders"] != nil {
                self.exposeHeaders = dict["ExposeHeaders"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TimeUnit") && dict["TimeUnit"] != nil {
                self.timeUnit = dict["TimeUnit"] as! String
            }
            if dict.keys.contains("UnitNum") && dict["UnitNum"] != nil {
                self.unitNum = dict["UnitNum"] as! Int64
            }
        }
    }
    public var acceptLanguage: String?

    public var corsJSON: UpdateGatewayRouteCORSRequest.CorsJSON?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.corsJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.corsJSON != nil {
            map["CorsJSON"] = self.corsJSON?.toMap()
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CorsJSON") && dict["CorsJSON"] != nil {
            var model = UpdateGatewayRouteCORSRequest.CorsJSON()
            model.fromMap(dict["CorsJSON"] as! [String: Any])
            self.corsJSON = model
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteCORSShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var corsJSONShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.corsJSONShrink != nil {
            map["CorsJSON"] = self.corsJSONShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CorsJSON") && dict["CorsJSON"] != nil {
            self.corsJSONShrink = dict["CorsJSON"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteCORSResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteCORSResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteCORSResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayRouteCORSResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteHTTPRewriteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var httpRewriteJSON: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.httpRewriteJSON != nil {
            map["HttpRewriteJSON"] = self.httpRewriteJSON!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HttpRewriteJSON") && dict["HttpRewriteJSON"] != nil {
            self.httpRewriteJSON = dict["HttpRewriteJSON"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteHTTPRewriteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteHTTPRewriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteHTTPRewriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayRouteHTTPRewriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteHeaderOpRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var headerOpJSON: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.headerOpJSON != nil {
            map["HeaderOpJSON"] = self.headerOpJSON!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HeaderOpJSON") && dict["HeaderOpJSON"] != nil {
            self.headerOpJSON = dict["HeaderOpJSON"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteHeaderOpResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteHeaderOpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteHeaderOpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayRouteHeaderOpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteRetryRequest : Tea.TeaModel {
    public class RetryJSON : Tea.TeaModel {
        public var attempts: Int32?

        public var httpCodes: [String]?

        public var retryOn: [String]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attempts != nil {
                map["Attempts"] = self.attempts!
            }
            if self.httpCodes != nil {
                map["HttpCodes"] = self.httpCodes!
            }
            if self.retryOn != nil {
                map["RetryOn"] = self.retryOn!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attempts") && dict["Attempts"] != nil {
                self.attempts = dict["Attempts"] as! Int32
            }
            if dict.keys.contains("HttpCodes") && dict["HttpCodes"] != nil {
                self.httpCodes = dict["HttpCodes"] as! [String]
            }
            if dict.keys.contains("RetryOn") && dict["RetryOn"] != nil {
                self.retryOn = dict["RetryOn"] as! [String]
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var retryJSON: UpdateGatewayRouteRetryRequest.RetryJSON?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.retryJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.retryJSON != nil {
            map["RetryJSON"] = self.retryJSON?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RetryJSON") && dict["RetryJSON"] != nil {
            var model = UpdateGatewayRouteRetryRequest.RetryJSON()
            model.fromMap(dict["RetryJSON"] as! [String: Any])
            self.retryJSON = model
        }
    }
}

public class UpdateGatewayRouteRetryShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var retryJSONShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.retryJSONShrink != nil {
            map["RetryJSON"] = self.retryJSONShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RetryJSON") && dict["RetryJSON"] != nil {
            self.retryJSONShrink = dict["RetryJSON"] as! String
        }
    }
}

public class UpdateGatewayRouteRetryResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteRetryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteRetryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayRouteRetryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteTimeoutRequest : Tea.TeaModel {
    public class TimeoutJSON : Tea.TeaModel {
        public var status: String?

        public var timeUnit: String?

        public var unitNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeUnit != nil {
                map["TimeUnit"] = self.timeUnit!
            }
            if self.unitNum != nil {
                map["UnitNum"] = self.unitNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TimeUnit") && dict["TimeUnit"] != nil {
                self.timeUnit = dict["TimeUnit"] as! String
            }
            if dict.keys.contains("UnitNum") && dict["UnitNum"] != nil {
                self.unitNum = dict["UnitNum"] as! Int32
            }
        }
    }
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var timeoutJSON: UpdateGatewayRouteTimeoutRequest.TimeoutJSON?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.timeoutJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.timeoutJSON != nil {
            map["TimeoutJSON"] = self.timeoutJSON?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TimeoutJSON") && dict["TimeoutJSON"] != nil {
            var model = UpdateGatewayRouteTimeoutRequest.TimeoutJSON()
            model.fromMap(dict["TimeoutJSON"] as! [String: Any])
            self.timeoutJSON = model
        }
    }
}

public class UpdateGatewayRouteTimeoutShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var timeoutJSONShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.timeoutJSONShrink != nil {
            map["TimeoutJSON"] = self.timeoutJSONShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TimeoutJSON") && dict["TimeoutJSON"] != nil {
            self.timeoutJSONShrink = dict["TimeoutJSON"] as! String
        }
    }
}

public class UpdateGatewayRouteTimeoutResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteTimeoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteTimeoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayRouteTimeoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteWafStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var enableWaf: Bool?

    public var gatewayUniqueId: String?

    public var routeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") && dict["RouteId"] != nil {
            self.routeId = dict["RouteId"] as! Int64
        }
    }
}

public class UpdateGatewayRouteWafStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Cors : Tea.TeaModel {
            public var allowCredentials: Bool?

            public var allowHeaders: String?

            public var allowMethods: String?

            public var allowOrigins: String?

            public var exposeHeaders: String?

            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowCredentials != nil {
                    map["AllowCredentials"] = self.allowCredentials!
                }
                if self.allowHeaders != nil {
                    map["AllowHeaders"] = self.allowHeaders!
                }
                if self.allowMethods != nil {
                    map["AllowMethods"] = self.allowMethods!
                }
                if self.allowOrigins != nil {
                    map["AllowOrigins"] = self.allowOrigins!
                }
                if self.exposeHeaders != nil {
                    map["ExposeHeaders"] = self.exposeHeaders!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowCredentials") && dict["AllowCredentials"] != nil {
                    self.allowCredentials = dict["AllowCredentials"] as! Bool
                }
                if dict.keys.contains("AllowHeaders") && dict["AllowHeaders"] != nil {
                    self.allowHeaders = dict["AllowHeaders"] as! String
                }
                if dict.keys.contains("AllowMethods") && dict["AllowMethods"] != nil {
                    self.allowMethods = dict["AllowMethods"] as! String
                }
                if dict.keys.contains("AllowOrigins") && dict["AllowOrigins"] != nil {
                    self.allowOrigins = dict["AllowOrigins"] as! String
                }
                if dict.keys.contains("ExposeHeaders") && dict["ExposeHeaders"] != nil {
                    self.exposeHeaders = dict["ExposeHeaders"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") && dict["TimeUnit"] != nil {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") && dict["UnitNum"] != nil {
                    self.unitNum = dict["UnitNum"] as! Int64
                }
            }
        }
        public class DirectResponse : Tea.TeaModel {
            public var body: String?

            public var code: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") && dict["Body"] != nil {
                    self.body = dict["Body"] as! String
                }
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! Int32
                }
            }
        }
        public class HTTPRewrite : Tea.TeaModel {
            public var host: String?

            public var path: String?

            public var pathType: String?

            public var pattern: String?

            public var status: String?

            public var substitution: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.pathType != nil {
                    map["PathType"] = self.pathType!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.substitution != nil {
                    map["Substitution"] = self.substitution!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("PathType") && dict["PathType"] != nil {
                    self.pathType = dict["PathType"] as! String
                }
                if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                    self.pattern = dict["Pattern"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Substitution") && dict["Substitution"] != nil {
                    self.substitution = dict["Substitution"] as! String
                }
            }
        }
        public class HeaderOp : Tea.TeaModel {
            public class HeaderOpItems : Tea.TeaModel {
                public var directionType: String?

                public var key: String?

                public var opType: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.directionType != nil {
                        map["DirectionType"] = self.directionType!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.opType != nil {
                        map["OpType"] = self.opType!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DirectionType") && dict["DirectionType"] != nil {
                        self.directionType = dict["DirectionType"] as! String
                    }
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("OpType") && dict["OpType"] != nil {
                        self.opType = dict["OpType"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerOpItems: [UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp.HeaderOpItems]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerOpItems != nil {
                    var tmp : [Any] = []
                    for k in self.headerOpItems! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderOpItems"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderOpItems") && dict["HeaderOpItems"] != nil {
                    var tmp : [UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp.HeaderOpItems] = []
                    for v in dict["HeaderOpItems"] as! [Any] {
                        var model = UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp.HeaderOpItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerOpItems = tmp
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Redirect : Tea.TeaModel {
            public var code: Int32?

            public var host: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! Int32
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public class Retry : Tea.TeaModel {
            public var attempts: Int32?

            public var httpCodes: [String]?

            public var retryOn: [String]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attempts != nil {
                    map["Attempts"] = self.attempts!
                }
                if self.httpCodes != nil {
                    map["HttpCodes"] = self.httpCodes!
                }
                if self.retryOn != nil {
                    map["RetryOn"] = self.retryOn!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attempts") && dict["Attempts"] != nil {
                    self.attempts = dict["Attempts"] as! Int32
                }
                if dict.keys.contains("HttpCodes") && dict["HttpCodes"] != nil {
                    self.httpCodes = dict["HttpCodes"] as! [String]
                }
                if dict.keys.contains("RetryOn") && dict["RetryOn"] != nil {
                    self.retryOn = dict["RetryOn"] as! [String]
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RoutePredicates : Tea.TeaModel {
            public class HeaderPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class PathPredicates : Tea.TeaModel {
                public var ignoreCase: Bool?

                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ignoreCase != nil {
                        map["IgnoreCase"] = self.ignoreCase!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IgnoreCase") && dict["IgnoreCase"] != nil {
                        self.ignoreCase = dict["IgnoreCase"] as! Bool
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class QueryPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerPredicates: [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.HeaderPredicates]?

            public var methodPredicates: [String]?

            public var pathPredicates: UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.PathPredicates?

            public var queryPredicates: [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.QueryPredicates]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pathPredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.headerPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderPredicates"] = tmp
                }
                if self.methodPredicates != nil {
                    map["MethodPredicates"] = self.methodPredicates!
                }
                if self.pathPredicates != nil {
                    map["PathPredicates"] = self.pathPredicates?.toMap()
                }
                if self.queryPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.queryPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["QueryPredicates"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderPredicates") && dict["HeaderPredicates"] != nil {
                    var tmp : [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.HeaderPredicates] = []
                    for v in dict["HeaderPredicates"] as! [Any] {
                        var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.HeaderPredicates()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerPredicates = tmp
                }
                if dict.keys.contains("MethodPredicates") && dict["MethodPredicates"] != nil {
                    self.methodPredicates = dict["MethodPredicates"] as! [String]
                }
                if dict.keys.contains("PathPredicates") && dict["PathPredicates"] != nil {
                    var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.PathPredicates()
                    model.fromMap(dict["PathPredicates"] as! [String: Any])
                    self.pathPredicates = model
                }
                if dict.keys.contains("QueryPredicates") && dict["QueryPredicates"] != nil {
                    var tmp : [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.QueryPredicates] = []
                    for v in dict["QueryPredicates"] as! [Any] {
                        var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.QueryPredicates()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.queryPredicates = tmp
                }
            }
        }
        public class RouteServices : Tea.TeaModel {
            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var percent: Int32?

            public var serviceId: Int64?

            public var serviceName: String?

            public var sourceType: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Percent") && dict["Percent"] != nil {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Timeout : Tea.TeaModel {
            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") && dict["TimeUnit"] != nil {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") && dict["UnitNum"] != nil {
                    self.unitNum = dict["UnitNum"] as! Int32
                }
            }
        }
        public var cors: UpdateGatewayRouteWafStatusResponseBody.Data.Cors?

        public var defaultServiceId: Int64?

        public var defaultServiceName: String?

        public var destinationType: String?

        public var directResponse: UpdateGatewayRouteWafStatusResponseBody.Data.DirectResponse?

        public var domainId: Int64?

        public var domainIdList: [Int64]?

        public var domainName: String?

        public var domainNameList: [String]?

        public var enableWaf: Bool?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var HTTPRewrite: UpdateGatewayRouteWafStatusResponseBody.Data.HTTPRewrite?

        public var headerOp: UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp?

        public var id: Int64?

        public var name: String?

        public var predicates: String?

        public var redirect: UpdateGatewayRouteWafStatusResponseBody.Data.Redirect?

        public var retry: UpdateGatewayRouteWafStatusResponseBody.Data.Retry?

        public var routeOrder: Int32?

        public var routePredicates: UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates?

        public var routeServices: [UpdateGatewayRouteWafStatusResponseBody.Data.RouteServices]?

        public var services: String?

        public var status: Int32?

        public var timeout: UpdateGatewayRouteWafStatusResponseBody.Data.Timeout?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cors?.validate()
            try self.directResponse?.validate()
            try self.HTTPRewrite?.validate()
            try self.headerOp?.validate()
            try self.redirect?.validate()
            try self.retry?.validate()
            try self.routePredicates?.validate()
            try self.timeout?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cors != nil {
                map["Cors"] = self.cors?.toMap()
            }
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.defaultServiceName != nil {
                map["DefaultServiceName"] = self.defaultServiceName!
            }
            if self.destinationType != nil {
                map["DestinationType"] = self.destinationType!
            }
            if self.directResponse != nil {
                map["DirectResponse"] = self.directResponse?.toMap()
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainIdList != nil {
                map["DomainIdList"] = self.domainIdList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameList != nil {
                map["DomainNameList"] = self.domainNameList!
            }
            if self.enableWaf != nil {
                map["EnableWaf"] = self.enableWaf!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.HTTPRewrite != nil {
                map["HTTPRewrite"] = self.HTTPRewrite?.toMap()
            }
            if self.headerOp != nil {
                map["HeaderOp"] = self.headerOp?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.predicates != nil {
                map["Predicates"] = self.predicates!
            }
            if self.redirect != nil {
                map["Redirect"] = self.redirect?.toMap()
            }
            if self.retry != nil {
                map["Retry"] = self.retry?.toMap()
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.routePredicates != nil {
                map["RoutePredicates"] = self.routePredicates?.toMap()
            }
            if self.routeServices != nil {
                var tmp : [Any] = []
                for k in self.routeServices! {
                    tmp.append(k.toMap())
                }
                map["RouteServices"] = tmp
            }
            if self.services != nil {
                map["Services"] = self.services!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cors") && dict["Cors"] != nil {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Cors()
                model.fromMap(dict["Cors"] as! [String: Any])
                self.cors = model
            }
            if dict.keys.contains("DefaultServiceId") && dict["DefaultServiceId"] != nil {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("DefaultServiceName") && dict["DefaultServiceName"] != nil {
                self.defaultServiceName = dict["DefaultServiceName"] as! String
            }
            if dict.keys.contains("DestinationType") && dict["DestinationType"] != nil {
                self.destinationType = dict["DestinationType"] as! String
            }
            if dict.keys.contains("DirectResponse") && dict["DirectResponse"] != nil {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.DirectResponse()
                model.fromMap(dict["DirectResponse"] as! [String: Any])
                self.directResponse = model
            }
            if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainIdList") && dict["DomainIdList"] != nil {
                self.domainIdList = dict["DomainIdList"] as! [Int64]
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainNameList") && dict["DomainNameList"] != nil {
                self.domainNameList = dict["DomainNameList"] as! [String]
            }
            if dict.keys.contains("EnableWaf") && dict["EnableWaf"] != nil {
                self.enableWaf = dict["EnableWaf"] as! Bool
            }
            if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("HTTPRewrite") && dict["HTTPRewrite"] != nil {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.HTTPRewrite()
                model.fromMap(dict["HTTPRewrite"] as! [String: Any])
                self.HTTPRewrite = model
            }
            if dict.keys.contains("HeaderOp") && dict["HeaderOp"] != nil {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp()
                model.fromMap(dict["HeaderOp"] as! [String: Any])
                self.headerOp = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Predicates") && dict["Predicates"] != nil {
                self.predicates = dict["Predicates"] as! String
            }
            if dict.keys.contains("Redirect") && dict["Redirect"] != nil {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Redirect()
                model.fromMap(dict["Redirect"] as! [String: Any])
                self.redirect = model
            }
            if dict.keys.contains("Retry") && dict["Retry"] != nil {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Retry()
                model.fromMap(dict["Retry"] as! [String: Any])
                self.retry = model
            }
            if dict.keys.contains("RouteOrder") && dict["RouteOrder"] != nil {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("RoutePredicates") && dict["RoutePredicates"] != nil {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates()
                model.fromMap(dict["RoutePredicates"] as! [String: Any])
                self.routePredicates = model
            }
            if dict.keys.contains("RouteServices") && dict["RouteServices"] != nil {
                var tmp : [UpdateGatewayRouteWafStatusResponseBody.Data.RouteServices] = []
                for v in dict["RouteServices"] as! [Any] {
                    var model = UpdateGatewayRouteWafStatusResponseBody.Data.RouteServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routeServices = tmp
            }
            if dict.keys.contains("Services") && dict["Services"] != nil {
                self.services = dict["Services"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Timeout()
                model.fromMap(dict["Timeout"] as! [String: Any])
                self.timeout = model
            }
        }
    }
    public var code: Int32?

    public var data: UpdateGatewayRouteWafStatusResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateGatewayRouteWafStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteWafStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteWafStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayRouteWafStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayServiceCheckRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var check: Bool?

    public var expectedStatuses: [Int32]?

    public var gatewayUniqueId: String?

    public var healthyThreshold: Int32?

    public var httpHost: String?

    public var httpPath: String?

    public var interval: Int32?

    public var protocol_: String?

    public var serviceId: String?

    public var timeout: Int32?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.check != nil {
            map["Check"] = self.check!
        }
        if self.expectedStatuses != nil {
            map["ExpectedStatuses"] = self.expectedStatuses!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.httpHost != nil {
            map["HttpHost"] = self.httpHost!
        }
        if self.httpPath != nil {
            map["HttpPath"] = self.httpPath!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Check") && dict["Check"] != nil {
            self.check = dict["Check"] as! Bool
        }
        if dict.keys.contains("ExpectedStatuses") && dict["ExpectedStatuses"] != nil {
            self.expectedStatuses = dict["ExpectedStatuses"] as! [Int32]
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("HttpHost") && dict["HttpHost"] != nil {
            self.httpHost = dict["HttpHost"] as! String
        }
        if dict.keys.contains("HttpPath") && dict["HttpPath"] != nil {
            self.httpPath = dict["HttpPath"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class UpdateGatewayServiceCheckShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var check: Bool?

    public var expectedStatusesShrink: String?

    public var gatewayUniqueId: String?

    public var healthyThreshold: Int32?

    public var httpHost: String?

    public var httpPath: String?

    public var interval: Int32?

    public var protocol_: String?

    public var serviceId: String?

    public var timeout: Int32?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.check != nil {
            map["Check"] = self.check!
        }
        if self.expectedStatusesShrink != nil {
            map["ExpectedStatuses"] = self.expectedStatusesShrink!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.httpHost != nil {
            map["HttpHost"] = self.httpHost!
        }
        if self.httpPath != nil {
            map["HttpPath"] = self.httpPath!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Check") && dict["Check"] != nil {
            self.check = dict["Check"] as! Bool
        }
        if dict.keys.contains("ExpectedStatuses") && dict["ExpectedStatuses"] != nil {
            self.expectedStatusesShrink = dict["ExpectedStatuses"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("HttpHost") && dict["HttpHost"] != nil {
            self.httpHost = dict["HttpHost"] as! String
        }
        if dict.keys.contains("HttpPath") && dict["HttpPath"] != nil {
            self.httpPath = dict["HttpPath"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class UpdateGatewayServiceCheckResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayServiceCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayServiceCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayServiceCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayTrafficPolicy: TrafficPolicy?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewayTrafficPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayTrafficPolicy != nil {
            map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayTrafficPolicy") && dict["GatewayTrafficPolicy"] != nil {
            var model = TrafficPolicy()
            model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
            self.gatewayTrafficPolicy = model
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! Int64
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayTrafficPolicyShrink: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayTrafficPolicyShrink != nil {
            map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicyShrink!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayTrafficPolicy") && dict["GatewayTrafficPolicy"] != nil {
            self.gatewayTrafficPolicyShrink = dict["GatewayTrafficPolicy"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! Int64
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GatewayService?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GatewayService()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayServiceTrafficPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayServiceTrafficPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayServiceVersionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! Int64
        }
        if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class UpdateGatewayServiceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayServiceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayServiceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewayServiceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewaySpecRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var replica: Int32?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.replica != nil {
            map["Replica"] = self.replica!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Replica") && dict["Replica"] != nil {
            self.replica = dict["Replica"] as! Int32
        }
        if dict.keys.contains("Spec") && dict["Spec"] != nil {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class UpdateGatewaySpecResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewaySpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewaySpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateGatewaySpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateImageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class UpdateImageResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMessageQueueRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var filterSide: String?

    public var namespace: String?

    public var region: String?

    public var tags: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.filterSide != nil {
            map["FilterSide"] = self.filterSide!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("FilterSide") && dict["FilterSide"] != nil {
            self.filterSide = dict["FilterSide"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! [String]
        }
    }
}

public class UpdateMessageQueueRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var filterSide: String?

    public var namespace: String?

    public var region: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.filterSide != nil {
            map["FilterSide"] = self.filterSide!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("FilterSide") && dict["FilterSide"] != nil {
            self.filterSide = dict["FilterSide"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class UpdateMessageQueueRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateMessageQueueRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMessageQueueRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMessageQueueRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMigrationTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var id: String?

    public var originInstanceAddress: String?

    public var originInstanceName: String?

    public var originInstanceNamespace: String?

    public var projectDesc: String?

    public var requestPars: String?

    public var targetClusterName: String?

    public var targetClusterUrl: String?

    public var targetInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.originInstanceAddress != nil {
            map["OriginInstanceAddress"] = self.originInstanceAddress!
        }
        if self.originInstanceName != nil {
            map["OriginInstanceName"] = self.originInstanceName!
        }
        if self.originInstanceNamespace != nil {
            map["OriginInstanceNamespace"] = self.originInstanceNamespace!
        }
        if self.projectDesc != nil {
            map["ProjectDesc"] = self.projectDesc!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.targetClusterName != nil {
            map["TargetClusterName"] = self.targetClusterName!
        }
        if self.targetClusterUrl != nil {
            map["TargetClusterUrl"] = self.targetClusterUrl!
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("OriginInstanceAddress") && dict["OriginInstanceAddress"] != nil {
            self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
        }
        if dict.keys.contains("OriginInstanceName") && dict["OriginInstanceName"] != nil {
            self.originInstanceName = dict["OriginInstanceName"] as! String
        }
        if dict.keys.contains("OriginInstanceNamespace") && dict["OriginInstanceNamespace"] != nil {
            self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
        }
        if dict.keys.contains("ProjectDesc") && dict["ProjectDesc"] != nil {
            self.projectDesc = dict["ProjectDesc"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("TargetClusterName") && dict["TargetClusterName"] != nil {
            self.targetClusterName = dict["TargetClusterName"] as! String
        }
        if dict.keys.contains("TargetClusterUrl") && dict["TargetClusterUrl"] != nil {
            self.targetClusterUrl = dict["TargetClusterUrl"] as! String
        }
        if dict.keys.contains("TargetInstanceId") && dict["TargetInstanceId"] != nil {
            self.targetInstanceId = dict["TargetInstanceId"] as! String
        }
    }
}

public class UpdateMigrationTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterType: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: String?

        public var originInstanceAddress: String?

        public var originInstanceName: String?

        public var originInstanceNamespace: String?

        public var projectDesc: String?

        public var targetClusterName: String?

        public var targetClusterUrl: String?

        public var targetInstanceId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.originInstanceAddress != nil {
                map["OriginInstanceAddress"] = self.originInstanceAddress!
            }
            if self.originInstanceName != nil {
                map["OriginInstanceName"] = self.originInstanceName!
            }
            if self.originInstanceNamespace != nil {
                map["OriginInstanceNamespace"] = self.originInstanceNamespace!
            }
            if self.projectDesc != nil {
                map["ProjectDesc"] = self.projectDesc!
            }
            if self.targetClusterName != nil {
                map["TargetClusterName"] = self.targetClusterName!
            }
            if self.targetClusterUrl != nil {
                map["TargetClusterUrl"] = self.targetClusterUrl!
            }
            if self.targetInstanceId != nil {
                map["TargetInstanceId"] = self.targetInstanceId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("OriginInstanceAddress") && dict["OriginInstanceAddress"] != nil {
                self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
            }
            if dict.keys.contains("OriginInstanceName") && dict["OriginInstanceName"] != nil {
                self.originInstanceName = dict["OriginInstanceName"] as! String
            }
            if dict.keys.contains("OriginInstanceNamespace") && dict["OriginInstanceNamespace"] != nil {
                self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
            }
            if dict.keys.contains("ProjectDesc") && dict["ProjectDesc"] != nil {
                self.projectDesc = dict["ProjectDesc"] as! String
            }
            if dict.keys.contains("TargetClusterName") && dict["TargetClusterName"] != nil {
                self.targetClusterName = dict["TargetClusterName"] as! String
            }
            if dict.keys.contains("TargetClusterUrl") && dict["TargetClusterUrl"] != nil {
                self.targetClusterUrl = dict["TargetClusterUrl"] as! String
            }
            if dict.keys.contains("TargetInstanceId") && dict["TargetInstanceId"] != nil {
                self.targetInstanceId = dict["TargetInstanceId"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var data: UpdateMigrationTaskResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateMigrationTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateMigrationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMigrationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMigrationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var checkPort: Int32?

    public var clusterName: String?

    public var groupName: String?

    public var healthChecker: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var serviceName: String?

    public var useInstancePortForCheck: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.checkPort != nil {
            map["CheckPort"] = self.checkPort!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.healthChecker != nil {
            map["HealthChecker"] = self.healthChecker!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.useInstancePortForCheck != nil {
            map["UseInstancePortForCheck"] = self.useInstancePortForCheck!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CheckPort") && dict["CheckPort"] != nil {
            self.checkPort = dict["CheckPort"] as! Int32
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HealthChecker") && dict["HealthChecker"] != nil {
            self.healthChecker = dict["HealthChecker"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("UseInstancePortForCheck") && dict["UseInstancePortForCheck"] != nil {
            self.useInstancePortForCheck = dict["UseInstancePortForCheck"] as! Bool
        }
    }
}

public class UpdateNacosClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateNacosClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var betaIps: String?

    public var content: String?

    public var dataId: String?

    public var desc: String?

    public var encryptedDataKey: String?

    public var group: String?

    public var instanceId: String?

    public var md5: String?

    public var namespaceId: String?

    public var tags: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.betaIps != nil {
            map["BetaIps"] = self.betaIps!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.encryptedDataKey != nil {
            map["EncryptedDataKey"] = self.encryptedDataKey!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.md5 != nil {
            map["Md5"] = self.md5!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BetaIps") && dict["BetaIps"] != nil {
            self.betaIps = dict["BetaIps"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataId") && dict["DataId"] != nil {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("EncryptedDataKey") && dict["EncryptedDataKey"] != nil {
            self.encryptedDataKey = dict["EncryptedDataKey"] as! String
        }
        if dict.keys.contains("Group") && dict["Group"] != nil {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Md5") && dict["Md5"] != nil {
            self.md5 = dict["Md5"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateNacosConfigResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosInstanceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterName: String?

    public var enabled: Bool?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var ip: String?

    public var metadata: String?

    public var namespaceId: String?

    public var port: Int32?

    public var serviceName: String?

    public var weight: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.metadata != nil {
            map["Metadata"] = self.metadata!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Enabled") && dict["Enabled"] != nil {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Ephemeral") && dict["Ephemeral"] != nil {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Metadata") && dict["Metadata"] != nil {
            self.metadata = dict["Metadata"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Weight") && dict["Weight"] != nil {
            self.weight = dict["Weight"] as! String
        }
    }
}

public class UpdateNacosInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateNacosInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var protectThreshold: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.protectThreshold != nil {
            map["ProtectThreshold"] = self.protectThreshold!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ProtectThreshold") && dict["ProtectThreshold"] != nil {
            self.protectThreshold = dict["ProtectThreshold"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class UpdateNacosServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateNacosServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePluginConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var config: String?

    public var configLevel: Int32?

    public var enable: Bool?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var id: Int64?

    public var pluginId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.configLevel != nil {
            map["ConfigLevel"] = self.configLevel!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("ConfigLevel") && dict["ConfigLevel"] != nil {
            self.configLevel = dict["ConfigLevel"] as! Int32
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PluginId") && dict["PluginId"] != nil {
            self.pluginId = dict["PluginId"] as! Int64
        }
    }
}

public class UpdatePluginConfigResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("DynamicMessage") && dict["DynamicMessage"] != nil {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePluginConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePluginConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdatePluginConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSSLCertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") && dict["CertIdentifier"] != nil {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("DomainId") && dict["DomainId"] != nil {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class UpdateSSLCertResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateSSLCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSSLCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSSLCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateServiceSourceRequest : Tea.TeaModel {
    public class IngressOptionsRequest : Tea.TeaModel {
        public var enableIngress: Bool?

        public var enableStatus: Bool?

        public var ingressClass: String?

        public var watchNamespace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableIngress != nil {
                map["EnableIngress"] = self.enableIngress!
            }
            if self.enableStatus != nil {
                map["EnableStatus"] = self.enableStatus!
            }
            if self.ingressClass != nil {
                map["IngressClass"] = self.ingressClass!
            }
            if self.watchNamespace != nil {
                map["WatchNamespace"] = self.watchNamespace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableIngress") && dict["EnableIngress"] != nil {
                self.enableIngress = dict["EnableIngress"] as! Bool
            }
            if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
                self.enableStatus = dict["EnableStatus"] as! Bool
            }
            if dict.keys.contains("IngressClass") && dict["IngressClass"] != nil {
                self.ingressClass = dict["IngressClass"] as! String
            }
            if dict.keys.contains("WatchNamespace") && dict["WatchNamespace"] != nil {
                self.watchNamespace = dict["WatchNamespace"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var ingressOptionsRequest: UpdateServiceSourceRequest.IngressOptionsRequest?

    public var name: String?

    public var pathList: [String]?

    public var source: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ingressOptionsRequest?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ingressOptionsRequest != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequest?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pathList != nil {
            map["PathList"] = self.pathList!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IngressOptionsRequest") && dict["IngressOptionsRequest"] != nil {
            var model = UpdateServiceSourceRequest.IngressOptionsRequest()
            model.fromMap(dict["IngressOptionsRequest"] as! [String: Any])
            self.ingressOptionsRequest = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PathList") && dict["PathList"] != nil {
            self.pathList = dict["PathList"] as! [String]
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateServiceSourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var ingressOptionsRequestShrink: String?

    public var name: String?

    public var pathListShrink: String?

    public var source: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ingressOptionsRequestShrink != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequestShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pathListShrink != nil {
            map["PathList"] = self.pathListShrink!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayId") && dict["GatewayId"] != nil {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") && dict["GatewayUniqueId"] != nil {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IngressOptionsRequest") && dict["IngressOptionsRequest"] != nil {
            self.ingressOptionsRequestShrink = dict["IngressOptionsRequest"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PathList") && dict["PathList"] != nil {
            self.pathListShrink = dict["PathList"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateServiceSourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateZnodeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var data: String?

    public var path: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class UpdateZnodeResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateZnodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateZnodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateZnodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var requestPars: String?

    public var upgradeVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.upgradeVersion != nil {
            map["UpgradeVersion"] = self.upgradeVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") && dict["AcceptLanguage"] != nil {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestPars") && dict["RequestPars"] != nil {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("UpgradeVersion") && dict["UpgradeVersion"] != nil {
            self.upgradeVersion = dict["UpgradeVersion"] as! String
        }
    }
}

public class UpgradeClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpgradeClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
