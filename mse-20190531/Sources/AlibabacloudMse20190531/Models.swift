import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class GatewayDomain : Tea.TeaModel {
    public var certIdentifier: String?

    public var gatewayId: Int64?

    public var gatewayName: String?

    public var gatewayUniqueId: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var id: Int64?

    public var mustHttps: String?

    public var name: String?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayName != nil {
            map["GatewayName"] = self.gatewayName!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mustHttps != nil {
            map["MustHttps"] = self.mustHttps!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayName") {
            self.gatewayName = dict["GatewayName"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MustHttps") {
            self.mustHttps = dict["MustHttps"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class GatewayOption : Tea.TeaModel {
    public class LogConfigDetails : Tea.TeaModel {
        public var logEnabled: Bool?

        public var logStoreName: String?

        public var projectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logEnabled != nil {
                map["LogEnabled"] = self.logEnabled!
            }
            if self.logStoreName != nil {
                map["LogStoreName"] = self.logStoreName!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogEnabled") {
                self.logEnabled = dict["LogEnabled"] as! Bool
            }
            if dict.keys.contains("LogStoreName") {
                self.logStoreName = dict["LogStoreName"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
        }
    }
    public class TraceDetails : Tea.TeaModel {
        public var sample: Int64?

        public var traceEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sample != nil {
                map["Sample"] = self.sample!
            }
            if self.traceEnabled != nil {
                map["TraceEnabled"] = self.traceEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Sample") {
                self.sample = dict["Sample"] as! Int64
            }
            if dict.keys.contains("TraceEnabled") {
                self.traceEnabled = dict["TraceEnabled"] as! Bool
            }
        }
    }
    public var disableHttp2Alpn: Bool?

    public var enableHardwareAcceleration: Bool?

    public var enableWaf: Bool?

    public var logConfigDetails: GatewayOption.LogConfigDetails?

    public var traceDetails: GatewayOption.TraceDetails?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logConfigDetails?.validate()
        try self.traceDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disableHttp2Alpn != nil {
            map["DisableHttp2Alpn"] = self.disableHttp2Alpn!
        }
        if self.enableHardwareAcceleration != nil {
            map["EnableHardwareAcceleration"] = self.enableHardwareAcceleration!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.logConfigDetails != nil {
            map["LogConfigDetails"] = self.logConfigDetails?.toMap()
        }
        if self.traceDetails != nil {
            map["TraceDetails"] = self.traceDetails?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DisableHttp2Alpn") {
            self.disableHttp2Alpn = dict["DisableHttp2Alpn"] as! Bool
        }
        if dict.keys.contains("EnableHardwareAcceleration") {
            self.enableHardwareAcceleration = dict["EnableHardwareAcceleration"] as! Bool
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("LogConfigDetails") {
            var model = GatewayOption.LogConfigDetails()
            model.fromMap(dict["LogConfigDetails"] as! [String: Any])
            self.logConfigDetails = model
        }
        if dict.keys.contains("TraceDetails") {
            var model = GatewayOption.TraceDetails()
            model.fromMap(dict["TraceDetails"] as! [String: Any])
            self.traceDetails = model
        }
    }
}

public class GatewayService : Tea.TeaModel {
    public var gatewayTrafficPolicy: TrafficPolicy?

    public var gatewayUniqueId: String?

    public var groupName: String?

    public var id: Int64?

    public var metaInfo: String?

    public var name: String?

    public var namespace: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewayTrafficPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gatewayTrafficPolicy != nil {
            map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.metaInfo != nil {
            map["MetaInfo"] = self.metaInfo!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GatewayTrafficPolicy") {
            var model = TrafficPolicy()
            model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
            self.gatewayTrafficPolicy = model
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MetaInfo") {
            self.metaInfo = dict["MetaInfo"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class TrafficPolicy : Tea.TeaModel {
    public class LoadBalancerSettings : Tea.TeaModel {
        public class ConsistentHashLBConfig : Tea.TeaModel {
            public class HttpCookie : Tea.TeaModel {
                public var name: String?

                public var path: String?

                public var TTL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.TTL != nil {
                        map["TTL"] = self.TTL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("TTL") {
                        self.TTL = dict["TTL"] as! String
                    }
                }
            }
            public var consistentHashLBType: String?

            public var httpCookie: TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie?

            public var parameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.httpCookie?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consistentHashLBType != nil {
                    map["ConsistentHashLBType"] = self.consistentHashLBType!
                }
                if self.httpCookie != nil {
                    map["HttpCookie"] = self.httpCookie?.toMap()
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsistentHashLBType") {
                    self.consistentHashLBType = dict["ConsistentHashLBType"] as! String
                }
                if dict.keys.contains("HttpCookie") {
                    var model = TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie()
                    model.fromMap(dict["HttpCookie"] as! [String: Any])
                    self.httpCookie = model
                }
                if dict.keys.contains("ParameterName") {
                    self.parameterName = dict["ParameterName"] as! String
                }
            }
        }
        public var consistentHashLBConfig: TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig?

        public var loadbalancerType: String?

        public var warmupDuration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.consistentHashLBConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consistentHashLBConfig != nil {
                map["ConsistentHashLBConfig"] = self.consistentHashLBConfig?.toMap()
            }
            if self.loadbalancerType != nil {
                map["LoadbalancerType"] = self.loadbalancerType!
            }
            if self.warmupDuration != nil {
                map["WarmupDuration"] = self.warmupDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsistentHashLBConfig") {
                var model = TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig()
                model.fromMap(dict["ConsistentHashLBConfig"] as! [String: Any])
                self.consistentHashLBConfig = model
            }
            if dict.keys.contains("LoadbalancerType") {
                self.loadbalancerType = dict["LoadbalancerType"] as! String
            }
            if dict.keys.contains("WarmupDuration") {
                self.warmupDuration = dict["WarmupDuration"] as! Int64
            }
        }
    }
    public class TlsSetting : Tea.TeaModel {
        public var caCertContent: String?

        public var certId: String?

        public var sni: String?

        public var tlsMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caCertContent != nil {
                map["CaCertContent"] = self.caCertContent!
            }
            if self.certId != nil {
                map["CertId"] = self.certId!
            }
            if self.sni != nil {
                map["Sni"] = self.sni!
            }
            if self.tlsMode != nil {
                map["TlsMode"] = self.tlsMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaCertContent") {
                self.caCertContent = dict["CaCertContent"] as! String
            }
            if dict.keys.contains("CertId") {
                self.certId = dict["CertId"] as! String
            }
            if dict.keys.contains("Sni") {
                self.sni = dict["Sni"] as! String
            }
            if dict.keys.contains("TlsMode") {
                self.tlsMode = dict["TlsMode"] as! String
            }
        }
    }
    public var loadBalancerSettings: TrafficPolicy.LoadBalancerSettings?

    public var tlsSetting: TrafficPolicy.TlsSetting?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.loadBalancerSettings?.validate()
        try self.tlsSetting?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerSettings != nil {
            map["LoadBalancerSettings"] = self.loadBalancerSettings?.toMap()
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerSettings") {
            var model = TrafficPolicy.LoadBalancerSettings()
            model.fromMap(dict["LoadBalancerSettings"] as! [String: Any])
            self.loadBalancerSettings = model
        }
        if dict.keys.contains("TlsSetting") {
            var model = TrafficPolicy.TlsSetting()
            model.fromMap(dict["TlsSetting"] as! [String: Any])
            self.tlsSetting = model
        }
    }
}

public class AddAuthResourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var authId: Int64?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public var matchType: String?

    public var mseSessionId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authId != nil {
            map["AuthId"] = self.authId!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.matchType != nil {
            map["MatchType"] = self.matchType!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthId") {
            self.authId = dict["AuthId"] as! Int64
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MatchType") {
            self.matchType = dict["MatchType"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
    }
}

public class AddAuthResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAuthResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAuthResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAuthResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddBlackWhiteListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var content: String?

    public var gatewayUniqueId: String?

    public var isWhite: Bool?

    public var mseSessionId: String?

    public var name: String?

    public var note: String?

    public var resourceIdJsonList: String?

    public var resourceType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.resourceIdJsonList != nil {
            map["ResourceIdJsonList"] = self.resourceIdJsonList!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsWhite") {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Note") {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("ResourceIdJsonList") {
            self.resourceIdJsonList = dict["ResourceIdJsonList"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddBlackWhiteListResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var enableHardwareAcceleration: Bool?

    public var enableSls: Bool?

    public var enableXtrace: Bool?

    public var enterpriseSecurityGroup: Bool?

    public var internetSlbSpec: String?

    public var mseSessionId: String?

    public var name: String?

    public var region: String?

    public var replica: Int32?

    public var slbSpec: String?

    public var spec: String?

    public var tag: [AddGatewayRequest.Tag]?

    public var vSwitchId: String?

    public var vSwitchId2: String?

    public var vpc: String?

    public var xtraceRatio: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enableHardwareAcceleration != nil {
            map["EnableHardwareAcceleration"] = self.enableHardwareAcceleration!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.enableXtrace != nil {
            map["EnableXtrace"] = self.enableXtrace!
        }
        if self.enterpriseSecurityGroup != nil {
            map["EnterpriseSecurityGroup"] = self.enterpriseSecurityGroup!
        }
        if self.internetSlbSpec != nil {
            map["InternetSlbSpec"] = self.internetSlbSpec!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.replica != nil {
            map["Replica"] = self.replica!
        }
        if self.slbSpec != nil {
            map["SlbSpec"] = self.slbSpec!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchId2 != nil {
            map["VSwitchId2"] = self.vSwitchId2!
        }
        if self.vpc != nil {
            map["Vpc"] = self.vpc!
        }
        if self.xtraceRatio != nil {
            map["XtraceRatio"] = self.xtraceRatio!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EnableHardwareAcceleration") {
            self.enableHardwareAcceleration = dict["EnableHardwareAcceleration"] as! Bool
        }
        if dict.keys.contains("EnableSls") {
            self.enableSls = dict["EnableSls"] as! Bool
        }
        if dict.keys.contains("EnableXtrace") {
            self.enableXtrace = dict["EnableXtrace"] as! Bool
        }
        if dict.keys.contains("EnterpriseSecurityGroup") {
            self.enterpriseSecurityGroup = dict["EnterpriseSecurityGroup"] as! Bool
        }
        if dict.keys.contains("InternetSlbSpec") {
            self.internetSlbSpec = dict["InternetSlbSpec"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Replica") {
            self.replica = dict["Replica"] as! Int32
        }
        if dict.keys.contains("SlbSpec") {
            self.slbSpec = dict["SlbSpec"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [AddGatewayRequest.Tag]
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchId2") {
            self.vSwitchId2 = dict["VSwitchId2"] as! String
        }
        if dict.keys.contains("Vpc") {
            self.vpc = dict["Vpc"] as! String
        }
        if dict.keys.contains("XtraceRatio") {
            self.xtraceRatio = dict["XtraceRatio"] as! String
        }
    }
}

public class AddGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gatewayUniqueId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AddGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = AddGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var gatewayUniqueId: String?

    public var http2: String?

    public var mseSessionId: String?

    public var mustHttps: Bool?

    public var name: String?

    public var protocol_: String?

    public var tlsMax: String?

    public var tlsMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.http2 != nil {
            map["Http2"] = self.http2!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.mustHttps != nil {
            map["MustHttps"] = self.mustHttps!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.tlsMax != nil {
            map["TlsMax"] = self.tlsMax!
        }
        if self.tlsMin != nil {
            map["TlsMin"] = self.tlsMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Http2") {
            self.http2 = dict["Http2"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("MustHttps") {
            self.mustHttps = dict["MustHttps"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TlsMax") {
            self.tlsMax = dict["TlsMax"] as! String
        }
        if dict.keys.contains("TlsMin") {
            self.tlsMin = dict["TlsMin"] as! String
        }
    }
}

public class AddGatewayDomainResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayRouteRequest : Tea.TeaModel {
    public class DirectResponseJSON : Tea.TeaModel {
        public var body: String?

        public var code: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.body != nil {
                map["Body"] = self.body!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Body") {
                self.body = dict["Body"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! Int64
            }
        }
    }
    public class FallbackServices : Tea.TeaModel {
        public var agreementType: String?

        public var groupName: String?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public class Predicates : Tea.TeaModel {
        public class HeaderPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class PathPredicates : Tea.TeaModel {
            public var ignoreCase: Bool?

            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ignoreCase != nil {
                    map["IgnoreCase"] = self.ignoreCase!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IgnoreCase") {
                    self.ignoreCase = dict["IgnoreCase"] as! Bool
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class QueryPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var headerPredicates: [AddGatewayRouteRequest.Predicates.HeaderPredicates]?

        public var methodPredicates: [String]?

        public var pathPredicates: AddGatewayRouteRequest.Predicates.PathPredicates?

        public var queryPredicates: [AddGatewayRouteRequest.Predicates.QueryPredicates]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pathPredicates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerPredicates != nil {
                var tmp : [Any] = []
                for k in self.headerPredicates! {
                    tmp.append(k.toMap())
                }
                map["HeaderPredicates"] = tmp
            }
            if self.methodPredicates != nil {
                map["MethodPredicates"] = self.methodPredicates!
            }
            if self.pathPredicates != nil {
                map["PathPredicates"] = self.pathPredicates?.toMap()
            }
            if self.queryPredicates != nil {
                var tmp : [Any] = []
                for k in self.queryPredicates! {
                    tmp.append(k.toMap())
                }
                map["QueryPredicates"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HeaderPredicates") {
                self.headerPredicates = dict["HeaderPredicates"] as! [AddGatewayRouteRequest.Predicates.HeaderPredicates]
            }
            if dict.keys.contains("MethodPredicates") {
                self.methodPredicates = dict["MethodPredicates"] as! [String]
            }
            if dict.keys.contains("PathPredicates") {
                var model = AddGatewayRouteRequest.Predicates.PathPredicates()
                model.fromMap(dict["PathPredicates"] as! [String: Any])
                self.pathPredicates = model
            }
            if dict.keys.contains("QueryPredicates") {
                self.queryPredicates = dict["QueryPredicates"] as! [AddGatewayRouteRequest.Predicates.QueryPredicates]
            }
        }
    }
    public class RedirectJSON : Tea.TeaModel {
        public var code: Int32?

        public var host: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! Int32
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class Services : Tea.TeaModel {
        public class HttpDubboTranscoder : Tea.TeaModel {
            public class MothedMapList : Tea.TeaModel {
                public class ParamMapsList : Tea.TeaModel {
                    public var extractKey: String?

                    public var extractKeySpec: String?

                    public var mappingType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extractKey != nil {
                            map["ExtractKey"] = self.extractKey!
                        }
                        if self.extractKeySpec != nil {
                            map["ExtractKeySpec"] = self.extractKeySpec!
                        }
                        if self.mappingType != nil {
                            map["MappingType"] = self.mappingType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtractKey") {
                            self.extractKey = dict["ExtractKey"] as! String
                        }
                        if dict.keys.contains("ExtractKeySpec") {
                            self.extractKeySpec = dict["ExtractKeySpec"] as! String
                        }
                        if dict.keys.contains("MappingType") {
                            self.mappingType = dict["MappingType"] as! String
                        }
                    }
                }
                public var dubboMothedName: String?

                public var httpMothed: String?

                public var mothedpath: String?

                public var paramMapsList: [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                public var passThroughAllHeaders: String?

                public var passThroughList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dubboMothedName != nil {
                        map["DubboMothedName"] = self.dubboMothedName!
                    }
                    if self.httpMothed != nil {
                        map["HttpMothed"] = self.httpMothed!
                    }
                    if self.mothedpath != nil {
                        map["Mothedpath"] = self.mothedpath!
                    }
                    if self.paramMapsList != nil {
                        var tmp : [Any] = []
                        for k in self.paramMapsList! {
                            tmp.append(k.toMap())
                        }
                        map["ParamMapsList"] = tmp
                    }
                    if self.passThroughAllHeaders != nil {
                        map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                    }
                    if self.passThroughList != nil {
                        map["PassThroughList"] = self.passThroughList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DubboMothedName") {
                        self.dubboMothedName = dict["DubboMothedName"] as! String
                    }
                    if dict.keys.contains("HttpMothed") {
                        self.httpMothed = dict["HttpMothed"] as! String
                    }
                    if dict.keys.contains("Mothedpath") {
                        self.mothedpath = dict["Mothedpath"] as! String
                    }
                    if dict.keys.contains("ParamMapsList") {
                        self.paramMapsList = dict["ParamMapsList"] as! [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList]
                    }
                    if dict.keys.contains("PassThroughAllHeaders") {
                        self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                    }
                    if dict.keys.contains("PassThroughList") {
                        self.passThroughList = dict["PassThroughList"] as! [String]
                    }
                }
            }
            public var dubboServiceGroup: String?

            public var dubboServiceName: String?

            public var dubboServiceVersion: String?

            public var mothedMapList: [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dubboServiceGroup != nil {
                    map["DubboServiceGroup"] = self.dubboServiceGroup!
                }
                if self.dubboServiceName != nil {
                    map["DubboServiceName"] = self.dubboServiceName!
                }
                if self.dubboServiceVersion != nil {
                    map["DubboServiceVersion"] = self.dubboServiceVersion!
                }
                if self.mothedMapList != nil {
                    var tmp : [Any] = []
                    for k in self.mothedMapList! {
                        tmp.append(k.toMap())
                    }
                    map["MothedMapList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DubboServiceGroup") {
                    self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                }
                if dict.keys.contains("DubboServiceName") {
                    self.dubboServiceName = dict["DubboServiceName"] as! String
                }
                if dict.keys.contains("DubboServiceVersion") {
                    self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                }
                if dict.keys.contains("MothedMapList") {
                    self.mothedMapList = dict["MothedMapList"] as! [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList]
                }
            }
        }
        public var agreementType: String?

        public var groupName: String?

        public var httpDubboTranscoder: AddGatewayRouteRequest.Services.HttpDubboTranscoder?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.httpDubboTranscoder?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.httpDubboTranscoder != nil {
                map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HttpDubboTranscoder") {
                var model = AddGatewayRouteRequest.Services.HttpDubboTranscoder()
                model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                self.httpDubboTranscoder = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var destinationType: String?

    public var directResponseJSON: AddGatewayRouteRequest.DirectResponseJSON?

    public var domainId: Int64?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServices: [AddGatewayRouteRequest.FallbackServices]?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var name: String?

    public var predicates: AddGatewayRouteRequest.Predicates?

    public var redirectJSON: AddGatewayRouteRequest.RedirectJSON?

    public var routeOrder: Int32?

    public var services: [AddGatewayRouteRequest.Services]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.directResponseJSON?.validate()
        try self.predicates?.validate()
        try self.redirectJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSON != nil {
            map["DirectResponseJSON"] = self.directResponseJSON?.toMap()
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServices != nil {
            var tmp : [Any] = []
            for k in self.fallbackServices! {
                tmp.append(k.toMap())
            }
            map["FallbackServices"] = tmp
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.predicates != nil {
            map["Predicates"] = self.predicates?.toMap()
        }
        if self.redirectJSON != nil {
            map["RedirectJSON"] = self.redirectJSON?.toMap()
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") {
            var model = AddGatewayRouteRequest.DirectResponseJSON()
            model.fromMap(dict["DirectResponseJSON"] as! [String: Any])
            self.directResponseJSON = model
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("DomainIdListJSON") {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") {
            self.fallbackServices = dict["FallbackServices"] as! [AddGatewayRouteRequest.FallbackServices]
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Predicates") {
            var model = AddGatewayRouteRequest.Predicates()
            model.fromMap(dict["Predicates"] as! [String: Any])
            self.predicates = model
        }
        if dict.keys.contains("RedirectJSON") {
            var model = AddGatewayRouteRequest.RedirectJSON()
            model.fromMap(dict["RedirectJSON"] as! [String: Any])
            self.redirectJSON = model
        }
        if dict.keys.contains("RouteOrder") {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("Services") {
            self.services = dict["Services"] as! [AddGatewayRouteRequest.Services]
        }
    }
}

public class AddGatewayRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var destinationType: String?

    public var directResponseJSONShrink: String?

    public var domainId: Int64?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServicesShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var name: String?

    public var predicatesShrink: String?

    public var redirectJSONShrink: String?

    public var routeOrder: Int32?

    public var servicesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSONShrink != nil {
            map["DirectResponseJSON"] = self.directResponseJSONShrink!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServicesShrink != nil {
            map["FallbackServices"] = self.fallbackServicesShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.predicatesShrink != nil {
            map["Predicates"] = self.predicatesShrink!
        }
        if self.redirectJSONShrink != nil {
            map["RedirectJSON"] = self.redirectJSONShrink!
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.servicesShrink != nil {
            map["Services"] = self.servicesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") {
            self.directResponseJSONShrink = dict["DirectResponseJSON"] as! String
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("DomainIdListJSON") {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") {
            self.fallbackServicesShrink = dict["FallbackServices"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Predicates") {
            self.predicatesShrink = dict["Predicates"] as! String
        }
        if dict.keys.contains("RedirectJSON") {
            self.redirectJSONShrink = dict["RedirectJSON"] as! String
        }
        if dict.keys.contains("RouteOrder") {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("Services") {
            self.servicesShrink = dict["Services"] as! String
        }
    }
}

public class AddGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayServiceVersionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var serviceId: Int64?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
        if dict.keys.contains("ServiceVersion") {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class AddGatewayServiceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayServiceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayServiceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayServiceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var httpPort: Int32?

    public var httpsPort: Int32?

    public var httpsVServerGroupId: String?

    public var mseSessionId: String?

    public var serviceWeight: Int32?

    public var slbId: String?

    public var type: String?

    public var VServerGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.httpPort != nil {
            map["HttpPort"] = self.httpPort!
        }
        if self.httpsPort != nil {
            map["HttpsPort"] = self.httpsPort!
        }
        if self.httpsVServerGroupId != nil {
            map["HttpsVServerGroupId"] = self.httpsVServerGroupId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceWeight != nil {
            map["ServiceWeight"] = self.serviceWeight!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.VServerGroupId != nil {
            map["VServerGroupId"] = self.VServerGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HttpPort") {
            self.httpPort = dict["HttpPort"] as! Int32
        }
        if dict.keys.contains("HttpsPort") {
            self.httpsPort = dict["HttpsPort"] as! Int32
        }
        if dict.keys.contains("HttpsVServerGroupId") {
            self.httpsVServerGroupId = dict["HttpsVServerGroupId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceWeight") {
            self.serviceWeight = dict["ServiceWeight"] as! Int32
        }
        if dict.keys.contains("SlbId") {
            self.slbId = dict["SlbId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VServerGroupId") {
            self.VServerGroupId = dict["VServerGroupId"] as! String
        }
    }
}

public class AddGatewaySlbResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMockRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerAppIds: String?

    public var dubboMockItems: String?

    public var enable: Bool?

    public var extraJson: String?

    public var mockType: Int64?

    public var mseSessionId: String?

    public var name: String?

    public var providerAppId: String?

    public var providerAppName: String?

    public var region: String?

    public var scMockItems: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerAppIds != nil {
            map["ConsumerAppIds"] = self.consumerAppIds!
        }
        if self.dubboMockItems != nil {
            map["DubboMockItems"] = self.dubboMockItems!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.extraJson != nil {
            map["ExtraJson"] = self.extraJson!
        }
        if self.mockType != nil {
            map["MockType"] = self.mockType!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.providerAppId != nil {
            map["ProviderAppId"] = self.providerAppId!
        }
        if self.providerAppName != nil {
            map["ProviderAppName"] = self.providerAppName!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.scMockItems != nil {
            map["ScMockItems"] = self.scMockItems!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerAppIds") {
            self.consumerAppIds = dict["ConsumerAppIds"] as! String
        }
        if dict.keys.contains("DubboMockItems") {
            self.dubboMockItems = dict["DubboMockItems"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("ExtraJson") {
            self.extraJson = dict["ExtraJson"] as! String
        }
        if dict.keys.contains("MockType") {
            self.mockType = dict["MockType"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProviderAppId") {
            self.providerAppId = dict["ProviderAppId"] as! String
        }
        if dict.keys.contains("ProviderAppName") {
            self.providerAppName = dict["ProviderAppName"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ScMockItems") {
            self.scMockItems = dict["ScMockItems"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class AddMockRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountId: String?

        public var consumerAppId: String?

        public var consumerAppName: String?

        public var enable: Bool?

        public var extraJson: String?

        public var id: Int64?

        public var mockType: Int64?

        public var name: String?

        public var namespaceId: String?

        public var providerAppId: String?

        public var providerAppName: String?

        public var region: String?

        public var scMockItemJson: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.consumerAppId != nil {
                map["ConsumerAppId"] = self.consumerAppId!
            }
            if self.consumerAppName != nil {
                map["ConsumerAppName"] = self.consumerAppName!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.extraJson != nil {
                map["ExtraJson"] = self.extraJson!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mockType != nil {
                map["MockType"] = self.mockType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.providerAppId != nil {
                map["ProviderAppId"] = self.providerAppId!
            }
            if self.providerAppName != nil {
                map["ProviderAppName"] = self.providerAppName!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.scMockItemJson != nil {
                map["ScMockItemJson"] = self.scMockItemJson!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("ConsumerAppId") {
                self.consumerAppId = dict["ConsumerAppId"] as! String
            }
            if dict.keys.contains("ConsumerAppName") {
                self.consumerAppName = dict["ConsumerAppName"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("ExtraJson") {
                self.extraJson = dict["ExtraJson"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MockType") {
                self.mockType = dict["MockType"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("ProviderAppId") {
                self.providerAppId = dict["ProviderAppId"] as! String
            }
            if dict.keys.contains("ProviderAppName") {
                self.providerAppName = dict["ProviderAppName"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("ScMockItemJson") {
                self.scMockItemJson = dict["ScMockItemJson"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AddMockRuleResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = AddMockRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddMockRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMockRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMockRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSSLCertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class AddSSLCertResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddSSLCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSSLCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSSLCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSecurityGroupRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var portRange: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class AddSecurityGroupRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddServiceSourceRequest : Tea.TeaModel {
    public class IngressOptionsRequest : Tea.TeaModel {
        public var enableIngress: Bool?

        public var ingressClass: String?

        public var watchNamespace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableIngress != nil {
                map["EnableIngress"] = self.enableIngress!
            }
            if self.ingressClass != nil {
                map["IngressClass"] = self.ingressClass!
            }
            if self.watchNamespace != nil {
                map["WatchNamespace"] = self.watchNamespace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableIngress") {
                self.enableIngress = dict["EnableIngress"] as! Bool
            }
            if dict.keys.contains("IngressClass") {
                self.ingressClass = dict["IngressClass"] as! String
            }
            if dict.keys.contains("WatchNamespace") {
                self.watchNamespace = dict["WatchNamespace"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayUniqueId: String?

    public var groupList: [String]?

    public var ingressOptionsRequest: AddServiceSourceRequest.IngressOptionsRequest?

    public var mseSessionId: String?

    public var name: String?

    public var source: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ingressOptionsRequest?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.groupList != nil {
            map["GroupList"] = self.groupList!
        }
        if self.ingressOptionsRequest != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequest?.toMap()
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GroupList") {
            self.groupList = dict["GroupList"] as! [String]
        }
        if dict.keys.contains("IngressOptionsRequest") {
            var model = AddServiceSourceRequest.IngressOptionsRequest()
            model.fromMap(dict["IngressOptionsRequest"] as! [String: Any])
            self.ingressOptionsRequest = model
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddServiceSourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayUniqueId: String?

    public var groupListShrink: String?

    public var ingressOptionsRequestShrink: String?

    public var mseSessionId: String?

    public var name: String?

    public var source: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.groupListShrink != nil {
            map["GroupList"] = self.groupListShrink!
        }
        if self.ingressOptionsRequestShrink != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequestShrink!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GroupList") {
            self.groupListShrink = dict["GroupList"] as! String
        }
        if dict.keys.contains("IngressOptionsRequest") {
            self.ingressOptionsRequestShrink = dict["IngressOptionsRequest"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddServiceSourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyGatewayRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var routeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! String
        }
    }
}

public class ApplyGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApplyGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyTagPoliciesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var enable: Bool?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var region: String?

    public var rules: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Rules") {
            self.rules = dict["Rules"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class ApplyTagPoliciesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var carryData: Bool?

        public var enable: Bool?

        public var id: Int64?

        public var instanceNum: Int32?

        public var name: String?

        public var rate: Int32?

        public var remove: Bool?

        public var rules: String?

        public var status: Int32?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.carryData != nil {
                map["CarryData"] = self.carryData!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceNum != nil {
                map["InstanceNum"] = self.instanceNum!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.rate != nil {
                map["Rate"] = self.rate!
            }
            if self.remove != nil {
                map["Remove"] = self.remove!
            }
            if self.rules != nil {
                map["Rules"] = self.rules!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CarryData") {
                self.carryData = dict["CarryData"] as! Bool
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceNum") {
                self.instanceNum = dict["InstanceNum"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Rate") {
                self.rate = dict["Rate"] as! Int32
            }
            if dict.keys.contains("Remove") {
                self.remove = dict["Remove"] as! Bool
            }
            if dict.keys.contains("Rules") {
                self.rules = dict["Rules"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tag") {
                self.tag = dict["Tag"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ApplyTagPoliciesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ApplyTagPoliciesResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApplyTagPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyTagPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyTagPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloneNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ids: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var originNamespaceId: String?

    public var policy: String?

    public var targetNamespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.originNamespaceId != nil {
            map["OriginNamespaceId"] = self.originNamespaceId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.targetNamespaceId != nil {
            map["TargetNamespaceId"] = self.targetNamespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("OriginNamespaceId") {
            self.originNamespaceId = dict["OriginNamespaceId"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("TargetNamespaceId") {
            self.targetNamespaceId = dict["TargetNamespaceId"] as! String
        }
    }
}

public class CloneNacosConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FailData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public class SkipData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public var failData: [CloneNacosConfigResponseBody.Data.FailData]?

        public var skipCount: Int32?

        public var skipData: [CloneNacosConfigResponseBody.Data.SkipData]?

        public var succCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failData != nil {
                var tmp : [Any] = []
                for k in self.failData! {
                    tmp.append(k.toMap())
                }
                map["FailData"] = tmp
            }
            if self.skipCount != nil {
                map["SkipCount"] = self.skipCount!
            }
            if self.skipData != nil {
                var tmp : [Any] = []
                for k in self.skipData! {
                    tmp.append(k.toMap())
                }
                map["SkipData"] = tmp
            }
            if self.succCount != nil {
                map["SuccCount"] = self.succCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailData") {
                self.failData = dict["FailData"] as! [CloneNacosConfigResponseBody.Data.FailData]
            }
            if dict.keys.contains("SkipCount") {
                self.skipCount = dict["SkipCount"] as! Int32
            }
            if dict.keys.contains("SkipData") {
                self.skipData = dict["SkipData"] as! [CloneNacosConfigResponseBody.Data.SkipData]
            }
            if dict.keys.contains("SuccCount") {
                self.succCount = dict["SuccCount"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: CloneNacosConfigResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = CloneNacosConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CloneNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloneNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApplicationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var extraInfo: String?

    public var language: String?

    public var mseSessionId: String?

    public var region: String?

    public var sentinelEnable: String?

    public var source: String?

    public var switchEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extraInfo != nil {
            map["ExtraInfo"] = self.extraInfo!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sentinelEnable != nil {
            map["SentinelEnable"] = self.sentinelEnable!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.switchEnable != nil {
            map["SwitchEnable"] = self.switchEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ExtraInfo") {
            self.extraInfo = dict["ExtraInfo"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SentinelEnable") {
            self.sentinelEnable = dict["SentinelEnable"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SwitchEnable") {
            self.switchEnable = dict["SwitchEnable"] as! String
        }
    }
}

public class CreateApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var createTime: Int64?

        public var extraInfo: String?

        public var language: String?

        public var licenseKey: String?

        public var regionId: String?

        public var source: String?

        public var status: Int32?

        public var updateTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.licenseKey != nil {
                map["LicenseKey"] = self.licenseKey!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExtraInfo") {
                self.extraInfo = dict["ExtraInfo"] as! String
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("LicenseKey") {
                self.licenseKey = dict["LicenseKey"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateApplicationResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = CreateApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClusterRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var clusterSpecification: String?

    public var clusterType: String?

    public var clusterVersion: String?

    public var connectionType: String?

    public var diskType: String?

    public var instanceCount: Int32?

    public var instanceName: String?

    public var mseSessionId: String?

    public var mseVersion: String?

    public var netType: String?

    public var privateSlbSpecification: String?

    public var pubNetworkFlow: String?

    public var pubSlbSpecification: String?

    public var region: String?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var tag: [CreateClusterRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterSpecification != nil {
            map["ClusterSpecification"] = self.clusterSpecification!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.clusterVersion != nil {
            map["ClusterVersion"] = self.clusterVersion!
        }
        if self.connectionType != nil {
            map["ConnectionType"] = self.connectionType!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.privateSlbSpecification != nil {
            map["PrivateSlbSpecification"] = self.privateSlbSpecification!
        }
        if self.pubNetworkFlow != nil {
            map["PubNetworkFlow"] = self.pubNetworkFlow!
        }
        if self.pubSlbSpecification != nil {
            map["PubSlbSpecification"] = self.pubSlbSpecification!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterSpecification") {
            self.clusterSpecification = dict["ClusterSpecification"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("ClusterVersion") {
            self.clusterVersion = dict["ClusterVersion"] as! String
        }
        if dict.keys.contains("ConnectionType") {
            self.connectionType = dict["ConnectionType"] as! String
        }
        if dict.keys.contains("DiskType") {
            self.diskType = dict["DiskType"] as! String
        }
        if dict.keys.contains("InstanceCount") {
            self.instanceCount = dict["InstanceCount"] as! Int32
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("NetType") {
            self.netType = dict["NetType"] as! String
        }
        if dict.keys.contains("PrivateSlbSpecification") {
            self.privateSlbSpecification = dict["PrivateSlbSpecification"] as! String
        }
        if dict.keys.contains("PubNetworkFlow") {
            self.pubNetworkFlow = dict["PubNetworkFlow"] as! String
        }
        if dict.keys.contains("PubSlbSpecification") {
            self.pubSlbSpecification = dict["PubSlbSpecification"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateClusterRequest.Tag]
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var instanceId: String?

    public var message: String?

    public var orderId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEngineNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var desc: String?

    public var id: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var name: String?

    public var serviceCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.serviceCount != nil {
            map["ServiceCount"] = self.serviceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServiceCount") {
            self.serviceCount = dict["ServiceCount"] as! Int32
        }
    }
}

public class CreateEngineNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configCount: Int32?

        public var namespace: String?

        public var namespaceDesc: String?

        public var namespaceShowName: String?

        public var quota: Int32?

        public var serviceCount: Int32?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configCount != nil {
                map["ConfigCount"] = self.configCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceDesc != nil {
                map["NamespaceDesc"] = self.namespaceDesc!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.serviceCount != nil {
                map["ServiceCount"] = self.serviceCount!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigCount") {
                self.configCount = dict["ConfigCount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceDesc") {
                self.namespaceDesc = dict["NamespaceDesc"] as! String
            }
            if dict.keys.contains("NamespaceShowName") {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Quota") {
                self.quota = dict["Quota"] as! Int32
            }
            if dict.keys.contains("ServiceCount") {
                self.serviceCount = dict["ServiceCount"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var clusterId: String?

    public var data: CreateEngineNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateEngineNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateEngineNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEngineNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEngineNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMseServiceApplicationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var extraInfo: String?

    public var language: String?

    public var mseSessionId: String?

    public var mseVersion: String?

    public var region: String?

    public var sentinelEnable: String?

    public var source: String?

    public var switchEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extraInfo != nil {
            map["ExtraInfo"] = self.extraInfo!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sentinelEnable != nil {
            map["SentinelEnable"] = self.sentinelEnable!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.switchEnable != nil {
            map["SwitchEnable"] = self.switchEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ExtraInfo") {
            self.extraInfo = dict["ExtraInfo"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SentinelEnable") {
            self.sentinelEnable = dict["SentinelEnable"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SwitchEnable") {
            self.switchEnable = dict["SwitchEnable"] as! String
        }
    }
}

public class CreateMseServiceApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var createTime: Int64?

        public var extraInfo: String?

        public var language: String?

        public var licenseKey: String?

        public var regionId: String?

        public var source: String?

        public var status: Int32?

        public var updateTime: Int64?

        public var userId: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.licenseKey != nil {
                map["LicenseKey"] = self.licenseKey!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExtraInfo") {
                self.extraInfo = dict["ExtraInfo"] as! String
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("LicenseKey") {
                self.licenseKey = dict["LicenseKey"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateMseServiceApplicationResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = CreateMseServiceApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateMseServiceApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMseServiceApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMseServiceApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var betaIps: String?

    public var content: String?

    public var dataId: String?

    public var desc: String?

    public var group: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var tags: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.betaIps != nil {
            map["BetaIps"] = self.betaIps!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BetaIps") {
            self.betaIps = dict["BetaIps"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateNacosConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNacosInstanceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterName: String?

    public var enabled: Bool?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var ip: String?

    public var metadata: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var port: Int32?

    public var serviceName: String?

    public var weight: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.metadata != nil {
            map["Metadata"] = self.metadata!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Ephemeral") {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Metadata") {
            self.metadata = dict["Metadata"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! String
        }
    }
}

public class CreateNacosInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNacosInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNacosInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNacosInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNacosServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var protectThreshold: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.protectThreshold != nil {
            map["ProtectThreshold"] = self.protectThreshold!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Ephemeral") {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ProtectThreshold") {
            self.protectThreshold = dict["ProtectThreshold"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class CreateNacosServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNacosServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNacosServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNacosServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateSwimmingLaneRequest : Tea.TeaModel {
    public class EntryRules : Tea.TeaModel {
        public class RestItems : Tea.TeaModel {
            public var cond: String?

            public var datum: String?

            public var divisor: Int32?

            public var name: String?

            public var nameList: [String]?

            public var operator_: String?

            public var rate: Int32?

            public var remainder: Int32?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cond != nil {
                    map["Cond"] = self.cond!
                }
                if self.datum != nil {
                    map["Datum"] = self.datum!
                }
                if self.divisor != nil {
                    map["Divisor"] = self.divisor!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameList != nil {
                    map["NameList"] = self.nameList!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.remainder != nil {
                    map["Remainder"] = self.remainder!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cond") {
                    self.cond = dict["Cond"] as! String
                }
                if dict.keys.contains("Datum") {
                    self.datum = dict["Datum"] as! String
                }
                if dict.keys.contains("Divisor") {
                    self.divisor = dict["Divisor"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameList") {
                    self.nameList = dict["NameList"] as! [String]
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! Int32
                }
                if dict.keys.contains("Remainder") {
                    self.remainder = dict["Remainder"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var condition: String?

        public var enable: Bool?

        public var path: String?

        public var paths: [String]?

        public var priority: Int32?

        public var restItems: [CreateOrUpdateSwimmingLaneRequest.EntryRules.RestItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.paths != nil {
                map["Paths"] = self.paths!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.restItems != nil {
                var tmp : [Any] = []
                for k in self.restItems! {
                    tmp.append(k.toMap())
                }
                map["RestItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Paths") {
                self.paths = dict["Paths"] as! [String]
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RestItems") {
                self.restItems = dict["RestItems"] as! [CreateOrUpdateSwimmingLaneRequest.EntryRules.RestItems]
            }
        }
    }
    public var acceptLanguage: String?

    public var enable: Bool?

    public var enableRules: Bool?

    public var entryRule: String?

    public var entryRules: [CreateOrUpdateSwimmingLaneRequest.EntryRules]?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var groupId: Int64?

    public var id: Int64?

    public var licenseKey: String?

    public var mseSessionId: String?

    public var name: String?

    public var regionId: String?

    public var source: String?

    public var status: Int32?

    public var tag: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.enableRules != nil {
            map["EnableRules"] = self.enableRules!
        }
        if self.entryRule != nil {
            map["EntryRule"] = self.entryRule!
        }
        if self.entryRules != nil {
            var tmp : [Any] = []
            for k in self.entryRules! {
                tmp.append(k.toMap())
            }
            map["EntryRules"] = tmp
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.licenseKey != nil {
            map["LicenseKey"] = self.licenseKey!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("EnableRules") {
            self.enableRules = dict["EnableRules"] as! Bool
        }
        if dict.keys.contains("EntryRule") {
            self.entryRule = dict["EntryRule"] as! String
        }
        if dict.keys.contains("EntryRules") {
            self.entryRules = dict["EntryRules"] as! [CreateOrUpdateSwimmingLaneRequest.EntryRules]
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("LicenseKey") {
            self.licenseKey = dict["LicenseKey"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CreateOrUpdateSwimmingLaneResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrUpdateSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appIds: String?

    public var enable: Bool?

    public var entryApp: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var id: Int64?

    public var licenseKey: String?

    public var messageQueueFilterSide: String?

    public var messageQueueGrayEnable: Bool?

    public var mseSessionId: String?

    public var name: String?

    public var region: String?

    public var source: String?

    public var status: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.entryApp != nil {
            map["EntryApp"] = self.entryApp!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.licenseKey != nil {
            map["LicenseKey"] = self.licenseKey!
        }
        if self.messageQueueFilterSide != nil {
            map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
        }
        if self.messageQueueGrayEnable != nil {
            map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("EntryApp") {
            self.entryApp = dict["EntryApp"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("LicenseKey") {
            self.licenseKey = dict["LicenseKey"] as! String
        }
        if dict.keys.contains("MessageQueueFilterSide") {
            self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
        }
        if dict.keys.contains("MessageQueueGrayEnable") {
            self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateZnodeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var data: String?

    public var mseSessionId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
    }
}

public class CreateZnodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: CreateZnodeResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateZnodeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateZnodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateZnodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateZnodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAuthResourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class DeleteAuthResourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var authId: Int64?

        public var domainId: Int64?

        public var domainName: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var isWhite: Bool?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authId != nil {
                map["AuthId"] = self.authId!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isWhite != nil {
                map["IsWhite"] = self.isWhite!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthId") {
                self.authId = dict["AuthId"] as! Int64
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsWhite") {
                self.isWhite = dict["IsWhite"] as! Bool
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteAuthResourceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteAuthResourceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAuthResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAuthResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAuthResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class DeleteClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEngineNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var id: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class DeleteEngineNamespaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEngineNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEngineNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEngineNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var deleteSlb: Bool?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.deleteSlb != nil {
            map["DeleteSlb"] = self.deleteSlb!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DeleteSlb") {
            self.deleteSlb = dict["DeleteSlb"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class DeleteGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var name: String?

        public var primaryUser: String?

        public var region: String?

        public var replica: Int32?

        public var securityGroup: String?

        public var spec: String?

        public var status: Int32?

        public var vpc: String?

        public var vswitch: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.replica != nil {
                map["Replica"] = self.replica!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Replica") {
                self.replica = dict["Replica"] as! Int32
            }
            if dict.keys.contains("SecurityGroup") {
                self.securityGroup = dict["SecurityGroup"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Vpc") {
                self.vpc = dict["Vpc"] as! String
            }
            if dict.keys.contains("Vswitch") {
                self.vswitch = dict["Vswitch"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class DeleteGatewayDomainResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var certIdentifier: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var mustHttps: Bool?

        public var name: String?

        public var protocol_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mustHttps != nil {
                map["MustHttps"] = self.mustHttps!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertIdentifier") {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MustHttps") {
                self.mustHttps = dict["MustHttps"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayDomainResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteGatewayDomainResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var routeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! String
        }
    }
}

public class DeleteGatewayRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var defaultServiceId: Int64?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var name: String?

        public var predicates: String?

        public var routeOrder: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.predicates != nil {
                map["Predicates"] = self.predicates!
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultServiceId") {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Predicates") {
                self.predicates = dict["Predicates"] as! String
            }
            if dict.keys.contains("RouteOrder") {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayRouteResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteGatewayRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var serviceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! String
        }
    }
}

public class DeleteGatewayServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupName: String?

        public var id: Int64?

        public var ips: [String]?

        public var metaInfo: String?

        public var name: String?

        public var namespace: String?

        public var serviceNameInRegistry: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.metaInfo != nil {
                map["MetaInfo"] = self.metaInfo!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.serviceNameInRegistry != nil {
                map["ServiceNameInRegistry"] = self.serviceNameInRegistry!
            }
            if self.sourceId != nil {
                map["SourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Ips") {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("MetaInfo") {
                self.metaInfo = dict["MetaInfo"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServiceNameInRegistry") {
                self.serviceNameInRegistry = dict["ServiceNameInRegistry"] as! String
            }
            if dict.keys.contains("SourceId") {
                self.sourceId = dict["SourceId"] as! Int64
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayServiceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteGatewayServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayServiceVersionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var serviceId: Int64?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
        if dict.keys.contains("ServiceVersion") {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class DeleteGatewayServiceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayServiceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayServiceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayServiceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var deleteSlb: Bool?

    public var gatewayUniqueId: String?

    public var id: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.deleteSlb != nil {
            map["DeleteSlb"] = self.deleteSlb!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DeleteSlb") {
            self.deleteSlb = dict["DeleteSlb"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class DeleteGatewaySlbResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var beta: Bool?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.beta != nil {
            map["Beta"] = self.beta!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Beta") {
            self.beta = dict["Beta"] as! Bool
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class DeleteNacosConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ids: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class DeleteNacosConfigsResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNacosConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosInstanceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterName: String?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var ip: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var port: Int32?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Ephemeral") {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class DeleteNacosInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNacosInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupName: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class DeleteNacosServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNacosServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSecurityGroupRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class DeleteSecurityGroupRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var description_: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ipProtocol: String?

        public var portRange: String?

        public var securityGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteSecurityGroupRuleResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteSecurityGroupRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteServiceSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var sourceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! Int64
        }
    }
}

public class DeleteServiceSourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSwimmingLaneRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var laneId: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("LaneId") {
            self.laneId = dict["LaneId"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class DeleteSwimmingLaneResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSwimmingLaneGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class DeleteSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteZnodeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var mseSessionId: String?

    public var path: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class DeleteZnodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: DeleteZnodeResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeleteZnodeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteZnodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteZnodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteZnodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var dataId: String?

    public var group: String?

    public var ids: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class ExportNacosConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: ExportNacosConfigResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ExportNacosConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExportNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppMessageQueueRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var mseSessionId: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class GetAppMessageQueueRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var enable: Bool?

        public var filterSide: String?

        public var region: String?

        public var tags: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.filterSide != nil {
                map["FilterSide"] = self.filterSide!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("FilterSide") {
                self.filterSide = dict["FilterSide"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! [String]
            }
        }
    }
    public var code: Int32?

    public var data: GetAppMessageQueueRouteResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetAppMessageQueueRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAppMessageQueueRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppMessageQueueRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAppMessageQueueRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApplicationListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var language: String?

    public var mseSessionId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var sentinelEnable: Bool?

    public var source: String?

    public var switchEnable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sentinelEnable != nil {
            map["SentinelEnable"] = self.sentinelEnable!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.switchEnable != nil {
            map["SwitchEnable"] = self.switchEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SentinelEnable") {
            self.sentinelEnable = dict["SentinelEnable"] as! Bool
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SwitchEnable") {
            self.switchEnable = dict["SwitchEnable"] as! Bool
        }
    }
}

public class GetApplicationListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var extraInfo: String?

            public var instancesNumber: Int32?

            public var language: String?

            public var licenseKey: String?

            public var regionId: String?

            public var source: String?

            public var status: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.instancesNumber != nil {
                    map["InstancesNumber"] = self.instancesNumber!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.licenseKey != nil {
                    map["LicenseKey"] = self.licenseKey!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ExtraInfo") {
                    self.extraInfo = dict["ExtraInfo"] as! String
                }
                if dict.keys.contains("InstancesNumber") {
                    self.instancesNumber = dict["InstancesNumber"] as! Int32
                }
                if dict.keys.contains("Language") {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("LicenseKey") {
                    self.licenseKey = dict["LicenseKey"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GetApplicationListResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! [GetApplicationListResponseBody.Data.Result]
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GetApplicationListResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetApplicationListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetApplicationListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetApplicationListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBlackWhiteListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var isWhite: Bool?

    public var mseSessionId: String?

    public var resourceType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsWhite") {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetBlackWhiteListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var content: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var isWhite: Bool?

        public var resourceId: Int64?

        public var resourceType: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isWhite != nil {
                map["IsWhite"] = self.isWhite!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsWhite") {
                self.isWhite = dict["IsWhite"] as! Bool
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! Int64
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetBlackWhiteListResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetBlackWhiteListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEngineNamepaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var id: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class GetEngineNamepaceResponseBody : Tea.TeaModel {
    public var configCount: String?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var namespace: String?

    public var namespaceDesc: String?

    public var namespaceShowName: String?

    public var quota: String?

    public var requestId: String?

    public var success: Bool?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configCount != nil {
            map["ConfigCount"] = self.configCount!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.namespaceDesc != nil {
            map["NamespaceDesc"] = self.namespaceDesc!
        }
        if self.namespaceShowName != nil {
            map["NamespaceShowName"] = self.namespaceShowName!
        }
        if self.quota != nil {
            map["Quota"] = self.quota!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigCount") {
            self.configCount = dict["ConfigCount"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NamespaceDesc") {
            self.namespaceDesc = dict["NamespaceDesc"] as! String
        }
        if dict.keys.contains("NamespaceShowName") {
            self.namespaceShowName = dict["NamespaceShowName"] as! String
        }
        if dict.keys.contains("Quota") {
            self.quota = dict["Quota"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetEngineNamepaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEngineNamepaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEngineNamepaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class GetGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class LogConfigDetails : Tea.TeaModel {
            public var logEnabled: Bool?

            public var logStoreName: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logEnabled != nil {
                    map["LogEnabled"] = self.logEnabled!
                }
                if self.logStoreName != nil {
                    map["LogStoreName"] = self.logStoreName!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LogEnabled") {
                    self.logEnabled = dict["LogEnabled"] as! Bool
                }
                if dict.keys.contains("LogStoreName") {
                    self.logStoreName = dict["LogStoreName"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
            }
        }
        public class XtraceDetails : Tea.TeaModel {
            public var sample: Int32?

            public var traceOn: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sample != nil {
                    map["Sample"] = self.sample!
                }
                if self.traceOn != nil {
                    map["TraceOn"] = self.traceOn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Sample") {
                    self.sample = dict["Sample"] as! Int32
                }
                if dict.keys.contains("TraceOn") {
                    self.traceOn = dict["TraceOn"] as! Bool
                }
            }
        }
        public var chargeType: String?

        public var endDate: String?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var instanceId: String?

        public var logConfigDetails: GetGatewayResponseBody.Data.LogConfigDetails?

        public var mseTag: String?

        public var name: String?

        public var primaryUser: String?

        public var region: String?

        public var replica: Int32?

        public var securityGroup: String?

        public var spec: String?

        public var status: Int32?

        public var statusDesc: String?

        public var vpc: String?

        public var vswitch: String?

        public var vswitch2: String?

        public var xtraceDetails: GetGatewayResponseBody.Data.XtraceDetails?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.logConfigDetails?.validate()
            try self.xtraceDetails?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logConfigDetails != nil {
                map["LogConfigDetails"] = self.logConfigDetails?.toMap()
            }
            if self.mseTag != nil {
                map["MseTag"] = self.mseTag!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.replica != nil {
                map["Replica"] = self.replica!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            if self.vswitch2 != nil {
                map["Vswitch2"] = self.vswitch2!
            }
            if self.xtraceDetails != nil {
                map["XtraceDetails"] = self.xtraceDetails?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("EndDate") {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LogConfigDetails") {
                var model = GetGatewayResponseBody.Data.LogConfigDetails()
                model.fromMap(dict["LogConfigDetails"] as! [String: Any])
                self.logConfigDetails = model
            }
            if dict.keys.contains("MseTag") {
                self.mseTag = dict["MseTag"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Replica") {
                self.replica = dict["Replica"] as! Int32
            }
            if dict.keys.contains("SecurityGroup") {
                self.securityGroup = dict["SecurityGroup"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("Vpc") {
                self.vpc = dict["Vpc"] as! String
            }
            if dict.keys.contains("Vswitch") {
                self.vswitch = dict["Vswitch"] as! String
            }
            if dict.keys.contains("Vswitch2") {
                self.vswitch2 = dict["Vswitch2"] as! String
            }
            if dict.keys.contains("XtraceDetails") {
                var model = GetGatewayResponseBody.Data.XtraceDetails()
                model.fromMap(dict["XtraceDetails"] as! [String: Any])
                self.xtraceDetails = model
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayDomainDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class GetGatewayDomainDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var afterDate: Int64?

        public var algorithm: String?

        public var beforeDate: Int64?

        public var certIdentifier: String?

        public var certName: String?

        public var commonName: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtAfter: String?

        public var gmtBefore: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var http2: String?

        public var id: Int64?

        public var issuer: String?

        public var mustHttps: Bool?

        public var name: String?

        public var protocol_: String?

        public var sans: String?

        public var tlsMax: String?

        public var tlsMin: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.afterDate != nil {
                map["AfterDate"] = self.afterDate!
            }
            if self.algorithm != nil {
                map["Algorithm"] = self.algorithm!
            }
            if self.beforeDate != nil {
                map["BeforeDate"] = self.beforeDate!
            }
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.commonName != nil {
                map["CommonName"] = self.commonName!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtAfter != nil {
                map["GmtAfter"] = self.gmtAfter!
            }
            if self.gmtBefore != nil {
                map["GmtBefore"] = self.gmtBefore!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.http2 != nil {
                map["Http2"] = self.http2!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.issuer != nil {
                map["Issuer"] = self.issuer!
            }
            if self.mustHttps != nil {
                map["MustHttps"] = self.mustHttps!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sans != nil {
                map["Sans"] = self.sans!
            }
            if self.tlsMax != nil {
                map["TlsMax"] = self.tlsMax!
            }
            if self.tlsMin != nil {
                map["TlsMin"] = self.tlsMin!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AfterDate") {
                self.afterDate = dict["AfterDate"] as! Int64
            }
            if dict.keys.contains("Algorithm") {
                self.algorithm = dict["Algorithm"] as! String
            }
            if dict.keys.contains("BeforeDate") {
                self.beforeDate = dict["BeforeDate"] as! Int64
            }
            if dict.keys.contains("CertIdentifier") {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("CertName") {
                self.certName = dict["CertName"] as! String
            }
            if dict.keys.contains("CommonName") {
                self.commonName = dict["CommonName"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtAfter") {
                self.gmtAfter = dict["GmtAfter"] as! String
            }
            if dict.keys.contains("GmtBefore") {
                self.gmtBefore = dict["GmtBefore"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Http2") {
                self.http2 = dict["Http2"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Issuer") {
                self.issuer = dict["Issuer"] as! String
            }
            if dict.keys.contains("MustHttps") {
                self.mustHttps = dict["MustHttps"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("Sans") {
                self.sans = dict["Sans"] as! String
            }
            if dict.keys.contains("TlsMax") {
                self.tlsMax = dict["TlsMax"] as! String
            }
            if dict.keys.contains("TlsMin") {
                self.tlsMin = dict["TlsMin"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayDomainDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayDomainDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayDomainDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayDomainDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayDomainDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayOptionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class GetGatewayOptionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GatewayOption?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GatewayOption()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayOptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayOptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayOptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayRouteDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var routeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
    }
}

public class GetGatewayRouteDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Cors : Tea.TeaModel {
            public var allowCredentials: Bool?

            public var allowHeaders: String?

            public var allowMethods: String?

            public var allowOrigins: String?

            public var exposeHeaders: String?

            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowCredentials != nil {
                    map["AllowCredentials"] = self.allowCredentials!
                }
                if self.allowHeaders != nil {
                    map["AllowHeaders"] = self.allowHeaders!
                }
                if self.allowMethods != nil {
                    map["AllowMethods"] = self.allowMethods!
                }
                if self.allowOrigins != nil {
                    map["AllowOrigins"] = self.allowOrigins!
                }
                if self.exposeHeaders != nil {
                    map["ExposeHeaders"] = self.exposeHeaders!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowCredentials") {
                    self.allowCredentials = dict["AllowCredentials"] as! Bool
                }
                if dict.keys.contains("AllowHeaders") {
                    self.allowHeaders = dict["AllowHeaders"] as! String
                }
                if dict.keys.contains("AllowMethods") {
                    self.allowMethods = dict["AllowMethods"] as! String
                }
                if dict.keys.contains("AllowOrigins") {
                    self.allowOrigins = dict["AllowOrigins"] as! String
                }
                if dict.keys.contains("ExposeHeaders") {
                    self.exposeHeaders = dict["ExposeHeaders"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int64
                }
            }
        }
        public class DirectResponse : Tea.TeaModel {
            public var body: String?

            public var code: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    self.body = dict["Body"] as! String
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! Int32
                }
            }
        }
        public class FallbackServices : Tea.TeaModel {
            public var agreementType: String?

            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var percent: Int32?

            public var serviceId: Int64?

            public var serviceName: String?

            public var servicePort: Int32?

            public var sourceType: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agreementType != nil {
                    map["AgreementType"] = self.agreementType!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgreementType") {
                    self.agreementType = dict["AgreementType"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("ServicePort") {
                    self.servicePort = dict["ServicePort"] as! Int32
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class HTTPRewrite : Tea.TeaModel {
            public var host: String?

            public var path: String?

            public var pathType: String?

            public var pattern: String?

            public var status: String?

            public var substitution: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.pathType != nil {
                    map["PathType"] = self.pathType!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.substitution != nil {
                    map["Substitution"] = self.substitution!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("PathType") {
                    self.pathType = dict["PathType"] as! String
                }
                if dict.keys.contains("Pattern") {
                    self.pattern = dict["Pattern"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Substitution") {
                    self.substitution = dict["Substitution"] as! String
                }
            }
        }
        public class HeaderOp : Tea.TeaModel {
            public class HeaderOpItems : Tea.TeaModel {
                public var directionType: String?

                public var key: String?

                public var opType: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.directionType != nil {
                        map["DirectionType"] = self.directionType!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.opType != nil {
                        map["OpType"] = self.opType!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DirectionType") {
                        self.directionType = dict["DirectionType"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("OpType") {
                        self.opType = dict["OpType"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerOpItems: [GetGatewayRouteDetailResponseBody.Data.HeaderOp.HeaderOpItems]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerOpItems != nil {
                    var tmp : [Any] = []
                    for k in self.headerOpItems! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderOpItems"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderOpItems") {
                    self.headerOpItems = dict["HeaderOpItems"] as! [GetGatewayRouteDetailResponseBody.Data.HeaderOp.HeaderOpItems]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Redirect : Tea.TeaModel {
            public var code: Int32?

            public var host: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! Int32
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public class Retry : Tea.TeaModel {
            public var attempts: Int32?

            public var httpCodes: [String]?

            public var retryOn: [String]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attempts != nil {
                    map["Attempts"] = self.attempts!
                }
                if self.httpCodes != nil {
                    map["HttpCodes"] = self.httpCodes!
                }
                if self.retryOn != nil {
                    map["RetryOn"] = self.retryOn!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attempts") {
                    self.attempts = dict["Attempts"] as! Int32
                }
                if dict.keys.contains("HttpCodes") {
                    self.httpCodes = dict["HttpCodes"] as! [String]
                }
                if dict.keys.contains("RetryOn") {
                    self.retryOn = dict["RetryOn"] as! [String]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RoutePredicates : Tea.TeaModel {
            public class HeaderPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class PathPredicates : Tea.TeaModel {
                public var ignoreCase: Bool?

                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ignoreCase != nil {
                        map["IgnoreCase"] = self.ignoreCase!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IgnoreCase") {
                        self.ignoreCase = dict["IgnoreCase"] as! Bool
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class QueryPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerPredicates: [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.HeaderPredicates]?

            public var methodPredicates: [String]?

            public var pathPredicates: GetGatewayRouteDetailResponseBody.Data.RoutePredicates.PathPredicates?

            public var queryPredicates: [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.QueryPredicates]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pathPredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.headerPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderPredicates"] = tmp
                }
                if self.methodPredicates != nil {
                    map["MethodPredicates"] = self.methodPredicates!
                }
                if self.pathPredicates != nil {
                    map["PathPredicates"] = self.pathPredicates?.toMap()
                }
                if self.queryPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.queryPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["QueryPredicates"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderPredicates") {
                    self.headerPredicates = dict["HeaderPredicates"] as! [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.HeaderPredicates]
                }
                if dict.keys.contains("MethodPredicates") {
                    self.methodPredicates = dict["MethodPredicates"] as! [String]
                }
                if dict.keys.contains("PathPredicates") {
                    var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates.PathPredicates()
                    model.fromMap(dict["PathPredicates"] as! [String: Any])
                    self.pathPredicates = model
                }
                if dict.keys.contains("QueryPredicates") {
                    self.queryPredicates = dict["QueryPredicates"] as! [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.QueryPredicates]
                }
            }
        }
        public class RouteServices : Tea.TeaModel {
            public var agreementType: String?

            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var percent: Int32?

            public var serviceId: Int64?

            public var serviceName: String?

            public var servicePort: Int32?

            public var sourceType: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agreementType != nil {
                    map["AgreementType"] = self.agreementType!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgreementType") {
                    self.agreementType = dict["AgreementType"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("ServicePort") {
                    self.servicePort = dict["ServicePort"] as! Int32
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Timeout : Tea.TeaModel {
            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int32
                }
            }
        }
        public var ahasStatus: Int32?

        public var cors: GetGatewayRouteDetailResponseBody.Data.Cors?

        public var defaultServiceId: Int64?

        public var defaultServiceName: String?

        public var destinationType: String?

        public var directResponse: GetGatewayRouteDetailResponseBody.Data.DirectResponse?

        public var domainId: Int64?

        public var domainIdList: [Int64]?

        public var domainName: String?

        public var domainNameList: [String]?

        public var enableWaf: Bool?

        public var fallback: Bool?

        public var fallbackServices: [GetGatewayRouteDetailResponseBody.Data.FallbackServices]?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var HTTPRewrite: GetGatewayRouteDetailResponseBody.Data.HTTPRewrite?

        public var headerOp: GetGatewayRouteDetailResponseBody.Data.HeaderOp?

        public var id: Int64?

        public var name: String?

        public var predicates: String?

        public var redirect: GetGatewayRouteDetailResponseBody.Data.Redirect?

        public var retry: GetGatewayRouteDetailResponseBody.Data.Retry?

        public var routeOrder: Int32?

        public var routePredicates: GetGatewayRouteDetailResponseBody.Data.RoutePredicates?

        public var routeServices: [GetGatewayRouteDetailResponseBody.Data.RouteServices]?

        public var services: String?

        public var status: Int32?

        public var timeout: GetGatewayRouteDetailResponseBody.Data.Timeout?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cors?.validate()
            try self.directResponse?.validate()
            try self.HTTPRewrite?.validate()
            try self.headerOp?.validate()
            try self.redirect?.validate()
            try self.retry?.validate()
            try self.routePredicates?.validate()
            try self.timeout?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ahasStatus != nil {
                map["AhasStatus"] = self.ahasStatus!
            }
            if self.cors != nil {
                map["Cors"] = self.cors?.toMap()
            }
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.defaultServiceName != nil {
                map["DefaultServiceName"] = self.defaultServiceName!
            }
            if self.destinationType != nil {
                map["DestinationType"] = self.destinationType!
            }
            if self.directResponse != nil {
                map["DirectResponse"] = self.directResponse?.toMap()
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainIdList != nil {
                map["DomainIdList"] = self.domainIdList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameList != nil {
                map["DomainNameList"] = self.domainNameList!
            }
            if self.enableWaf != nil {
                map["EnableWaf"] = self.enableWaf!
            }
            if self.fallback != nil {
                map["Fallback"] = self.fallback!
            }
            if self.fallbackServices != nil {
                var tmp : [Any] = []
                for k in self.fallbackServices! {
                    tmp.append(k.toMap())
                }
                map["FallbackServices"] = tmp
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.HTTPRewrite != nil {
                map["HTTPRewrite"] = self.HTTPRewrite?.toMap()
            }
            if self.headerOp != nil {
                map["HeaderOp"] = self.headerOp?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.predicates != nil {
                map["Predicates"] = self.predicates!
            }
            if self.redirect != nil {
                map["Redirect"] = self.redirect?.toMap()
            }
            if self.retry != nil {
                map["Retry"] = self.retry?.toMap()
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.routePredicates != nil {
                map["RoutePredicates"] = self.routePredicates?.toMap()
            }
            if self.routeServices != nil {
                var tmp : [Any] = []
                for k in self.routeServices! {
                    tmp.append(k.toMap())
                }
                map["RouteServices"] = tmp
            }
            if self.services != nil {
                map["Services"] = self.services!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AhasStatus") {
                self.ahasStatus = dict["AhasStatus"] as! Int32
            }
            if dict.keys.contains("Cors") {
                var model = GetGatewayRouteDetailResponseBody.Data.Cors()
                model.fromMap(dict["Cors"] as! [String: Any])
                self.cors = model
            }
            if dict.keys.contains("DefaultServiceId") {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("DefaultServiceName") {
                self.defaultServiceName = dict["DefaultServiceName"] as! String
            }
            if dict.keys.contains("DestinationType") {
                self.destinationType = dict["DestinationType"] as! String
            }
            if dict.keys.contains("DirectResponse") {
                var model = GetGatewayRouteDetailResponseBody.Data.DirectResponse()
                model.fromMap(dict["DirectResponse"] as! [String: Any])
                self.directResponse = model
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainIdList") {
                self.domainIdList = dict["DomainIdList"] as! [Int64]
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainNameList") {
                self.domainNameList = dict["DomainNameList"] as! [String]
            }
            if dict.keys.contains("EnableWaf") {
                self.enableWaf = dict["EnableWaf"] as! Bool
            }
            if dict.keys.contains("Fallback") {
                self.fallback = dict["Fallback"] as! Bool
            }
            if dict.keys.contains("FallbackServices") {
                self.fallbackServices = dict["FallbackServices"] as! [GetGatewayRouteDetailResponseBody.Data.FallbackServices]
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("HTTPRewrite") {
                var model = GetGatewayRouteDetailResponseBody.Data.HTTPRewrite()
                model.fromMap(dict["HTTPRewrite"] as! [String: Any])
                self.HTTPRewrite = model
            }
            if dict.keys.contains("HeaderOp") {
                var model = GetGatewayRouteDetailResponseBody.Data.HeaderOp()
                model.fromMap(dict["HeaderOp"] as! [String: Any])
                self.headerOp = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Predicates") {
                self.predicates = dict["Predicates"] as! String
            }
            if dict.keys.contains("Redirect") {
                var model = GetGatewayRouteDetailResponseBody.Data.Redirect()
                model.fromMap(dict["Redirect"] as! [String: Any])
                self.redirect = model
            }
            if dict.keys.contains("Retry") {
                var model = GetGatewayRouteDetailResponseBody.Data.Retry()
                model.fromMap(dict["Retry"] as! [String: Any])
                self.retry = model
            }
            if dict.keys.contains("RouteOrder") {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("RoutePredicates") {
                var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates()
                model.fromMap(dict["RoutePredicates"] as! [String: Any])
                self.routePredicates = model
            }
            if dict.keys.contains("RouteServices") {
                self.routeServices = dict["RouteServices"] as! [GetGatewayRouteDetailResponseBody.Data.RouteServices]
            }
            if dict.keys.contains("Services") {
                self.services = dict["Services"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Timeout") {
                var model = GetGatewayRouteDetailResponseBody.Data.Timeout()
                model.fromMap(dict["Timeout"] as! [String: Any])
                self.timeout = model
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayRouteDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayRouteDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayRouteDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayRouteDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayRouteDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayServiceDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
    }
}

public class GetGatewayServiceDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class LabelDetails : Tea.TeaModel {
            public var key: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Values") {
                    self.values = dict["Values"] as! [String]
                }
            }
        }
        public class PortTrafficPolicyList : Tea.TeaModel {
            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var serviceId: Int64?

            public var servicePort: Int32?

            public var trafficPolicy: TrafficPolicy?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.trafficPolicy?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.trafficPolicy != nil {
                    map["TrafficPolicy"] = self.trafficPolicy?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServicePort") {
                    self.servicePort = dict["ServicePort"] as! Int32
                }
                if dict.keys.contains("TrafficPolicy") {
                    var model = TrafficPolicy()
                    model.fromMap(dict["TrafficPolicy"] as! [String: Any])
                    self.trafficPolicy = model
                }
            }
        }
        public class VersionDetails : Tea.TeaModel {
            public class ServiceVersion : Tea.TeaModel {
                public class Labels : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var labels: [GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion.Labels]?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.labels != nil {
                        var tmp : [Any] = []
                        for k in self.labels! {
                            tmp.append(k.toMap())
                        }
                        map["Labels"] = tmp
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Labels") {
                        self.labels = dict["Labels"] as! [GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion.Labels]
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var endpointNum: Int32?

            public var endpointNumPercent: String?

            public var serviceVersion: GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.serviceVersion?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpointNum != nil {
                    map["EndpointNum"] = self.endpointNum!
                }
                if self.endpointNumPercent != nil {
                    map["EndpointNumPercent"] = self.endpointNumPercent!
                }
                if self.serviceVersion != nil {
                    map["ServiceVersion"] = self.serviceVersion?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndpointNum") {
                    self.endpointNum = dict["EndpointNum"] as! Int32
                }
                if dict.keys.contains("EndpointNumPercent") {
                    self.endpointNumPercent = dict["EndpointNumPercent"] as! String
                }
                if dict.keys.contains("ServiceVersion") {
                    var model = GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion()
                    model.fromMap(dict["ServiceVersion"] as! [String: Any])
                    self.serviceVersion = model
                }
            }
        }
        public class Versions : Tea.TeaModel {
            public var label: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var gatewayId: Int64?

        public var gatewayTrafficPolicy: TrafficPolicy?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupName: String?

        public var healthCheck: String?

        public var healthStatus: String?

        public var id: Int64?

        public var ips: [String]?

        public var labelDetails: [GetGatewayServiceDetailResponseBody.Data.LabelDetails]?

        public var metaInfo: String?

        public var name: String?

        public var namespace: String?

        public var portTrafficPolicyList: [GetGatewayServiceDetailResponseBody.Data.PortTrafficPolicyList]?

        public var ports: [Int32]?

        public var serviceNameInRegistry: String?

        public var serviceProtocol: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public var versionDetails: [GetGatewayServiceDetailResponseBody.Data.VersionDetails]?

        public var versions: [GetGatewayServiceDetailResponseBody.Data.Versions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.gatewayTrafficPolicy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayTrafficPolicy != nil {
                map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.healthCheck != nil {
                map["HealthCheck"] = self.healthCheck!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.labelDetails != nil {
                var tmp : [Any] = []
                for k in self.labelDetails! {
                    tmp.append(k.toMap())
                }
                map["LabelDetails"] = tmp
            }
            if self.metaInfo != nil {
                map["MetaInfo"] = self.metaInfo!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.portTrafficPolicyList != nil {
                var tmp : [Any] = []
                for k in self.portTrafficPolicyList! {
                    tmp.append(k.toMap())
                }
                map["PortTrafficPolicyList"] = tmp
            }
            if self.ports != nil {
                map["Ports"] = self.ports!
            }
            if self.serviceNameInRegistry != nil {
                map["ServiceNameInRegistry"] = self.serviceNameInRegistry!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.sourceId != nil {
                map["SourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.versionDetails != nil {
                var tmp : [Any] = []
                for k in self.versionDetails! {
                    tmp.append(k.toMap())
                }
                map["VersionDetails"] = tmp
            }
            if self.versions != nil {
                var tmp : [Any] = []
                for k in self.versions! {
                    tmp.append(k.toMap())
                }
                map["Versions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayTrafficPolicy") {
                var model = TrafficPolicy()
                model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
                self.gatewayTrafficPolicy = model
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HealthCheck") {
                self.healthCheck = dict["HealthCheck"] as! String
            }
            if dict.keys.contains("HealthStatus") {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Ips") {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("LabelDetails") {
                self.labelDetails = dict["LabelDetails"] as! [GetGatewayServiceDetailResponseBody.Data.LabelDetails]
            }
            if dict.keys.contains("MetaInfo") {
                self.metaInfo = dict["MetaInfo"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PortTrafficPolicyList") {
                self.portTrafficPolicyList = dict["PortTrafficPolicyList"] as! [GetGatewayServiceDetailResponseBody.Data.PortTrafficPolicyList]
            }
            if dict.keys.contains("Ports") {
                self.ports = dict["Ports"] as! [Int32]
            }
            if dict.keys.contains("ServiceNameInRegistry") {
                self.serviceNameInRegistry = dict["ServiceNameInRegistry"] as! String
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("SourceId") {
                self.sourceId = dict["SourceId"] as! Int64
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("VersionDetails") {
                self.versionDetails = dict["VersionDetails"] as! [GetGatewayServiceDetailResponseBody.Data.VersionDetails]
            }
            if dict.keys.contains("Versions") {
                self.versions = dict["Versions"] as! [GetGatewayServiceDetailResponseBody.Data.Versions]
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayServiceDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayServiceDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayServiceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayServiceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayServiceDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGovernanceKubernetesClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var mseSessionId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetGovernanceKubernetesClusterResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Namespaces : Tea.TeaModel {
            public var name: String?

            public var tags: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! String
                }
            }
        }
        public var clusterId: String?

        public var clusterName: String?

        public var k8sVersion: String?

        public var namespaceInfos: String?

        public var namespaces: [GetGovernanceKubernetesClusterResponseBody.Data.Namespaces]?

        public var pilotStartTime: String?

        public var region: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.k8sVersion != nil {
                map["K8sVersion"] = self.k8sVersion!
            }
            if self.namespaceInfos != nil {
                map["NamespaceInfos"] = self.namespaceInfos!
            }
            if self.namespaces != nil {
                var tmp : [Any] = []
                for k in self.namespaces! {
                    tmp.append(k.toMap())
                }
                map["Namespaces"] = tmp
            }
            if self.pilotStartTime != nil {
                map["PilotStartTime"] = self.pilotStartTime!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("K8sVersion") {
                self.k8sVersion = dict["K8sVersion"] as! String
            }
            if dict.keys.contains("NamespaceInfos") {
                self.namespaceInfos = dict["NamespaceInfos"] as! String
            }
            if dict.keys.contains("Namespaces") {
                self.namespaces = dict["Namespaces"] as! [GetGovernanceKubernetesClusterResponseBody.Data.Namespaces]
            }
            if dict.keys.contains("PilotStartTime") {
                self.pilotStartTime = dict["PilotStartTime"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetGovernanceKubernetesClusterResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGovernanceKubernetesClusterResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGovernanceKubernetesClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGovernanceKubernetesClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGovernanceKubernetesClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class GetImageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var currentVersionFullShowName: String?

        public var maxVersionChangelogUrl: String?

        public var maxVersionCode: String?

        public var maxVersionFullShowName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentVersionFullShowName != nil {
                map["CurrentVersionFullShowName"] = self.currentVersionFullShowName!
            }
            if self.maxVersionChangelogUrl != nil {
                map["MaxVersionChangelogUrl"] = self.maxVersionChangelogUrl!
            }
            if self.maxVersionCode != nil {
                map["MaxVersionCode"] = self.maxVersionCode!
            }
            if self.maxVersionFullShowName != nil {
                map["MaxVersionFullShowName"] = self.maxVersionFullShowName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentVersionFullShowName") {
                self.currentVersionFullShowName = dict["CurrentVersionFullShowName"] as! String
            }
            if dict.keys.contains("MaxVersionChangelogUrl") {
                self.maxVersionChangelogUrl = dict["MaxVersionChangelogUrl"] as! String
            }
            if dict.keys.contains("MaxVersionCode") {
                self.maxVersionCode = dict["MaxVersionCode"] as! String
            }
            if dict.keys.contains("MaxVersionFullShowName") {
                self.maxVersionFullShowName = dict["MaxVersionFullShowName"] as! String
            }
        }
    }
    public var data: GetImageResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetImageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImportFileUrlRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var contentType: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class GetImportFileUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetImportFileUrlResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetImportFileUrlResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetImportFileUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImportFileUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetImportFileUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetKubernetesSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class GetKubernetesSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cluster: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cluster != nil {
                map["Cluster"] = self.cluster!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cluster") {
                self.cluster = dict["Cluster"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetKubernetesSourceResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetKubernetesSourceResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetKubernetesSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetKubernetesSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetKubernetesSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMseFeatureSwitchRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class GetMseFeatureSwitchResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [String: Any]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String: Any]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMseFeatureSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMseFeatureSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMseFeatureSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMseSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetMseSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var address: String?

        public var clusterId: String?

        public var instanceId: String?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetMseSourceResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetMseSourceResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMseSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMseSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMseSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var beta: Bool?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.beta != nil {
            map["Beta"] = self.beta!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Beta") {
            self.beta = dict["Beta"] as! Bool
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class GetNacosConfigResponseBody : Tea.TeaModel {
    public class Configuration : Tea.TeaModel {
        public var appName: String?

        public var betaIps: String?

        public var content: String?

        public var dataId: String?

        public var desc: String?

        public var encryptedDataKey: String?

        public var group: String?

        public var md5: String?

        public var tags: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.betaIps != nil {
                map["BetaIps"] = self.betaIps!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.encryptedDataKey != nil {
                map["EncryptedDataKey"] = self.encryptedDataKey!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("BetaIps") {
                self.betaIps = dict["BetaIps"] as! String
            }
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Desc") {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("EncryptedDataKey") {
                self.encryptedDataKey = dict["EncryptedDataKey"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var configuration: GetNacosConfigResponseBody.Configuration?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configuration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configuration != nil {
            map["Configuration"] = self.configuration?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configuration") {
            var model = GetNacosConfigResponseBody.Configuration()
            model.fromMap(dict["Configuration"] as! [String: Any])
            self.configuration = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNacosHistoryConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var nid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nid != nil {
            map["Nid"] = self.nid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Nid") {
            self.nid = dict["Nid"] as! String
        }
    }
}

public class GetNacosHistoryConfigResponseBody : Tea.TeaModel {
    public class Configuration : Tea.TeaModel {
        public var appName: String?

        public var content: String?

        public var dataId: String?

        public var encryptedDataKey: String?

        public var group: String?

        public var md5: String?

        public var opType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.encryptedDataKey != nil {
                map["EncryptedDataKey"] = self.encryptedDataKey!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("EncryptedDataKey") {
                self.encryptedDataKey = dict["EncryptedDataKey"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("OpType") {
                self.opType = dict["OpType"] as! String
            }
        }
    }
    public var configuration: GetNacosHistoryConfigResponseBody.Configuration?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configuration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configuration != nil {
            map["Configuration"] = self.configuration?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configuration") {
            var model = GetNacosHistoryConfigResponseBody.Configuration()
            model.fromMap(dict["Configuration"] as! [String: Any])
            self.configuration = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNacosHistoryConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNacosHistoryConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNacosHistoryConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOverviewRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public var period: Int32?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class GetOverviewResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetOverviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOverviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOverviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPluginConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var pluginId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! Int64
        }
    }
}

public class GetPluginConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class GatewayConfigList : Tea.TeaModel {
            public var config: String?

            public var configLevel: Int32?

            public var enable: Bool?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var pluginId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.config != nil {
                    map["Config"] = self.config!
                }
                if self.configLevel != nil {
                    map["ConfigLevel"] = self.configLevel!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.pluginId != nil {
                    map["PluginId"] = self.pluginId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Config") {
                    self.config = dict["Config"] as! String
                }
                if dict.keys.contains("ConfigLevel") {
                    self.configLevel = dict["ConfigLevel"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("PluginId") {
                    self.pluginId = dict["PluginId"] as! Int64
                }
            }
        }
        public var category: Int32?

        public var configCheck: String?

        public var gatewayConfigList: [GetPluginConfigResponseBody.Data.GatewayConfigList]?

        public var id: Int64?

        public var imageName: String?

        public var mode: Int32?

        public var name: String?

        public var phase: Int32?

        public var primaryUser: String?

        public var priority: Int32?

        public var publishState: Int32?

        public var readme: String?

        public var readmeEn: String?

        public var status: String?

        public var summary: String?

        public var type: Int32?

        public var version: String?

        public var wasmLang: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configCheck != nil {
                map["ConfigCheck"] = self.configCheck!
            }
            if self.gatewayConfigList != nil {
                var tmp : [Any] = []
                for k in self.gatewayConfigList! {
                    tmp.append(k.toMap())
                }
                map["GatewayConfigList"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.readme != nil {
                map["Readme"] = self.readme!
            }
            if self.readmeEn != nil {
                map["ReadmeEn"] = self.readmeEn!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.wasmLang != nil {
                map["WasmLang"] = self.wasmLang!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! Int32
            }
            if dict.keys.contains("ConfigCheck") {
                self.configCheck = dict["ConfigCheck"] as! String
            }
            if dict.keys.contains("GatewayConfigList") {
                self.gatewayConfigList = dict["GatewayConfigList"] as! [GetPluginConfigResponseBody.Data.GatewayConfigList]
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ImageName") {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Phase") {
                self.phase = dict["Phase"] as! Int32
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("PublishState") {
                self.publishState = dict["PublishState"] as! Int32
            }
            if dict.keys.contains("Readme") {
                self.readme = dict["Readme"] as! String
            }
            if dict.keys.contains("ReadmeEn") {
                self.readmeEn = dict["ReadmeEn"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("WasmLang") {
                self.wasmLang = dict["WasmLang"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GetPluginConfigResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetPluginConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPluginConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPluginConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPluginConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPluginsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var category: Int32?

    public var enableOnly: Bool?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.enableOnly != nil {
            map["EnableOnly"] = self.enableOnly!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! Int32
        }
        if dict.keys.contains("EnableOnly") {
            self.enableOnly = dict["EnableOnly"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class GetPluginsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var category: Int32?

        public var configCheck: String?

        public var id: Int64?

        public var name: String?

        public var phase: Int32?

        public var primaryUser: String?

        public var priority: Int32?

        public var publishState: Int32?

        public var status: String?

        public var summary: String?

        public var version: String?

        public var wasmFile: String?

        public var wasmLang: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configCheck != nil {
                map["ConfigCheck"] = self.configCheck!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.wasmFile != nil {
                map["WasmFile"] = self.wasmFile!
            }
            if self.wasmLang != nil {
                map["WasmLang"] = self.wasmLang!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! Int32
            }
            if dict.keys.contains("ConfigCheck") {
                self.configCheck = dict["ConfigCheck"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Phase") {
                self.phase = dict["Phase"] as! Int32
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("PublishState") {
                self.publishState = dict["PublishState"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("WasmFile") {
                self.wasmFile = dict["WasmFile"] as! String
            }
            if dict.keys.contains("WasmLang") {
                self.wasmLang = dict["WasmLang"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: [GetPluginsResponseBody.Data]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetPluginsResponseBody.Data]
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPluginsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var ip: String?

    public var mseSessionId: String?

    public var region: String?

    public var serviceName: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class GetServiceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Methods : Tea.TeaModel {
            public var methodController: String?

            public var name: String?

            public var parameterTypes: [String]?

            public var paths: [String]?

            public var requestMethods: [String]?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MethodController") {
                    self.methodController = dict["MethodController"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParameterTypes") {
                    self.parameterTypes = dict["ParameterTypes"] as! [String]
                }
                if dict.keys.contains("Paths") {
                    self.paths = dict["Paths"] as! [String]
                }
                if dict.keys.contains("RequestMethods") {
                    self.requestMethods = dict["RequestMethods"] as! [String]
                }
                if dict.keys.contains("ReturnType") {
                    self.returnType = dict["ReturnType"] as! String
                }
            }
        }
        public var dubboApplicationName: String?

        public var edasAppName: String?

        public var group: String?

        public var metadata: [String: Any]?

        public var methods: [GetServiceListResponseBody.Data.Methods]?

        public var registryType: String?

        public var serviceName: String?

        public var serviceType: String?

        public var springApplicationName: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dubboApplicationName != nil {
                map["DubboApplicationName"] = self.dubboApplicationName!
            }
            if self.edasAppName != nil {
                map["EdasAppName"] = self.edasAppName!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.methods != nil {
                var tmp : [Any] = []
                for k in self.methods! {
                    tmp.append(k.toMap())
                }
                map["Methods"] = tmp
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.springApplicationName != nil {
                map["SpringApplicationName"] = self.springApplicationName!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DubboApplicationName") {
                self.dubboApplicationName = dict["DubboApplicationName"] as! String
            }
            if dict.keys.contains("EdasAppName") {
                self.edasAppName = dict["EdasAppName"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Metadata") {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Methods") {
                self.methods = dict["Methods"] as! [GetServiceListResponseBody.Data.Methods]
            }
            if dict.keys.contains("RegistryType") {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("ServiceType") {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("SpringApplicationName") {
                self.springApplicationName = dict["SpringApplicationName"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetServiceListResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetServiceListResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetServiceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceListenersRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var hasIpCount: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.hasIpCount != nil {
            map["HasIpCount"] = self.hasIpCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HasIpCount") {
            self.hasIpCount = dict["HasIpCount"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class GetServiceListenersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var addr: String?

        public var agent: String?

        public var app: String?

        public var cluster: String?

        public var IP: String?

        public var namespaceId: String?

        public var port: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                map["Addr"] = self.addr!
            }
            if self.agent != nil {
                map["Agent"] = self.agent!
            }
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.cluster != nil {
                map["Cluster"] = self.cluster!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                self.addr = dict["Addr"] as! String
            }
            if dict.keys.contains("Agent") {
                self.agent = dict["Agent"] as! String
            }
            if dict.keys.contains("App") {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("Cluster") {
                self.cluster = dict["Cluster"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public var data: [GetServiceListenersResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetServiceListenersResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class GetServiceListenersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListenersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetServiceListenersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTagsBySwimmingLaneGroupIdRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class GetTagsBySwimmingLaneGroupIdResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTagsBySwimmingLaneGroupIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTagsBySwimmingLaneGroupIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTagsBySwimmingLaneGroupIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var fileUrl: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var policy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
    }
}

public class ImportNacosConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FailData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public class SkipData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public var failData: [ImportNacosConfigResponseBody.Data.FailData]?

        public var skipCount: Int32?

        public var skipData: [ImportNacosConfigResponseBody.Data.SkipData]?

        public var succCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failData != nil {
                var tmp : [Any] = []
                for k in self.failData! {
                    tmp.append(k.toMap())
                }
                map["FailData"] = tmp
            }
            if self.skipCount != nil {
                map["SkipCount"] = self.skipCount!
            }
            if self.skipData != nil {
                var tmp : [Any] = []
                for k in self.skipData! {
                    tmp.append(k.toMap())
                }
                map["SkipData"] = tmp
            }
            if self.succCount != nil {
                map["SuccCount"] = self.succCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailData") {
                self.failData = dict["FailData"] as! [ImportNacosConfigResponseBody.Data.FailData]
            }
            if dict.keys.contains("SkipCount") {
                self.skipCount = dict["SkipCount"] as! Int32
            }
            if dict.keys.contains("SkipData") {
                self.skipData = dict["SkipData"] as! [ImportNacosConfigResponseBody.Data.SkipData]
            }
            if dict.keys.contains("SuccCount") {
                self.succCount = dict["SuccCount"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ImportNacosConfigResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ImportNacosConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportServicesRequest : Tea.TeaModel {
    public class ServiceList : Tea.TeaModel {
        public var groupName: String?

        public var ips: [String]?

        public var name: String?

        public var namespace: String?

        public var servicePort: Int64?

        public var serviceProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Ips") {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int64
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var serviceList: [ImportServicesRequest.ServiceList]?

    public var sourceType: String?

    public var tlsSetting: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceList != nil {
            var tmp : [Any] = []
            for k in self.serviceList! {
                tmp.append(k.toMap())
            }
            map["ServiceList"] = tmp
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceList") {
            self.serviceList = dict["ServiceList"] as! [ImportServicesRequest.ServiceList]
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("TlsSetting") {
            self.tlsSetting = dict["TlsSetting"] as! String
        }
    }
}

public class ImportServicesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var serviceListShrink: String?

    public var sourceType: String?

    public var tlsSetting: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceListShrink != nil {
            map["ServiceList"] = self.serviceListShrink!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceList") {
            self.serviceListShrink = dict["ServiceList"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("TlsSetting") {
            self.tlsSetting = dict["TlsSetting"] as! String
        }
    }
}

public class ImportServicesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAnsInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListAnsInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var app: String?

        public var clusterName: String?

        public var datumKey: String?

        public var defaultKey: String?

        public var enabled: Bool?

        public var ephemeral: Bool?

        public var failCount: Int32?

        public var healthy: Bool?

        public var instanceHeartBeatInterval: Int32?

        public var instanceHeartBeatTimeOut: Int32?

        public var instanceId: String?

        public var ip: String?

        public var ipDeleteTimeout: Int32?

        public var lastBeat: Int64?

        public var marked: Bool?

        public var metadata: [String: Any]?

        public var okCount: Int32?

        public var port: Int32?

        public var serviceName: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.datumKey != nil {
                map["DatumKey"] = self.datumKey!
            }
            if self.defaultKey != nil {
                map["DefaultKey"] = self.defaultKey!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.ephemeral != nil {
                map["Ephemeral"] = self.ephemeral!
            }
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.healthy != nil {
                map["Healthy"] = self.healthy!
            }
            if self.instanceHeartBeatInterval != nil {
                map["InstanceHeartBeatInterval"] = self.instanceHeartBeatInterval!
            }
            if self.instanceHeartBeatTimeOut != nil {
                map["InstanceHeartBeatTimeOut"] = self.instanceHeartBeatTimeOut!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.ipDeleteTimeout != nil {
                map["IpDeleteTimeout"] = self.ipDeleteTimeout!
            }
            if self.lastBeat != nil {
                map["LastBeat"] = self.lastBeat!
            }
            if self.marked != nil {
                map["Marked"] = self.marked!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.okCount != nil {
                map["OkCount"] = self.okCount!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("DatumKey") {
                self.datumKey = dict["DatumKey"] as! String
            }
            if dict.keys.contains("DefaultKey") {
                self.defaultKey = dict["DefaultKey"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("Ephemeral") {
                self.ephemeral = dict["Ephemeral"] as! Bool
            }
            if dict.keys.contains("FailCount") {
                self.failCount = dict["FailCount"] as! Int32
            }
            if dict.keys.contains("Healthy") {
                self.healthy = dict["Healthy"] as! Bool
            }
            if dict.keys.contains("InstanceHeartBeatInterval") {
                self.instanceHeartBeatInterval = dict["InstanceHeartBeatInterval"] as! Int32
            }
            if dict.keys.contains("InstanceHeartBeatTimeOut") {
                self.instanceHeartBeatTimeOut = dict["InstanceHeartBeatTimeOut"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("IpDeleteTimeout") {
                self.ipDeleteTimeout = dict["IpDeleteTimeout"] as! Int32
            }
            if dict.keys.contains("LastBeat") {
                self.lastBeat = dict["LastBeat"] as! Int64
            }
            if dict.keys.contains("Marked") {
                self.marked = dict["Marked"] as! Bool
            }
            if dict.keys.contains("Metadata") {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("OkCount") {
                self.okCount = dict["OkCount"] as! Int32
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var data: [ListAnsInstancesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListAnsInstancesResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAnsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAnsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAnsInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAnsServiceClustersRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListAnsServiceClustersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Clusters : Tea.TeaModel {
            public var defaultCheckPort: Int32?

            public var defaultPort: Int32?

            public var healthCheckerType: String?

            public var metadata: [String: Any]?

            public var name: String?

            public var serviceName: String?

            public var useIPPort4Check: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.defaultCheckPort != nil {
                    map["DefaultCheckPort"] = self.defaultCheckPort!
                }
                if self.defaultPort != nil {
                    map["DefaultPort"] = self.defaultPort!
                }
                if self.healthCheckerType != nil {
                    map["HealthCheckerType"] = self.healthCheckerType!
                }
                if self.metadata != nil {
                    map["Metadata"] = self.metadata!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.useIPPort4Check != nil {
                    map["UseIPPort4Check"] = self.useIPPort4Check!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DefaultCheckPort") {
                    self.defaultCheckPort = dict["DefaultCheckPort"] as! Int32
                }
                if dict.keys.contains("DefaultPort") {
                    self.defaultPort = dict["DefaultPort"] as! Int32
                }
                if dict.keys.contains("HealthCheckerType") {
                    self.healthCheckerType = dict["HealthCheckerType"] as! String
                }
                if dict.keys.contains("Metadata") {
                    self.metadata = dict["Metadata"] as! [String: Any]
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("UseIPPort4Check") {
                    self.useIPPort4Check = dict["UseIPPort4Check"] as! Bool
                }
            }
        }
        public var clusters: [ListAnsServiceClustersResponseBody.Data.Clusters]?

        public var ephemeral: Bool?

        public var groupName: String?

        public var metadata: [String: Any]?

        public var name: String?

        public var protectThreshold: Double?

        public var selectorType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusters != nil {
                var tmp : [Any] = []
                for k in self.clusters! {
                    tmp.append(k.toMap())
                }
                map["Clusters"] = tmp
            }
            if self.ephemeral != nil {
                map["Ephemeral"] = self.ephemeral!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protectThreshold != nil {
                map["ProtectThreshold"] = self.protectThreshold!
            }
            if self.selectorType != nil {
                map["SelectorType"] = self.selectorType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Clusters") {
                self.clusters = dict["Clusters"] as! [ListAnsServiceClustersResponseBody.Data.Clusters]
            }
            if dict.keys.contains("Ephemeral") {
                self.ephemeral = dict["Ephemeral"] as! Bool
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Metadata") {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProtectThreshold") {
                self.protectThreshold = dict["ProtectThreshold"] as! Double
            }
            if dict.keys.contains("SelectorType") {
                self.selectorType = dict["SelectorType"] as! String
            }
        }
    }
    public var data: ListAnsServiceClustersResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListAnsServiceClustersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAnsServiceClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAnsServiceClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAnsServiceClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAnsServicesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var groupName: String?

    public var hasIpCount: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.hasIpCount != nil {
            map["HasIpCount"] = self.hasIpCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HasIpCount") {
            self.hasIpCount = dict["HasIpCount"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListAnsServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterCount: Int32?

        public var groupName: String?

        public var healthyInstanceCount: Int32?

        public var ipCount: Int32?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterCount != nil {
                map["ClusterCount"] = self.clusterCount!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.healthyInstanceCount != nil {
                map["HealthyInstanceCount"] = self.healthyInstanceCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterCount") {
                self.clusterCount = dict["ClusterCount"] as! Int32
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HealthyInstanceCount") {
                self.healthyInstanceCount = dict["HealthyInstanceCount"] as! Int32
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var data: [ListAnsServicesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListAnsServicesResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAnsServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAnsServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAnsServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppBySwimmingLaneGroupTagRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var mseSessionId: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class ListAppBySwimmingLaneGroupTagResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAppBySwimmingLaneGroupTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppBySwimmingLaneGroupTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAppBySwimmingLaneGroupTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationsWithTagRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var mseSessionId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class ListApplicationsWithTagRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class RouteRules : Tea.TeaModel {
                public var carryData: Bool?

                public var enable: Bool?

                public var gmtModified: String?

                public var id: Int64?

                public var instanceNum: Int32?

                public var name: String?

                public var rate: Int32?

                public var remove: Bool?

                public var rules: String?

                public var status: Int32?

                public var tag: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.carryData != nil {
                        map["CarryData"] = self.carryData!
                    }
                    if self.enable != nil {
                        map["Enable"] = self.enable!
                    }
                    if self.gmtModified != nil {
                        map["GmtModified"] = self.gmtModified!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.instanceNum != nil {
                        map["InstanceNum"] = self.instanceNum!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.remove != nil {
                        map["Remove"] = self.remove!
                    }
                    if self.rules != nil {
                        map["Rules"] = self.rules!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CarryData") {
                        self.carryData = dict["CarryData"] as! Bool
                    }
                    if dict.keys.contains("Enable") {
                        self.enable = dict["Enable"] as! Bool
                    }
                    if dict.keys.contains("GmtModified") {
                        self.gmtModified = dict["GmtModified"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("InstanceNum") {
                        self.instanceNum = dict["InstanceNum"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! Int32
                    }
                    if dict.keys.contains("Remove") {
                        self.remove = dict["Remove"] as! Bool
                    }
                    if dict.keys.contains("Rules") {
                        self.rules = dict["Rules"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! Int32
                    }
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! String
                    }
                }
            }
            public var appId: String?

            public var appName: String?

            public var routeRules: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules]?

            public var routeStatus: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.routeRules != nil {
                    var tmp : [Any] = []
                    for k in self.routeRules! {
                        tmp.append(k.toMap())
                    }
                    map["RouteRules"] = tmp
                }
                if self.routeStatus != nil {
                    map["RouteStatus"] = self.routeStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("RouteRules") {
                    self.routeRules = dict["RouteRules"] as! [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules]
                }
                if dict.keys.contains("RouteStatus") {
                    self.routeStatus = dict["RouteStatus"] as! Int64
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListApplicationsWithTagRulesResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! [ListApplicationsWithTagRulesResponseBody.Data.Result]
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListApplicationsWithTagRulesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListApplicationsWithTagRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListApplicationsWithTagRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsWithTagRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApplicationsWithTagRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterConnectionTypesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class ListClusterConnectionTypesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ShowName") {
                self.showName = dict["ShowName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListClusterConnectionTypesResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListClusterConnectionTypesResponseBody.Data]
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterConnectionTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterConnectionTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClusterConnectionTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterTypesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var connectType: String?

    public var mseSessionId: String?

    public var mseVersion: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.connectType != nil {
            map["ConnectType"] = self.connectType!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConnectType") {
            self.connectType = dict["ConnectType"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListClusterTypesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ShowName") {
                self.showName = dict["ShowName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListClusterTypesResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListClusterTypesResponseBody.Data]
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClusterTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterVersionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var mseSessionId: String?

    public var mseVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
    }
}

public class ListClusterVersionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterType: String?

        public var code: String?

        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ShowName") {
                self.showName = dict["ShowName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListClusterVersionsResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListClusterVersionsResponseBody.Data]
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClusterVersionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClustersRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var clusterAliasName: String?

    public var mseSessionId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var tag: [ListClustersRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterAliasName != nil {
            map["ClusterAliasName"] = self.clusterAliasName!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterAliasName") {
            self.clusterAliasName = dict["ClusterAliasName"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ListClustersRequest.Tag]
        }
    }
}

public class ListClustersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appVersion: String?

        public var canUpdate: Bool?

        public var chargeType: String?

        public var clusterAliasName: String?

        public var clusterName: String?

        public var clusterType: String?

        public var createTime: String?

        public var endDate: String?

        public var initStatus: String?

        public var instanceCount: Int64?

        public var instanceId: String?

        public var internetAddress: String?

        public var internetDomain: String?

        public var intranetAddress: String?

        public var intranetDomain: String?

        public var mseVersion: String?

        public var resourceGroupId: String?

        public var tags: [String: Any]?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.canUpdate != nil {
                map["CanUpdate"] = self.canUpdate!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterAliasName != nil {
                map["ClusterAliasName"] = self.clusterAliasName!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.initStatus != nil {
                map["InitStatus"] = self.initStatus!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.internetAddress != nil {
                map["InternetAddress"] = self.internetAddress!
            }
            if self.internetDomain != nil {
                map["InternetDomain"] = self.internetDomain!
            }
            if self.intranetAddress != nil {
                map["IntranetAddress"] = self.intranetAddress!
            }
            if self.intranetDomain != nil {
                map["IntranetDomain"] = self.intranetDomain!
            }
            if self.mseVersion != nil {
                map["MseVersion"] = self.mseVersion!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("CanUpdate") {
                self.canUpdate = dict["CanUpdate"] as! Bool
            }
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterAliasName") {
                self.clusterAliasName = dict["ClusterAliasName"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EndDate") {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("InitStatus") {
                self.initStatus = dict["InitStatus"] as! String
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InternetAddress") {
                self.internetAddress = dict["InternetAddress"] as! String
            }
            if dict.keys.contains("InternetDomain") {
                self.internetDomain = dict["InternetDomain"] as! String
            }
            if dict.keys.contains("IntranetAddress") {
                self.intranetAddress = dict["IntranetAddress"] as! String
            }
            if dict.keys.contains("IntranetDomain") {
                self.intranetDomain = dict["IntranetDomain"] as! String
            }
            if dict.keys.contains("MseVersion") {
                self.mseVersion = dict["MseVersion"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! [String: Any]
            }
            if dict.keys.contains("VersionCode") {
                self.versionCode = dict["VersionCode"] as! String
            }
        }
    }
    public var data: [ListClustersResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListClustersResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEngineNamespacesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class ListEngineNamespacesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configCount: Int32?

        public var namespace: String?

        public var namespaceDesc: String?

        public var namespaceShowName: String?

        public var quota: Int32?

        public var serviceCount: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configCount != nil {
                map["ConfigCount"] = self.configCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceDesc != nil {
                map["NamespaceDesc"] = self.namespaceDesc!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.serviceCount != nil {
                map["ServiceCount"] = self.serviceCount!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigCount") {
                self.configCount = dict["ConfigCount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceDesc") {
                self.namespaceDesc = dict["NamespaceDesc"] as! String
            }
            if dict.keys.contains("NamespaceShowName") {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Quota") {
                self.quota = dict["Quota"] as! Int32
            }
            if dict.keys.contains("ServiceCount") {
                self.serviceCount = dict["ServiceCount"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var data: [ListEngineNamespacesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListEngineNamespacesResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEngineNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEngineNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEngineNamespacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEurekaInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var mseSessionId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListEurekaInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var app: String?

        public var durationInSecs: Int32?

        public var homePageUrl: String?

        public var hostName: String?

        public var instanceId: String?

        public var ipAddr: String?

        public var lastDirtyTimestamp: Int64?

        public var lastUpdatedTimestamp: Int64?

        public var metadata: [String: Any]?

        public var port: Int32?

        public var renewalIntervalInSecs: Int32?

        public var securePort: Int32?

        public var status: String?

        public var vipAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.durationInSecs != nil {
                map["DurationInSecs"] = self.durationInSecs!
            }
            if self.homePageUrl != nil {
                map["HomePageUrl"] = self.homePageUrl!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ipAddr != nil {
                map["IpAddr"] = self.ipAddr!
            }
            if self.lastDirtyTimestamp != nil {
                map["LastDirtyTimestamp"] = self.lastDirtyTimestamp!
            }
            if self.lastUpdatedTimestamp != nil {
                map["LastUpdatedTimestamp"] = self.lastUpdatedTimestamp!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.renewalIntervalInSecs != nil {
                map["RenewalIntervalInSecs"] = self.renewalIntervalInSecs!
            }
            if self.securePort != nil {
                map["SecurePort"] = self.securePort!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vipAddress != nil {
                map["VipAddress"] = self.vipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("DurationInSecs") {
                self.durationInSecs = dict["DurationInSecs"] as! Int32
            }
            if dict.keys.contains("HomePageUrl") {
                self.homePageUrl = dict["HomePageUrl"] as! String
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("IpAddr") {
                self.ipAddr = dict["IpAddr"] as! String
            }
            if dict.keys.contains("LastDirtyTimestamp") {
                self.lastDirtyTimestamp = dict["LastDirtyTimestamp"] as! Int64
            }
            if dict.keys.contains("LastUpdatedTimestamp") {
                self.lastUpdatedTimestamp = dict["LastUpdatedTimestamp"] as! Int64
            }
            if dict.keys.contains("Metadata") {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("RenewalIntervalInSecs") {
                self.renewalIntervalInSecs = dict["RenewalIntervalInSecs"] as! Int32
            }
            if dict.keys.contains("SecurePort") {
                self.securePort = dict["SecurePort"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VipAddress") {
                self.vipAddress = dict["VipAddress"] as! String
            }
        }
    }
    public var data: [ListEurekaInstancesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListEurekaInstancesResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEurekaInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEurekaInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEurekaInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEurekaServicesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var mseSessionId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListEurekaServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instancesId: [String]?

        public var name: String?

        public var upStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instancesId != nil {
                map["InstancesId"] = self.instancesId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.upStatus != nil {
                map["UpStatus"] = self.upStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstancesId") {
                self.instancesId = dict["InstancesId"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UpStatus") {
                self.upStatus = dict["UpStatus"] as! String
            }
        }
    }
    public var data: [ListEurekaServicesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListEurekaServicesResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEurekaServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEurekaServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEurekaServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var gatewayType: String?

        public var gatewayUniqueId: String?

        public var instanceId: String?

        public var mseTag: String?

        public var name: String?

        public var vpc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayType != nil {
                map["GatewayType"] = self.gatewayType!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.mseTag != nil {
                map["MseTag"] = self.mseTag!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayType") {
                self.gatewayType = dict["GatewayType"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MseTag") {
                self.mseTag = dict["MseTag"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Vpc") {
                self.vpc = dict["Vpc"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: ListGatewayRequest.FilterParams?

    public var mseSessionId: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            var model = ListGatewayRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var mseSessionId: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class InitConfig : Tea.TeaModel {
                public var enableWaf: Bool?

                public var supportWaf: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableWaf != nil {
                        map["EnableWaf"] = self.enableWaf!
                    }
                    if self.supportWaf != nil {
                        map["SupportWaf"] = self.supportWaf!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnableWaf") {
                        self.enableWaf = dict["EnableWaf"] as! Bool
                    }
                    if dict.keys.contains("SupportWaf") {
                        self.supportWaf = dict["SupportWaf"] as! Bool
                    }
                }
            }
            public class InternetSlb : Tea.TeaModel {
                public var gatewaySlbMode: String?

                public var gatewaySlbStatus: String?

                public var internetNetworkFlow: String?

                public var slbId: String?

                public var slbIp: String?

                public var slbPort: String?

                public var slbSpec: String?

                public var statusDesc: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gatewaySlbMode != nil {
                        map["GatewaySlbMode"] = self.gatewaySlbMode!
                    }
                    if self.gatewaySlbStatus != nil {
                        map["GatewaySlbStatus"] = self.gatewaySlbStatus!
                    }
                    if self.internetNetworkFlow != nil {
                        map["InternetNetworkFlow"] = self.internetNetworkFlow!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbIp != nil {
                        map["SlbIp"] = self.slbIp!
                    }
                    if self.slbPort != nil {
                        map["SlbPort"] = self.slbPort!
                    }
                    if self.slbSpec != nil {
                        map["SlbSpec"] = self.slbSpec!
                    }
                    if self.statusDesc != nil {
                        map["StatusDesc"] = self.statusDesc!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GatewaySlbMode") {
                        self.gatewaySlbMode = dict["GatewaySlbMode"] as! String
                    }
                    if dict.keys.contains("GatewaySlbStatus") {
                        self.gatewaySlbStatus = dict["GatewaySlbStatus"] as! String
                    }
                    if dict.keys.contains("InternetNetworkFlow") {
                        self.internetNetworkFlow = dict["InternetNetworkFlow"] as! String
                    }
                    if dict.keys.contains("SlbId") {
                        self.slbId = dict["SlbId"] as! String
                    }
                    if dict.keys.contains("SlbIp") {
                        self.slbIp = dict["SlbIp"] as! String
                    }
                    if dict.keys.contains("SlbPort") {
                        self.slbPort = dict["SlbPort"] as! String
                    }
                    if dict.keys.contains("SlbSpec") {
                        self.slbSpec = dict["SlbSpec"] as! String
                    }
                    if dict.keys.contains("StatusDesc") {
                        self.statusDesc = dict["StatusDesc"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Slb : Tea.TeaModel {
                public var gatewaySlbMode: String?

                public var gatewaySlbStatus: String?

                public var slbId: String?

                public var slbIp: String?

                public var slbPort: String?

                public var slbSpec: String?

                public var statusDesc: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gatewaySlbMode != nil {
                        map["GatewaySlbMode"] = self.gatewaySlbMode!
                    }
                    if self.gatewaySlbStatus != nil {
                        map["GatewaySlbStatus"] = self.gatewaySlbStatus!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbIp != nil {
                        map["SlbIp"] = self.slbIp!
                    }
                    if self.slbPort != nil {
                        map["SlbPort"] = self.slbPort!
                    }
                    if self.slbSpec != nil {
                        map["SlbSpec"] = self.slbSpec!
                    }
                    if self.statusDesc != nil {
                        map["StatusDesc"] = self.statusDesc!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GatewaySlbMode") {
                        self.gatewaySlbMode = dict["GatewaySlbMode"] as! String
                    }
                    if dict.keys.contains("GatewaySlbStatus") {
                        self.gatewaySlbStatus = dict["GatewaySlbStatus"] as! String
                    }
                    if dict.keys.contains("SlbId") {
                        self.slbId = dict["SlbId"] as! String
                    }
                    if dict.keys.contains("SlbIp") {
                        self.slbIp = dict["SlbIp"] as! String
                    }
                    if dict.keys.contains("SlbPort") {
                        self.slbPort = dict["SlbPort"] as! String
                    }
                    if dict.keys.contains("SlbSpec") {
                        self.slbSpec = dict["SlbSpec"] as! String
                    }
                    if dict.keys.contains("StatusDesc") {
                        self.statusDesc = dict["StatusDesc"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var ahasOn: Bool?

            public var appVersion: String?

            public var armsOn: Bool?

            public var chargeType: String?

            public var currentVersion: String?

            public var endDate: String?

            public var gatewayType: String?

            public var gatewayUniqueId: String?

            public var gatewayVersion: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var initConfig: ListGatewayResponseBody.Data.Result.InitConfig?

            public var instanceId: String?

            public var internetSlb: [ListGatewayResponseBody.Data.Result.InternetSlb]?

            public var latestVersion: String?

            public var mseTag: String?

            public var mustUpgrade: Bool?

            public var name: String?

            public var primaryUser: String?

            public var region: String?

            public var replica: Int32?

            public var rollBack: Bool?

            public var slb: [ListGatewayResponseBody.Data.Result.Slb]?

            public var spec: String?

            public var status: Int32?

            public var statusDesc: String?

            public var supportWasm: Bool?

            public var tag: String?

            public var upgrade: Bool?

            public var vswitch2: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.initConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ahasOn != nil {
                    map["AhasOn"] = self.ahasOn!
                }
                if self.appVersion != nil {
                    map["AppVersion"] = self.appVersion!
                }
                if self.armsOn != nil {
                    map["ArmsOn"] = self.armsOn!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.currentVersion != nil {
                    map["CurrentVersion"] = self.currentVersion!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.gatewayType != nil {
                    map["GatewayType"] = self.gatewayType!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gatewayVersion != nil {
                    map["GatewayVersion"] = self.gatewayVersion!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.initConfig != nil {
                    map["InitConfig"] = self.initConfig?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.internetSlb != nil {
                    var tmp : [Any] = []
                    for k in self.internetSlb! {
                        tmp.append(k.toMap())
                    }
                    map["InternetSlb"] = tmp
                }
                if self.latestVersion != nil {
                    map["LatestVersion"] = self.latestVersion!
                }
                if self.mseTag != nil {
                    map["MseTag"] = self.mseTag!
                }
                if self.mustUpgrade != nil {
                    map["MustUpgrade"] = self.mustUpgrade!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.primaryUser != nil {
                    map["PrimaryUser"] = self.primaryUser!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.replica != nil {
                    map["Replica"] = self.replica!
                }
                if self.rollBack != nil {
                    map["RollBack"] = self.rollBack!
                }
                if self.slb != nil {
                    var tmp : [Any] = []
                    for k in self.slb! {
                        tmp.append(k.toMap())
                    }
                    map["Slb"] = tmp
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusDesc != nil {
                    map["StatusDesc"] = self.statusDesc!
                }
                if self.supportWasm != nil {
                    map["SupportWasm"] = self.supportWasm!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                if self.vswitch2 != nil {
                    map["Vswitch2"] = self.vswitch2!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AhasOn") {
                    self.ahasOn = dict["AhasOn"] as! Bool
                }
                if dict.keys.contains("AppVersion") {
                    self.appVersion = dict["AppVersion"] as! String
                }
                if dict.keys.contains("ArmsOn") {
                    self.armsOn = dict["ArmsOn"] as! Bool
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CurrentVersion") {
                    self.currentVersion = dict["CurrentVersion"] as! String
                }
                if dict.keys.contains("EndDate") {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("GatewayType") {
                    self.gatewayType = dict["GatewayType"] as! String
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GatewayVersion") {
                    self.gatewayVersion = dict["GatewayVersion"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InitConfig") {
                    var model = ListGatewayResponseBody.Data.Result.InitConfig()
                    model.fromMap(dict["InitConfig"] as! [String: Any])
                    self.initConfig = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InternetSlb") {
                    self.internetSlb = dict["InternetSlb"] as! [ListGatewayResponseBody.Data.Result.InternetSlb]
                }
                if dict.keys.contains("LatestVersion") {
                    self.latestVersion = dict["LatestVersion"] as! String
                }
                if dict.keys.contains("MseTag") {
                    self.mseTag = dict["MseTag"] as! String
                }
                if dict.keys.contains("MustUpgrade") {
                    self.mustUpgrade = dict["MustUpgrade"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PrimaryUser") {
                    self.primaryUser = dict["PrimaryUser"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Replica") {
                    self.replica = dict["Replica"] as! Int32
                }
                if dict.keys.contains("RollBack") {
                    self.rollBack = dict["RollBack"] as! Bool
                }
                if dict.keys.contains("Slb") {
                    self.slb = dict["Slb"] as! [ListGatewayResponseBody.Data.Result.Slb]
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("StatusDesc") {
                    self.statusDesc = dict["StatusDesc"] as! String
                }
                if dict.keys.contains("SupportWasm") {
                    self.supportWasm = dict["SupportWasm"] as! Bool
                }
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Upgrade") {
                    self.upgrade = dict["Upgrade"] as! Bool
                }
                if dict.keys.contains("Vswitch2") {
                    self.vswitch2 = dict["Vswitch2"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! [ListGatewayResponseBody.Data.Result]
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListGatewayDomainResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Comment : Tea.TeaModel {
            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var certBeforeDate: String?

        public var certIdentifier: String?

        public var comment: ListGatewayDomainResponseBody.Data.Comment?

        public var gatewayId: Int64?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var http2: String?

        public var id: Int64?

        public var mustHttps: Bool?

        public var name: String?

        public var protocol_: String?

        public var status: Int32?

        public var tlsMax: String?

        public var tlsMin: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.comment?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certBeforeDate != nil {
                map["CertBeforeDate"] = self.certBeforeDate!
            }
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.comment != nil {
                map["Comment"] = self.comment?.toMap()
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.http2 != nil {
                map["Http2"] = self.http2!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mustHttps != nil {
                map["MustHttps"] = self.mustHttps!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tlsMax != nil {
                map["TlsMax"] = self.tlsMax!
            }
            if self.tlsMin != nil {
                map["TlsMin"] = self.tlsMin!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertBeforeDate") {
                self.certBeforeDate = dict["CertBeforeDate"] as! String
            }
            if dict.keys.contains("CertIdentifier") {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("Comment") {
                var model = ListGatewayDomainResponseBody.Data.Comment()
                model.fromMap(dict["Comment"] as! [String: Any])
                self.comment = model
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Http2") {
                self.http2 = dict["Http2"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MustHttps") {
                self.mustHttps = dict["MustHttps"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TlsMax") {
                self.tlsMax = dict["TlsMax"] as! String
            }
            if dict.keys.contains("TlsMin") {
                self.tlsMin = dict["TlsMin"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListGatewayDomainResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListGatewayDomainResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayRouteRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var defaultServiceId: Int64?

        public var domainId: Int64?

        public var domainName: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var name: String?

        public var routeOrder: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultServiceId") {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RouteOrder") {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: ListGatewayRouteRequest.FilterParams?

    public var mseSessionId: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            var model = ListGatewayRouteRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var mseSessionId: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class Comment : Tea.TeaModel {
                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DirectResponse : Tea.TeaModel {
                public var body: String?

                public var code: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body!
                    }
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") {
                        self.body = dict["Body"] as! String
                    }
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                }
            }
            public class FallbackServices : Tea.TeaModel {
                public var agreementType: String?

                public var groupName: String?

                public var name: String?

                public var namespace: String?

                public var percent: Int32?

                public var serviceId: Int64?

                public var serviceName: String?

                public var servicePort: Int32?

                public var sourceType: String?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agreementType != nil {
                        map["AgreementType"] = self.agreementType!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.serviceId != nil {
                        map["ServiceId"] = self.serviceId!
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    if self.servicePort != nil {
                        map["ServicePort"] = self.servicePort!
                    }
                    if self.sourceType != nil {
                        map["SourceType"] = self.sourceType!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AgreementType") {
                        self.agreementType = dict["AgreementType"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Namespace") {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! Int32
                    }
                    if dict.keys.contains("ServiceId") {
                        self.serviceId = dict["ServiceId"] as! Int64
                    }
                    if dict.keys.contains("ServiceName") {
                        self.serviceName = dict["ServiceName"] as! String
                    }
                    if dict.keys.contains("ServicePort") {
                        self.servicePort = dict["ServicePort"] as! Int32
                    }
                    if dict.keys.contains("SourceType") {
                        self.sourceType = dict["SourceType"] as! String
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public class Redirect : Tea.TeaModel {
                public var code: Int32?

                public var host: String?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                    if dict.keys.contains("Host") {
                        self.host = dict["Host"] as! String
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public class RoutePredicates : Tea.TeaModel {
                public class HeaderPredicates : Tea.TeaModel {
                    public var key: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class PathPredicates : Tea.TeaModel {
                    public var ignoreCase: Bool?

                    public var path: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ignoreCase != nil {
                            map["IgnoreCase"] = self.ignoreCase!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IgnoreCase") {
                            self.ignoreCase = dict["IgnoreCase"] as! Bool
                        }
                        if dict.keys.contains("Path") {
                            self.path = dict["Path"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class QueryPredicates : Tea.TeaModel {
                    public var key: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var headerPredicates: [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.HeaderPredicates]?

                public var methodPredicates: [String]?

                public var pathPredicates: ListGatewayRouteResponseBody.Data.Result.RoutePredicates.PathPredicates?

                public var queryPredicates: [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.QueryPredicates]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.pathPredicates?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerPredicates != nil {
                        var tmp : [Any] = []
                        for k in self.headerPredicates! {
                            tmp.append(k.toMap())
                        }
                        map["HeaderPredicates"] = tmp
                    }
                    if self.methodPredicates != nil {
                        map["MethodPredicates"] = self.methodPredicates!
                    }
                    if self.pathPredicates != nil {
                        map["PathPredicates"] = self.pathPredicates?.toMap()
                    }
                    if self.queryPredicates != nil {
                        var tmp : [Any] = []
                        for k in self.queryPredicates! {
                            tmp.append(k.toMap())
                        }
                        map["QueryPredicates"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderPredicates") {
                        self.headerPredicates = dict["HeaderPredicates"] as! [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.HeaderPredicates]
                    }
                    if dict.keys.contains("MethodPredicates") {
                        self.methodPredicates = dict["MethodPredicates"] as! [String]
                    }
                    if dict.keys.contains("PathPredicates") {
                        var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates.PathPredicates()
                        model.fromMap(dict["PathPredicates"] as! [String: Any])
                        self.pathPredicates = model
                    }
                    if dict.keys.contains("QueryPredicates") {
                        self.queryPredicates = dict["QueryPredicates"] as! [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.QueryPredicates]
                    }
                }
            }
            public class RouteServices : Tea.TeaModel {
                public class HttpDubboTranscoder : Tea.TeaModel {
                    public class MothedMapList : Tea.TeaModel {
                        public class ParamMapsList : Tea.TeaModel {
                            public var extractKey: String?

                            public var extractKeySpec: String?

                            public var mappingType: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.extractKey != nil {
                                    map["ExtractKey"] = self.extractKey!
                                }
                                if self.extractKeySpec != nil {
                                    map["ExtractKeySpec"] = self.extractKeySpec!
                                }
                                if self.mappingType != nil {
                                    map["MappingType"] = self.mappingType!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ExtractKey") {
                                    self.extractKey = dict["ExtractKey"] as! String
                                }
                                if dict.keys.contains("ExtractKeySpec") {
                                    self.extractKeySpec = dict["ExtractKeySpec"] as! String
                                }
                                if dict.keys.contains("MappingType") {
                                    self.mappingType = dict["MappingType"] as! String
                                }
                            }
                        }
                        public var dubboMothedName: String?

                        public var httpMothed: String?

                        public var mothedpath: String?

                        public var paramMapsList: [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                        public var passThroughAllHeaders: String?

                        public var passThroughList: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dubboMothedName != nil {
                                map["DubboMothedName"] = self.dubboMothedName!
                            }
                            if self.httpMothed != nil {
                                map["HttpMothed"] = self.httpMothed!
                            }
                            if self.mothedpath != nil {
                                map["Mothedpath"] = self.mothedpath!
                            }
                            if self.paramMapsList != nil {
                                var tmp : [Any] = []
                                for k in self.paramMapsList! {
                                    tmp.append(k.toMap())
                                }
                                map["ParamMapsList"] = tmp
                            }
                            if self.passThroughAllHeaders != nil {
                                map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                            }
                            if self.passThroughList != nil {
                                map["PassThroughList"] = self.passThroughList!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DubboMothedName") {
                                self.dubboMothedName = dict["DubboMothedName"] as! String
                            }
                            if dict.keys.contains("HttpMothed") {
                                self.httpMothed = dict["HttpMothed"] as! String
                            }
                            if dict.keys.contains("Mothedpath") {
                                self.mothedpath = dict["Mothedpath"] as! String
                            }
                            if dict.keys.contains("ParamMapsList") {
                                self.paramMapsList = dict["ParamMapsList"] as! [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList]
                            }
                            if dict.keys.contains("PassThroughAllHeaders") {
                                self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                            }
                            if dict.keys.contains("PassThroughList") {
                                self.passThroughList = dict["PassThroughList"] as! [String]
                            }
                        }
                    }
                    public var dubboServiceGroup: String?

                    public var dubboServiceName: String?

                    public var dubboServiceVersion: String?

                    public var mothedMapList: [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dubboServiceGroup != nil {
                            map["DubboServiceGroup"] = self.dubboServiceGroup!
                        }
                        if self.dubboServiceName != nil {
                            map["DubboServiceName"] = self.dubboServiceName!
                        }
                        if self.dubboServiceVersion != nil {
                            map["DubboServiceVersion"] = self.dubboServiceVersion!
                        }
                        if self.mothedMapList != nil {
                            var tmp : [Any] = []
                            for k in self.mothedMapList! {
                                tmp.append(k.toMap())
                            }
                            map["MothedMapList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DubboServiceGroup") {
                            self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                        }
                        if dict.keys.contains("DubboServiceName") {
                            self.dubboServiceName = dict["DubboServiceName"] as! String
                        }
                        if dict.keys.contains("DubboServiceVersion") {
                            self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                        }
                        if dict.keys.contains("MothedMapList") {
                            self.mothedMapList = dict["MothedMapList"] as! [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList]
                        }
                    }
                }
                public var agreementType: String?

                public var groupName: String?

                public var httpDubboTranscoder: ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder?

                public var name: String?

                public var namespace: String?

                public var percent: Int32?

                public var serviceId: Int64?

                public var serviceName: String?

                public var servicePort: Int32?

                public var sourceType: String?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.httpDubboTranscoder?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agreementType != nil {
                        map["AgreementType"] = self.agreementType!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.httpDubboTranscoder != nil {
                        map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.serviceId != nil {
                        map["ServiceId"] = self.serviceId!
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    if self.servicePort != nil {
                        map["ServicePort"] = self.servicePort!
                    }
                    if self.sourceType != nil {
                        map["SourceType"] = self.sourceType!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AgreementType") {
                        self.agreementType = dict["AgreementType"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("HttpDubboTranscoder") {
                        var model = ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder()
                        model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                        self.httpDubboTranscoder = model
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Namespace") {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! Int32
                    }
                    if dict.keys.contains("ServiceId") {
                        self.serviceId = dict["ServiceId"] as! Int64
                    }
                    if dict.keys.contains("ServiceName") {
                        self.serviceName = dict["ServiceName"] as! String
                    }
                    if dict.keys.contains("ServicePort") {
                        self.servicePort = dict["ServicePort"] as! Int32
                    }
                    if dict.keys.contains("SourceType") {
                        self.sourceType = dict["SourceType"] as! String
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public var comment: ListGatewayRouteResponseBody.Data.Result.Comment?

            public var defaultServiceId: Int64?

            public var defaultServiceName: String?

            public var destinationType: String?

            public var directResponse: ListGatewayRouteResponseBody.Data.Result.DirectResponse?

            public var domainId: Int64?

            public var domainIdList: [Int64]?

            public var domainName: String?

            public var domainNameList: [String]?

            public var enableWaf: String?

            public var fallback: Bool?

            public var fallbackServices: [ListGatewayRouteResponseBody.Data.Result.FallbackServices]?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var name: String?

            public var predicates: String?

            public var redirect: ListGatewayRouteResponseBody.Data.Result.Redirect?

            public var routeOrder: Int32?

            public var routePredicates: ListGatewayRouteResponseBody.Data.Result.RoutePredicates?

            public var routeServices: [ListGatewayRouteResponseBody.Data.Result.RouteServices]?

            public var services: String?

            public var status: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.comment?.validate()
                try self.directResponse?.validate()
                try self.redirect?.validate()
                try self.routePredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment?.toMap()
                }
                if self.defaultServiceId != nil {
                    map["DefaultServiceId"] = self.defaultServiceId!
                }
                if self.defaultServiceName != nil {
                    map["DefaultServiceName"] = self.defaultServiceName!
                }
                if self.destinationType != nil {
                    map["DestinationType"] = self.destinationType!
                }
                if self.directResponse != nil {
                    map["DirectResponse"] = self.directResponse?.toMap()
                }
                if self.domainId != nil {
                    map["DomainId"] = self.domainId!
                }
                if self.domainIdList != nil {
                    map["DomainIdList"] = self.domainIdList!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainNameList != nil {
                    map["DomainNameList"] = self.domainNameList!
                }
                if self.enableWaf != nil {
                    map["EnableWaf"] = self.enableWaf!
                }
                if self.fallback != nil {
                    map["Fallback"] = self.fallback!
                }
                if self.fallbackServices != nil {
                    var tmp : [Any] = []
                    for k in self.fallbackServices! {
                        tmp.append(k.toMap())
                    }
                    map["FallbackServices"] = tmp
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.predicates != nil {
                    map["Predicates"] = self.predicates!
                }
                if self.redirect != nil {
                    map["Redirect"] = self.redirect?.toMap()
                }
                if self.routeOrder != nil {
                    map["RouteOrder"] = self.routeOrder!
                }
                if self.routePredicates != nil {
                    map["RoutePredicates"] = self.routePredicates?.toMap()
                }
                if self.routeServices != nil {
                    var tmp : [Any] = []
                    for k in self.routeServices! {
                        tmp.append(k.toMap())
                    }
                    map["RouteServices"] = tmp
                }
                if self.services != nil {
                    map["Services"] = self.services!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Comment") {
                    var model = ListGatewayRouteResponseBody.Data.Result.Comment()
                    model.fromMap(dict["Comment"] as! [String: Any])
                    self.comment = model
                }
                if dict.keys.contains("DefaultServiceId") {
                    self.defaultServiceId = dict["DefaultServiceId"] as! Int64
                }
                if dict.keys.contains("DefaultServiceName") {
                    self.defaultServiceName = dict["DefaultServiceName"] as! String
                }
                if dict.keys.contains("DestinationType") {
                    self.destinationType = dict["DestinationType"] as! String
                }
                if dict.keys.contains("DirectResponse") {
                    var model = ListGatewayRouteResponseBody.Data.Result.DirectResponse()
                    model.fromMap(dict["DirectResponse"] as! [String: Any])
                    self.directResponse = model
                }
                if dict.keys.contains("DomainId") {
                    self.domainId = dict["DomainId"] as! Int64
                }
                if dict.keys.contains("DomainIdList") {
                    self.domainIdList = dict["DomainIdList"] as! [Int64]
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainNameList") {
                    self.domainNameList = dict["DomainNameList"] as! [String]
                }
                if dict.keys.contains("EnableWaf") {
                    self.enableWaf = dict["EnableWaf"] as! String
                }
                if dict.keys.contains("Fallback") {
                    self.fallback = dict["Fallback"] as! Bool
                }
                if dict.keys.contains("FallbackServices") {
                    self.fallbackServices = dict["FallbackServices"] as! [ListGatewayRouteResponseBody.Data.Result.FallbackServices]
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Predicates") {
                    self.predicates = dict["Predicates"] as! String
                }
                if dict.keys.contains("Redirect") {
                    var model = ListGatewayRouteResponseBody.Data.Result.Redirect()
                    model.fromMap(dict["Redirect"] as! [String: Any])
                    self.redirect = model
                }
                if dict.keys.contains("RouteOrder") {
                    self.routeOrder = dict["RouteOrder"] as! Int32
                }
                if dict.keys.contains("RoutePredicates") {
                    var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates()
                    model.fromMap(dict["RoutePredicates"] as! [String: Any])
                    self.routePredicates = model
                }
                if dict.keys.contains("RouteServices") {
                    self.routeServices = dict["RouteServices"] as! [ListGatewayRouteResponseBody.Data.Result.RouteServices]
                }
                if dict.keys.contains("Services") {
                    self.services = dict["Services"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayRouteResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! [ListGatewayRouteResponseBody.Data.Result]
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayRouteResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListGatewayRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayServiceRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var gatewayUniqueId: String?

        public var groupName: String?

        public var name: String?

        public var namespace: String?

        public var serviceProtocol: String?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: ListGatewayServiceRequest.FilterParams?

    public var mseSessionId: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            var model = ListGatewayServiceRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayServiceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var mseSessionId: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class GatewayTrafficPolicy : Tea.TeaModel {
                public class LoadBalancerSettings : Tea.TeaModel {
                    public class ConsistentHashLBConfig : Tea.TeaModel {
                        public class HttpCookie : Tea.TeaModel {
                            public var name: String?

                            public var path: String?

                            public var ttl: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.name != nil {
                                    map["Name"] = self.name!
                                }
                                if self.path != nil {
                                    map["Path"] = self.path!
                                }
                                if self.ttl != nil {
                                    map["Ttl"] = self.ttl!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Name") {
                                    self.name = dict["Name"] as! String
                                }
                                if dict.keys.contains("Path") {
                                    self.path = dict["Path"] as! String
                                }
                                if dict.keys.contains("Ttl") {
                                    self.ttl = dict["Ttl"] as! String
                                }
                            }
                        }
                        public var consistentHashLBType: String?

                        public var httpCookie: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie?

                        public var minimumRingSize: Int64?

                        public var parameterName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.httpCookie?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.consistentHashLBType != nil {
                                map["ConsistentHashLBType"] = self.consistentHashLBType!
                            }
                            if self.httpCookie != nil {
                                map["HttpCookie"] = self.httpCookie?.toMap()
                            }
                            if self.minimumRingSize != nil {
                                map["MinimumRingSize"] = self.minimumRingSize!
                            }
                            if self.parameterName != nil {
                                map["ParameterName"] = self.parameterName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ConsistentHashLBType") {
                                self.consistentHashLBType = dict["ConsistentHashLBType"] as! String
                            }
                            if dict.keys.contains("HttpCookie") {
                                var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie()
                                model.fromMap(dict["HttpCookie"] as! [String: Any])
                                self.httpCookie = model
                            }
                            if dict.keys.contains("MinimumRingSize") {
                                self.minimumRingSize = dict["MinimumRingSize"] as! Int64
                            }
                            if dict.keys.contains("ParameterName") {
                                self.parameterName = dict["ParameterName"] as! String
                            }
                        }
                    }
                    public var consistentHashLBConfig: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig?

                    public var loadbalancerType: String?

                    public var warmupDuration: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.consistentHashLBConfig?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.consistentHashLBConfig != nil {
                            map["ConsistentHashLBConfig"] = self.consistentHashLBConfig?.toMap()
                        }
                        if self.loadbalancerType != nil {
                            map["LoadbalancerType"] = self.loadbalancerType!
                        }
                        if self.warmupDuration != nil {
                            map["WarmupDuration"] = self.warmupDuration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConsistentHashLBConfig") {
                            var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig()
                            model.fromMap(dict["ConsistentHashLBConfig"] as! [String: Any])
                            self.consistentHashLBConfig = model
                        }
                        if dict.keys.contains("LoadbalancerType") {
                            self.loadbalancerType = dict["LoadbalancerType"] as! String
                        }
                        if dict.keys.contains("WarmupDuration") {
                            self.warmupDuration = dict["WarmupDuration"] as! Int32
                        }
                    }
                }
                public class Tls : Tea.TeaModel {
                    public var caCertContent: String?

                    public var caCertId: String?

                    public var certId: String?

                    public var mode: String?

                    public var sni: String?

                    public var subjectAltNames: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.caCertContent != nil {
                            map["CaCertContent"] = self.caCertContent!
                        }
                        if self.caCertId != nil {
                            map["CaCertId"] = self.caCertId!
                        }
                        if self.certId != nil {
                            map["CertId"] = self.certId!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.sni != nil {
                            map["Sni"] = self.sni!
                        }
                        if self.subjectAltNames != nil {
                            map["SubjectAltNames"] = self.subjectAltNames!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CaCertContent") {
                            self.caCertContent = dict["CaCertContent"] as! String
                        }
                        if dict.keys.contains("CaCertId") {
                            self.caCertId = dict["CaCertId"] as! String
                        }
                        if dict.keys.contains("CertId") {
                            self.certId = dict["CertId"] as! String
                        }
                        if dict.keys.contains("Mode") {
                            self.mode = dict["Mode"] as! String
                        }
                        if dict.keys.contains("Sni") {
                            self.sni = dict["Sni"] as! String
                        }
                        if dict.keys.contains("SubjectAltNames") {
                            self.subjectAltNames = dict["SubjectAltNames"] as! [String]
                        }
                    }
                }
                public var loadBalancerSettings: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings?

                public var tls: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.Tls?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.loadBalancerSettings?.validate()
                    try self.tls?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.loadBalancerSettings != nil {
                        map["LoadBalancerSettings"] = self.loadBalancerSettings?.toMap()
                    }
                    if self.tls != nil {
                        map["Tls"] = self.tls?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LoadBalancerSettings") {
                        var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings()
                        model.fromMap(dict["LoadBalancerSettings"] as! [String: Any])
                        self.loadBalancerSettings = model
                    }
                    if dict.keys.contains("Tls") {
                        var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.Tls()
                        model.fromMap(dict["Tls"] as! [String: Any])
                        self.tls = model
                    }
                }
            }
            public class HealthCheckInfo : Tea.TeaModel {
                public var check: Bool?

                public var expectedStatuses: [Int32]?

                public var healthyThreshold: Int32?

                public var httpHost: String?

                public var httpPath: String?

                public var interval: Int32?

                public var protocol_: String?

                public var timeout: Int32?

                public var unhealthyThreshold: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.check != nil {
                        map["Check"] = self.check!
                    }
                    if self.expectedStatuses != nil {
                        map["ExpectedStatuses"] = self.expectedStatuses!
                    }
                    if self.healthyThreshold != nil {
                        map["HealthyThreshold"] = self.healthyThreshold!
                    }
                    if self.httpHost != nil {
                        map["HttpHost"] = self.httpHost!
                    }
                    if self.httpPath != nil {
                        map["HttpPath"] = self.httpPath!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.unhealthyThreshold != nil {
                        map["UnhealthyThreshold"] = self.unhealthyThreshold!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Check") {
                        self.check = dict["Check"] as! Bool
                    }
                    if dict.keys.contains("ExpectedStatuses") {
                        self.expectedStatuses = dict["ExpectedStatuses"] as! [Int32]
                    }
                    if dict.keys.contains("HealthyThreshold") {
                        self.healthyThreshold = dict["HealthyThreshold"] as! Int32
                    }
                    if dict.keys.contains("HttpHost") {
                        self.httpHost = dict["HttpHost"] as! String
                    }
                    if dict.keys.contains("HttpPath") {
                        self.httpPath = dict["HttpPath"] as! String
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                    if dict.keys.contains("Timeout") {
                        self.timeout = dict["Timeout"] as! Int32
                    }
                    if dict.keys.contains("UnhealthyThreshold") {
                        self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
                    }
                }
            }
            public class Versions : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var gatewayId: Int64?

            public var gatewayTrafficPolicy: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var groupName: String?

            public var healehStatus: String?

            public var healthCheck: Bool?

            public var healthCheckInfo: ListGatewayServiceResponseBody.Data.Result.HealthCheckInfo?

            public var healthStatus: String?

            public var id: Int64?

            public var ips: [String]?

            public var metaInfo: String?

            public var name: String?

            public var namespace: String?

            public var ports: [Int32]?

            public var serviceNameInRegistry: String?

            public var servicePort: Int64?

            public var serviceProtocol: String?

            public var sourceId: Int64?

            public var sourceType: String?

            public var unhealthyEndpoints: [String]?

            public var versions: [ListGatewayServiceResponseBody.Data.Result.Versions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.gatewayTrafficPolicy?.validate()
                try self.healthCheckInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayTrafficPolicy != nil {
                    map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.healehStatus != nil {
                    map["HealehStatus"] = self.healehStatus!
                }
                if self.healthCheck != nil {
                    map["HealthCheck"] = self.healthCheck!
                }
                if self.healthCheckInfo != nil {
                    map["HealthCheckInfo"] = self.healthCheckInfo?.toMap()
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips!
                }
                if self.metaInfo != nil {
                    map["MetaInfo"] = self.metaInfo!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.ports != nil {
                    map["Ports"] = self.ports!
                }
                if self.serviceNameInRegistry != nil {
                    map["ServiceNameInRegistry"] = self.serviceNameInRegistry!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.serviceProtocol != nil {
                    map["ServiceProtocol"] = self.serviceProtocol!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.unhealthyEndpoints != nil {
                    map["UnhealthyEndpoints"] = self.unhealthyEndpoints!
                }
                if self.versions != nil {
                    var tmp : [Any] = []
                    for k in self.versions! {
                        tmp.append(k.toMap())
                    }
                    map["Versions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayTrafficPolicy") {
                    var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy()
                    model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
                    self.gatewayTrafficPolicy = model
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HealehStatus") {
                    self.healehStatus = dict["HealehStatus"] as! String
                }
                if dict.keys.contains("HealthCheck") {
                    self.healthCheck = dict["HealthCheck"] as! Bool
                }
                if dict.keys.contains("HealthCheckInfo") {
                    var model = ListGatewayServiceResponseBody.Data.Result.HealthCheckInfo()
                    model.fromMap(dict["HealthCheckInfo"] as! [String: Any])
                    self.healthCheckInfo = model
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Ips") {
                    self.ips = dict["Ips"] as! [String]
                }
                if dict.keys.contains("MetaInfo") {
                    self.metaInfo = dict["MetaInfo"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Ports") {
                    self.ports = dict["Ports"] as! [Int32]
                }
                if dict.keys.contains("ServiceNameInRegistry") {
                    self.serviceNameInRegistry = dict["ServiceNameInRegistry"] as! String
                }
                if dict.keys.contains("ServicePort") {
                    self.servicePort = dict["ServicePort"] as! Int64
                }
                if dict.keys.contains("ServiceProtocol") {
                    self.serviceProtocol = dict["ServiceProtocol"] as! String
                }
                if dict.keys.contains("SourceId") {
                    self.sourceId = dict["SourceId"] as! Int64
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("UnhealthyEndpoints") {
                    self.unhealthyEndpoints = dict["UnhealthyEndpoints"] as! [String]
                }
                if dict.keys.contains("Versions") {
                    self.versions = dict["Versions"] as! [ListGatewayServiceResponseBody.Data.Result.Versions]
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayServiceResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! [ListGatewayServiceResponseBody.Data.Result]
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayServiceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListGatewayServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class ListGatewaySlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var editEnable: Bool?

        public var gatewayId: String?

        public var gatewaySlbMode: String?

        public var gatewaySlbStatus: String?

        public var gmtCreate: String?

        public var httpPort: Int32?

        public var httpsPort: Int32?

        public var httpsVServerGroupId: String?

        public var id: String?

        public var serviceWeight: Int32?

        public var slbId: String?

        public var slbIp: String?

        public var slbPort: String?

        public var statusDesc: String?

        public var type: String?

        public var VServerGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.editEnable != nil {
                map["EditEnable"] = self.editEnable!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewaySlbMode != nil {
                map["GatewaySlbMode"] = self.gatewaySlbMode!
            }
            if self.gatewaySlbStatus != nil {
                map["GatewaySlbStatus"] = self.gatewaySlbStatus!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.httpsPort != nil {
                map["HttpsPort"] = self.httpsPort!
            }
            if self.httpsVServerGroupId != nil {
                map["HttpsVServerGroupId"] = self.httpsVServerGroupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.serviceWeight != nil {
                map["ServiceWeight"] = self.serviceWeight!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbIp != nil {
                map["SlbIp"] = self.slbIp!
            }
            if self.slbPort != nil {
                map["SlbPort"] = self.slbPort!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.VServerGroupId != nil {
                map["VServerGroupId"] = self.VServerGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EditEnable") {
                self.editEnable = dict["EditEnable"] as! Bool
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! String
            }
            if dict.keys.contains("GatewaySlbMode") {
                self.gatewaySlbMode = dict["GatewaySlbMode"] as! String
            }
            if dict.keys.contains("GatewaySlbStatus") {
                self.gatewaySlbStatus = dict["GatewaySlbStatus"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("HttpPort") {
                self.httpPort = dict["HttpPort"] as! Int32
            }
            if dict.keys.contains("HttpsPort") {
                self.httpsPort = dict["HttpsPort"] as! Int32
            }
            if dict.keys.contains("HttpsVServerGroupId") {
                self.httpsVServerGroupId = dict["HttpsVServerGroupId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ServiceWeight") {
                self.serviceWeight = dict["ServiceWeight"] as! Int32
            }
            if dict.keys.contains("SlbId") {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbIp") {
                self.slbIp = dict["SlbIp"] as! String
            }
            if dict.keys.contains("SlbPort") {
                self.slbPort = dict["SlbPort"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("VServerGroupId") {
                self.VServerGroupId = dict["VServerGroupId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListGatewaySlbResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListGatewaySlbResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceCountRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var mseSessionId: String?

    public var mseVersion: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListInstanceCountResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [Int32]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [Int32]
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListInstanceCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public var region: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appClusterId: String?

        public var appVersion: String?

        public var dbPassword: String?

        public var dbUrl: String?

        public var dbUserName: String?

        public var endDate: String?

        public var environmentId: Int64?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var imageVersion: String?

        public var instanceId: String?

        public var isCreatedRedis: Bool?

        public var isCreatedSlb: Bool?

        public var k8sResourceId: Int64?

        public var name: String?

        public var nameServer: String?

        public var nameServerPublic: String?

        public var orderId: String?

        public var podCidr: String?

        public var primaryUser: String?

        public var region: String?

        public var replica: Int64?

        public var seataServerUniqueId: String?

        public var securityGroup: String?

        public var spec: String?

        public var startDate: String?

        public var status: Int64?

        public var statusDesc: String?

        public var storeMode: String?

        public var vpc: String?

        public var vswitch: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appClusterId != nil {
                map["AppClusterId"] = self.appClusterId!
            }
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.dbPassword != nil {
                map["DbPassword"] = self.dbPassword!
            }
            if self.dbUrl != nil {
                map["DbUrl"] = self.dbUrl!
            }
            if self.dbUserName != nil {
                map["DbUserName"] = self.dbUserName!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageVersion != nil {
                map["ImageVersion"] = self.imageVersion!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.isCreatedRedis != nil {
                map["IsCreatedRedis"] = self.isCreatedRedis!
            }
            if self.isCreatedSlb != nil {
                map["IsCreatedSlb"] = self.isCreatedSlb!
            }
            if self.k8sResourceId != nil {
                map["K8sResourceId"] = self.k8sResourceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nameServer != nil {
                map["NameServer"] = self.nameServer!
            }
            if self.nameServerPublic != nil {
                map["NameServerPublic"] = self.nameServerPublic!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.podCidr != nil {
                map["PodCidr"] = self.podCidr!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.replica != nil {
                map["Replica"] = self.replica!
            }
            if self.seataServerUniqueId != nil {
                map["SeataServerUniqueId"] = self.seataServerUniqueId!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.startDate != nil {
                map["StartDate"] = self.startDate!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.storeMode != nil {
                map["StoreMode"] = self.storeMode!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppClusterId") {
                self.appClusterId = dict["AppClusterId"] as! String
            }
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("DbPassword") {
                self.dbPassword = dict["DbPassword"] as! String
            }
            if dict.keys.contains("DbUrl") {
                self.dbUrl = dict["DbUrl"] as! String
            }
            if dict.keys.contains("DbUserName") {
                self.dbUserName = dict["DbUserName"] as! String
            }
            if dict.keys.contains("EndDate") {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! Int64
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ImageVersion") {
                self.imageVersion = dict["ImageVersion"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("IsCreatedRedis") {
                self.isCreatedRedis = dict["IsCreatedRedis"] as! Bool
            }
            if dict.keys.contains("IsCreatedSlb") {
                self.isCreatedSlb = dict["IsCreatedSlb"] as! Bool
            }
            if dict.keys.contains("K8sResourceId") {
                self.k8sResourceId = dict["K8sResourceId"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NameServer") {
                self.nameServer = dict["NameServer"] as! String
            }
            if dict.keys.contains("NameServerPublic") {
                self.nameServerPublic = dict["NameServerPublic"] as! String
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! String
            }
            if dict.keys.contains("PodCidr") {
                self.podCidr = dict["PodCidr"] as! String
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Replica") {
                self.replica = dict["Replica"] as! Int64
            }
            if dict.keys.contains("SeataServerUniqueId") {
                self.seataServerUniqueId = dict["SeataServerUniqueId"] as! String
            }
            if dict.keys.contains("SecurityGroup") {
                self.securityGroup = dict["SecurityGroup"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("StartDate") {
                self.startDate = dict["StartDate"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("StoreMode") {
                self.storeMode = dict["StoreMode"] as! String
            }
            if dict.keys.contains("Vpc") {
                self.vpc = dict["Vpc"] as! String
            }
            if dict.keys.contains("Vswitch") {
                self.vswitch = dict["Vswitch"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListInstancesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListInstancesResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListListenersByConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListListenersByConfigResponseBody : Tea.TeaModel {
    public class Listeners : Tea.TeaModel {
        public var ip: String?

        public var md5: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var listeners: [ListListenersByConfigResponseBody.Listeners]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.listeners != nil {
            var tmp : [Any] = []
            for k in self.listeners! {
                tmp.append(k.toMap())
            }
            map["Listeners"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Listeners") {
            self.listeners = dict["Listeners"] as! [ListListenersByConfigResponseBody.Listeners]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListListenersByConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListListenersByConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListListenersByConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListListenersByIpRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var ip: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListListenersByIpResponseBody : Tea.TeaModel {
    public class Listeners : Tea.TeaModel {
        public var dataId: String?

        public var group: String?

        public var md5: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var listeners: [ListListenersByIpResponseBody.Listeners]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.listeners != nil {
            var tmp : [Any] = []
            for k in self.listeners! {
                tmp.append(k.toMap())
            }
            map["Listeners"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Listeners") {
            self.listeners = dict["Listeners"] as! [ListListenersByIpResponseBody.Listeners]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListListenersByIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListListenersByIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListListenersByIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNacosConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class ListNacosConfigsResponseBody : Tea.TeaModel {
    public class Configurations : Tea.TeaModel {
        public var appName: String?

        public var dataId: String?

        public var group: String?

        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var code: Int32?

    public var configurations: [ListNacosConfigsResponseBody.Configurations]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.configurations != nil {
            var tmp : [Any] = []
            for k in self.configurations! {
                tmp.append(k.toMap())
            }
            map["Configurations"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Configurations") {
            self.configurations = dict["Configurations"] as! [ListNacosConfigsResponseBody.Configurations]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListNacosConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNacosConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNacosConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNacosHistoryConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListNacosHistoryConfigsResponseBody : Tea.TeaModel {
    public class HistoryItems : Tea.TeaModel {
        public var appName: String?

        public var dataId: String?

        public var group: String?

        public var id: Int64?

        public var lastModifiedTime: Int64?

        public var opType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lastModifiedTime != nil {
                map["LastModifiedTime"] = self.lastModifiedTime!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("LastModifiedTime") {
                self.lastModifiedTime = dict["LastModifiedTime"] as! Int64
            }
            if dict.keys.contains("OpType") {
                self.opType = dict["OpType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var historyItems: [ListNacosHistoryConfigsResponseBody.HistoryItems]?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.historyItems != nil {
            var tmp : [Any] = []
            for k in self.historyItems! {
                tmp.append(k.toMap())
            }
            map["HistoryItems"] = tmp
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HistoryItems") {
            self.historyItems = dict["HistoryItems"] as! [ListNacosHistoryConfigsResponseBody.HistoryItems]
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListNacosHistoryConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNacosHistoryConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNacosHistoryConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSSLCertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class ListSSLCertResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var afterDate: String?

        public var algorithm: String?

        public var beforeDate: String?

        public var certIdentifier: String?

        public var certName: String?

        public var commonName: String?

        public var gmtAfter: String?

        public var gmtBefore: String?

        public var issuer: String?

        public var sans: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.afterDate != nil {
                map["AfterDate"] = self.afterDate!
            }
            if self.algorithm != nil {
                map["Algorithm"] = self.algorithm!
            }
            if self.beforeDate != nil {
                map["BeforeDate"] = self.beforeDate!
            }
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.commonName != nil {
                map["CommonName"] = self.commonName!
            }
            if self.gmtAfter != nil {
                map["GmtAfter"] = self.gmtAfter!
            }
            if self.gmtBefore != nil {
                map["GmtBefore"] = self.gmtBefore!
            }
            if self.issuer != nil {
                map["Issuer"] = self.issuer!
            }
            if self.sans != nil {
                map["Sans"] = self.sans!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AfterDate") {
                self.afterDate = dict["AfterDate"] as! String
            }
            if dict.keys.contains("Algorithm") {
                self.algorithm = dict["Algorithm"] as! String
            }
            if dict.keys.contains("BeforeDate") {
                self.beforeDate = dict["BeforeDate"] as! String
            }
            if dict.keys.contains("CertIdentifier") {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("CertName") {
                self.certName = dict["CertName"] as! String
            }
            if dict.keys.contains("CommonName") {
                self.commonName = dict["CommonName"] as! String
            }
            if dict.keys.contains("GmtAfter") {
                self.gmtAfter = dict["GmtAfter"] as! String
            }
            if dict.keys.contains("GmtBefore") {
                self.gmtBefore = dict["GmtBefore"] as! String
            }
            if dict.keys.contains("Issuer") {
                self.issuer = dict["Issuer"] as! String
            }
            if dict.keys.contains("Sans") {
                self.sans = dict["Sans"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSSLCertResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListSSLCertResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSSLCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSSLCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSSLCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSecurityGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class ListSecurityGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var securityGroupId: String?

        public var securityGroupName: String?

        public var securityGroupType: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupName != nil {
                map["SecurityGroupName"] = self.securityGroupName!
            }
            if self.securityGroupType != nil {
                map["SecurityGroupType"] = self.securityGroupType!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupName") {
                self.securityGroupName = dict["SecurityGroupName"] as! String
            }
            if dict.keys.contains("SecurityGroupType") {
                self.securityGroupType = dict["SecurityGroupType"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSecurityGroupResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListSecurityGroupResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSecurityGroupRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class ListSecurityGroupRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var description_: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: String?

        public var ipProtocol: String?

        public var portRange: String?

        public var securityGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSecurityGroupRuleResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListSecurityGroupRuleResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class ListServiceSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class IngressOptions : Tea.TeaModel {
            public var enableIngress: Bool?

            public var ingressClass: String?

            public var watchNamespace: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableIngress != nil {
                    map["EnableIngress"] = self.enableIngress!
                }
                if self.ingressClass != nil {
                    map["IngressClass"] = self.ingressClass!
                }
                if self.watchNamespace != nil {
                    map["WatchNamespace"] = self.watchNamespace!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnableIngress") {
                    self.enableIngress = dict["EnableIngress"] as! Bool
                }
                if dict.keys.contains("IngressClass") {
                    self.ingressClass = dict["IngressClass"] as! String
                }
                if dict.keys.contains("WatchNamespace") {
                    self.watchNamespace = dict["WatchNamespace"] as! String
                }
            }
        }
        public var address: String?

        public var bindingWithGateway: Int32?

        public var gatewayId: Int64?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ingressOptions: ListServiceSourceResponseBody.Data.IngressOptions?

        public var name: String?

        public var source: String?

        public var sourceUniqueId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ingressOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.bindingWithGateway != nil {
                map["BindingWithGateway"] = self.bindingWithGateway!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ingressOptions != nil {
                map["IngressOptions"] = self.ingressOptions?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.sourceUniqueId != nil {
                map["SourceUniqueId"] = self.sourceUniqueId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("BindingWithGateway") {
                self.bindingWithGateway = dict["BindingWithGateway"] as! Int32
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IngressOptions") {
                var model = ListServiceSourceResponseBody.Data.IngressOptions()
                model.fromMap(dict["IngressOptions"] as! [String: Any])
                self.ingressOptions = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("SourceUniqueId") {
                self.sourceUniqueId = dict["SourceUniqueId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListServiceSourceResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListServiceSourceResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public var nextToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ListTagResourcesRequest.Tag]
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") {
                self.tagResource = dict["TagResource"] as! [ListTagResourcesResponseBody.TagResources.TagResource]
            }
        }
    }
    public var errorCode: String?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagResources") {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public var region: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListUserInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appClusterId: String?

        public var appVersion: String?

        public var dbPassword: String?

        public var dbUrl: String?

        public var dbUserName: String?

        public var endDate: String?

        public var environmentId: Int64?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var imageVersion: String?

        public var instanceId: String?

        public var isCreatedRedis: Bool?

        public var k8sResourceId: Int64?

        public var name: String?

        public var nameServer: String?

        public var orderId: String?

        public var podCidr: String?

        public var primaryUser: String?

        public var region: String?

        public var replica: Int64?

        public var seataServerUniqueId: String?

        public var securityGroup: String?

        public var spec: String?

        public var startDate: String?

        public var status: Int64?

        public var statusDesc: String?

        public var storeMode: String?

        public var vpc: String?

        public var vswitch: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appClusterId != nil {
                map["AppClusterId"] = self.appClusterId!
            }
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.dbPassword != nil {
                map["DbPassword"] = self.dbPassword!
            }
            if self.dbUrl != nil {
                map["DbUrl"] = self.dbUrl!
            }
            if self.dbUserName != nil {
                map["DbUserName"] = self.dbUserName!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.environmentId != nil {
                map["EnvironmentId"] = self.environmentId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageVersion != nil {
                map["ImageVersion"] = self.imageVersion!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.isCreatedRedis != nil {
                map["IsCreatedRedis"] = self.isCreatedRedis!
            }
            if self.k8sResourceId != nil {
                map["K8sResourceId"] = self.k8sResourceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nameServer != nil {
                map["NameServer"] = self.nameServer!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.podCidr != nil {
                map["PodCidr"] = self.podCidr!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.replica != nil {
                map["Replica"] = self.replica!
            }
            if self.seataServerUniqueId != nil {
                map["SeataServerUniqueId"] = self.seataServerUniqueId!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.startDate != nil {
                map["StartDate"] = self.startDate!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.storeMode != nil {
                map["StoreMode"] = self.storeMode!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppClusterId") {
                self.appClusterId = dict["AppClusterId"] as! String
            }
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("DbPassword") {
                self.dbPassword = dict["DbPassword"] as! String
            }
            if dict.keys.contains("DbUrl") {
                self.dbUrl = dict["DbUrl"] as! String
            }
            if dict.keys.contains("DbUserName") {
                self.dbUserName = dict["DbUserName"] as! String
            }
            if dict.keys.contains("EndDate") {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("EnvironmentId") {
                self.environmentId = dict["EnvironmentId"] as! Int64
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ImageVersion") {
                self.imageVersion = dict["ImageVersion"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("IsCreatedRedis") {
                self.isCreatedRedis = dict["IsCreatedRedis"] as! Bool
            }
            if dict.keys.contains("K8sResourceId") {
                self.k8sResourceId = dict["K8sResourceId"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NameServer") {
                self.nameServer = dict["NameServer"] as! String
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! String
            }
            if dict.keys.contains("PodCidr") {
                self.podCidr = dict["PodCidr"] as! String
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Replica") {
                self.replica = dict["Replica"] as! Int64
            }
            if dict.keys.contains("SeataServerUniqueId") {
                self.seataServerUniqueId = dict["SeataServerUniqueId"] as! String
            }
            if dict.keys.contains("SecurityGroup") {
                self.securityGroup = dict["SecurityGroup"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("StartDate") {
                self.startDate = dict["StartDate"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("StoreMode") {
                self.storeMode = dict["StoreMode"] as! String
            }
            if dict.keys.contains("Vpc") {
                self.vpc = dict["Vpc"] as! String
            }
            if dict.keys.contains("Vswitch") {
                self.vswitch = dict["Vswitch"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListUserInstancesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListUserInstancesResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListUserInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVgroupsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public var region: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListVgroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var name: String?

        public var nameServer: String?

        public var primaryUser: String?

        public var region: String?

        public var seataServerUniqueId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nameServer != nil {
                map["NameServer"] = self.nameServer!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.seataServerUniqueId != nil {
                map["SeataServerUniqueId"] = self.seataServerUniqueId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NameServer") {
                self.nameServer = dict["NameServer"] as! String
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("SeataServerUniqueId") {
                self.seataServerUniqueId = dict["SeataServerUniqueId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListVgroupsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListVgroupsResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListVgroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVgroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVgroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListZnodeChildrenRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var mseSessionId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
    }
}

public class ListZnodeChildrenResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: [ListZnodeChildrenResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListZnodeChildrenResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListZnodeChildrenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListZnodeChildrenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListZnodeChildrenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyGovernanceKubernetesClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var mseSessionId: String?

    public var namespaceInfos: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceInfos != nil {
            map["NamespaceInfos"] = self.namespaceInfos!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceInfos") {
            self.namespaceInfos = dict["NamespaceInfos"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyGovernanceKubernetesClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyGovernanceKubernetesClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGovernanceKubernetesClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyGovernanceKubernetesClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLosslessRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aligned: Bool?

    public var appId: String?

    public var appName: String?

    public var delayTime: Int64?

    public var enable: Bool?

    public var funcType: Int64?

    public var mseSessionId: String?

    public var regionId: String?

    public var related: Bool?

    public var shutdownWaitSeconds: Int32?

    public var source: String?

    public var warmupTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aligned != nil {
            map["Aligned"] = self.aligned!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.delayTime != nil {
            map["DelayTime"] = self.delayTime!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.funcType != nil {
            map["FuncType"] = self.funcType!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.related != nil {
            map["Related"] = self.related!
        }
        if self.shutdownWaitSeconds != nil {
            map["ShutdownWaitSeconds"] = self.shutdownWaitSeconds!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.warmupTime != nil {
            map["WarmupTime"] = self.warmupTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Aligned") {
            self.aligned = dict["Aligned"] as! Bool
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DelayTime") {
            self.delayTime = dict["DelayTime"] as! Int64
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("FuncType") {
            self.funcType = dict["FuncType"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Related") {
            self.related = dict["Related"] as! Bool
        }
        if dict.keys.contains("ShutdownWaitSeconds") {
            self.shutdownWaitSeconds = dict["ShutdownWaitSeconds"] as! Int32
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("WarmupTime") {
            self.warmupTime = dict["WarmupTime"] as! Int64
        }
    }
}

public class ModifyLosslessRuleResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyLosslessRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLosslessRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyLosslessRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OfflineGatewayRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var routeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! String
        }
    }
}

public class OfflineGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class OfflineGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OfflineGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OfflineGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PullServicesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var namespace: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class PullServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Services : Tea.TeaModel {
            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var sourceId: String?

            public var sourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("SourceId") {
                    self.sourceId = dict["SourceId"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
            }
        }
        public var groupName: String?

        public var namespace: String?

        public var namespaceShowName: String?

        public var services: [PullServicesResponseBody.Data.Services]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.services != nil {
                var tmp : [Any] = []
                for k in self.services! {
                    tmp.append(k.toMap())
                }
                map["Services"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceShowName") {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Services") {
                self.services = dict["Services"] as! [PullServicesResponseBody.Data.Services]
            }
        }
    }
    public var code: Int32?

    public var data: [PullServicesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [PullServicesResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PullServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PullServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PullServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAllSwimmingLaneRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class QueryAllSwimmingLaneResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAllSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAllSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAllSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAllSwimmingLaneGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class QueryAllSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAllSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAllSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAllSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBusinessLocationsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class QueryBusinessLocationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cnName: String?

        public var description_: String?

        public var districtCnName: String?

        public var districtEnName: String?

        public var districtId: String?

        public var districtOrdering: Int32?

        public var districtShowName: String?

        public var enDescription: String?

        public var enName: String?

        public var name: String?

        public var ordering: Int32?

        public var showName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cnName != nil {
                map["CnName"] = self.cnName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.districtCnName != nil {
                map["DistrictCnName"] = self.districtCnName!
            }
            if self.districtEnName != nil {
                map["DistrictEnName"] = self.districtEnName!
            }
            if self.districtId != nil {
                map["DistrictId"] = self.districtId!
            }
            if self.districtOrdering != nil {
                map["DistrictOrdering"] = self.districtOrdering!
            }
            if self.districtShowName != nil {
                map["DistrictShowName"] = self.districtShowName!
            }
            if self.enDescription != nil {
                map["EnDescription"] = self.enDescription!
            }
            if self.enName != nil {
                map["EnName"] = self.enName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ordering != nil {
                map["Ordering"] = self.ordering!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CnName") {
                self.cnName = dict["CnName"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DistrictCnName") {
                self.districtCnName = dict["DistrictCnName"] as! String
            }
            if dict.keys.contains("DistrictEnName") {
                self.districtEnName = dict["DistrictEnName"] as! String
            }
            if dict.keys.contains("DistrictId") {
                self.districtId = dict["DistrictId"] as! String
            }
            if dict.keys.contains("DistrictOrdering") {
                self.districtOrdering = dict["DistrictOrdering"] as! Int32
            }
            if dict.keys.contains("DistrictShowName") {
                self.districtShowName = dict["DistrictShowName"] as! String
            }
            if dict.keys.contains("EnDescription") {
                self.enDescription = dict["EnDescription"] as! String
            }
            if dict.keys.contains("EnName") {
                self.enName = dict["EnName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Ordering") {
                self.ordering = dict["Ordering"] as! Int32
            }
            if dict.keys.contains("ShowName") {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [QueryBusinessLocationsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [QueryBusinessLocationsResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QueryBusinessLocationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBusinessLocationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryBusinessLocationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aclSwitch: Bool?

    public var instanceId: String?

    public var mseSessionId: String?

    public var orderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aclSwitch != nil {
            map["AclSwitch"] = self.aclSwitch!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AclSwitch") {
            self.aclSwitch = dict["AclSwitch"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
    }
}

public class QueryClusterDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class InstanceModels : Tea.TeaModel {
            public var creationTimestamp: String?

            public var healthStatus: String?

            public var internetIp: String?

            public var ip: String?

            public var podName: String?

            public var role: String?

            public var singleTunnelVip: String?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTimestamp != nil {
                    map["CreationTimestamp"] = self.creationTimestamp!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.podName != nil {
                    map["PodName"] = self.podName!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.singleTunnelVip != nil {
                    map["SingleTunnelVip"] = self.singleTunnelVip!
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTimestamp") {
                    self.creationTimestamp = dict["CreationTimestamp"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InternetIp") {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("PodName") {
                    self.podName = dict["PodName"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("SingleTunnelVip") {
                    self.singleTunnelVip = dict["SingleTunnelVip"] as! String
                }
                if dict.keys.contains("Zone") {
                    self.zone = dict["Zone"] as! String
                }
            }
        }
        public var aclEntryList: String?

        public var aclId: String?

        public var appVersion: String?

        public var chargeType: String?

        public var clusterAliasName: String?

        public var clusterName: String?

        public var clusterSpecification: String?

        public var clusterType: String?

        public var clusterVersion: String?

        public var connectionType: String?

        public var cpu: Int32?

        public var createTime: String?

        public var diskCapacity: Int64?

        public var diskType: String?

        public var healthStatus: String?

        public var initCostTime: Int64?

        public var initStatus: String?

        public var instanceCount: Int32?

        public var instanceId: String?

        public var instanceModels: [QueryClusterDetailResponseBody.Data.InstanceModels]?

        public var internetAddress: String?

        public var internetDomain: String?

        public var internetPort: String?

        public var intranetAddress: String?

        public var intranetDomain: String?

        public var intranetPort: String?

        public var memoryCapacity: Int64?

        public var mseVersion: String?

        public var netType: String?

        public var orderClusterVersion: String?

        public var payInfo: String?

        public var pubNetworkFlow: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var tags: [String: Any]?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclEntryList != nil {
                map["AclEntryList"] = self.aclEntryList!
            }
            if self.aclId != nil {
                map["AclId"] = self.aclId!
            }
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterAliasName != nil {
                map["ClusterAliasName"] = self.clusterAliasName!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterSpecification != nil {
                map["ClusterSpecification"] = self.clusterSpecification!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.clusterVersion != nil {
                map["ClusterVersion"] = self.clusterVersion!
            }
            if self.connectionType != nil {
                map["ConnectionType"] = self.connectionType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.initCostTime != nil {
                map["InitCostTime"] = self.initCostTime!
            }
            if self.initStatus != nil {
                map["InitStatus"] = self.initStatus!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceModels != nil {
                var tmp : [Any] = []
                for k in self.instanceModels! {
                    tmp.append(k.toMap())
                }
                map["InstanceModels"] = tmp
            }
            if self.internetAddress != nil {
                map["InternetAddress"] = self.internetAddress!
            }
            if self.internetDomain != nil {
                map["InternetDomain"] = self.internetDomain!
            }
            if self.internetPort != nil {
                map["InternetPort"] = self.internetPort!
            }
            if self.intranetAddress != nil {
                map["IntranetAddress"] = self.intranetAddress!
            }
            if self.intranetDomain != nil {
                map["IntranetDomain"] = self.intranetDomain!
            }
            if self.intranetPort != nil {
                map["IntranetPort"] = self.intranetPort!
            }
            if self.memoryCapacity != nil {
                map["MemoryCapacity"] = self.memoryCapacity!
            }
            if self.mseVersion != nil {
                map["MseVersion"] = self.mseVersion!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.orderClusterVersion != nil {
                map["OrderClusterVersion"] = self.orderClusterVersion!
            }
            if self.payInfo != nil {
                map["PayInfo"] = self.payInfo!
            }
            if self.pubNetworkFlow != nil {
                map["PubNetworkFlow"] = self.pubNetworkFlow!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclEntryList") {
                self.aclEntryList = dict["AclEntryList"] as! String
            }
            if dict.keys.contains("AclId") {
                self.aclId = dict["AclId"] as! String
            }
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterAliasName") {
                self.clusterAliasName = dict["ClusterAliasName"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterSpecification") {
                self.clusterSpecification = dict["ClusterSpecification"] as! String
            }
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("ClusterVersion") {
                self.clusterVersion = dict["ClusterVersion"] as! String
            }
            if dict.keys.contains("ConnectionType") {
                self.connectionType = dict["ConnectionType"] as! String
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DiskCapacity") {
                self.diskCapacity = dict["DiskCapacity"] as! Int64
            }
            if dict.keys.contains("DiskType") {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("HealthStatus") {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InitCostTime") {
                self.initCostTime = dict["InitCostTime"] as! Int64
            }
            if dict.keys.contains("InitStatus") {
                self.initStatus = dict["InitStatus"] as! String
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceModels") {
                self.instanceModels = dict["InstanceModels"] as! [QueryClusterDetailResponseBody.Data.InstanceModels]
            }
            if dict.keys.contains("InternetAddress") {
                self.internetAddress = dict["InternetAddress"] as! String
            }
            if dict.keys.contains("InternetDomain") {
                self.internetDomain = dict["InternetDomain"] as! String
            }
            if dict.keys.contains("InternetPort") {
                self.internetPort = dict["InternetPort"] as! String
            }
            if dict.keys.contains("IntranetAddress") {
                self.intranetAddress = dict["IntranetAddress"] as! String
            }
            if dict.keys.contains("IntranetDomain") {
                self.intranetDomain = dict["IntranetDomain"] as! String
            }
            if dict.keys.contains("IntranetPort") {
                self.intranetPort = dict["IntranetPort"] as! String
            }
            if dict.keys.contains("MemoryCapacity") {
                self.memoryCapacity = dict["MemoryCapacity"] as! Int64
            }
            if dict.keys.contains("MseVersion") {
                self.mseVersion = dict["MseVersion"] as! String
            }
            if dict.keys.contains("NetType") {
                self.netType = dict["NetType"] as! String
            }
            if dict.keys.contains("OrderClusterVersion") {
                self.orderClusterVersion = dict["OrderClusterVersion"] as! String
            }
            if dict.keys.contains("PayInfo") {
                self.payInfo = dict["PayInfo"] as! String
            }
            if dict.keys.contains("PubNetworkFlow") {
                self.pubNetworkFlow = dict["PubNetworkFlow"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! [String: Any]
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var data: QueryClusterDetailResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryClusterDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryClusterDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterDiskSpecificationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class QueryClusterDiskSpecificationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var max: Int32?

        public var min: Int32?

        public var step: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.max != nil {
                map["Max"] = self.max!
            }
            if self.min != nil {
                map["Min"] = self.min!
            }
            if self.step != nil {
                map["Step"] = self.step!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Max") {
                self.max = dict["Max"] as! Int32
            }
            if dict.keys.contains("Min") {
                self.min = dict["Min"] as! Int32
            }
            if dict.keys.contains("Step") {
                self.step = dict["Step"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: QueryClusterDiskSpecificationResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = QueryClusterDiskSpecificationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterDiskSpecificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterDiskSpecificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryClusterDiskSpecificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterSpecificationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var connectType: String?

    public var mseSessionId: String?

    public var mseVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.connectType != nil {
            map["ConnectType"] = self.connectType!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConnectType") {
            self.connectType = dict["ConnectType"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
    }
}

public class QueryClusterSpecificationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterSpecificationName: String?

        public var cpuCapacity: String?

        public var diskCapacity: String?

        public var instanceCount: String?

        public var maxCon: String?

        public var maxTps: String?

        public var memoryCapacity: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterSpecificationName != nil {
                map["ClusterSpecificationName"] = self.clusterSpecificationName!
            }
            if self.cpuCapacity != nil {
                map["CpuCapacity"] = self.cpuCapacity!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.maxCon != nil {
                map["MaxCon"] = self.maxCon!
            }
            if self.maxTps != nil {
                map["MaxTps"] = self.maxTps!
            }
            if self.memoryCapacity != nil {
                map["MemoryCapacity"] = self.memoryCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterSpecificationName") {
                self.clusterSpecificationName = dict["ClusterSpecificationName"] as! String
            }
            if dict.keys.contains("CpuCapacity") {
                self.cpuCapacity = dict["CpuCapacity"] as! String
            }
            if dict.keys.contains("DiskCapacity") {
                self.diskCapacity = dict["DiskCapacity"] as! String
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! String
            }
            if dict.keys.contains("MaxCon") {
                self.maxCon = dict["MaxCon"] as! String
            }
            if dict.keys.contains("MaxTps") {
                self.maxTps = dict["MaxTps"] as! String
            }
            if dict.keys.contains("MemoryCapacity") {
                self.memoryCapacity = dict["MemoryCapacity"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [QueryClusterSpecificationResponseBody.Data]?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [QueryClusterSpecificationResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterSpecificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterSpecificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryClusterSpecificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var configType: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigType") {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var autopurgePurgeInterval: String?

        public var autopurgeSnapRetainCount: String?

        public var clusterName: String?

        public var configAuthEnabled: Bool?

        public var configAuthSupported: Bool?

        public var configSecretEnabled: Bool?

        public var configSecretSupported: Bool?

        public var initLimit: String?

        public var juteMaxbuffer: String?

        public var jvmFlagsCustom: String?

        public var MCPEnabled: Bool?

        public var MCPSupported: Bool?

        public var maxClientCnxns: String?

        public var maxSessionTimeout: String?

        public var minSessionTimeout: String?

        public var namingAuthEnabled: Bool?

        public var namingAuthSupported: Bool?

        public var namingCreateServiceSupported: Bool?

        public var openSuperAcl: Bool?

        public var passWord: String?

        public var restartFlag: Bool?

        public var snapshotCount: String?

        public var syncLimit: String?

        public var tickTime: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autopurgePurgeInterval != nil {
                map["AutopurgePurgeInterval"] = self.autopurgePurgeInterval!
            }
            if self.autopurgeSnapRetainCount != nil {
                map["AutopurgeSnapRetainCount"] = self.autopurgeSnapRetainCount!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.configAuthEnabled != nil {
                map["ConfigAuthEnabled"] = self.configAuthEnabled!
            }
            if self.configAuthSupported != nil {
                map["ConfigAuthSupported"] = self.configAuthSupported!
            }
            if self.configSecretEnabled != nil {
                map["ConfigSecretEnabled"] = self.configSecretEnabled!
            }
            if self.configSecretSupported != nil {
                map["ConfigSecretSupported"] = self.configSecretSupported!
            }
            if self.initLimit != nil {
                map["InitLimit"] = self.initLimit!
            }
            if self.juteMaxbuffer != nil {
                map["JuteMaxbuffer"] = self.juteMaxbuffer!
            }
            if self.jvmFlagsCustom != nil {
                map["JvmFlagsCustom"] = self.jvmFlagsCustom!
            }
            if self.MCPEnabled != nil {
                map["MCPEnabled"] = self.MCPEnabled!
            }
            if self.MCPSupported != nil {
                map["MCPSupported"] = self.MCPSupported!
            }
            if self.maxClientCnxns != nil {
                map["MaxClientCnxns"] = self.maxClientCnxns!
            }
            if self.maxSessionTimeout != nil {
                map["MaxSessionTimeout"] = self.maxSessionTimeout!
            }
            if self.minSessionTimeout != nil {
                map["MinSessionTimeout"] = self.minSessionTimeout!
            }
            if self.namingAuthEnabled != nil {
                map["NamingAuthEnabled"] = self.namingAuthEnabled!
            }
            if self.namingAuthSupported != nil {
                map["NamingAuthSupported"] = self.namingAuthSupported!
            }
            if self.namingCreateServiceSupported != nil {
                map["NamingCreateServiceSupported"] = self.namingCreateServiceSupported!
            }
            if self.openSuperAcl != nil {
                map["OpenSuperAcl"] = self.openSuperAcl!
            }
            if self.passWord != nil {
                map["PassWord"] = self.passWord!
            }
            if self.restartFlag != nil {
                map["RestartFlag"] = self.restartFlag!
            }
            if self.snapshotCount != nil {
                map["SnapshotCount"] = self.snapshotCount!
            }
            if self.syncLimit != nil {
                map["SyncLimit"] = self.syncLimit!
            }
            if self.tickTime != nil {
                map["TickTime"] = self.tickTime!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutopurgePurgeInterval") {
                self.autopurgePurgeInterval = dict["AutopurgePurgeInterval"] as! String
            }
            if dict.keys.contains("AutopurgeSnapRetainCount") {
                self.autopurgeSnapRetainCount = dict["AutopurgeSnapRetainCount"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ConfigAuthEnabled") {
                self.configAuthEnabled = dict["ConfigAuthEnabled"] as! Bool
            }
            if dict.keys.contains("ConfigAuthSupported") {
                self.configAuthSupported = dict["ConfigAuthSupported"] as! Bool
            }
            if dict.keys.contains("ConfigSecretEnabled") {
                self.configSecretEnabled = dict["ConfigSecretEnabled"] as! Bool
            }
            if dict.keys.contains("ConfigSecretSupported") {
                self.configSecretSupported = dict["ConfigSecretSupported"] as! Bool
            }
            if dict.keys.contains("InitLimit") {
                self.initLimit = dict["InitLimit"] as! String
            }
            if dict.keys.contains("JuteMaxbuffer") {
                self.juteMaxbuffer = dict["JuteMaxbuffer"] as! String
            }
            if dict.keys.contains("JvmFlagsCustom") {
                self.jvmFlagsCustom = dict["JvmFlagsCustom"] as! String
            }
            if dict.keys.contains("MCPEnabled") {
                self.MCPEnabled = dict["MCPEnabled"] as! Bool
            }
            if dict.keys.contains("MCPSupported") {
                self.MCPSupported = dict["MCPSupported"] as! Bool
            }
            if dict.keys.contains("MaxClientCnxns") {
                self.maxClientCnxns = dict["MaxClientCnxns"] as! String
            }
            if dict.keys.contains("MaxSessionTimeout") {
                self.maxSessionTimeout = dict["MaxSessionTimeout"] as! String
            }
            if dict.keys.contains("MinSessionTimeout") {
                self.minSessionTimeout = dict["MinSessionTimeout"] as! String
            }
            if dict.keys.contains("NamingAuthEnabled") {
                self.namingAuthEnabled = dict["NamingAuthEnabled"] as! Bool
            }
            if dict.keys.contains("NamingAuthSupported") {
                self.namingAuthSupported = dict["NamingAuthSupported"] as! Bool
            }
            if dict.keys.contains("NamingCreateServiceSupported") {
                self.namingCreateServiceSupported = dict["NamingCreateServiceSupported"] as! Bool
            }
            if dict.keys.contains("OpenSuperAcl") {
                self.openSuperAcl = dict["OpenSuperAcl"] as! Bool
            }
            if dict.keys.contains("PassWord") {
                self.passWord = dict["PassWord"] as! String
            }
            if dict.keys.contains("RestartFlag") {
                self.restartFlag = dict["RestartFlag"] as! Bool
            }
            if dict.keys.contains("SnapshotCount") {
                self.snapshotCount = dict["SnapshotCount"] as! String
            }
            if dict.keys.contains("SyncLimit") {
                self.syncLimit = dict["SyncLimit"] as! String
            }
            if dict.keys.contains("TickTime") {
                self.tickTime = dict["TickTime"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: QueryConfigResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = QueryConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGatewayRegionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class QueryGatewayRegionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGatewayRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGatewayRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryGatewayRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGatewayTypeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class QueryGatewayTypeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGatewayTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGatewayTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryGatewayTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGovernanceKubernetesClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var mseSessionId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryGovernanceKubernetesClusterResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var clusterId: String?

            public var clusterName: String?

            public var k8sVersion: String?

            public var namespaceInfos: String?

            public var pilotStartTime: String?

            public var region: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.k8sVersion != nil {
                    map["K8sVersion"] = self.k8sVersion!
                }
                if self.namespaceInfos != nil {
                    map["NamespaceInfos"] = self.namespaceInfos!
                }
                if self.pilotStartTime != nil {
                    map["PilotStartTime"] = self.pilotStartTime!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("K8sVersion") {
                    self.k8sVersion = dict["K8sVersion"] as! String
                }
                if dict.keys.contains("NamespaceInfos") {
                    self.namespaceInfos = dict["NamespaceInfos"] as! String
                }
                if dict.keys.contains("PilotStartTime") {
                    self.pilotStartTime = dict["PilotStartTime"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [QueryGovernanceKubernetesClusterResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! [QueryGovernanceKubernetesClusterResponseBody.Data.Result]
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: QueryGovernanceKubernetesClusterResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = QueryGovernanceKubernetesClusterResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGovernanceKubernetesClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGovernanceKubernetesClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryGovernanceKubernetesClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMonitorRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var monitorType: String?

    public var mseSessionId: String?

    public var requestPars: String?

    public var startTime: Int64?

    public var step: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.monitorType != nil {
            map["MonitorType"] = self.monitorType!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.step != nil {
            map["Step"] = self.step!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MonitorType") {
            self.monitorType = dict["MonitorType"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Step") {
            self.step = dict["Step"] as! Int64
        }
    }
}

public class QueryMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterNamePrefix: String?

        public var podName: String?

        public var values: [[String: Any]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterNamePrefix != nil {
                map["clusterNamePrefix"] = self.clusterNamePrefix!
            }
            if self.podName != nil {
                map["podName"] = self.podName!
            }
            if self.values != nil {
                map["values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("clusterNamePrefix") {
                self.clusterNamePrefix = dict["clusterNamePrefix"] as! String
            }
            if dict.keys.contains("podName") {
                self.podName = dict["podName"] as! String
            }
            if dict.keys.contains("values") {
                self.values = dict["values"] as! [[String: Any]]
            }
        }
    }
    public var data: [QueryMonitorResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [QueryMonitorResponseBody.Data]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySlbSpecRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class QuerySlbSpecResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int32?

        public var maxConnection: String?

        public var name: String?

        public var newConnectionPerSecond: String?

        public var qps: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxConnection != nil {
                map["MaxConnection"] = self.maxConnection!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.newConnectionPerSecond != nil {
                map["NewConnectionPerSecond"] = self.newConnectionPerSecond!
            }
            if self.qps != nil {
                map["Qps"] = self.qps!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("MaxConnection") {
                self.maxConnection = dict["MaxConnection"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NewConnectionPerSecond") {
                self.newConnectionPerSecond = dict["NewConnectionPerSecond"] as! String
            }
            if dict.keys.contains("Qps") {
                self.qps = dict["Qps"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [QuerySlbSpecResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [QuerySlbSpecResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QuerySlbSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySlbSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySlbSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySwimmingLaneByIdRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var laneId: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("LaneId") {
            self.laneId = dict["LaneId"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class QuerySwimmingLaneByIdResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QuerySwimmingLaneByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySwimmingLaneByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySwimmingLaneByIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryZnodeDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var path: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryZnodeDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: QueryZnodeDetailResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryZnodeDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QueryZnodeDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryZnodeDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryZnodeDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var podNameList: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.podNameList != nil {
            map["PodNameList"] = self.podNameList!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PodNameList") {
            self.podNameList = dict["PodNameList"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class RestartClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestartClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class RetryClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RetryClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetryClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SelectGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var name: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class SelectGatewaySlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var slbId: String?

        public var slbName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbName != nil {
                map["SlbName"] = self.slbName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbId") {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbName") {
                self.slbName = dict["SlbName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [SelectGatewaySlbResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [SelectGatewaySlbResponseBody.Data]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SelectGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SelectGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SelectGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var mseSessionId: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [TagResourcesRequest.Tag]
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var all: Bool?

    public var mseSessionId: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAclRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aclEntryList: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aclEntryList != nil {
            map["AclEntryList"] = self.aclEntryList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AclEntryList") {
            self.aclEntryList = dict["AclEntryList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class UpdateAclResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBlackWhiteListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var content: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var isWhite: Bool?

    public var mseSessionId: String?

    public var name: String?

    public var note: String?

    public var resourceIdJsonList: String?

    public var resourceType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.resourceIdJsonList != nil {
            map["ResourceIdJsonList"] = self.resourceIdJsonList!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IsWhite") {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Note") {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("ResourceIdJsonList") {
            self.resourceIdJsonList = dict["ResourceIdJsonList"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateBlackWhiteListResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterAliasName: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterAliasName != nil {
            map["ClusterAliasName"] = self.clusterAliasName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterAliasName") {
            self.clusterAliasName = dict["ClusterAliasName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class UpdateClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateClusterSpecRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterSpecification: String?

    public var instanceCount: Int32?

    public var instanceId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterSpecification != nil {
            map["ClusterSpecification"] = self.clusterSpecification!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterSpecification") {
            self.clusterSpecification = dict["ClusterSpecification"] as! String
        }
        if dict.keys.contains("InstanceCount") {
            self.instanceCount = dict["InstanceCount"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class UpdateClusterSpecResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateClusterSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateClusterSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateClusterSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var autopurgePurgeInterval: String?

    public var autopurgeSnapRetainCount: String?

    public var clusterId: String?

    public var configAuthEnabled: Bool?

    public var configSecretEnabled: Bool?

    public var configType: String?

    public var initLimit: String?

    public var instanceId: String?

    public var juteMaxbuffer: String?

    public var MCPEnabled: Bool?

    public var maxClientCnxns: String?

    public var maxSessionTimeout: String?

    public var minSessionTimeout: String?

    public var mseSessionId: String?

    public var namingAuthEnabled: Bool?

    public var openSuperAcl: String?

    public var passWord: String?

    public var requestPars: String?

    public var snapshotCount: String?

    public var syncLimit: String?

    public var tickTime: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.autopurgePurgeInterval != nil {
            map["AutopurgePurgeInterval"] = self.autopurgePurgeInterval!
        }
        if self.autopurgeSnapRetainCount != nil {
            map["AutopurgeSnapRetainCount"] = self.autopurgeSnapRetainCount!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configAuthEnabled != nil {
            map["ConfigAuthEnabled"] = self.configAuthEnabled!
        }
        if self.configSecretEnabled != nil {
            map["ConfigSecretEnabled"] = self.configSecretEnabled!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.initLimit != nil {
            map["InitLimit"] = self.initLimit!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.juteMaxbuffer != nil {
            map["JuteMaxbuffer"] = self.juteMaxbuffer!
        }
        if self.MCPEnabled != nil {
            map["MCPEnabled"] = self.MCPEnabled!
        }
        if self.maxClientCnxns != nil {
            map["MaxClientCnxns"] = self.maxClientCnxns!
        }
        if self.maxSessionTimeout != nil {
            map["MaxSessionTimeout"] = self.maxSessionTimeout!
        }
        if self.minSessionTimeout != nil {
            map["MinSessionTimeout"] = self.minSessionTimeout!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namingAuthEnabled != nil {
            map["NamingAuthEnabled"] = self.namingAuthEnabled!
        }
        if self.openSuperAcl != nil {
            map["OpenSuperAcl"] = self.openSuperAcl!
        }
        if self.passWord != nil {
            map["PassWord"] = self.passWord!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.snapshotCount != nil {
            map["SnapshotCount"] = self.snapshotCount!
        }
        if self.syncLimit != nil {
            map["SyncLimit"] = self.syncLimit!
        }
        if self.tickTime != nil {
            map["TickTime"] = self.tickTime!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AutopurgePurgeInterval") {
            self.autopurgePurgeInterval = dict["AutopurgePurgeInterval"] as! String
        }
        if dict.keys.contains("AutopurgeSnapRetainCount") {
            self.autopurgeSnapRetainCount = dict["AutopurgeSnapRetainCount"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigAuthEnabled") {
            self.configAuthEnabled = dict["ConfigAuthEnabled"] as! Bool
        }
        if dict.keys.contains("ConfigSecretEnabled") {
            self.configSecretEnabled = dict["ConfigSecretEnabled"] as! Bool
        }
        if dict.keys.contains("ConfigType") {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("InitLimit") {
            self.initLimit = dict["InitLimit"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JuteMaxbuffer") {
            self.juteMaxbuffer = dict["JuteMaxbuffer"] as! String
        }
        if dict.keys.contains("MCPEnabled") {
            self.MCPEnabled = dict["MCPEnabled"] as! Bool
        }
        if dict.keys.contains("MaxClientCnxns") {
            self.maxClientCnxns = dict["MaxClientCnxns"] as! String
        }
        if dict.keys.contains("MaxSessionTimeout") {
            self.maxSessionTimeout = dict["MaxSessionTimeout"] as! String
        }
        if dict.keys.contains("MinSessionTimeout") {
            self.minSessionTimeout = dict["MinSessionTimeout"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamingAuthEnabled") {
            self.namingAuthEnabled = dict["NamingAuthEnabled"] as! Bool
        }
        if dict.keys.contains("OpenSuperAcl") {
            self.openSuperAcl = dict["OpenSuperAcl"] as! String
        }
        if dict.keys.contains("PassWord") {
            self.passWord = dict["PassWord"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("SnapshotCount") {
            self.snapshotCount = dict["SnapshotCount"] as! String
        }
        if dict.keys.contains("SyncLimit") {
            self.syncLimit = dict["SyncLimit"] as! String
        }
        if dict.keys.contains("TickTime") {
            self.tickTime = dict["TickTime"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class UpdateConfigResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEngineNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var desc: String?

    public var id: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var name: String?

    public var serviceCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.serviceCount != nil {
            map["ServiceCount"] = self.serviceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServiceCount") {
            self.serviceCount = dict["ServiceCount"] as! Int32
        }
    }
}

public class UpdateEngineNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configCount: Int32?

        public var namespace: String?

        public var namespaceDesc: String?

        public var namespaceShowName: String?

        public var quota: Int32?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configCount != nil {
                map["ConfigCount"] = self.configCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceDesc != nil {
                map["NamespaceDesc"] = self.namespaceDesc!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigCount") {
                self.configCount = dict["ConfigCount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceDesc") {
                self.namespaceDesc = dict["NamespaceDesc"] as! String
            }
            if dict.keys.contains("NamespaceShowName") {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Quota") {
                self.quota = dict["Quota"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var data: UpdateEngineNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateEngineNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEngineNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEngineNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEngineNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var gatewayUniqueId: String?

    public var http2: String?

    public var id: Int64?

    public var mseSessionId: String?

    public var mustHttps: Bool?

    public var protocol_: String?

    public var tlsMax: String?

    public var tlsMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.http2 != nil {
            map["Http2"] = self.http2!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.mustHttps != nil {
            map["MustHttps"] = self.mustHttps!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.tlsMax != nil {
            map["TlsMax"] = self.tlsMax!
        }
        if self.tlsMin != nil {
            map["TlsMin"] = self.tlsMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Http2") {
            self.http2 = dict["Http2"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("MustHttps") {
            self.mustHttps = dict["MustHttps"] as! Bool
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TlsMax") {
            self.tlsMax = dict["TlsMax"] as! String
        }
        if dict.keys.contains("TlsMin") {
            self.tlsMin = dict["TlsMin"] as! String
        }
    }
}

public class UpdateGatewayDomainResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayNameRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateGatewayNameResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayOptionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayOption: GatewayOption?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewayOption?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayOption != nil {
            map["GatewayOption"] = self.gatewayOption?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayOption") {
            var model = GatewayOption()
            model.fromMap(dict["GatewayOption"] as! [String: Any])
            self.gatewayOption = model
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class UpdateGatewayOptionShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayOptionShrink: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayOptionShrink != nil {
            map["GatewayOption"] = self.gatewayOptionShrink!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayOption") {
            self.gatewayOptionShrink = dict["GatewayOption"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class UpdateGatewayOptionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GatewayOption?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GatewayOption()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayOptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayOptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayOptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteRequest : Tea.TeaModel {
    public class DirectResponseJSON : Tea.TeaModel {
        public var body: String?

        public var code: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.body != nil {
                map["Body"] = self.body!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Body") {
                self.body = dict["Body"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! Int64
            }
        }
    }
    public class FallbackServices : Tea.TeaModel {
        public var agreementType: String?

        public var groupName: String?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public class Predicates : Tea.TeaModel {
        public class HeaderPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class PathPredicates : Tea.TeaModel {
            public var ignoreCase: Bool?

            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ignoreCase != nil {
                    map["IgnoreCase"] = self.ignoreCase!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IgnoreCase") {
                    self.ignoreCase = dict["IgnoreCase"] as! Bool
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class QueryPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var headerPredicates: [UpdateGatewayRouteRequest.Predicates.HeaderPredicates]?

        public var methodPredicates: [String]?

        public var pathPredicates: UpdateGatewayRouteRequest.Predicates.PathPredicates?

        public var queryPredicates: [UpdateGatewayRouteRequest.Predicates.QueryPredicates]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pathPredicates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerPredicates != nil {
                var tmp : [Any] = []
                for k in self.headerPredicates! {
                    tmp.append(k.toMap())
                }
                map["HeaderPredicates"] = tmp
            }
            if self.methodPredicates != nil {
                map["MethodPredicates"] = self.methodPredicates!
            }
            if self.pathPredicates != nil {
                map["PathPredicates"] = self.pathPredicates?.toMap()
            }
            if self.queryPredicates != nil {
                var tmp : [Any] = []
                for k in self.queryPredicates! {
                    tmp.append(k.toMap())
                }
                map["QueryPredicates"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HeaderPredicates") {
                self.headerPredicates = dict["HeaderPredicates"] as! [UpdateGatewayRouteRequest.Predicates.HeaderPredicates]
            }
            if dict.keys.contains("MethodPredicates") {
                self.methodPredicates = dict["MethodPredicates"] as! [String]
            }
            if dict.keys.contains("PathPredicates") {
                var model = UpdateGatewayRouteRequest.Predicates.PathPredicates()
                model.fromMap(dict["PathPredicates"] as! [String: Any])
                self.pathPredicates = model
            }
            if dict.keys.contains("QueryPredicates") {
                self.queryPredicates = dict["QueryPredicates"] as! [UpdateGatewayRouteRequest.Predicates.QueryPredicates]
            }
        }
    }
    public class RedirectJSON : Tea.TeaModel {
        public var code: Int32?

        public var host: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! Int32
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class Services : Tea.TeaModel {
        public class HttpDubboTranscoder : Tea.TeaModel {
            public class MothedMapList : Tea.TeaModel {
                public class ParamMapsList : Tea.TeaModel {
                    public var extractKey: String?

                    public var extractKeySpec: String?

                    public var mappingType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extractKey != nil {
                            map["ExtractKey"] = self.extractKey!
                        }
                        if self.extractKeySpec != nil {
                            map["ExtractKeySpec"] = self.extractKeySpec!
                        }
                        if self.mappingType != nil {
                            map["MappingType"] = self.mappingType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtractKey") {
                            self.extractKey = dict["ExtractKey"] as! String
                        }
                        if dict.keys.contains("ExtractKeySpec") {
                            self.extractKeySpec = dict["ExtractKeySpec"] as! String
                        }
                        if dict.keys.contains("MappingType") {
                            self.mappingType = dict["MappingType"] as! String
                        }
                    }
                }
                public var dubboMothedName: String?

                public var httpMothed: String?

                public var mothedpath: String?

                public var paramMapsList: [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                public var passThroughAllHeaders: String?

                public var passThroughList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dubboMothedName != nil {
                        map["DubboMothedName"] = self.dubboMothedName!
                    }
                    if self.httpMothed != nil {
                        map["HttpMothed"] = self.httpMothed!
                    }
                    if self.mothedpath != nil {
                        map["Mothedpath"] = self.mothedpath!
                    }
                    if self.paramMapsList != nil {
                        var tmp : [Any] = []
                        for k in self.paramMapsList! {
                            tmp.append(k.toMap())
                        }
                        map["ParamMapsList"] = tmp
                    }
                    if self.passThroughAllHeaders != nil {
                        map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                    }
                    if self.passThroughList != nil {
                        map["PassThroughList"] = self.passThroughList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DubboMothedName") {
                        self.dubboMothedName = dict["DubboMothedName"] as! String
                    }
                    if dict.keys.contains("HttpMothed") {
                        self.httpMothed = dict["HttpMothed"] as! String
                    }
                    if dict.keys.contains("Mothedpath") {
                        self.mothedpath = dict["Mothedpath"] as! String
                    }
                    if dict.keys.contains("ParamMapsList") {
                        self.paramMapsList = dict["ParamMapsList"] as! [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList]
                    }
                    if dict.keys.contains("PassThroughAllHeaders") {
                        self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                    }
                    if dict.keys.contains("PassThroughList") {
                        self.passThroughList = dict["PassThroughList"] as! [String]
                    }
                }
            }
            public var dubboServiceGroup: String?

            public var dubboServiceName: String?

            public var dubboServiceVersion: String?

            public var mothedMapList: [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dubboServiceGroup != nil {
                    map["DubboServiceGroup"] = self.dubboServiceGroup!
                }
                if self.dubboServiceName != nil {
                    map["DubboServiceName"] = self.dubboServiceName!
                }
                if self.dubboServiceVersion != nil {
                    map["DubboServiceVersion"] = self.dubboServiceVersion!
                }
                if self.mothedMapList != nil {
                    var tmp : [Any] = []
                    for k in self.mothedMapList! {
                        tmp.append(k.toMap())
                    }
                    map["MothedMapList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DubboServiceGroup") {
                    self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                }
                if dict.keys.contains("DubboServiceName") {
                    self.dubboServiceName = dict["DubboServiceName"] as! String
                }
                if dict.keys.contains("DubboServiceVersion") {
                    self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                }
                if dict.keys.contains("MothedMapList") {
                    self.mothedMapList = dict["MothedMapList"] as! [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList]
                }
            }
        }
        public var agreementType: String?

        public var groupName: String?

        public var httpDubboTranscoder: UpdateGatewayRouteRequest.Services.HttpDubboTranscoder?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.httpDubboTranscoder?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.httpDubboTranscoder != nil {
                map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HttpDubboTranscoder") {
                var model = UpdateGatewayRouteRequest.Services.HttpDubboTranscoder()
                model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                self.httpDubboTranscoder = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var destinationType: String?

    public var directResponseJSON: UpdateGatewayRouteRequest.DirectResponseJSON?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServices: [UpdateGatewayRouteRequest.FallbackServices]?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public var name: String?

    public var predicates: UpdateGatewayRouteRequest.Predicates?

    public var redirectJSON: UpdateGatewayRouteRequest.RedirectJSON?

    public var routeOrder: Int32?

    public var services: [UpdateGatewayRouteRequest.Services]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.directResponseJSON?.validate()
        try self.predicates?.validate()
        try self.redirectJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSON != nil {
            map["DirectResponseJSON"] = self.directResponseJSON?.toMap()
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServices != nil {
            var tmp : [Any] = []
            for k in self.fallbackServices! {
                tmp.append(k.toMap())
            }
            map["FallbackServices"] = tmp
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.predicates != nil {
            map["Predicates"] = self.predicates?.toMap()
        }
        if self.redirectJSON != nil {
            map["RedirectJSON"] = self.redirectJSON?.toMap()
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") {
            var model = UpdateGatewayRouteRequest.DirectResponseJSON()
            model.fromMap(dict["DirectResponseJSON"] as! [String: Any])
            self.directResponseJSON = model
        }
        if dict.keys.contains("DomainIdListJSON") {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") {
            self.fallbackServices = dict["FallbackServices"] as! [UpdateGatewayRouteRequest.FallbackServices]
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Predicates") {
            var model = UpdateGatewayRouteRequest.Predicates()
            model.fromMap(dict["Predicates"] as! [String: Any])
            self.predicates = model
        }
        if dict.keys.contains("RedirectJSON") {
            var model = UpdateGatewayRouteRequest.RedirectJSON()
            model.fromMap(dict["RedirectJSON"] as! [String: Any])
            self.redirectJSON = model
        }
        if dict.keys.contains("RouteOrder") {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("Services") {
            self.services = dict["Services"] as! [UpdateGatewayRouteRequest.Services]
        }
    }
}

public class UpdateGatewayRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var destinationType: String?

    public var directResponseJSONShrink: String?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServicesShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public var name: String?

    public var predicatesShrink: String?

    public var redirectJSONShrink: String?

    public var routeOrder: Int32?

    public var servicesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSONShrink != nil {
            map["DirectResponseJSON"] = self.directResponseJSONShrink!
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServicesShrink != nil {
            map["FallbackServices"] = self.fallbackServicesShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.predicatesShrink != nil {
            map["Predicates"] = self.predicatesShrink!
        }
        if self.redirectJSONShrink != nil {
            map["RedirectJSON"] = self.redirectJSONShrink!
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.servicesShrink != nil {
            map["Services"] = self.servicesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") {
            self.directResponseJSONShrink = dict["DirectResponseJSON"] as! String
        }
        if dict.keys.contains("DomainIdListJSON") {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") {
            self.fallbackServicesShrink = dict["FallbackServices"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Predicates") {
            self.predicatesShrink = dict["Predicates"] as! String
        }
        if dict.keys.contains("RedirectJSON") {
            self.redirectJSONShrink = dict["RedirectJSON"] as! String
        }
        if dict.keys.contains("RouteOrder") {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("Services") {
            self.servicesShrink = dict["Services"] as! String
        }
    }
}

public class UpdateGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteCORSRequest : Tea.TeaModel {
    public class CorsJSON : Tea.TeaModel {
        public var allowCredentials: Bool?

        public var allowHeaders: String?

        public var allowMethods: String?

        public var allowOrigins: String?

        public var exposeHeaders: String?

        public var status: String?

        public var timeUnit: String?

        public var unitNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowCredentials != nil {
                map["AllowCredentials"] = self.allowCredentials!
            }
            if self.allowHeaders != nil {
                map["AllowHeaders"] = self.allowHeaders!
            }
            if self.allowMethods != nil {
                map["AllowMethods"] = self.allowMethods!
            }
            if self.allowOrigins != nil {
                map["AllowOrigins"] = self.allowOrigins!
            }
            if self.exposeHeaders != nil {
                map["ExposeHeaders"] = self.exposeHeaders!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeUnit != nil {
                map["TimeUnit"] = self.timeUnit!
            }
            if self.unitNum != nil {
                map["UnitNum"] = self.unitNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowCredentials") {
                self.allowCredentials = dict["AllowCredentials"] as! Bool
            }
            if dict.keys.contains("AllowHeaders") {
                self.allowHeaders = dict["AllowHeaders"] as! String
            }
            if dict.keys.contains("AllowMethods") {
                self.allowMethods = dict["AllowMethods"] as! String
            }
            if dict.keys.contains("AllowOrigins") {
                self.allowOrigins = dict["AllowOrigins"] as! String
            }
            if dict.keys.contains("ExposeHeaders") {
                self.exposeHeaders = dict["ExposeHeaders"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TimeUnit") {
                self.timeUnit = dict["TimeUnit"] as! String
            }
            if dict.keys.contains("UnitNum") {
                self.unitNum = dict["UnitNum"] as! Int64
            }
        }
    }
    public var acceptLanguage: String?

    public var corsJSON: UpdateGatewayRouteCORSRequest.CorsJSON?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.corsJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.corsJSON != nil {
            map["CorsJSON"] = self.corsJSON?.toMap()
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CorsJSON") {
            var model = UpdateGatewayRouteCORSRequest.CorsJSON()
            model.fromMap(dict["CorsJSON"] as! [String: Any])
            self.corsJSON = model
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class UpdateGatewayRouteCORSShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var corsJSONShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.corsJSONShrink != nil {
            map["CorsJSON"] = self.corsJSONShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CorsJSON") {
            self.corsJSONShrink = dict["CorsJSON"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class UpdateGatewayRouteCORSResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteCORSResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteCORSResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteCORSResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteHTTPRewriteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var httpRewriteJSON: String?

    public var id: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.httpRewriteJSON != nil {
            map["HttpRewriteJSON"] = self.httpRewriteJSON!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HttpRewriteJSON") {
            self.httpRewriteJSON = dict["HttpRewriteJSON"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class UpdateGatewayRouteHTTPRewriteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteHTTPRewriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteHTTPRewriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteHTTPRewriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteHeaderOpRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var headerOpJSON: String?

    public var id: Int64?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.headerOpJSON != nil {
            map["HeaderOpJSON"] = self.headerOpJSON!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HeaderOpJSON") {
            self.headerOpJSON = dict["HeaderOpJSON"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class UpdateGatewayRouteHeaderOpResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteHeaderOpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteHeaderOpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteHeaderOpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteRetryRequest : Tea.TeaModel {
    public class RetryJSON : Tea.TeaModel {
        public var attempts: Int32?

        public var httpCodes: [String]?

        public var retryOn: [String]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attempts != nil {
                map["Attempts"] = self.attempts!
            }
            if self.httpCodes != nil {
                map["HttpCodes"] = self.httpCodes!
            }
            if self.retryOn != nil {
                map["RetryOn"] = self.retryOn!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attempts") {
                self.attempts = dict["Attempts"] as! Int32
            }
            if dict.keys.contains("HttpCodes") {
                self.httpCodes = dict["HttpCodes"] as! [String]
            }
            if dict.keys.contains("RetryOn") {
                self.retryOn = dict["RetryOn"] as! [String]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public var retryJSON: UpdateGatewayRouteRetryRequest.RetryJSON?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.retryJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.retryJSON != nil {
            map["RetryJSON"] = self.retryJSON?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RetryJSON") {
            var model = UpdateGatewayRouteRetryRequest.RetryJSON()
            model.fromMap(dict["RetryJSON"] as! [String: Any])
            self.retryJSON = model
        }
    }
}

public class UpdateGatewayRouteRetryShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public var retryJSONShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.retryJSONShrink != nil {
            map["RetryJSON"] = self.retryJSONShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RetryJSON") {
            self.retryJSONShrink = dict["RetryJSON"] as! String
        }
    }
}

public class UpdateGatewayRouteRetryResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteRetryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteRetryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteRetryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteTimeoutRequest : Tea.TeaModel {
    public class TimeoutJSON : Tea.TeaModel {
        public var status: String?

        public var timeUnit: String?

        public var unitNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeUnit != nil {
                map["TimeUnit"] = self.timeUnit!
            }
            if self.unitNum != nil {
                map["UnitNum"] = self.unitNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TimeUnit") {
                self.timeUnit = dict["TimeUnit"] as! String
            }
            if dict.keys.contains("UnitNum") {
                self.unitNum = dict["UnitNum"] as! Int32
            }
        }
    }
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public var timeoutJSON: UpdateGatewayRouteTimeoutRequest.TimeoutJSON?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.timeoutJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.timeoutJSON != nil {
            map["TimeoutJSON"] = self.timeoutJSON?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("TimeoutJSON") {
            var model = UpdateGatewayRouteTimeoutRequest.TimeoutJSON()
            model.fromMap(dict["TimeoutJSON"] as! [String: Any])
            self.timeoutJSON = model
        }
    }
}

public class UpdateGatewayRouteTimeoutShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var mseSessionId: String?

    public var timeoutJSONShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.timeoutJSONShrink != nil {
            map["TimeoutJSON"] = self.timeoutJSONShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("TimeoutJSON") {
            self.timeoutJSONShrink = dict["TimeoutJSON"] as! String
        }
    }
}

public class UpdateGatewayRouteTimeoutResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteTimeoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteTimeoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteTimeoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteWafStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var enableWaf: Bool?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var routeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
    }
}

public class UpdateGatewayRouteWafStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Cors : Tea.TeaModel {
            public var allowCredentials: Bool?

            public var allowHeaders: String?

            public var allowMethods: String?

            public var allowOrigins: String?

            public var exposeHeaders: String?

            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowCredentials != nil {
                    map["AllowCredentials"] = self.allowCredentials!
                }
                if self.allowHeaders != nil {
                    map["AllowHeaders"] = self.allowHeaders!
                }
                if self.allowMethods != nil {
                    map["AllowMethods"] = self.allowMethods!
                }
                if self.allowOrigins != nil {
                    map["AllowOrigins"] = self.allowOrigins!
                }
                if self.exposeHeaders != nil {
                    map["ExposeHeaders"] = self.exposeHeaders!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowCredentials") {
                    self.allowCredentials = dict["AllowCredentials"] as! Bool
                }
                if dict.keys.contains("AllowHeaders") {
                    self.allowHeaders = dict["AllowHeaders"] as! String
                }
                if dict.keys.contains("AllowMethods") {
                    self.allowMethods = dict["AllowMethods"] as! String
                }
                if dict.keys.contains("AllowOrigins") {
                    self.allowOrigins = dict["AllowOrigins"] as! String
                }
                if dict.keys.contains("ExposeHeaders") {
                    self.exposeHeaders = dict["ExposeHeaders"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int64
                }
            }
        }
        public class DirectResponse : Tea.TeaModel {
            public var body: String?

            public var code: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    self.body = dict["Body"] as! String
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! Int32
                }
            }
        }
        public class HTTPRewrite : Tea.TeaModel {
            public var host: String?

            public var path: String?

            public var pathType: String?

            public var pattern: String?

            public var status: String?

            public var substitution: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.pathType != nil {
                    map["PathType"] = self.pathType!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.substitution != nil {
                    map["Substitution"] = self.substitution!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("PathType") {
                    self.pathType = dict["PathType"] as! String
                }
                if dict.keys.contains("Pattern") {
                    self.pattern = dict["Pattern"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Substitution") {
                    self.substitution = dict["Substitution"] as! String
                }
            }
        }
        public class HeaderOp : Tea.TeaModel {
            public class HeaderOpItems : Tea.TeaModel {
                public var directionType: String?

                public var key: String?

                public var opType: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.directionType != nil {
                        map["DirectionType"] = self.directionType!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.opType != nil {
                        map["OpType"] = self.opType!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DirectionType") {
                        self.directionType = dict["DirectionType"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("OpType") {
                        self.opType = dict["OpType"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerOpItems: [UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp.HeaderOpItems]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerOpItems != nil {
                    var tmp : [Any] = []
                    for k in self.headerOpItems! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderOpItems"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderOpItems") {
                    self.headerOpItems = dict["HeaderOpItems"] as! [UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp.HeaderOpItems]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Redirect : Tea.TeaModel {
            public var code: Int32?

            public var host: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! Int32
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public class Retry : Tea.TeaModel {
            public var attempts: Int32?

            public var httpCodes: [String]?

            public var retryOn: [String]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attempts != nil {
                    map["Attempts"] = self.attempts!
                }
                if self.httpCodes != nil {
                    map["HttpCodes"] = self.httpCodes!
                }
                if self.retryOn != nil {
                    map["RetryOn"] = self.retryOn!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attempts") {
                    self.attempts = dict["Attempts"] as! Int32
                }
                if dict.keys.contains("HttpCodes") {
                    self.httpCodes = dict["HttpCodes"] as! [String]
                }
                if dict.keys.contains("RetryOn") {
                    self.retryOn = dict["RetryOn"] as! [String]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RoutePredicates : Tea.TeaModel {
            public class HeaderPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class PathPredicates : Tea.TeaModel {
                public var ignoreCase: Bool?

                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ignoreCase != nil {
                        map["IgnoreCase"] = self.ignoreCase!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IgnoreCase") {
                        self.ignoreCase = dict["IgnoreCase"] as! Bool
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class QueryPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerPredicates: [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.HeaderPredicates]?

            public var methodPredicates: [String]?

            public var pathPredicates: UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.PathPredicates?

            public var queryPredicates: [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.QueryPredicates]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pathPredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.headerPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderPredicates"] = tmp
                }
                if self.methodPredicates != nil {
                    map["MethodPredicates"] = self.methodPredicates!
                }
                if self.pathPredicates != nil {
                    map["PathPredicates"] = self.pathPredicates?.toMap()
                }
                if self.queryPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.queryPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["QueryPredicates"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderPredicates") {
                    self.headerPredicates = dict["HeaderPredicates"] as! [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.HeaderPredicates]
                }
                if dict.keys.contains("MethodPredicates") {
                    self.methodPredicates = dict["MethodPredicates"] as! [String]
                }
                if dict.keys.contains("PathPredicates") {
                    var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.PathPredicates()
                    model.fromMap(dict["PathPredicates"] as! [String: Any])
                    self.pathPredicates = model
                }
                if dict.keys.contains("QueryPredicates") {
                    self.queryPredicates = dict["QueryPredicates"] as! [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.QueryPredicates]
                }
            }
        }
        public class RouteServices : Tea.TeaModel {
            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var percent: Int32?

            public var serviceId: Int64?

            public var serviceName: String?

            public var sourceType: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Timeout : Tea.TeaModel {
            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int32
                }
            }
        }
        public var cors: UpdateGatewayRouteWafStatusResponseBody.Data.Cors?

        public var defaultServiceId: Int64?

        public var defaultServiceName: String?

        public var destinationType: String?

        public var directResponse: UpdateGatewayRouteWafStatusResponseBody.Data.DirectResponse?

        public var domainId: Int64?

        public var domainIdList: [Int64]?

        public var domainName: String?

        public var domainNameList: [String]?

        public var enableWaf: Bool?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var HTTPRewrite: UpdateGatewayRouteWafStatusResponseBody.Data.HTTPRewrite?

        public var headerOp: UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp?

        public var id: Int64?

        public var name: String?

        public var predicates: String?

        public var redirect: UpdateGatewayRouteWafStatusResponseBody.Data.Redirect?

        public var retry: UpdateGatewayRouteWafStatusResponseBody.Data.Retry?

        public var routeOrder: Int32?

        public var routePredicates: UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates?

        public var routeServices: [UpdateGatewayRouteWafStatusResponseBody.Data.RouteServices]?

        public var services: String?

        public var status: Int32?

        public var timeout: UpdateGatewayRouteWafStatusResponseBody.Data.Timeout?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cors?.validate()
            try self.directResponse?.validate()
            try self.HTTPRewrite?.validate()
            try self.headerOp?.validate()
            try self.redirect?.validate()
            try self.retry?.validate()
            try self.routePredicates?.validate()
            try self.timeout?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cors != nil {
                map["Cors"] = self.cors?.toMap()
            }
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.defaultServiceName != nil {
                map["DefaultServiceName"] = self.defaultServiceName!
            }
            if self.destinationType != nil {
                map["DestinationType"] = self.destinationType!
            }
            if self.directResponse != nil {
                map["DirectResponse"] = self.directResponse?.toMap()
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainIdList != nil {
                map["DomainIdList"] = self.domainIdList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameList != nil {
                map["DomainNameList"] = self.domainNameList!
            }
            if self.enableWaf != nil {
                map["EnableWaf"] = self.enableWaf!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.HTTPRewrite != nil {
                map["HTTPRewrite"] = self.HTTPRewrite?.toMap()
            }
            if self.headerOp != nil {
                map["HeaderOp"] = self.headerOp?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.predicates != nil {
                map["Predicates"] = self.predicates!
            }
            if self.redirect != nil {
                map["Redirect"] = self.redirect?.toMap()
            }
            if self.retry != nil {
                map["Retry"] = self.retry?.toMap()
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.routePredicates != nil {
                map["RoutePredicates"] = self.routePredicates?.toMap()
            }
            if self.routeServices != nil {
                var tmp : [Any] = []
                for k in self.routeServices! {
                    tmp.append(k.toMap())
                }
                map["RouteServices"] = tmp
            }
            if self.services != nil {
                map["Services"] = self.services!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cors") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Cors()
                model.fromMap(dict["Cors"] as! [String: Any])
                self.cors = model
            }
            if dict.keys.contains("DefaultServiceId") {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("DefaultServiceName") {
                self.defaultServiceName = dict["DefaultServiceName"] as! String
            }
            if dict.keys.contains("DestinationType") {
                self.destinationType = dict["DestinationType"] as! String
            }
            if dict.keys.contains("DirectResponse") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.DirectResponse()
                model.fromMap(dict["DirectResponse"] as! [String: Any])
                self.directResponse = model
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainIdList") {
                self.domainIdList = dict["DomainIdList"] as! [Int64]
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainNameList") {
                self.domainNameList = dict["DomainNameList"] as! [String]
            }
            if dict.keys.contains("EnableWaf") {
                self.enableWaf = dict["EnableWaf"] as! Bool
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("HTTPRewrite") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.HTTPRewrite()
                model.fromMap(dict["HTTPRewrite"] as! [String: Any])
                self.HTTPRewrite = model
            }
            if dict.keys.contains("HeaderOp") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp()
                model.fromMap(dict["HeaderOp"] as! [String: Any])
                self.headerOp = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Predicates") {
                self.predicates = dict["Predicates"] as! String
            }
            if dict.keys.contains("Redirect") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Redirect()
                model.fromMap(dict["Redirect"] as! [String: Any])
                self.redirect = model
            }
            if dict.keys.contains("Retry") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Retry()
                model.fromMap(dict["Retry"] as! [String: Any])
                self.retry = model
            }
            if dict.keys.contains("RouteOrder") {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("RoutePredicates") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates()
                model.fromMap(dict["RoutePredicates"] as! [String: Any])
                self.routePredicates = model
            }
            if dict.keys.contains("RouteServices") {
                self.routeServices = dict["RouteServices"] as! [UpdateGatewayRouteWafStatusResponseBody.Data.RouteServices]
            }
            if dict.keys.contains("Services") {
                self.services = dict["Services"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Timeout") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Timeout()
                model.fromMap(dict["Timeout"] as! [String: Any])
                self.timeout = model
            }
        }
    }
    public var code: Int32?

    public var data: UpdateGatewayRouteWafStatusResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = UpdateGatewayRouteWafStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteWafStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteWafStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteWafStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayTrafficPolicy: TrafficPolicy?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewayTrafficPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayTrafficPolicy != nil {
            map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayTrafficPolicy") {
            var model = TrafficPolicy()
            model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
            self.gatewayTrafficPolicy = model
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayTrafficPolicyShrink: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayTrafficPolicyShrink != nil {
            map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicyShrink!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayTrafficPolicy") {
            self.gatewayTrafficPolicyShrink = dict["GatewayTrafficPolicy"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GatewayService?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GatewayService()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayServiceTrafficPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayServiceTrafficPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayServiceVersionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var serviceId: Int64?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
        if dict.keys.contains("ServiceVersion") {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class UpdateGatewayServiceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayServiceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayServiceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayServiceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewaySpecRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public var replica: Int32?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.replica != nil {
            map["Replica"] = self.replica!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Replica") {
            self.replica = dict["Replica"] as! Int32
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class UpdateGatewaySpecResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewaySpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewaySpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewaySpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateImageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var mseSessionId: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class UpdateImageResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMessageQueueRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var enable: Bool?

    public var filterSide: String?

    public var mseSessionId: String?

    public var region: String?

    public var tags: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.filterSide != nil {
            map["FilterSide"] = self.filterSide!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("FilterSide") {
            self.filterSide = dict["FilterSide"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! [String]
        }
    }
}

public class UpdateMessageQueueRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var enable: Bool?

    public var filterSide: String?

    public var mseSessionId: String?

    public var region: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.filterSide != nil {
            map["FilterSide"] = self.filterSide!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("FilterSide") {
            self.filterSide = dict["FilterSide"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class UpdateMessageQueueRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateMessageQueueRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMessageQueueRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMessageQueueRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var checkPort: Int32?

    public var clusterName: String?

    public var groupName: String?

    public var healthChecker: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var serviceName: String?

    public var useInstancePortForCheck: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.checkPort != nil {
            map["CheckPort"] = self.checkPort!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.healthChecker != nil {
            map["HealthChecker"] = self.healthChecker!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.useInstancePortForCheck != nil {
            map["UseInstancePortForCheck"] = self.useInstancePortForCheck!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CheckPort") {
            self.checkPort = dict["CheckPort"] as! Int32
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HealthChecker") {
            self.healthChecker = dict["HealthChecker"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("UseInstancePortForCheck") {
            self.useInstancePortForCheck = dict["UseInstancePortForCheck"] as! Bool
        }
    }
}

public class UpdateNacosClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNacosClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var betaIps: String?

    public var content: String?

    public var dataId: String?

    public var desc: String?

    public var encryptedDataKey: String?

    public var group: String?

    public var instanceId: String?

    public var md5: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var tags: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.betaIps != nil {
            map["BetaIps"] = self.betaIps!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.encryptedDataKey != nil {
            map["EncryptedDataKey"] = self.encryptedDataKey!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.md5 != nil {
            map["Md5"] = self.md5!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BetaIps") {
            self.betaIps = dict["BetaIps"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("EncryptedDataKey") {
            self.encryptedDataKey = dict["EncryptedDataKey"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Md5") {
            self.md5 = dict["Md5"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateNacosConfigResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosInstanceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterName: String?

    public var enabled: Bool?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var ip: String?

    public var metadata: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var port: Int32?

    public var serviceName: String?

    public var weight: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.metadata != nil {
            map["Metadata"] = self.metadata!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Ephemeral") {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Metadata") {
            self.metadata = dict["Metadata"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! String
        }
    }
}

public class UpdateNacosInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNacosInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var groupName: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var namespaceId: String?

    public var protectThreshold: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.protectThreshold != nil {
            map["ProtectThreshold"] = self.protectThreshold!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ProtectThreshold") {
            self.protectThreshold = dict["ProtectThreshold"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class UpdateNacosServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNacosServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePluginConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var config: String?

    public var configLevel: Int32?

    public var enable: Bool?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var id: Int64?

    public var mseSessionId: String?

    public var pluginId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.configLevel != nil {
            map["ConfigLevel"] = self.configLevel!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("ConfigLevel") {
            self.configLevel = dict["ConfigLevel"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! Int64
        }
    }
}

public class UpdatePluginConfigResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePluginConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePluginConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePluginConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSSLCertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public var mseSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
    }
}

public class UpdateSSLCertResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateSSLCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSSLCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSSLCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateServiceSourceRequest : Tea.TeaModel {
    public class IngressOptionsRequest : Tea.TeaModel {
        public var enableIngress: Bool?

        public var ingressClass: String?

        public var watchNamespace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableIngress != nil {
                map["EnableIngress"] = self.enableIngress!
            }
            if self.ingressClass != nil {
                map["IngressClass"] = self.ingressClass!
            }
            if self.watchNamespace != nil {
                map["WatchNamespace"] = self.watchNamespace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableIngress") {
                self.enableIngress = dict["EnableIngress"] as! Bool
            }
            if dict.keys.contains("IngressClass") {
                self.ingressClass = dict["IngressClass"] as! String
            }
            if dict.keys.contains("WatchNamespace") {
                self.watchNamespace = dict["WatchNamespace"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var ingressOptionsRequest: UpdateServiceSourceRequest.IngressOptionsRequest?

    public var mseSessionId: String?

    public var name: String?

    public var source: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ingressOptionsRequest?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ingressOptionsRequest != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequest?.toMap()
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IngressOptionsRequest") {
            var model = UpdateServiceSourceRequest.IngressOptionsRequest()
            model.fromMap(dict["IngressOptionsRequest"] as! [String: Any])
            self.ingressOptionsRequest = model
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateServiceSourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var ingressOptionsRequestShrink: String?

    public var mseSessionId: String?

    public var name: String?

    public var source: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ingressOptionsRequestShrink != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequestShrink!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IngressOptionsRequest") {
            self.ingressOptionsRequestShrink = dict["IngressOptionsRequest"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateServiceSourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateZnodeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var data: String?

    public var mseSessionId: String?

    public var path: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class UpdateZnodeResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateZnodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateZnodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateZnodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var mseSessionId: String?

    public var requestPars: String?

    public var upgradeVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseSessionId != nil {
            map["MseSessionId"] = self.mseSessionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.upgradeVersion != nil {
            map["UpgradeVersion"] = self.upgradeVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseSessionId") {
            self.mseSessionId = dict["MseSessionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("UpgradeVersion") {
            self.upgradeVersion = dict["UpgradeVersion"] as! String
        }
    }
}

public class UpgradeClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
